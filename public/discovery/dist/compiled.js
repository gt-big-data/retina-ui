!function(e) {
    if ("object" == typeof exports) module.exports = e(); else if ("function" == typeof define && false) define(e); else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), 
        f.p2 = e();
    }
}(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'");
                }
                var f = n[o] = {
                    exports: {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(_dereq_, module, exports) {
            var Scalar = _dereq_("./Scalar");
            module.exports = Line;
            function Line() {}
            Line.lineInt = function(l1, l2, precision) {
                precision = precision || 0;
                var i = [ 0, 0 ];
                var a1, b1, c1, a2, b2, c2, det;
                a1 = l1[1][1] - l1[0][1];
                b1 = l1[0][0] - l1[1][0];
                c1 = a1 * l1[0][0] + b1 * l1[0][1];
                a2 = l2[1][1] - l2[0][1];
                b2 = l2[0][0] - l2[1][0];
                c2 = a2 * l2[0][0] + b2 * l2[0][1];
                det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, precision)) {
                    i[0] = (b2 * c1 - b1 * c2) / det;
                    i[1] = (a1 * c2 - a2 * c1) / det;
                }
                return i;
            };
            Line.segmentsIntersect = function(p1, p2, q1, q2) {
                var dx = p2[0] - p1[0];
                var dy = p2[1] - p1[1];
                var da = q2[0] - q1[0];
                var db = q2[1] - q1[1];
                if (da * dy - db * dx == 0) return false;
                var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
                var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
                return s >= 0 && s <= 1 && t >= 0 && t <= 1;
            };
        }, {
            "./Scalar": 4
        } ],
        2: [ function(_dereq_, module, exports) {
            module.exports = Point;
            function Point() {}
            Point.area = function(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            };
            Point.left = function(a, b, c) {
                return Point.area(a, b, c) > 0;
            };
            Point.leftOn = function(a, b, c) {
                return Point.area(a, b, c) >= 0;
            };
            Point.right = function(a, b, c) {
                return Point.area(a, b, c) < 0;
            };
            Point.rightOn = function(a, b, c) {
                return Point.area(a, b, c) <= 0;
            };
            var tmpPoint1 = [], tmpPoint2 = [];
            Point.collinear = function(a, b, c, thresholdAngle) {
                if (!thresholdAngle) return Point.area(a, b, c) == 0; else {
                    var ab = tmpPoint1, bc = tmpPoint2;
                    ab[0] = b[0] - a[0];
                    ab[1] = b[1] - a[1];
                    bc[0] = c[0] - b[0];
                    bc[1] = c[1] - b[1];
                    var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
                    return angle < thresholdAngle;
                }
            };
            Point.sqdist = function(a, b) {
                var dx = b[0] - a[0];
                var dy = b[1] - a[1];
                return dx * dx + dy * dy;
            };
        }, {} ],
        3: [ function(_dereq_, module, exports) {
            var Line = _dereq_("./Line"), Point = _dereq_("./Point"), Scalar = _dereq_("./Scalar");
            module.exports = Polygon;
            function Polygon() {
                this.vertices = [];
            }
            Polygon.prototype.at = function(i) {
                var v = this.vertices, s = v.length;
                return v[i < 0 ? i % s + s : i % s];
            };
            Polygon.prototype.first = function() {
                return this.vertices[0];
            };
            Polygon.prototype.last = function() {
                return this.vertices[this.vertices.length - 1];
            };
            Polygon.prototype.clear = function() {
                this.vertices.length = 0;
            };
            Polygon.prototype.append = function(poly, from, to) {
                if (typeof from == "undefined") throw new Error("From is not given!");
                if (typeof to == "undefined") throw new Error("To is not given!");
                if (to - 1 < from) throw new Error("lol1");
                if (to > poly.vertices.length) throw new Error("lol2");
                if (from < 0) throw new Error("lol3");
                for (var i = from; i < to; i++) {
                    this.vertices.push(poly.vertices[i]);
                }
            };
            Polygon.prototype.makeCCW = function() {
                var br = 0, v = this.vertices;
                for (var i = 1; i < this.vertices.length; ++i) {
                    if (v[i][1] < v[br][1] || v[i][1] == v[br][1] && v[i][0] > v[br][0]) {
                        br = i;
                    }
                }
                if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
                    this.reverse();
                }
            };
            Polygon.prototype.reverse = function() {
                var tmp = [];
                for (var i = 0, N = this.vertices.length; i !== N; i++) {
                    tmp.push(this.vertices.pop());
                }
                this.vertices = tmp;
            };
            Polygon.prototype.isReflex = function(i) {
                return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
            };
            var tmpLine1 = [], tmpLine2 = [];
            Polygon.prototype.canSee = function(a, b) {
                var p, dist, l1 = tmpLine1, l2 = tmpLine2;
                if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
                    return false;
                }
                dist = Point.sqdist(this.at(a), this.at(b));
                for (var i = 0; i !== this.vertices.length; ++i) {
                    if ((i + 1) % this.vertices.length === a || i === a) continue;
                    if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) {
                        l1[0] = this.at(a);
                        l1[1] = this.at(b);
                        l2[0] = this.at(i);
                        l2[1] = this.at(i + 1);
                        p = Line.lineInt(l1, l2);
                        if (Point.sqdist(this.at(a), p) < dist) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Polygon.prototype.copy = function(i, j, targetPoly) {
                var p = targetPoly || new Polygon();
                p.clear();
                if (i < j) {
                    for (var k = i; k <= j; k++) p.vertices.push(this.vertices[k]);
                } else {
                    for (var k = 0; k <= j; k++) p.vertices.push(this.vertices[k]);
                    for (var k = i; k < this.vertices.length; k++) p.vertices.push(this.vertices[k]);
                }
                return p;
            };
            Polygon.prototype.getCutEdges = function() {
                var min = [], tmp1 = [], tmp2 = [], tmpPoly = new Polygon();
                var nDiags = Number.MAX_VALUE;
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (this.isReflex(i)) {
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (this.canSee(i, j)) {
                                tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                                tmp2 = this.copy(j, i, tmpPoly).getCutEdges();
                                for (var k = 0; k < tmp2.length; k++) tmp1.push(tmp2[k]);
                                if (tmp1.length < nDiags) {
                                    min = tmp1;
                                    nDiags = tmp1.length;
                                    min.push([ this.at(i), this.at(j) ]);
                                }
                            }
                        }
                    }
                }
                return min;
            };
            Polygon.prototype.decomp = function() {
                var edges = this.getCutEdges();
                if (edges.length > 0) return this.slice(edges); else return [ this ];
            };
            Polygon.prototype.slice = function(cutEdges) {
                if (cutEdges.length == 0) return [ this ];
                if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length == 2 && cutEdges[0][0] instanceof Array) {
                    var polys = [ this ];
                    for (var i = 0; i < cutEdges.length; i++) {
                        var cutEdge = cutEdges[i];
                        for (var j = 0; j < polys.length; j++) {
                            var poly = polys[j];
                            var result = poly.slice(cutEdge);
                            if (result) {
                                polys.splice(j, 1);
                                polys.push(result[0], result[1]);
                                break;
                            }
                        }
                    }
                    return polys;
                } else {
                    var cutEdge = cutEdges;
                    var i = this.vertices.indexOf(cutEdge[0]);
                    var j = this.vertices.indexOf(cutEdge[1]);
                    if (i != -1 && j != -1) {
                        return [ this.copy(i, j), this.copy(j, i) ];
                    } else {
                        return false;
                    }
                }
            };
            Polygon.prototype.isSimple = function() {
                var path = this.vertices;
                for (var i = 0; i < path.length - 1; i++) {
                    for (var j = 0; j < i - 1; j++) {
                        if (Line.segmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                            return false;
                        }
                    }
                }
                for (var i = 1; i < path.length - 2; i++) {
                    if (Line.segmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                        return false;
                    }
                }
                return true;
            };
            function getIntersectionPoint(p1, p2, q1, q2, delta) {
                delta = delta || 0;
                var a1 = p2[1] - p1[1];
                var b1 = p1[0] - p2[0];
                var c1 = a1 * p1[0] + b1 * p1[1];
                var a2 = q2[1] - q1[1];
                var b2 = q1[0] - q2[0];
                var c2 = a2 * q1[0] + b2 * q1[1];
                var det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, delta)) return [ (b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det ]; else return [ 0, 0 ];
            }
            Polygon.prototype.quickDecomp = function(result, reflexVertices, steinerPoints, delta, maxlevel, level) {
                maxlevel = maxlevel || 100;
                level = level || 0;
                delta = delta || 25;
                result = typeof result != "undefined" ? result : [];
                reflexVertices = reflexVertices || [];
                steinerPoints = steinerPoints || [];
                var upperInt = [ 0, 0 ], lowerInt = [ 0, 0 ], p = [ 0, 0 ];
                var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
                var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
                var lowerPoly = new Polygon(), upperPoly = new Polygon();
                var poly = this, v = this.vertices;
                if (v.length < 3) return result;
                level++;
                if (level > maxlevel) {
                    console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
                    return result;
                }
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (poly.isReflex(i)) {
                        reflexVertices.push(poly.vertices[i]);
                        upperDist = lowerDist = Number.MAX_VALUE;
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) {
                                p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1));
                                if (Point.right(poly.at(i + 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < lowerDist) {
                                        lowerDist = d;
                                        lowerInt = p;
                                        lowerIndex = j;
                                    }
                                }
                            }
                            if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                                if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < upperDist) {
                                        upperDist = d;
                                        upperInt = p;
                                        upperIndex = j;
                                    }
                                }
                            }
                        }
                        if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                            p[0] = (lowerInt[0] + upperInt[0]) / 2;
                            p[1] = (lowerInt[1] + upperInt[1]) / 2;
                            steinerPoints.push(p);
                            if (i < upperIndex) {
                                lowerPoly.append(poly, i, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                if (lowerIndex != 0) {
                                    upperPoly.append(poly, lowerIndex, poly.vertices.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, poly.vertices.length);
                                }
                                lowerPoly.append(poly, 0, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                upperPoly.append(poly, lowerIndex, i + 1);
                            }
                        } else {
                            if (lowerIndex > upperIndex) {
                                upperIndex += this.vertices.length;
                            }
                            closestDist = Number.MAX_VALUE;
                            if (upperIndex < lowerIndex) {
                                return result;
                            }
                            for (var j = lowerIndex; j <= upperIndex; ++j) {
                                if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                    d = Point.sqdist(poly.at(i), poly.at(j));
                                    if (d < closestDist) {
                                        closestDist = d;
                                        closestIndex = j % this.vertices.length;
                                    }
                                }
                            }
                            if (i < closestIndex) {
                                lowerPoly.append(poly, i, closestIndex + 1);
                                if (closestIndex != 0) {
                                    upperPoly.append(poly, closestIndex, v.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, v.length);
                                }
                                lowerPoly.append(poly, 0, closestIndex + 1);
                                upperPoly.append(poly, closestIndex, i + 1);
                            }
                        }
                        if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        } else {
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        }
                        return result;
                    }
                }
                result.push(this);
                return result;
            };
            Polygon.prototype.removeCollinearPoints = function(precision) {
                var num = 0;
                for (var i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) {
                    if (Point.collinear(this.at(i - 1), this.at(i), this.at(i + 1), precision)) {
                        this.vertices.splice(i % this.vertices.length, 1);
                        i--;
                        num++;
                    }
                }
                return num;
            };
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        } ],
        4: [ function(_dereq_, module, exports) {
            module.exports = Scalar;
            function Scalar() {}
            Scalar.eq = function(a, b, precision) {
                precision = precision || 0;
                return Math.abs(a - b) < precision;
            };
        }, {} ],
        5: [ function(_dereq_, module, exports) {
            module.exports = {
                Polygon: _dereq_("./Polygon"),
                Point: _dereq_("./Point")
            };
        }, {
            "./Point": 2,
            "./Polygon": 3
        } ],
        6: [ function(_dereq_, module, exports) {
            module.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: [ "p2.js", "p2", "physics", "engine", "2d" ],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [ {
                    type: "MIT"
                } ],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            };
        }, {} ],
        7: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), Utils = _dereq_("../utils/Utils");
            module.exports = AABB;
            function AABB(options) {
                this.lowerBound = vec2.create();
                if (options && options.lowerBound) {
                    vec2.copy(this.lowerBound, options.lowerBound);
                }
                this.upperBound = vec2.create();
                if (options && options.upperBound) {
                    vec2.copy(this.upperBound, options.upperBound);
                }
            }
            var tmp = vec2.create();
            AABB.prototype.setFromPoints = function(points, position, angle, skinSize) {
                var l = this.lowerBound, u = this.upperBound;
                if (typeof angle !== "number") {
                    angle = 0;
                }
                if (angle !== 0) {
                    vec2.rotate(l, points[0], angle);
                } else {
                    vec2.copy(l, points[0]);
                }
                vec2.copy(u, l);
                var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
                for (var i = 1; i < points.length; i++) {
                    var p = points[i];
                    if (angle !== 0) {
                        var x = p[0], y = p[1];
                        tmp[0] = cosAngle * x - sinAngle * y;
                        tmp[1] = sinAngle * x + cosAngle * y;
                        p = tmp;
                    }
                    for (var j = 0; j < 2; j++) {
                        if (p[j] > u[j]) {
                            u[j] = p[j];
                        }
                        if (p[j] < l[j]) {
                            l[j] = p[j];
                        }
                    }
                }
                if (position) {
                    vec2.add(this.lowerBound, this.lowerBound, position);
                    vec2.add(this.upperBound, this.upperBound, position);
                }
                if (skinSize) {
                    this.lowerBound[0] -= skinSize;
                    this.lowerBound[1] -= skinSize;
                    this.upperBound[0] += skinSize;
                    this.upperBound[1] += skinSize;
                }
            };
            AABB.prototype.copy = function(aabb) {
                vec2.copy(this.lowerBound, aabb.lowerBound);
                vec2.copy(this.upperBound, aabb.upperBound);
            };
            AABB.prototype.extend = function(aabb) {
                var i = 2;
                while (i--) {
                    var l = aabb.lowerBound[i];
                    if (this.lowerBound[i] > l) {
                        this.lowerBound[i] = l;
                    }
                    var u = aabb.upperBound[i];
                    if (this.upperBound[i] < u) {
                        this.upperBound[i] = u;
                    }
                }
            };
            AABB.prototype.overlaps = function(aabb) {
                var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                return (l2[0] <= u1[0] && u1[0] <= u2[0] || l1[0] <= u2[0] && u2[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u2[1] || l1[1] <= u2[1] && u2[1] <= u1[1]);
            };
            AABB.prototype.containsPoint = function(point) {
                var l = this.lowerBound, u = this.upperBound;
                return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
            };
            AABB.prototype.overlapsRay = function(ray) {
                var t = 0;
                var dirFracX = 1 / ray.direction[0];
                var dirFracY = 1 / ray.direction[1];
                var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;
                var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;
                var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;
                var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;
                var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
                var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
                if (tmax < 0) {
                    return -1;
                }
                if (tmin > tmax) {
                    return -1;
                }
                return tmin;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        } ],
        8: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Body = _dereq_("../objects/Body");
            module.exports = Broadphase;
            function Broadphase(type) {
                this.type = type;
                this.result = [];
                this.world = null;
                this.boundingVolumeType = Broadphase.AABB;
            }
            Broadphase.AABB = 1;
            Broadphase.BOUNDING_CIRCLE = 2;
            Broadphase.prototype.setWorld = function(world) {
                this.world = world;
            };
            Broadphase.prototype.getCollisionPairs = function(world) {};
            var dist = vec2.create();
            Broadphase.boundingRadiusCheck = function(bodyA, bodyB) {
                vec2.sub(dist, bodyA.position, bodyB.position);
                var d2 = vec2.squaredLength(dist), r = bodyA.boundingRadius + bodyB.boundingRadius;
                return d2 <= r * r;
            };
            Broadphase.aabbCheck = function(bodyA, bodyB) {
                return bodyA.getAABB().overlaps(bodyB.getAABB());
            };
            Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB) {
                var result;
                switch (this.boundingVolumeType) {
                  case Broadphase.BOUNDING_CIRCLE:
                    result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                    break;

                  case Broadphase.AABB:
                    result = Broadphase.aabbCheck(bodyA, bodyB);
                    break;

                  default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                }
                return result;
            };
            Broadphase.canCollide = function(bodyA, bodyB) {
                var KINEMATIC = Body.KINEMATIC;
                var STATIC = Body.STATIC;
                if (bodyA.type === STATIC && bodyB.type === STATIC) {
                    return false;
                }
                if (bodyA.type === KINEMATIC && bodyB.type === STATIC || bodyA.type === STATIC && bodyB.type === KINEMATIC) {
                    return false;
                }
                if (bodyA.type === KINEMATIC && bodyB.type === KINEMATIC) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC || bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC) {
                    return false;
                }
                return true;
            };
            Broadphase.NAIVE = 1;
            Broadphase.SAP = 2;
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        } ],
        9: [ function(_dereq_, module, exports) {
            var Circle = _dereq_("../shapes/Circle"), Plane = _dereq_("../shapes/Plane"), Shape = _dereq_("../shapes/Shape"), Particle = _dereq_("../shapes/Particle"), Broadphase = _dereq_("../collision/Broadphase"), vec2 = _dereq_("../math/vec2");
            module.exports = NaiveBroadphase;
            function NaiveBroadphase() {
                Broadphase.call(this, Broadphase.NAIVE);
            }
            NaiveBroadphase.prototype = new Broadphase();
            NaiveBroadphase.prototype.constructor = NaiveBroadphase;
            NaiveBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = world.bodies, result = this.result;
                result.length = 0;
                for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
                    var bi = bodies[i];
                    for (var j = 0; j < i; j++) {
                        var bj = bodies[j];
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
            NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                result = result || [];
                var bodies = world.bodies;
                for (var i = 0; i < bodies.length; i++) {
                    var b = bodies[i];
                    if (b.aabbNeedsUpdate) {
                        b.updateAABB();
                    }
                    if (b.aabb.overlaps(aabb)) {
                        result.push(b);
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        } ],
        10: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), sub = vec2.sub, add = vec2.add, dot = vec2.dot, Utils = _dereq_("../utils/Utils"), ContactEquationPool = _dereq_("../utils/ContactEquationPool"), FrictionEquationPool = _dereq_("../utils/FrictionEquationPool"), TupleDictionary = _dereq_("../utils/TupleDictionary"), Equation = _dereq_("../equations/Equation"), ContactEquation = _dereq_("../equations/ContactEquation"), FrictionEquation = _dereq_("../equations/FrictionEquation"), Circle = _dereq_("../shapes/Circle"), Convex = _dereq_("../shapes/Convex"), Shape = _dereq_("../shapes/Shape"), Body = _dereq_("../objects/Body"), Box = _dereq_("../shapes/Box");
            module.exports = Narrowphase;
            var yAxis = vec2.fromValues(0, 1);
            var tmp1 = vec2.fromValues(0, 0), tmp2 = vec2.fromValues(0, 0), tmp3 = vec2.fromValues(0, 0), tmp4 = vec2.fromValues(0, 0), tmp5 = vec2.fromValues(0, 0), tmp6 = vec2.fromValues(0, 0), tmp7 = vec2.fromValues(0, 0), tmp8 = vec2.fromValues(0, 0), tmp9 = vec2.fromValues(0, 0), tmp10 = vec2.fromValues(0, 0), tmp11 = vec2.fromValues(0, 0), tmp12 = vec2.fromValues(0, 0), tmp13 = vec2.fromValues(0, 0), tmp14 = vec2.fromValues(0, 0), tmp15 = vec2.fromValues(0, 0), tmp16 = vec2.fromValues(0, 0), tmp17 = vec2.fromValues(0, 0), tmp18 = vec2.fromValues(0, 0), tmpArray = [];
            function Narrowphase() {
                this.contactEquations = [];
                this.frictionEquations = [];
                this.enableFriction = true;
                this.enabledEquations = true;
                this.slipForce = 10;
                this.frictionCoefficient = .3;
                this.surfaceVelocity = 0;
                this.contactEquationPool = new ContactEquationPool({
                    size: 32
                });
                this.frictionEquationPool = new FrictionEquationPool({
                    size: 64
                });
                this.restitution = 0;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = Equation.DEFAULT_RELAXATION;
                this.enableFrictionReduction = true;
                this.collidingBodiesLastStep = new TupleDictionary();
                this.contactSkinSize = .01;
            }
            var bodiesOverlap_shapePositionA = vec2.create();
            var bodiesOverlap_shapePositionB = vec2.create();
            Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB) {
                var shapePositionA = bodiesOverlap_shapePositionA;
                var shapePositionB = bodiesOverlap_shapePositionB;
                for (var k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++) {
                    var shapeA = bodyA.shapes[k];
                    bodyA.toWorldFrame(shapePositionA, shapeA.position);
                    for (var l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++) {
                        var shapeB = bodyB.shapes[l];
                        bodyB.toWorldFrame(shapePositionB, shapeB.position);
                        if (this[shapeA.type | shapeB.type](bodyA, shapeA, shapePositionA, shapeA.angle + bodyA.angle, bodyB, shapeB, shapePositionB, shapeB.angle + bodyB.angle, true)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB) {
                var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
                return !!this.collidingBodiesLastStep.get(id1, id2);
            };
            Narrowphase.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                var eqs = this.contactEquations;
                var l = eqs.length;
                while (l--) {
                    var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
                    this.collidingBodiesLastStep.set(id1, id2, true);
                }
                var ce = this.contactEquations, fe = this.frictionEquations;
                for (var i = 0; i < ce.length; i++) {
                    this.contactEquationPool.release(ce[i]);
                }
                for (var i = 0; i < fe.length; i++) {
                    this.frictionEquationPool.release(fe[i]);
                }
                this.contactEquations.length = this.frictionEquations.length = 0;
            };
            Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.contactEquationPool.get();
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.restitution = this.restitution;
                c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
                c.stiffness = this.stiffness;
                c.relaxation = this.relaxation;
                c.needsUpdate = true;
                c.enabled = this.enabledEquations;
                c.offset = this.contactSkinSize;
                return c;
            };
            Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.frictionEquationPool.get();
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.setSlipForce(this.slipForce);
                c.frictionCoefficient = this.frictionCoefficient;
                c.relativeVelocity = this.surfaceVelocity;
                c.enabled = this.enabledEquations;
                c.needsUpdate = true;
                c.stiffness = this.frictionStiffness;
                c.relaxation = this.frictionRelaxation;
                c.contactEquations.length = 0;
                return c;
            };
            Narrowphase.prototype.createFrictionFromContact = function(c) {
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                vec2.copy(eq.contactPointA, c.contactPointA);
                vec2.copy(eq.contactPointB, c.contactPointB);
                vec2.rotate90cw(eq.t, c.normalA);
                eq.contactEquations.push(c);
                return eq;
            };
            Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
                var c = this.contactEquations[this.contactEquations.length - 1];
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                var bodyA = c.bodyA;
                var bodyB = c.bodyB;
                vec2.set(eq.contactPointA, 0, 0);
                vec2.set(eq.contactPointB, 0, 0);
                vec2.set(eq.t, 0, 0);
                for (var i = 0; i !== numContacts; i++) {
                    c = this.contactEquations[this.contactEquations.length - 1 - i];
                    if (c.bodyA === bodyA) {
                        vec2.add(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
                    } else {
                        vec2.sub(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
                    }
                    eq.contactEquations.push(c);
                }
                var invNumContacts = 1 / numContacts;
                vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
                vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
                vec2.normalize(eq.t, eq.t);
                vec2.rotate90cw(eq.t, eq.t);
                return eq;
            };
            Narrowphase.prototype[Shape.LINE | Shape.CONVEX] = Narrowphase.prototype.convexLine = function(convexBody, convexShape, convexOffset, convexAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.LINE | Shape.BOX] = Narrowphase.prototype.lineBox = function(lineBody, lineShape, lineOffset, lineAngle, boxBody, boxShape, boxOffset, boxAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
                vec2.set(convexShape.vertices[0], -capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[1], capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[2], capsuleShape.length * .5, capsuleShape.radius);
                vec2.set(convexShape.vertices[3], -capsuleShape.length * .5, capsuleShape.radius);
            }
            var convexCapsule_tempRect = new Box({
                width: 1,
                height: 1
            }), convexCapsule_tempVec = vec2.create();
            Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] = Narrowphase.prototype[Shape.CAPSULE | Shape.BOX] = Narrowphase.prototype.convexCapsule = function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                var circlePos = convexCapsule_tempVec;
                vec2.set(circlePos, capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                vec2.set(circlePos, -capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                if (justTest && (result1 || result2)) {
                    return true;
                }
                var r = convexCapsule_tempRect;
                setConvexToCapsuleShapeMiddle(r, capsuleShape);
                var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
                return result + result1 + result2;
            };
            Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] = Narrowphase.prototype.lineCapsule = function(lineBody, lineShape, linePosition, lineAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            var capsuleCapsule_tempVec1 = vec2.create();
            var capsuleCapsule_tempVec2 = vec2.create();
            var capsuleCapsule_tempRect1 = new Box({
                width: 1,
                height: 1
            });
            Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] = Narrowphase.prototype.capsuleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var enableFrictionBefore;
                var circlePosi = capsuleCapsule_tempVec1, circlePosj = capsuleCapsule_tempVec2;
                var numContacts = 0;
                for (var i = 0; i < 2; i++) {
                    vec2.set(circlePosi, (i === 0 ? -1 : 1) * si.length / 2, 0);
                    vec2.rotate(circlePosi, circlePosi, ai);
                    vec2.add(circlePosi, circlePosi, xi);
                    for (var j = 0; j < 2; j++) {
                        vec2.set(circlePosj, (j === 0 ? -1 : 1) * sj.length / 2, 0);
                        vec2.rotate(circlePosj, circlePosj, aj);
                        vec2.add(circlePosj, circlePosj, xj);
                        if (this.enableFrictionReduction) {
                            enableFrictionBefore = this.enableFriction;
                            this.enableFriction = false;
                        }
                        var result = this.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);
                        if (this.enableFrictionReduction) {
                            this.enableFriction = enableFrictionBefore;
                        }
                        if (justTest && result) {
                            return true;
                        }
                        numContacts += result;
                    }
                }
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var rect = capsuleCapsule_tempRect1;
                setConvexToCapsuleShapeMiddle(rect, si);
                var result1 = this.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result1) {
                    return true;
                }
                numContacts += result1;
                if (this.enableFrictionReduction) {
                    var enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                setConvexToCapsuleShapeMiddle(rect, sj);
                var result2 = this.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result2) {
                    return true;
                }
                numContacts += result2;
                if (this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.LINE | Shape.LINE] = Narrowphase.prototype.lineLine = function(bodyA, shapeA, positionA, angleA, bodyB, shapeB, positionB, angleB, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.PLANE | Shape.LINE] = Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, planeOffset);
                    var d = dot(dist, worldNormal);
                    if (d < 0) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                        numContacts++;
                        vec2.copy(c.normalA, worldNormal);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(dist, worldNormal, d);
                        sub(c.contactPointA, v, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (justTest) {
                    return false;
                }
                if (!this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] = Narrowphase.prototype.particleCapsule = function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                return this.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] = Narrowphase.prototype.circleLine = function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
                var lineRadius = lineRadius || 0, circleRadius = typeof circleRadius !== "undefined" ? circleRadius : circleShape.radius, orthoDist = tmp1, lineToCircleOrthoUnit = tmp2, projectedPoint = tmp3, centerDist = tmp4, worldTangent = tmp5, worldEdge = tmp6, worldEdgeUnit = tmp7, worldVertex0 = tmp8, worldVertex1 = tmp9, worldVertex01 = tmp10, worldVertex11 = tmp11, dist = tmp12, lineToCircle = tmp13, lineEndToLineRadius = tmp14, verts = tmpArray;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                sub(dist, circleOffset, worldVertex0);
                var d = dot(dist, worldTangent);
                sub(centerDist, worldVertex0, lineOffset);
                sub(lineToCircle, circleOffset, lineOffset);
                var radiusSum = circleRadius + lineRadius;
                if (Math.abs(d) < radiusSum) {
                    vec2.scale(orthoDist, worldTangent, d);
                    sub(projectedPoint, circleOffset, orthoDist);
                    vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
                    vec2.normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
                    vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
                    add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
                    var pos = dot(worldEdgeUnit, projectedPoint);
                    var pos0 = dot(worldEdgeUnit, worldVertex0);
                    var pos1 = dot(worldEdgeUnit, worldVertex1);
                    if (pos > pos0 && pos < pos1) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.scale(c.normalA, orthoDist, -1);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, projectedPoint, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, circleOffset);
                    if (vec2.squaredLength(dist) < Math.pow(radiusSum, 2)) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.copy(c.normalA, dist);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
                        add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] = Narrowphase.prototype.circleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                return this.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] = Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] = Narrowphase.prototype.circleConvex = function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
                var circleRadius = typeof circleRadius === "number" ? circleRadius : circleShape.radius;
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldNormal = tmp5, centerDist = tmp6, convexToCircle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, minCandidate = tmp16, found = false, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0;
                var verts = convexShape.vertices;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldNormal, worldEdgeUnit);
                    vec2.scale(candidate, worldNormal, -circleShape.radius);
                    add(candidate, candidate, circleOffset);
                    if (pointInConvex(candidate, convexShape, convexOffset, convexAngle)) {
                        vec2.sub(candidateDist, worldVertex0, candidate);
                        var candidateDistance = Math.abs(vec2.dot(candidateDist, worldNormal));
                        if (candidateDistance < minCandidateDistance) {
                            vec2.copy(minCandidate, candidate);
                            minCandidateDistance = candidateDistance;
                            vec2.scale(closestEdgeProjectedPoint, worldNormal, candidateDistance);
                            vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
                            found = true;
                        }
                    }
                }
                if (found) {
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    vec2.sub(c.normalA, minCandidate, circleOffset);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                if (circleRadius > 0) {
                    for (var i = 0; i < verts.length; i++) {
                        var localVertex = verts[i];
                        vec2.rotate(worldVertex, localVertex, convexAngle);
                        add(worldVertex, worldVertex, convexOffset);
                        sub(dist, worldVertex, circleOffset);
                        if (vec2.squaredLength(dist) < Math.pow(circleRadius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointA, c.normalA, circleRadius);
                            add(c.contactPointA, c.contactPointA, circleOffset);
                            sub(c.contactPointA, c.contactPointA, circleBody.position);
                            sub(c.contactPointB, worldVertex, convexOffset);
                            add(c.contactPointB, c.contactPointB, convexOffset);
                            sub(c.contactPointB, c.contactPointB, convexBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                            return 1;
                        }
                    }
                }
                return 0;
            };
            var pic_worldVertex0 = vec2.create(), pic_worldVertex1 = vec2.create(), pic_r0 = vec2.create(), pic_r1 = vec2.create();
            function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
                var worldVertex0 = pic_worldVertex0, worldVertex1 = pic_worldVertex1, r0 = pic_r0, r1 = pic_r1, point = worldPoint, verts = convexShape.vertices, lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(r0, worldVertex0, point);
                    sub(r1, worldVertex1, point);
                    var cross = vec2.crossLength(r0, r1);
                    if (lastCross === null) {
                        lastCross = cross;
                    }
                    if (cross * lastCross <= 0) {
                        return false;
                    }
                    lastCross = cross;
                }
                return true;
            }
            Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] = Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] = Narrowphase.prototype.particleConvex = function(particleBody, particleShape, particleOffset, particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, r0 = tmp14, r1 = tmp15, localPoint = tmp16, candidateDist = tmp17, minEdgeNormal = tmp18, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0, found = false, verts = convexShape.vertices;
                if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldTangent, worldEdgeUnit);
                    sub(dist, particleOffset, worldVertex0);
                    var d = dot(dist, worldTangent);
                    sub(centerDist, worldVertex0, convexOffset);
                    sub(convexToparticle, particleOffset, convexOffset);
                    vec2.sub(candidateDist, worldVertex0, particleOffset);
                    var candidateDistance = Math.abs(vec2.dot(candidateDist, worldTangent));
                    if (candidateDistance < minCandidateDistance) {
                        minCandidateDistance = candidateDistance;
                        vec2.scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                        vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                        vec2.copy(minEdgeNormal, worldTangent);
                        found = true;
                    }
                }
                if (found) {
                    var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
                    vec2.scale(c.normalA, minEdgeNormal, -1);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.set(c.contactPointA, 0, 0);
                    add(c.contactPointA, c.contactPointA, particleOffset);
                    sub(c.contactPointA, c.contactPointA, particleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE] = Narrowphase.prototype.circleCircle = function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, radiusB) {
                var dist = tmp1, radiusA = radiusA || shapeA.radius, radiusB = radiusB || shapeB.radius;
                sub(dist, offsetA, offsetB);
                var r = radiusA + radiusB;
                if (vec2.squaredLength(dist) > Math.pow(r, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                sub(c.normalA, offsetB, offsetA);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, radiusA);
                vec2.scale(c.contactPointB, c.normalA, -radiusB);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] = Narrowphase.prototype[Shape.PLANE | Shape.BOX] = Narrowphase.prototype.planeConvex = function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3;
                var numReported = 0;
                vec2.rotate(worldNormal, yAxis, planeAngle);
                for (var i = 0; i !== convexShape.vertices.length; i++) {
                    var v = convexShape.vertices[i];
                    vec2.rotate(worldVertex, v, convexAngle);
                    add(worldVertex, worldVertex, convexOffset);
                    sub(dist, worldVertex, planeOffset);
                    if (dot(dist, worldNormal) <= 0) {
                        if (justTest) {
                            return true;
                        }
                        numReported++;
                        var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                        sub(dist, worldVertex, planeOffset);
                        vec2.copy(c.normalA, worldNormal);
                        var d = dot(dist, c.normalA);
                        vec2.scale(dist, c.normalA, d);
                        sub(c.contactPointB, worldVertex, convexBody.position);
                        sub(c.contactPointA, worldVertex, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numReported) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numReported));
                    }
                }
                return numReported;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] = Narrowphase.prototype.particlePlane = function(particleBody, particleShape, particleOffset, particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
                var dist = tmp1, worldNormal = tmp2;
                planeAngle = planeAngle || 0;
                sub(dist, particleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(dist, worldNormal);
                if (d > 0) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
                vec2.copy(c.normalA, worldNormal);
                vec2.scale(dist, c.normalA, d);
                sub(c.contactPointA, particleOffset, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] = Narrowphase.prototype.circleParticle = function(circleBody, circleShape, circleOffset, circleAngle, particleBody, particleShape, particleOffset, particleAngle, justTest) {
                var dist = tmp1;
                sub(dist, particleOffset, circleOffset);
                if (vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            var planeCapsule_tmpCircle = new Circle({
                radius: 1
            }), planeCapsule_tmp1 = vec2.create(), planeCapsule_tmp2 = vec2.create(), planeCapsule_tmp3 = vec2.create();
            Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] = Narrowphase.prototype.planeCapsule = function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
                var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, dst = planeCapsule_tmp3;
                vec2.set(end1, -capsuleShape.length / 2, 0);
                vec2.rotate(end1, end1, capsuleAngle);
                add(end1, end1, capsuleOffset);
                vec2.set(end2, capsuleShape.length / 2, 0);
                vec2.rotate(end2, end2, capsuleAngle);
                add(end2, end2, capsuleOffset);
                circle.radius = capsuleShape.radius;
                var enableFrictionBefore;
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var numContacts1 = this.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest) {
                    return numContacts1 || numContacts2;
                } else {
                    var numTotal = numContacts1 + numContacts2;
                    if (this.enableFrictionReduction) {
                        if (numTotal) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                        }
                    }
                    return numTotal;
                }
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] = Narrowphase.prototype.circlePlane = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var circleBody = bi, circleShape = si, circleOffset = xi, planeBody = bj, shapeB = sj, planeOffset = xj, planeAngle = aj;
                planeAngle = planeAngle || 0;
                var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
                sub(planeToCircle, circleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(worldNormal, planeToCircle);
                if (d > circleShape.radius) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var contact = this.createContactEquation(planeBody, circleBody, sj, si);
                vec2.copy(contact.normalA, worldNormal);
                vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
                add(contact.contactPointB, contact.contactPointB, circleOffset);
                sub(contact.contactPointB, contact.contactPointB, circleBody.position);
                vec2.scale(temp, contact.normalA, d);
                sub(contact.contactPointA, planeToCircle, temp);
                add(contact.contactPointA, contact.contactPointA, planeOffset);
                sub(contact.contactPointA, contact.contactPointA, planeBody.position);
                this.contactEquations.push(contact);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(contact));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CONVEX] = Narrowphase.prototype[Shape.CONVEX | Shape.BOX] = Narrowphase.prototype[Shape.BOX] = Narrowphase.prototype.convexConvex = function(bi, si, xi, ai, bj, sj, xj, aj, justTest, precision) {
                var sepAxis = tmp1, worldPoint = tmp2, worldPoint0 = tmp3, worldPoint1 = tmp4, worldEdge = tmp5, projected = tmp6, penetrationVec = tmp7, dist = tmp8, worldNormal = tmp9, numContacts = 0, precision = typeof precision === "number" ? precision : 0;
                var found = Narrowphase.findSeparatingAxis(si, xi, ai, sj, xj, aj, sepAxis);
                if (!found) {
                    return 0;
                }
                sub(dist, xj, xi);
                if (dot(sepAxis, dist) > 0) {
                    vec2.scale(sepAxis, sepAxis, -1);
                }
                var closestEdge1 = Narrowphase.getClosestEdge(si, ai, sepAxis, true), closestEdge2 = Narrowphase.getClosestEdge(sj, aj, sepAxis);
                if (closestEdge1 === -1 || closestEdge2 === -1) {
                    return 0;
                }
                for (var k = 0; k < 2; k++) {
                    var closestEdgeA = closestEdge1, closestEdgeB = closestEdge2, shapeA = si, shapeB = sj, offsetA = xi, offsetB = xj, angleA = ai, angleB = aj, bodyA = bi, bodyB = bj;
                    if (k === 0) {
                        var tmp;
                        tmp = closestEdgeA;
                        closestEdgeA = closestEdgeB;
                        closestEdgeB = tmp;
                        tmp = shapeA;
                        shapeA = shapeB;
                        shapeB = tmp;
                        tmp = offsetA;
                        offsetA = offsetB;
                        offsetB = tmp;
                        tmp = angleA;
                        angleA = angleB;
                        angleB = tmp;
                        tmp = bodyA;
                        bodyA = bodyB;
                        bodyB = tmp;
                    }
                    for (var j = closestEdgeB; j < closestEdgeB + 2; j++) {
                        var v = shapeB.vertices[(j + shapeB.vertices.length) % shapeB.vertices.length];
                        vec2.rotate(worldPoint, v, angleB);
                        add(worldPoint, worldPoint, offsetB);
                        var insideNumEdges = 0;
                        for (var i = closestEdgeA - 1; i < closestEdgeA + 2; i++) {
                            var v0 = shapeA.vertices[(i + shapeA.vertices.length) % shapeA.vertices.length], v1 = shapeA.vertices[(i + 1 + shapeA.vertices.length) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(worldNormal, worldEdge);
                            vec2.normalize(worldNormal, worldNormal);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(worldNormal, dist);
                            if (i === closestEdgeA && d <= precision || i !== closestEdgeA && d <= 0) {
                                insideNumEdges++;
                            }
                        }
                        if (insideNumEdges >= 3) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                            numContacts++;
                            var v0 = shapeA.vertices[closestEdgeA % shapeA.vertices.length], v1 = shapeA.vertices[(closestEdgeA + 1) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(c.normalA, worldEdge);
                            vec2.normalize(c.normalA, c.normalA);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(c.normalA, dist);
                            vec2.scale(penetrationVec, c.normalA, d);
                            sub(c.contactPointA, worldPoint, offsetA);
                            sub(c.contactPointA, c.contactPointA, penetrationVec);
                            add(c.contactPointA, c.contactPointA, offsetA);
                            sub(c.contactPointA, c.contactPointA, bodyA.position);
                            sub(c.contactPointB, worldPoint, offsetB);
                            add(c.contactPointB, c.contactPointB, offsetB);
                            sub(c.contactPointB, c.contactPointB, bodyB.position);
                            this.contactEquations.push(c);
                            if (!this.enableFrictionReduction) {
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numContacts) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            var pcoa_tmp1 = vec2.fromValues(0, 0);
            Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result) {
                var max = null, min = null, v, value, localAxis = pcoa_tmp1;
                vec2.rotate(localAxis, worldAxis, -convexAngle);
                for (var i = 0; i < convexShape.vertices.length; i++) {
                    v = convexShape.vertices[i];
                    value = dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                var offset = dot(convexOffset, worldAxis);
                vec2.set(result, min + offset, max + offset);
            };
            var fsa_tmp1 = vec2.fromValues(0, 0), fsa_tmp2 = vec2.fromValues(0, 0), fsa_tmp3 = vec2.fromValues(0, 0), fsa_tmp4 = vec2.fromValues(0, 0), fsa_tmp5 = vec2.fromValues(0, 0), fsa_tmp6 = vec2.fromValues(0, 0);
            Narrowphase.findSeparatingAxis = function(c1, offset1, angle1, c2, offset2, angle2, sepAxis) {
                var maxDist = null, overlap = false, found = false, edge = fsa_tmp1, worldPoint0 = fsa_tmp2, worldPoint1 = fsa_tmp3, normal = fsa_tmp4, span1 = fsa_tmp5, span2 = fsa_tmp6;
                if (c1 instanceof Box && c2 instanceof Box) {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== 2; i++) {
                            if (i === 0) {
                                vec2.set(normal, 0, 1);
                            } else if (i === 1) {
                                vec2.set(normal, 1, 0);
                            }
                            if (angle !== 0) {
                                vec2.rotate(normal, normal, angle);
                            }
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                } else {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== c.vertices.length; i++) {
                            vec2.rotate(worldPoint0, c.vertices[i], angle);
                            vec2.rotate(worldPoint1, c.vertices[(i + 1) % c.vertices.length], angle);
                            sub(edge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(normal, edge);
                            vec2.normalize(normal, normal);
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                }
                return found;
            };
            var gce_tmp1 = vec2.fromValues(0, 0), gce_tmp2 = vec2.fromValues(0, 0), gce_tmp3 = vec2.fromValues(0, 0);
            Narrowphase.getClosestEdge = function(c, angle, axis, flip) {
                var localAxis = gce_tmp1, edge = gce_tmp2, normal = gce_tmp3;
                vec2.rotate(localAxis, axis, -angle);
                if (flip) {
                    vec2.scale(localAxis, localAxis, -1);
                }
                var closestEdge = -1, N = c.vertices.length, maxDot = -1;
                for (var i = 0; i !== N; i++) {
                    sub(edge, c.vertices[(i + 1) % N], c.vertices[i % N]);
                    vec2.rotate90cw(normal, edge);
                    vec2.normalize(normal, normal);
                    var d = dot(normal, localAxis);
                    if (closestEdge === -1 || d > maxDot) {
                        closestEdge = i % N;
                        maxDot = d;
                    }
                }
                return closestEdge;
            };
            var circleHeightfield_candidate = vec2.create(), circleHeightfield_dist = vec2.create(), circleHeightfield_v0 = vec2.create(), circleHeightfield_v1 = vec2.create(), circleHeightfield_minCandidate = vec2.create(), circleHeightfield_worldNormal = vec2.create(), circleHeightfield_minCandidateNormal = vec2.create();
            Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] = Narrowphase.prototype.circleHeightfield = function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, radius) {
                var data = hfShape.heights, radius = radius || circleShape.radius, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
                var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (circlePos[1] - radius > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    vec2.sub(worldNormal, v1, v0);
                    vec2.rotate(worldNormal, worldNormal, Math.PI / 2);
                    vec2.normalize(worldNormal, worldNormal);
                    vec2.scale(candidate, worldNormal, -radius);
                    vec2.add(candidate, candidate, circlePos);
                    vec2.sub(dist, candidate, v0);
                    var d = vec2.dot(dist, worldNormal);
                    if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                        if (justTest) {
                            return true;
                        }
                        found = true;
                        vec2.scale(dist, worldNormal, -d);
                        vec2.add(minCandidate, candidate, dist);
                        vec2.copy(minCandidateNormal, worldNormal);
                        var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                        vec2.copy(c.normalA, minCandidateNormal);
                        vec2.scale(c.contactPointB, c.normalA, -radius);
                        add(c.contactPointB, c.contactPointB, circlePos);
                        sub(c.contactPointB, c.contactPointB, circleBody.position);
                        vec2.copy(c.contactPointA, minCandidate);
                        vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                    }
                }
                found = false;
                if (radius > 0) {
                    for (var i = idxA; i <= idxB; i++) {
                        vec2.set(v0, i * w, data[i]);
                        vec2.add(v0, v0, hfPos);
                        vec2.sub(dist, circlePos, v0);
                        if (vec2.squaredLength(dist) < Math.pow(radius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointB, c.normalA, -radius);
                            add(c.contactPointB, c.contactPointB, circlePos);
                            sub(c.contactPointB, c.contactPointB, circleBody.position);
                            sub(c.contactPointA, v0, hfPos);
                            add(c.contactPointA, c.contactPointA, hfPos);
                            sub(c.contactPointA, c.contactPointA, hfBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (found) {
                    return 1;
                }
                return 0;
            };
            var convexHeightfield_v0 = vec2.create(), convexHeightfield_v1 = vec2.create(), convexHeightfield_tilePos = vec2.create(), convexHeightfield_tempConvexShape = new Convex({
                vertices: [ vec2.create(), vec2.create(), vec2.create(), vec2.create() ]
            });
            Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] = Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
                var data = hfShape.heights, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
                var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (convexBody.aabb.lowerBound[1] > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                var numContacts = 0;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    var tileHeight = 100;
                    vec2.set(tilePos, (v1[0] + v0[0]) * .5, (v1[1] + v0[1] - tileHeight) * .5);
                    vec2.sub(tileConvex.vertices[0], v1, tilePos);
                    vec2.sub(tileConvex.vertices[1], v0, tilePos);
                    vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
                    vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
                    tileConvex.vertices[2][1] -= tileHeight;
                    tileConvex.vertices[3][1] -= tileHeight;
                    numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
                }
                return numContacts;
            };
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        } ],
        11: [ function(_dereq_, module, exports) {
            module.exports = Ray;
            var vec2 = _dereq_("../math/vec2");
            var RaycastResult = _dereq_("../collision/RaycastResult");
            var Shape = _dereq_("../shapes/Shape");
            var AABB = _dereq_("../collision/AABB");
            function Ray(options) {
                options = options || {};
                this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();
                this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();
                this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
                this.skipBackfaces = !!options.skipBackfaces;
                this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
                this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
                this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
                this.callback = options.callback || function(result) {};
                this.direction = vec2.create();
                this.length = 1;
                this.update();
            }
            Ray.prototype.constructor = Ray;
            Ray.CLOSEST = 1;
            Ray.ANY = 2;
            Ray.ALL = 4;
            Ray.prototype.update = function() {
                var d = this.direction;
                vec2.sub(d, this.to, this.from);
                this.length = vec2.length(d);
                vec2.normalize(d, d);
            };
            Ray.prototype.intersectBodies = function(result, bodies) {
                for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
                    var body = bodies[i];
                    var aabb = body.getAABB();
                    if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
                        this.intersectBody(result, body);
                    }
                }
            };
            var intersectBody_worldPosition = vec2.create();
            Ray.prototype.intersectBody = function(result, body) {
                var checkCollisionResponse = this.checkCollisionResponse;
                if (checkCollisionResponse && !body.collisionResponse) {
                    return;
                }
                var worldPosition = intersectBody_worldPosition;
                for (var i = 0, N = body.shapes.length; i < N; i++) {
                    var shape = body.shapes[i];
                    if (checkCollisionResponse && !shape.collisionResponse) {
                        continue;
                    }
                    if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
                        continue;
                    }
                    vec2.rotate(worldPosition, shape.position, body.angle);
                    vec2.add(worldPosition, worldPosition, body.position);
                    var worldAngle = shape.angle + body.angle;
                    this.intersectShape(result, shape, worldAngle, worldPosition, body);
                    if (result.shouldStop(this)) {
                        break;
                    }
                }
            };
            Ray.prototype.intersectShape = function(result, shape, angle, position, body) {
                var from = this.from;
                var distance = distanceFromIntersectionSquared(from, this.direction, position);
                if (distance > shape.boundingRadius * shape.boundingRadius) {
                    return;
                }
                this._currentBody = body;
                this._currentShape = shape;
                shape.raycast(result, this, position, angle);
                this._currentBody = this._currentShape = null;
            };
            Ray.prototype.getAABB = function(result) {
                var to = this.to;
                var from = this.from;
                vec2.set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
                vec2.set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
            };
            var hitPointWorld = vec2.create();
            Ray.prototype.reportIntersection = function(result, fraction, normal, faceIndex) {
                var from = this.from;
                var to = this.to;
                var shape = this._currentShape;
                var body = this._currentBody;
                if (this.skipBackfaces && vec2.dot(normal, this.direction) > 0) {
                    return;
                }
                switch (this.mode) {
                  case Ray.ALL:
                    result.set(normal, shape, body, fraction, faceIndex);
                    this.callback(result);
                    break;

                  case Ray.CLOSEST:
                    if (fraction < result.fraction || !result.hasHit()) {
                        result.set(normal, shape, body, fraction, faceIndex);
                    }
                    break;

                  case Ray.ANY:
                    result.set(normal, shape, body, fraction, faceIndex);
                    break;
                }
            };
            var v0 = vec2.create(), intersect = vec2.create();
            function distanceFromIntersectionSquared(from, direction, position) {
                vec2.sub(v0, position, from);
                var dot = vec2.dot(v0, direction);
                vec2.scale(intersect, direction, dot);
                vec2.add(intersect, intersect, from);
                return vec2.squaredDistance(position, intersect);
            }
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        } ],
        12: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Ray = _dereq_("../collision/Ray");
            module.exports = RaycastResult;
            function RaycastResult() {
                this.normal = vec2.create();
                this.shape = null;
                this.body = null;
                this.faceIndex = -1;
                this.fraction = -1;
                this.isStopped = false;
            }
            RaycastResult.prototype.reset = function() {
                vec2.set(this.normal, 0, 0);
                this.shape = null;
                this.body = null;
                this.faceIndex = -1;
                this.fraction = -1;
                this.isStopped = false;
            };
            RaycastResult.prototype.getHitDistance = function(ray) {
                return vec2.distance(ray.from, ray.to) * this.fraction;
            };
            RaycastResult.prototype.hasHit = function() {
                return this.fraction !== -1;
            };
            RaycastResult.prototype.getHitPoint = function(out, ray) {
                vec2.lerp(out, ray.from, ray.to, this.fraction);
            };
            RaycastResult.prototype.stop = function() {
                this.isStopped = true;
            };
            RaycastResult.prototype.shouldStop = function(ray) {
                return this.isStopped || this.fraction !== -1 && ray.mode === Ray.ANY;
            };
            RaycastResult.prototype.set = function(normal, shape, body, fraction, faceIndex) {
                vec2.copy(this.normal, normal);
                this.shape = shape;
                this.body = body;
                this.fraction = fraction;
                this.faceIndex = faceIndex;
            };
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        } ],
        13: [ function(_dereq_, module, exports) {
            var Utils = _dereq_("../utils/Utils"), Broadphase = _dereq_("../collision/Broadphase");
            module.exports = SAPBroadphase;
            function SAPBroadphase() {
                Broadphase.call(this, Broadphase.SAP);
                this.axisList = [];
                this.axisIndex = 0;
                var that = this;
                this._addBodyHandler = function(e) {
                    that.axisList.push(e.body);
                };
                this._removeBodyHandler = function(e) {
                    var idx = that.axisList.indexOf(e.body);
                    if (idx !== -1) {
                        that.axisList.splice(idx, 1);
                    }
                };
            }
            SAPBroadphase.prototype = new Broadphase();
            SAPBroadphase.prototype.constructor = SAPBroadphase;
            SAPBroadphase.prototype.setWorld = function(world) {
                this.axisList.length = 0;
                Utils.appendArray(this.axisList, world.bodies);
                world.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                world.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                this.world = world;
            };
            SAPBroadphase.sortAxisList = function(a, axisIndex) {
                axisIndex = axisIndex | 0;
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };
            SAPBroadphase.prototype.sortList = function() {
                var bodies = this.axisList, axisIndex = this.axisIndex;
                SAPBroadphase.sortAxisList(bodies, axisIndex);
            };
            SAPBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
                result.length = 0;
                var l = bodies.length;
                while (l--) {
                    var b = bodies[l];
                    if (b.aabbNeedsUpdate) {
                        b.updateAABB();
                    }
                }
                this.sortList();
                for (var i = 0, N = bodies.length | 0; i !== N; i++) {
                    var bi = bodies[i];
                    for (var j = i + 1; j < N; j++) {
                        var bj = bodies[j];
                        var overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];
                        if (!overlaps) {
                            break;
                        }
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
            SAPBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                result = result || [];
                this.sortList();
                var axisIndex = this.axisIndex;
                var axis = "x";
                if (axisIndex === 1) {
                    axis = "y";
                }
                if (axisIndex === 2) {
                    axis = "z";
                }
                var axisList = this.axisList;
                var lower = aabb.lowerBound[axis];
                var upper = aabb.upperBound[axis];
                for (var i = 0; i < axisList.length; i++) {
                    var b = axisList[i];
                    if (b.aabbNeedsUpdate) {
                        b.updateAABB();
                    }
                    if (b.aabb.overlaps(aabb)) {
                        result.push(b);
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        } ],
        14: [ function(_dereq_, module, exports) {
            module.exports = Constraint;
            var Utils = _dereq_("../utils/Utils");
            function Constraint(bodyA, bodyB, type, options) {
                this.type = type;
                options = Utils.defaults(options, {
                    collideConnected: true,
                    wakeUpBodies: true
                });
                this.equations = [];
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.collideConnected = options.collideConnected;
                if (options.wakeUpBodies) {
                    if (bodyA) {
                        bodyA.wakeUp();
                    }
                    if (bodyB) {
                        bodyB.wakeUp();
                    }
                }
            }
            Constraint.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            };
            Constraint.DISTANCE = 1;
            Constraint.GEAR = 2;
            Constraint.LOCK = 3;
            Constraint.PRISMATIC = 4;
            Constraint.REVOLUTE = 5;
            Constraint.prototype.setStiffness = function(stiffness) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.stiffness = stiffness;
                    eq.needsUpdate = true;
                }
            };
            Constraint.prototype.setRelaxation = function(relaxation) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.relaxation = relaxation;
                    eq.needsUpdate = true;
                }
            };
        }, {
            "../utils/Utils": 57
        } ],
        15: [ function(_dereq_, module, exports) {
            var Constraint = _dereq_("./Constraint"), Equation = _dereq_("../equations/Equation"), vec2 = _dereq_("../math/vec2"), Utils = _dereq_("../utils/Utils");
            module.exports = DistanceConstraint;
            function DistanceConstraint(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    localAnchorA: [ 0, 0 ],
                    localAnchorB: [ 0, 0 ]
                });
                Constraint.call(this, bodyA, bodyB, Constraint.DISTANCE, options);
                this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);
                this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);
                var localAnchorA = this.localAnchorA;
                var localAnchorB = this.localAnchorB;
                this.distance = 0;
                if (typeof options.distance === "number") {
                    this.distance = options.distance;
                } else {
                    var worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), r = vec2.create();
                    vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
                    vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);
                    vec2.add(r, bodyB.position, worldAnchorB);
                    vec2.sub(r, r, worldAnchorA);
                    vec2.sub(r, r, bodyA.position);
                    this.distance = vec2.length(r);
                }
                var maxForce;
                if (typeof options.maxForce === "undefined") {
                    maxForce = Number.MAX_VALUE;
                } else {
                    maxForce = options.maxForce;
                }
                var normal = new Equation(bodyA, bodyB, -maxForce, maxForce);
                this.equations = [ normal ];
                this.maxForce = maxForce;
                var r = vec2.create();
                var ri = vec2.create();
                var rj = vec2.create();
                var that = this;
                normal.computeGq = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(r, xj, rj);
                    vec2.sub(r, r, ri);
                    vec2.sub(r, r, xi);
                    return vec2.length(r) - that.distance;
                };
                this.setMaxForce(maxForce);
                this.upperLimitEnabled = false;
                this.upperLimit = 1;
                this.lowerLimitEnabled = false;
                this.lowerLimit = 0;
                this.position = 0;
            }
            DistanceConstraint.prototype = new Constraint();
            DistanceConstraint.prototype.constructor = DistanceConstraint;
            var n = vec2.create();
            var ri = vec2.create();
            var rj = vec2.create();
            DistanceConstraint.prototype.update = function() {
                var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, distance = this.distance, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
                vec2.rotate(ri, this.localAnchorA, bodyA.angle);
                vec2.rotate(rj, this.localAnchorB, bodyB.angle);
                vec2.add(n, xj, rj);
                vec2.sub(n, n, ri);
                vec2.sub(n, n, xi);
                this.position = vec2.length(n);
                var violating = false;
                if (this.upperLimitEnabled) {
                    if (this.position > this.upperLimit) {
                        normalEquation.maxForce = 0;
                        normalEquation.minForce = -this.maxForce;
                        this.distance = this.upperLimit;
                        violating = true;
                    }
                }
                if (this.lowerLimitEnabled) {
                    if (this.position < this.lowerLimit) {
                        normalEquation.maxForce = this.maxForce;
                        normalEquation.minForce = 0;
                        this.distance = this.lowerLimit;
                        violating = true;
                    }
                }
                if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
                    normalEquation.enabled = false;
                    return;
                }
                normalEquation.enabled = true;
                vec2.normalize(n, n);
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
            };
            DistanceConstraint.prototype.setMaxForce = function(maxForce) {
                var normal = this.equations[0];
                normal.minForce = -maxForce;
                normal.maxForce = maxForce;
            };
            DistanceConstraint.prototype.getMaxForce = function() {
                var normal = this.equations[0];
                return normal.maxForce;
            };
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        } ],
        16: [ function(_dereq_, module, exports) {
            var Constraint = _dereq_("./Constraint"), Equation = _dereq_("../equations/Equation"), AngleLockEquation = _dereq_("../equations/AngleLockEquation"), vec2 = _dereq_("../math/vec2");
            module.exports = GearConstraint;
            function GearConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);
                this.ratio = options.ratio !== undefined ? options.ratio : 1;
                this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;
                options.angle = this.angle;
                options.ratio = this.ratio;
                this.equations = [ new AngleLockEquation(bodyA, bodyB, options) ];
                if (options.maxTorque !== undefined) {
                    this.setMaxTorque(options.maxTorque);
                }
            }
            GearConstraint.prototype = new Constraint();
            GearConstraint.prototype.constructor = GearConstraint;
            GearConstraint.prototype.update = function() {
                var eq = this.equations[0];
                if (eq.ratio !== this.ratio) {
                    eq.setRatio(this.ratio);
                }
                eq.angle = this.angle;
            };
            GearConstraint.prototype.setMaxTorque = function(torque) {
                this.equations[0].setMaxTorque(torque);
            };
            GearConstraint.prototype.getMaxTorque = function(torque) {
                return this.equations[0].maxForce;
            };
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        17: [ function(_dereq_, module, exports) {
            var Constraint = _dereq_("./Constraint"), vec2 = _dereq_("../math/vec2"), Equation = _dereq_("../equations/Equation");
            module.exports = LockConstraint;
            function LockConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.LOCK, options);
                var maxForce = typeof options.maxForce === "undefined" ? Number.MAX_VALUE : options.maxForce;
                var localAngleB = options.localAngleB || 0;
                var x = new Equation(bodyA, bodyB, -maxForce, maxForce), y = new Equation(bodyA, bodyB, -maxForce, maxForce), rot = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var l = vec2.create(), g = vec2.create(), that = this;
                x.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[0];
                };
                y.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[1];
                };
                var r = vec2.create(), t = vec2.create();
                rot.computeGq = function() {
                    vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
                    vec2.scale(r, r, -1);
                    vec2.sub(g, bodyA.position, bodyB.position);
                    vec2.add(g, g, r);
                    vec2.rotate(t, r, -Math.PI / 2);
                    vec2.normalize(t, t);
                    return vec2.dot(g, t);
                };
                this.localOffsetB = vec2.create();
                if (options.localOffsetB) {
                    vec2.copy(this.localOffsetB, options.localOffsetB);
                } else {
                    vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
                    vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
                }
                this.localAngleB = 0;
                if (typeof options.localAngleB === "number") {
                    this.localAngleB = options.localAngleB;
                } else {
                    this.localAngleB = bodyB.angle - bodyA.angle;
                }
                this.equations.push(x, y, rot);
                this.setMaxForce(maxForce);
            }
            LockConstraint.prototype = new Constraint();
            LockConstraint.prototype.constructor = LockConstraint;
            LockConstraint.prototype.setMaxForce = function(force) {
                var eqs = this.equations;
                for (var i = 0; i < this.equations.length; i++) {
                    eqs[i].maxForce = force;
                    eqs[i].minForce = -force;
                }
            };
            LockConstraint.prototype.getMaxForce = function() {
                return this.equations[0].maxForce;
            };
            var l = vec2.create();
            var r = vec2.create();
            var t = vec2.create();
            var xAxis = vec2.fromValues(1, 0);
            var yAxis = vec2.fromValues(0, 1);
            LockConstraint.prototype.update = function() {
                var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
                vec2.rotate(l, this.localOffsetB, bodyA.angle);
                vec2.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
                vec2.scale(r, r, -1);
                vec2.rotate(t, r, Math.PI / 2);
                vec2.normalize(t, t);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(l, xAxis);
                x.G[3] = 1;
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(l, yAxis);
                y.G[4] = 1;
                rot.G[0] = -t[0];
                rot.G[1] = -t[1];
                rot.G[3] = t[0];
                rot.G[4] = t[1];
                rot.G[5] = vec2.crossLength(r, t);
            };
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        18: [ function(_dereq_, module, exports) {
            var Constraint = _dereq_("./Constraint"), ContactEquation = _dereq_("../equations/ContactEquation"), Equation = _dereq_("../equations/Equation"), vec2 = _dereq_("../math/vec2"), RotationalLockEquation = _dereq_("../equations/RotationalLockEquation");
            module.exports = PrismaticConstraint;
            function PrismaticConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.PRISMATIC, options);
                var localAnchorA = vec2.fromValues(0, 0), localAxisA = vec2.fromValues(1, 0), localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(localAnchorA, options.localAnchorA);
                }
                if (options.localAxisA) {
                    vec2.copy(localAxisA, options.localAxisA);
                }
                if (options.localAnchorB) {
                    vec2.copy(localAnchorB, options.localAnchorB);
                }
                this.localAnchorA = localAnchorA;
                this.localAnchorB = localAnchorB;
                this.localAxisA = localAxisA;
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                var trans = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var ri = new vec2.create(), rj = new vec2.create(), gg = new vec2.create(), t = new vec2.create();
                trans.computeGq = function() {
                    return vec2.dot(gg, t);
                };
                trans.updateJacobian = function() {
                    var G = this.G, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(gg, xj, rj);
                    vec2.sub(gg, gg, xi);
                    vec2.sub(gg, gg, ri);
                    vec2.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
                    G[0] = -t[0];
                    G[1] = -t[1];
                    G[2] = -vec2.crossLength(ri, t) + vec2.crossLength(t, gg);
                    G[3] = t[0];
                    G[4] = t[1];
                    G[5] = vec2.crossLength(rj, t);
                };
                this.equations.push(trans);
                if (!options.disableRotationalLock) {
                    var rot = new RotationalLockEquation(bodyA, bodyB, -maxForce, maxForce);
                    this.equations.push(rot);
                }
                this.position = 0;
                this.velocity = 0;
                this.lowerLimitEnabled = typeof options.lowerLimit !== "undefined" ? true : false;
                this.upperLimitEnabled = typeof options.upperLimit !== "undefined" ? true : false;
                this.lowerLimit = typeof options.lowerLimit !== "undefined" ? options.lowerLimit : 0;
                this.upperLimit = typeof options.upperLimit !== "undefined" ? options.upperLimit : 1;
                this.upperLimitEquation = new ContactEquation(bodyA, bodyB);
                this.lowerLimitEquation = new ContactEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;
                this.motorEquation = new Equation(bodyA, bodyB);
                this.motorEnabled = false;
                this.motorSpeed = 0;
                var that = this;
                var motorEquation = this.motorEquation;
                var old = motorEquation.computeGW;
                motorEquation.computeGq = function() {
                    return 0;
                };
                motorEquation.computeGW = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                    return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
                };
            }
            PrismaticConstraint.prototype = new Constraint();
            PrismaticConstraint.prototype.constructor = PrismaticConstraint;
            var worldAxisA = vec2.create(), worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), orientedAnchorA = vec2.create(), orientedAnchorB = vec2.create(), tmp = vec2.create();
            PrismaticConstraint.prototype.update = function() {
                var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
                trans.updateJacobian();
                vec2.rotate(worldAxisA, localAxisA, bodyA.angle);
                vec2.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
                vec2.add(worldAnchorA, orientedAnchorA, bodyA.position);
                vec2.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
                vec2.add(worldAnchorB, orientedAnchorB, bodyB.position);
                var relPosition = this.position = vec2.dot(worldAnchorB, worldAxisA) - vec2.dot(worldAnchorA, worldAxisA);
                if (this.motorEnabled) {
                    var G = this.motorEquation.G;
                    G[0] = worldAxisA[0];
                    G[1] = worldAxisA[1];
                    G[2] = vec2.crossLength(worldAxisA, orientedAnchorB);
                    G[3] = -worldAxisA[0];
                    G[4] = -worldAxisA[1];
                    G[5] = -vec2.crossLength(worldAxisA, orientedAnchorA);
                }
                if (this.upperLimitEnabled && relPosition > upperLimit) {
                    vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
                    vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, upperLimit);
                    vec2.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relPosition < lowerLimit) {
                    vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
                    vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, lowerLimit);
                    vec2.sub(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
            };
            PrismaticConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            PrismaticConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            PrismaticConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        19: [ function(_dereq_, module, exports) {
            var Constraint = _dereq_("./Constraint"), Equation = _dereq_("../equations/Equation"), RotationalVelocityEquation = _dereq_("../equations/RotationalVelocityEquation"), RotationalLockEquation = _dereq_("../equations/RotationalLockEquation"), vec2 = _dereq_("../math/vec2");
            module.exports = RevoluteConstraint;
            var worldPivotA = vec2.create(), worldPivotB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1), g = vec2.create();
            function RevoluteConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.REVOLUTE, options);
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                this.pivotA = vec2.create();
                this.pivotB = vec2.create();
                if (options.worldPivot) {
                    vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
                    vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
                    vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
                    vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
                } else {
                    vec2.copy(this.pivotA, options.localPivotA);
                    vec2.copy(this.pivotB, options.localPivotB);
                }
                var eqs = this.equations = [ new Equation(bodyA, bodyB, -maxForce, maxForce), new Equation(bodyA, bodyB, -maxForce, maxForce) ];
                var x = eqs[0];
                var y = eqs[1];
                var that = this;
                x.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, xAxis);
                };
                y.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, yAxis);
                };
                y.minForce = x.minForce = -maxForce;
                y.maxForce = x.maxForce = maxForce;
                this.motorEquation = new RotationalVelocityEquation(bodyA, bodyB);
                this.motorEnabled = false;
                this.angle = 0;
                this.lowerLimitEnabled = false;
                this.upperLimitEnabled = false;
                this.lowerLimit = 0;
                this.upperLimit = 0;
                this.upperLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.lowerLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = 0;
                this.lowerLimitEquation.maxForce = 0;
            }
            RevoluteConstraint.prototype = new Constraint();
            RevoluteConstraint.prototype.constructor = RevoluteConstraint;
            RevoluteConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
            RevoluteConstraint.prototype.update = function() {
                var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, normal = eqs[0], tangent = eqs[1], x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
                var relAngle = this.angle = bodyB.angle - bodyA.angle;
                if (this.upperLimitEnabled && relAngle > upperLimit) {
                    upperLimitEquation.angle = upperLimit;
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relAngle < lowerLimit) {
                    lowerLimitEquation.angle = lowerLimit;
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                vec2.rotate(worldPivotA, pivotA, bodyA.angle);
                vec2.rotate(worldPivotB, pivotB, bodyB.angle);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(worldPivotA, xAxis);
                x.G[3] = 1;
                x.G[4] = 0;
                x.G[5] = vec2.crossLength(worldPivotB, xAxis);
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(worldPivotA, yAxis);
                y.G[3] = 0;
                y.G[4] = 1;
                y.G[5] = vec2.crossLength(worldPivotB, yAxis);
            };
            RevoluteConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            RevoluteConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            RevoluteConstraint.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled;
            };
            RevoluteConstraint.prototype.setMotorSpeed = function(speed) {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations[i].relativeVelocity = speed;
            };
            RevoluteConstraint.prototype.getMotorSpeed = function() {
                if (!this.motorEnabled) {
                    return false;
                }
                return this.motorEquation.relativeVelocity;
            };
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        20: [ function(_dereq_, module, exports) {
            var Equation = _dereq_("./Equation"), vec2 = _dereq_("../math/vec2");
            module.exports = AngleLockEquation;
            function AngleLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                this.setRatio(this.ratio);
            }
            AngleLockEquation.prototype = new Equation();
            AngleLockEquation.prototype.constructor = AngleLockEquation;
            AngleLockEquation.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
            };
            AngleLockEquation.prototype.setRatio = function(ratio) {
                var G = this.G;
                G[2] = ratio;
                G[5] = -1;
                this.ratio = ratio;
            };
            AngleLockEquation.prototype.setMaxTorque = function(torque) {
                this.maxForce = torque;
                this.minForce = -torque;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        21: [ function(_dereq_, module, exports) {
            var Equation = _dereq_("./Equation"), vec2 = _dereq_("../math/vec2");
            module.exports = ContactEquation;
            function ContactEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);
                this.contactPointA = vec2.create();
                this.penetrationVec = vec2.create();
                this.contactPointB = vec2.create();
                this.normalA = vec2.create();
                this.restitution = 0;
                this.firstImpact = false;
                this.shapeA = null;
                this.shapeB = null;
            }
            ContactEquation.prototype = new Equation();
            ContactEquation.prototype.constructor = ContactEquation;
            ContactEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = bi.position, xj = bj.position;
                var penetrationVec = this.penetrationVec, n = this.normalA, G = this.G;
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
                vec2.add(penetrationVec, xj, rj);
                vec2.sub(penetrationVec, penetrationVec, xi);
                vec2.sub(penetrationVec, penetrationVec, ri);
                var GW, Gq;
                if (this.firstImpact && this.restitution !== 0) {
                    Gq = 0;
                    GW = 1 / b * (1 + this.restitution) * this.computeGW();
                } else {
                    Gq = vec2.dot(n, penetrationVec) + this.offset;
                    GW = this.computeGW();
                }
                var GiMf = this.computeGiMf();
                var B = -Gq * a - GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        22: [ function(_dereq_, module, exports) {
            module.exports = Equation;
            var vec2 = _dereq_("../math/vec2"), Utils = _dereq_("../utils/Utils"), Body = _dereq_("../objects/Body");
            function Equation(bodyA, bodyB, minForce, maxForce) {
                this.minForce = typeof minForce === "undefined" ? -Number.MAX_VALUE : minForce;
                this.maxForce = typeof maxForce === "undefined" ? Number.MAX_VALUE : maxForce;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.G = new Utils.ARRAY_TYPE(6);
                for (var i = 0; i < 6; i++) {
                    this.G[i] = 0;
                }
                this.offset = 0;
                this.a = 0;
                this.b = 0;
                this.epsilon = 0;
                this.timeStep = 1 / 60;
                this.needsUpdate = true;
                this.multiplier = 0;
                this.relativeVelocity = 0;
                this.enabled = true;
            }
            Equation.prototype.constructor = Equation;
            Equation.DEFAULT_STIFFNESS = 1e6;
            Equation.DEFAULT_RELAXATION = 4;
            Equation.prototype.update = function() {
                var k = this.stiffness, d = this.relaxation, h = this.timeStep;
                this.a = 4 / (h * (1 + 4 * d));
                this.b = 4 * d / (1 + 4 * d);
                this.epsilon = 4 / (h * h * k * (1 + 4 * d));
                this.needsUpdate = false;
            };
            Equation.prototype.gmult = function(G, vi, wi, vj, wj) {
                return G[0] * vi[0] + G[1] * vi[1] + G[2] * wi + G[3] * vj[0] + G[4] * vj[1] + G[5] * wj;
            };
            Equation.prototype.computeB = function(a, b, h) {
                var GW = this.computeGW();
                var Gq = this.computeGq();
                var GiMf = this.computeGiMf();
                return -Gq * a - GW * b - GiMf * h;
            };
            var qi = vec2.create(), qj = vec2.create();
            Equation.prototype.computeGq = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, xi = bi.position, xj = bj.position, ai = bi.angle, aj = bj.angle;
                return this.gmult(G, qi, ai, qj, aj) + this.offset;
            };
            Equation.prototype.computeGW = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
            };
            Equation.prototype.computeGWlambda = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
                return this.gmult(G, vi, wi, vj, wj);
            };
            var iMfi = vec2.create(), iMfj = vec2.create();
            Equation.prototype.computeGiMf = function() {
                var bi = this.bodyA, bj = this.bodyB, fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                vec2.scale(iMfi, fi, invMassi);
                vec2.multiply(iMfi, bi.massMultiplier, iMfi);
                vec2.scale(iMfj, fj, invMassj);
                vec2.multiply(iMfj, bj.massMultiplier, iMfj);
                return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
            };
            Equation.prototype.computeGiMGt = function() {
                var bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                return G[0] * G[0] * invMassi * bi.massMultiplier[0] + G[1] * G[1] * invMassi * bi.massMultiplier[1] + G[2] * G[2] * invIi + G[3] * G[3] * invMassj * bj.massMultiplier[0] + G[4] * G[4] * invMassj * bj.massMultiplier[1] + G[5] * G[5] * invIj;
            };
            var addToWlambda_temp = vec2.create(), addToWlambda_Gi = vec2.create(), addToWlambda_Gj = vec2.create(), addToWlambda_ri = vec2.create(), addToWlambda_rj = vec2.create(), addToWlambda_Mdiag = vec2.create();
            Equation.prototype.addToWlambda = function(deltalambda) {
                var bi = this.bodyA, bj = this.bodyB, temp = addToWlambda_temp, Gi = addToWlambda_Gi, Gj = addToWlambda_Gj, ri = addToWlambda_ri, rj = addToWlambda_rj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, Mdiag = addToWlambda_Mdiag, G = this.G;
                Gi[0] = G[0];
                Gi[1] = G[1];
                Gj[0] = G[3];
                Gj[1] = G[4];
                vec2.scale(temp, Gi, invMassi * deltalambda);
                vec2.multiply(temp, temp, bi.massMultiplier);
                vec2.add(bi.vlambda, bi.vlambda, temp);
                bi.wlambda += invIi * G[2] * deltalambda;
                vec2.scale(temp, Gj, invMassj * deltalambda);
                vec2.multiply(temp, temp, bj.massMultiplier);
                vec2.add(bj.vlambda, bj.vlambda, temp);
                bj.wlambda += invIj * G[5] * deltalambda;
            };
            Equation.prototype.computeInvC = function(eps) {
                return 1 / (this.computeGiMGt() + eps);
            };
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        } ],
        23: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), Equation = _dereq_("./Equation"), Utils = _dereq_("../utils/Utils");
            module.exports = FrictionEquation;
            function FrictionEquation(bodyA, bodyB, slipForce) {
                Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
                this.contactPointA = vec2.create();
                this.contactPointB = vec2.create();
                this.t = vec2.create();
                this.contactEquations = [];
                this.shapeA = null;
                this.shapeB = null;
                this.frictionCoefficient = .3;
            }
            FrictionEquation.prototype = new Equation();
            FrictionEquation.prototype.constructor = FrictionEquation;
            FrictionEquation.prototype.setSlipForce = function(slipForce) {
                this.maxForce = slipForce;
                this.minForce = -slipForce;
            };
            FrictionEquation.prototype.getSlipForce = function() {
                return this.maxForce;
            };
            FrictionEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
                G[0] = -t[0];
                G[1] = -t[1];
                G[2] = -vec2.crossLength(ri, t);
                G[3] = t[0];
                G[4] = t[1];
                G[5] = vec2.crossLength(rj, t);
                var GW = this.computeGW(), GiMf = this.computeGiMf();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        } ],
        24: [ function(_dereq_, module, exports) {
            var Equation = _dereq_("./Equation"), vec2 = _dereq_("../math/vec2");
            module.exports = RotationalLockEquation;
            function RotationalLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                var G = this.G;
                G[2] = 1;
                G[5] = -1;
            }
            RotationalLockEquation.prototype = new Equation();
            RotationalLockEquation.prototype.constructor = RotationalLockEquation;
            var worldVectorA = vec2.create(), worldVectorB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1);
            RotationalLockEquation.prototype.computeGq = function() {
                vec2.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
                vec2.rotate(worldVectorB, yAxis, this.bodyB.angle);
                return vec2.dot(worldVectorA, worldVectorB);
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        25: [ function(_dereq_, module, exports) {
            var Equation = _dereq_("./Equation"), vec2 = _dereq_("../math/vec2");
            module.exports = RotationalVelocityEquation;
            function RotationalVelocityEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.relativeVelocity = 1;
                this.ratio = 1;
            }
            RotationalVelocityEquation.prototype = new Equation();
            RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
            RotationalVelocityEquation.prototype.computeB = function(a, b, h) {
                var G = this.G;
                G[2] = -1;
                G[5] = this.ratio;
                var GiMf = this.computeGiMf();
                var GW = this.computeGW();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        26: [ function(_dereq_, module, exports) {
            var EventEmitter = function() {};
            module.exports = EventEmitter;
            EventEmitter.prototype = {
                constructor: EventEmitter,
                on: function(type, listener, context) {
                    listener.context = context || this;
                    if (this._listeners === undefined) {
                        this._listeners = {};
                    }
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = [];
                    }
                    if (listeners[type].indexOf(listener) === -1) {
                        listeners[type].push(listener);
                    }
                    return this;
                },
                has: function(type, listener) {
                    if (this._listeners === undefined) {
                        return false;
                    }
                    var listeners = this._listeners;
                    if (listener) {
                        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                            return true;
                        }
                    } else {
                        if (listeners[type] !== undefined) {
                            return true;
                        }
                    }
                    return false;
                },
                off: function(type, listener) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var index = listeners[type].indexOf(listener);
                    if (index !== -1) {
                        listeners[type].splice(index, 1);
                    }
                    return this;
                },
                emit: function(event) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        for (var i = 0, l = listenerArray.length; i < l; i++) {
                            var listener = listenerArray[i];
                            listener.call(listener.context, event);
                        }
                    }
                    return this;
                }
            };
        }, {} ],
        27: [ function(_dereq_, module, exports) {
            var Material = _dereq_("./Material");
            var Equation = _dereq_("../equations/Equation");
            module.exports = ContactMaterial;
            function ContactMaterial(materialA, materialB, options) {
                options = options || {};
                if (!(materialA instanceof Material) || !(materialB instanceof Material)) {
                    throw new Error("First two arguments must be Material instances.");
                }
                this.id = ContactMaterial.idCounter++;
                this.materialA = materialA;
                this.materialB = materialB;
                this.friction = typeof options.friction !== "undefined" ? Number(options.friction) : .3;
                this.restitution = typeof options.restitution !== "undefined" ? Number(options.restitution) : 0;
                this.stiffness = typeof options.stiffness !== "undefined" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;
                this.relaxation = typeof options.relaxation !== "undefined" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = typeof options.frictionStiffness !== "undefined" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = typeof options.frictionRelaxation !== "undefined" ? Number(options.frictionRelaxation) : Equation.DEFAULT_RELAXATION;
                this.surfaceVelocity = typeof options.surfaceVelocity !== "undefined" ? Number(options.surfaceVelocity) : 0;
                this.contactSkinSize = .005;
            }
            ContactMaterial.idCounter = 0;
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        } ],
        28: [ function(_dereq_, module, exports) {
            module.exports = Material;
            function Material(id) {
                this.id = id || Material.idCounter++;
            }
            Material.idCounter = 0;
        }, {} ],
        29: [ function(_dereq_, module, exports) {
            var PolyK = {};
            PolyK.GetArea = function(p) {
                if (p.length < 6) return 0;
                var l = p.length - 2;
                var sum = 0;
                for (var i = 0; i < l; i += 2) sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
                sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
                return -sum * .5;
            };
            PolyK.Triangulate = function(p) {
                var n = p.length >> 1;
                if (n < 3) return [];
                var tgs = [];
                var avl = [];
                for (var i = 0; i < n; i++) avl.push(i);
                var i = 0;
                var al = n;
                while (al > 3) {
                    var i0 = avl[(i + 0) % al];
                    var i1 = avl[(i + 1) % al];
                    var i2 = avl[(i + 2) % al];
                    var ax = p[2 * i0], ay = p[2 * i0 + 1];
                    var bx = p[2 * i1], by = p[2 * i1 + 1];
                    var cx = p[2 * i2], cy = p[2 * i2 + 1];
                    var earFound = false;
                    if (PolyK._convex(ax, ay, bx, by, cx, cy)) {
                        earFound = true;
                        for (var j = 0; j < al; j++) {
                            var vi = avl[j];
                            if (vi == i0 || vi == i1 || vi == i2) continue;
                            if (PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                                earFound = false;
                                break;
                            }
                        }
                    }
                    if (earFound) {
                        tgs.push(i0, i1, i2);
                        avl.splice((i + 1) % al, 1);
                        al--;
                        i = 0;
                    } else if (i++ > 3 * al) break;
                }
                tgs.push(avl[0], avl[1], avl[2]);
                return tgs;
            };
            PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
                var v0x = cx - ax;
                var v0y = cy - ay;
                var v1x = bx - ax;
                var v1y = by - ay;
                var v2x = px - ax;
                var v2y = py - ay;
                var dot00 = v0x * v0x + v0y * v0y;
                var dot01 = v0x * v1x + v0y * v1y;
                var dot02 = v0x * v2x + v0y * v2y;
                var dot11 = v1x * v1x + v1y * v1y;
                var dot12 = v1x * v2x + v1y * v2y;
                var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return u >= 0 && v >= 0 && u + v < 1;
            };
            PolyK._convex = function(ax, ay, bx, by, cx, cy) {
                return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
            };
            module.exports = PolyK;
        }, {} ],
        30: [ function(_dereq_, module, exports) {
            var vec2 = module.exports = {};
            var Utils = _dereq_("../utils/Utils");
            vec2.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0];
            };
            vec2.crossVZ = function(out, vec, zcomp) {
                vec2.rotate(out, vec, -Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.crossZV = function(out, zcomp, vec) {
                vec2.rotate(out, vec, Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.rotate = function(out, a, angle) {
                if (angle !== 0) {
                    var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
                    out[0] = c * x - s * y;
                    out[1] = s * x + c * y;
                } else {
                    out[0] = a[0];
                    out[1] = a[1];
                }
            };
            vec2.rotate90cw = function(out, a) {
                var x = a[0];
                var y = a[1];
                out[0] = y;
                out[1] = -x;
            };
            vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle) {
                vec2.copy(out, worldPoint);
                vec2.sub(out, out, framePosition);
                vec2.rotate(out, out, -frameAngle);
            };
            vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle) {
                vec2.copy(out, localPoint);
                vec2.rotate(out, out, frameAngle);
                vec2.add(out, out, framePosition);
            };
            vec2.vectorToLocalFrame = function(out, worldVector, frameAngle) {
                vec2.rotate(out, worldVector, -frameAngle);
            };
            vec2.vectorToGlobalFrame = function(out, localVector, frameAngle) {
                vec2.rotate(out, localVector, frameAngle);
            };
            vec2.centroid = function(out, a, b, c) {
                vec2.add(out, a, b);
                vec2.add(out, out, c);
                vec2.scale(out, out, 1 / 3);
                return out;
            };
            vec2.create = function() {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = 0;
                out[1] = 0;
                return out;
            };
            vec2.clone = function(a) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.fromValues = function(x, y) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.set = function(out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            };
            vec2.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            };
            vec2.sub = vec2.subtract;
            vec2.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                return out;
            };
            vec2.mul = vec2.multiply;
            vec2.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                return out;
            };
            vec2.div = vec2.divide;
            vec2.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            };
            vec2.distance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.dist = vec2.distance;
            vec2.squaredDistance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return x * x + y * y;
            };
            vec2.sqrDist = vec2.squaredDistance;
            vec2.length = function(a) {
                var x = a[0], y = a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.len = vec2.length;
            vec2.squaredLength = function(a) {
                var x = a[0], y = a[1];
                return x * x + y * y;
            };
            vec2.sqrLen = vec2.squaredLength;
            vec2.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            };
            vec2.normalize = function(out, a) {
                var x = a[0], y = a[1];
                var len = x * x + y * y;
                if (len > 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            };
            vec2.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1];
            };
            vec2.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")";
            };
            vec2.lerp = function(out, a, b, t) {
                var ax = a[0], ay = a[1];
                out[0] = ax + t * (b[0] - ax);
                out[1] = ay + t * (b[1] - ay);
                return out;
            };
            vec2.reflect = function(out, vector, normal) {
                var dot = vector[0] * normal[0] + vector[1] * normal[1];
                out[0] = vector[0] - 2 * normal[0] * dot;
                out[1] = vector[1] - 2 * normal[1] * dot;
            };
            vec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {
                var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
                if (t < 0) {
                    return false;
                } else {
                    out[0] = p0[0] + t * (p1[0] - p0[0]);
                    out[1] = p0[1] + t * (p1[1] - p0[1]);
                    return true;
                }
            };
            vec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {
                var s1_x = p1[0] - p0[0];
                var s1_y = p1[1] - p0[1];
                var s2_x = p3[0] - p2[0];
                var s2_y = p3[1] - p2[1];
                var s, t;
                s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
                t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                    return t;
                }
                return -1;
            };
        }, {
            "../utils/Utils": 57
        } ],
        31: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), decomp = _dereq_("poly-decomp"), Convex = _dereq_("../shapes/Convex"), RaycastResult = _dereq_("../collision/RaycastResult"), Ray = _dereq_("../collision/Ray"), AABB = _dereq_("../collision/AABB"), EventEmitter = _dereq_("../events/EventEmitter");
            module.exports = Body;
            function Body(options) {
                options = options || {};
                EventEmitter.call(this);
                this.id = options.id || ++Body._idCounter;
                this.world = null;
                this.shapes = [];
                this.mass = options.mass || 0;
                this.invMass = 0;
                this.inertia = 0;
                this.invInertia = 0;
                this.invMassSolve = 0;
                this.invInertiaSolve = 0;
                this.fixedRotation = !!options.fixedRotation;
                this.fixedX = !!options.fixedX;
                this.fixedY = !!options.fixedY;
                this.massMultiplier = vec2.create();
                this.position = vec2.fromValues(0, 0);
                if (options.position) {
                    vec2.copy(this.position, options.position);
                }
                this.interpolatedPosition = vec2.fromValues(0, 0);
                this.interpolatedAngle = 0;
                this.previousPosition = vec2.fromValues(0, 0);
                this.previousAngle = 0;
                this.velocity = vec2.fromValues(0, 0);
                if (options.velocity) {
                    vec2.copy(this.velocity, options.velocity);
                }
                this.vlambda = vec2.fromValues(0, 0);
                this.wlambda = 0;
                this.angle = options.angle || 0;
                this.angularVelocity = options.angularVelocity || 0;
                this.force = vec2.create();
                if (options.force) {
                    vec2.copy(this.force, options.force);
                }
                this.angularForce = options.angularForce || 0;
                this.damping = typeof options.damping === "number" ? options.damping : .1;
                this.angularDamping = typeof options.angularDamping === "number" ? options.angularDamping : .1;
                this.type = Body.STATIC;
                if (typeof options.type !== "undefined") {
                    this.type = options.type;
                } else if (!options.mass) {
                    this.type = Body.STATIC;
                } else {
                    this.type = Body.DYNAMIC;
                }
                this.boundingRadius = 0;
                this.aabb = new AABB();
                this.aabbNeedsUpdate = true;
                this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;
                this.wantsToSleep = false;
                this.sleepState = Body.AWAKE;
                this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : .2;
                this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;
                this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;
                this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
                this.idleTime = 0;
                this.timeLastSleepy = 0;
                this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;
                this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;
                this.concavePath = null;
                this._wakeUpAfterNarrowphase = false;
                this.updateMassProperties();
            }
            Body.prototype = new EventEmitter();
            Body.prototype.constructor = Body;
            Body._idCounter = 0;
            Body.prototype.updateSolveMassProperties = function() {
                if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                    this.invMassSolve = 0;
                    this.invInertiaSolve = 0;
                } else {
                    this.invMassSolve = this.invMass;
                    this.invInertiaSolve = this.invInertia;
                }
            };
            Body.prototype.setDensity = function(density) {
                var totalArea = this.getArea();
                this.mass = totalArea * density;
                this.updateMassProperties();
            };
            Body.prototype.getArea = function() {
                var totalArea = 0;
                for (var i = 0; i < this.shapes.length; i++) {
                    totalArea += this.shapes[i].area;
                }
                return totalArea;
            };
            Body.prototype.getAABB = function() {
                if (this.aabbNeedsUpdate) {
                    this.updateAABB();
                }
                return this.aabb;
            };
            var shapeAABB = new AABB(), tmp = vec2.create();
            Body.prototype.updateAABB = function() {
                var shapes = this.shapes, N = shapes.length, offset = tmp, bodyAngle = this.angle;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], angle = shape.angle + bodyAngle;
                    vec2.rotate(offset, shape.position, bodyAngle);
                    vec2.add(offset, offset, this.position);
                    shape.computeAABB(shapeAABB, offset, angle);
                    if (i === 0) {
                        this.aabb.copy(shapeAABB);
                    } else {
                        this.aabb.extend(shapeAABB);
                    }
                }
                this.aabbNeedsUpdate = false;
            };
            Body.prototype.updateBoundingRadius = function() {
                var shapes = this.shapes, N = shapes.length, radius = 0;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], offset = vec2.length(shape.position), r = shape.boundingRadius;
                    if (offset + r > radius) {
                        radius = offset + r;
                    }
                }
                this.boundingRadius = radius;
            };
            Body.prototype.addShape = function(shape, offset, angle) {
                if (shape.body) {
                    throw new Error("A shape can only be added to one body.");
                }
                shape.body = this;
                if (offset) {
                    vec2.copy(shape.position, offset);
                } else {
                    vec2.set(shape.position, 0, 0);
                }
                shape.angle = angle || 0;
                this.shapes.push(shape);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = true;
            };
            Body.prototype.removeShape = function(shape) {
                var idx = this.shapes.indexOf(shape);
                if (idx !== -1) {
                    this.shapes.splice(idx, 1);
                    this.aabbNeedsUpdate = true;
                    shape.body = null;
                    return true;
                } else {
                    return false;
                }
            };
            Body.prototype.updateMassProperties = function() {
                if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
                    this.mass = Number.MAX_VALUE;
                    this.invMass = 0;
                    this.inertia = Number.MAX_VALUE;
                    this.invInertia = 0;
                } else {
                    var shapes = this.shapes, N = shapes.length, m = this.mass / N, I = 0;
                    if (!this.fixedRotation) {
                        for (var i = 0; i < N; i++) {
                            var shape = shapes[i], r2 = vec2.squaredLength(shape.position), Icm = shape.computeMomentOfInertia(m);
                            I += Icm + m * r2;
                        }
                        this.inertia = I;
                        this.invInertia = I > 0 ? 1 / I : 0;
                    } else {
                        this.inertia = Number.MAX_VALUE;
                        this.invInertia = 0;
                    }
                    this.invMass = 1 / this.mass;
                    vec2.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
                }
            };
            var Body_applyForce_r = vec2.create();
            Body.prototype.applyForce = function(force, relativePoint) {
                vec2.add(this.force, this.force, force);
                if (relativePoint) {
                    var rotForce = vec2.crossLength(relativePoint, force);
                    this.angularForce += rotForce;
                }
            };
            var Body_applyForce_forceWorld = vec2.create();
            var Body_applyForce_pointWorld = vec2.create();
            var Body_applyForce_pointLocal = vec2.create();
            Body.prototype.applyForceLocal = function(localForce, localPoint) {
                localPoint = localPoint || Body_applyForce_pointLocal;
                var worldForce = Body_applyForce_forceWorld;
                var worldPoint = Body_applyForce_pointWorld;
                this.vectorToWorldFrame(worldForce, localForce);
                this.vectorToWorldFrame(worldPoint, localPoint);
                this.applyForce(worldForce, worldPoint);
            };
            var Body_applyImpulse_velo = vec2.create();
            Body.prototype.applyImpulse = function(impulseVector, relativePoint) {
                if (this.type !== Body.DYNAMIC) {
                    return;
                }
                var velo = Body_applyImpulse_velo;
                vec2.scale(velo, impulseVector, this.invMass);
                vec2.multiply(velo, this.massMultiplier, velo);
                vec2.add(this.velocity, velo, this.velocity);
                if (relativePoint) {
                    var rotVelo = vec2.crossLength(relativePoint, impulseVector);
                    rotVelo *= this.invInertia;
                    this.angularVelocity += rotVelo;
                }
            };
            var Body_applyImpulse_impulseWorld = vec2.create();
            var Body_applyImpulse_pointWorld = vec2.create();
            var Body_applyImpulse_pointLocal = vec2.create();
            Body.prototype.applyImpulseLocal = function(localImpulse, localPoint) {
                localPoint = localPoint || Body_applyImpulse_pointLocal;
                var worldImpulse = Body_applyImpulse_impulseWorld;
                var worldPoint = Body_applyImpulse_pointWorld;
                this.vectorToWorldFrame(worldImpulse, localImpulse);
                this.vectorToWorldFrame(worldPoint, localPoint);
                this.applyImpulse(worldImpulse, worldPoint);
            };
            Body.prototype.toLocalFrame = function(out, worldPoint) {
                vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
            };
            Body.prototype.toWorldFrame = function(out, localPoint) {
                vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
            };
            Body.prototype.vectorToLocalFrame = function(out, worldVector) {
                vec2.vectorToLocalFrame(out, worldVector, this.angle);
            };
            Body.prototype.vectorToWorldFrame = function(out, localVector) {
                vec2.vectorToGlobalFrame(out, localVector, this.angle);
            };
            Body.prototype.fromPolygon = function(path, options) {
                options = options || {};
                for (var i = this.shapes.length; i >= 0; --i) {
                    this.removeShape(this.shapes[i]);
                }
                var p = new decomp.Polygon();
                p.vertices = path;
                p.makeCCW();
                if (typeof options.removeCollinearPoints === "number") {
                    p.removeCollinearPoints(options.removeCollinearPoints);
                }
                if (typeof options.skipSimpleCheck === "undefined") {
                    if (!p.isSimple()) {
                        return false;
                    }
                }
                this.concavePath = p.vertices.slice(0);
                for (var i = 0; i < this.concavePath.length; i++) {
                    var v = [ 0, 0 ];
                    vec2.copy(v, this.concavePath[i]);
                    this.concavePath[i] = v;
                }
                var convexes;
                if (options.optimalDecomp) {
                    convexes = p.decomp();
                } else {
                    convexes = p.quickDecomp();
                }
                var cm = vec2.create();
                for (var i = 0; i !== convexes.length; i++) {
                    var c = new Convex({
                        vertices: convexes[i].vertices
                    });
                    for (var j = 0; j !== c.vertices.length; j++) {
                        var v = c.vertices[j];
                        vec2.sub(v, v, c.centerOfMass);
                    }
                    vec2.scale(cm, c.centerOfMass, 1);
                    c.updateTriangles();
                    c.updateCenterOfMass();
                    c.updateBoundingRadius();
                    this.addShape(c, cm);
                }
                this.adjustCenterOfMass();
                this.aabbNeedsUpdate = true;
                return true;
            };
            var adjustCenterOfMass_tmp1 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp2 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp3 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp4 = vec2.fromValues(0, 0);
            Body.prototype.adjustCenterOfMass = function() {
                var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
                vec2.set(sum, 0, 0);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i];
                    vec2.scale(offset_times_area, s.position, s.area);
                    vec2.add(sum, sum, offset_times_area);
                    totalArea += s.area;
                }
                vec2.scale(cm, sum, 1 / totalArea);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i];
                    vec2.sub(s.position, s.position, cm);
                }
                vec2.add(this.position, this.position, cm);
                for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
                    vec2.sub(this.concavePath[i], this.concavePath[i], cm);
                }
                this.updateMassProperties();
                this.updateBoundingRadius();
            };
            Body.prototype.setZeroForce = function() {
                vec2.set(this.force, 0, 0);
                this.angularForce = 0;
            };
            Body.prototype.resetConstraintVelocity = function() {
                var b = this, vlambda = b.vlambda;
                vec2.set(vlambda, 0, 0);
                b.wlambda = 0;
            };
            Body.prototype.addConstraintVelocity = function() {
                var b = this, v = b.velocity;
                vec2.add(v, v, b.vlambda);
                b.angularVelocity += b.wlambda;
            };
            Body.prototype.applyDamping = function(dt) {
                if (this.type === Body.DYNAMIC) {
                    var v = this.velocity;
                    vec2.scale(v, v, Math.pow(1 - this.damping, dt));
                    this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
                }
            };
            Body.prototype.wakeUp = function() {
                var s = this.sleepState;
                this.sleepState = Body.AWAKE;
                this.idleTime = 0;
                if (s !== Body.AWAKE) {
                    this.emit(Body.wakeUpEvent);
                }
            };
            Body.prototype.sleep = function() {
                this.sleepState = Body.SLEEPING;
                this.angularVelocity = 0;
                this.angularForce = 0;
                vec2.set(this.velocity, 0, 0);
                vec2.set(this.force, 0, 0);
                this.emit(Body.sleepEvent);
            };
            Body.prototype.sleepTick = function(time, dontSleep, dt) {
                if (!this.allowSleep || this.type === Body.SLEEPING) {
                    return;
                }
                this.wantsToSleep = false;
                var sleepState = this.sleepState, speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                if (speedSquared >= speedLimitSquared) {
                    this.idleTime = 0;
                    this.sleepState = Body.AWAKE;
                } else {
                    this.idleTime += dt;
                    this.sleepState = Body.SLEEPY;
                }
                if (this.idleTime > this.sleepTimeLimit) {
                    if (!dontSleep) {
                        this.sleep();
                    } else {
                        this.wantsToSleep = true;
                    }
                }
            };
            Body.prototype.overlaps = function(body) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
            };
            var integrate_fhMinv = vec2.create();
            var integrate_velodt = vec2.create();
            Body.prototype.integrate = function(dt) {
                var minv = this.invMass, f = this.force, pos = this.position, velo = this.velocity;
                vec2.copy(this.previousPosition, this.position);
                this.previousAngle = this.angle;
                if (!this.fixedRotation) {
                    this.angularVelocity += this.angularForce * this.invInertia * dt;
                }
                vec2.scale(integrate_fhMinv, f, dt * minv);
                vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
                vec2.add(velo, integrate_fhMinv, velo);
                if (!this.integrateToTimeOfImpact(dt)) {
                    vec2.scale(integrate_velodt, velo, dt);
                    vec2.add(pos, pos, integrate_velodt);
                    if (!this.fixedRotation) {
                        this.angle += this.angularVelocity * dt;
                    }
                }
                this.aabbNeedsUpdate = true;
            };
            var result = new RaycastResult();
            var ray = new Ray({
                mode: Ray.ALL
            });
            var direction = vec2.create();
            var end = vec2.create();
            var startToEnd = vec2.create();
            var rememberPosition = vec2.create();
            Body.prototype.integrateToTimeOfImpact = function(dt) {
                if (this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
                    return false;
                }
                vec2.normalize(direction, this.velocity);
                vec2.scale(end, this.velocity, dt);
                vec2.add(end, end, this.position);
                vec2.sub(startToEnd, end, this.position);
                var startToEndAngle = this.angularVelocity * dt;
                var len = vec2.length(startToEnd);
                var timeOfImpact = 1;
                var hit;
                var that = this;
                result.reset();
                ray.callback = function(result) {
                    if (result.body === that) {
                        return;
                    }
                    hit = result.body;
                    result.getHitPoint(end, ray);
                    vec2.sub(startToEnd, end, that.position);
                    timeOfImpact = vec2.length(startToEnd) / len;
                    result.stop();
                };
                vec2.copy(ray.from, this.position);
                vec2.copy(ray.to, end);
                ray.update();
                this.world.raycast(result, ray);
                if (!hit) {
                    return false;
                }
                var rememberAngle = this.angle;
                vec2.copy(rememberPosition, this.position);
                var iter = 0;
                var tmin = 0;
                var tmid = 0;
                var tmax = timeOfImpact;
                while (tmax >= tmin && iter < this.ccdIterations) {
                    iter++;
                    tmid = (tmax - tmin) / 2;
                    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
                    vec2.add(this.position, rememberPosition, integrate_velodt);
                    this.angle = rememberAngle + startToEndAngle * timeOfImpact;
                    this.updateAABB();
                    var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);
                    if (overlaps) {
                        tmin = tmid;
                    } else {
                        tmax = tmid;
                    }
                }
                timeOfImpact = tmid;
                vec2.copy(this.position, rememberPosition);
                this.angle = rememberAngle;
                vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
                vec2.add(this.position, this.position, integrate_velodt);
                if (!this.fixedRotation) {
                    this.angle += startToEndAngle * timeOfImpact;
                }
                return true;
            };
            Body.prototype.getVelocityAtPoint = function(result, relativePoint) {
                vec2.crossVZ(result, relativePoint, this.angularVelocity);
                vec2.subtract(result, this.velocity, result);
                return result;
            };
            Body.sleepyEvent = {
                type: "sleepy"
            };
            Body.sleepEvent = {
                type: "sleep"
            };
            Body.wakeUpEvent = {
                type: "wakeup"
            };
            Body.DYNAMIC = 1;
            Body.STATIC = 2;
            Body.KINEMATIC = 4;
            Body.AWAKE = 0;
            Body.SLEEPY = 1;
            Body.SLEEPING = 2;
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        } ],
        32: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Spring = _dereq_("./Spring");
            var Utils = _dereq_("../utils/Utils");
            module.exports = LinearSpring;
            function LinearSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.localAnchorA = vec2.fromValues(0, 0);
                this.localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(this.localAnchorA, options.localAnchorA);
                }
                if (options.localAnchorB) {
                    vec2.copy(this.localAnchorB, options.localAnchorB);
                }
                if (options.worldAnchorA) {
                    this.setWorldAnchorA(options.worldAnchorA);
                }
                if (options.worldAnchorB) {
                    this.setWorldAnchorB(options.worldAnchorB);
                }
                var worldAnchorA = vec2.create();
                var worldAnchorB = vec2.create();
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);
                this.restLength = typeof options.restLength === "number" ? options.restLength : worldDistance;
            }
            LinearSpring.prototype = new Spring();
            LinearSpring.prototype.constructor = LinearSpring;
            LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA) {
                this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
            };
            LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB) {
                this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
            };
            LinearSpring.prototype.getWorldAnchorA = function(result) {
                this.bodyA.toWorldFrame(result, this.localAnchorA);
            };
            LinearSpring.prototype.getWorldAnchorB = function(result) {
                this.bodyB.toWorldFrame(result, this.localAnchorB);
            };
            var applyForce_r = vec2.create(), applyForce_r_unit = vec2.create(), applyForce_u = vec2.create(), applyForce_f = vec2.create(), applyForce_worldAnchorA = vec2.create(), applyForce_worldAnchorB = vec2.create(), applyForce_ri = vec2.create(), applyForce_rj = vec2.create(), applyForce_tmp = vec2.create();
            LinearSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
                var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                vec2.sub(ri, worldAnchorA, bodyA.position);
                vec2.sub(rj, worldAnchorB, bodyB.position);
                vec2.sub(r, worldAnchorB, worldAnchorA);
                var rlen = vec2.len(r);
                vec2.normalize(r_unit, r);
                vec2.sub(u, bodyB.velocity, bodyA.velocity);
                vec2.crossZV(tmp, bodyB.angularVelocity, rj);
                vec2.add(u, u, tmp);
                vec2.crossZV(tmp, bodyA.angularVelocity, ri);
                vec2.sub(u, u, tmp);
                vec2.scale(f, r_unit, -k * (rlen - l) - d * vec2.dot(u, r_unit));
                vec2.sub(bodyA.force, bodyA.force, f);
                vec2.add(bodyB.force, bodyB.force, f);
                var ri_x_f = vec2.crossLength(ri, f);
                var rj_x_f = vec2.crossLength(rj, f);
                bodyA.angularForce -= ri_x_f;
                bodyB.angularForce += rj_x_f;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        } ],
        33: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Spring = _dereq_("./Spring");
            module.exports = RotationalSpring;
            function RotationalSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.restAngle = typeof options.restAngle === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
            }
            RotationalSpring.prototype = new Spring();
            RotationalSpring.prototype.constructor = RotationalSpring;
            RotationalSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
                var torque = -k * (x - l) - d * u * 0;
                bodyA.angularForce -= torque;
                bodyB.angularForce += torque;
            };
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        } ],
        34: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Utils = _dereq_("../utils/Utils");
            module.exports = Spring;
            function Spring(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    stiffness: 100,
                    damping: 1
                });
                this.stiffness = options.stiffness;
                this.damping = options.damping;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            Spring.prototype.applyForce = function() {};
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        } ],
        35: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2");
            var Utils = _dereq_("../utils/Utils");
            var Constraint = _dereq_("../constraints/Constraint");
            var FrictionEquation = _dereq_("../equations/FrictionEquation");
            var Body = _dereq_("../objects/Body");
            module.exports = TopDownVehicle;
            function TopDownVehicle(chassisBody, options) {
                options = options || {};
                this.chassisBody = chassisBody;
                this.wheels = [];
                this.groundBody = new Body({
                    mass: 0
                });
                this.world = null;
                var that = this;
                this.preStepCallback = function() {
                    that.update();
                };
            }
            TopDownVehicle.prototype.addToWorld = function(world) {
                this.world = world;
                world.addBody(this.groundBody);
                world.on("preStep", this.preStepCallback);
                for (var i = 0; i < this.wheels.length; i++) {
                    var wheel = this.wheels[i];
                    world.addConstraint(wheel);
                }
            };
            TopDownVehicle.prototype.removeFromWorld = function() {
                var world = this.world;
                world.removeBody(this.groundBody);
                world.off("preStep", this.preStepCallback);
                for (var i = 0; i < this.wheels.length; i++) {
                    var wheel = this.wheels[i];
                    world.removeConstraint(wheel);
                }
                this.world = null;
            };
            TopDownVehicle.prototype.addWheel = function(wheelOptions) {
                var wheel = new WheelConstraint(this, wheelOptions);
                this.wheels.push(wheel);
                return wheel;
            };
            TopDownVehicle.prototype.update = function() {
                for (var i = 0; i < this.wheels.length; i++) {
                    this.wheels[i].update();
                }
            };
            function WheelConstraint(vehicle, options) {
                options = options || {};
                this.vehicle = vehicle;
                this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
                this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
                this.steerValue = 0;
                this.engineForce = 0;
                this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);
                this.localForwardVector = vec2.fromValues(0, 1);
                if (options.localForwardVector) {
                    vec2.copy(this.localForwardVector, options.localForwardVector);
                }
                this.localPosition = vec2.fromValues(0, 0);
                if (options.localPosition) {
                    vec2.copy(this.localPosition, options.localPosition);
                }
                Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);
                this.equations.push(this.forwardEquation, this.sideEquation);
                this.setBrakeForce(0);
            }
            WheelConstraint.prototype = new Constraint();
            WheelConstraint.prototype.setBrakeForce = function(force) {
                this.forwardEquation.setSlipForce(force);
            };
            WheelConstraint.prototype.setSideFriction = function(force) {
                this.sideEquation.setSlipForce(force);
            };
            var worldVelocity = vec2.create();
            var relativePoint = vec2.create();
            WheelConstraint.prototype.getSpeed = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);
                this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);
                return vec2.dot(worldVelocity, relativePoint);
            };
            var tmpVec = vec2.create();
            WheelConstraint.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);
                vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);
                this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);
                vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);
                vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);
                this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);
                vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);
                vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);
                vec2.normalize(tmpVec, this.forwardEquation.t);
                vec2.scale(tmpVec, tmpVec, this.engineForce);
                this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);
            };
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        } ],
        36: [ function(_dereq_, module, exports) {
            var p2 = module.exports = {
                AABB: _dereq_("./collision/AABB"),
                AngleLockEquation: _dereq_("./equations/AngleLockEquation"),
                Body: _dereq_("./objects/Body"),
                Broadphase: _dereq_("./collision/Broadphase"),
                Capsule: _dereq_("./shapes/Capsule"),
                Circle: _dereq_("./shapes/Circle"),
                Constraint: _dereq_("./constraints/Constraint"),
                ContactEquation: _dereq_("./equations/ContactEquation"),
                ContactEquationPool: _dereq_("./utils/ContactEquationPool"),
                ContactMaterial: _dereq_("./material/ContactMaterial"),
                Convex: _dereq_("./shapes/Convex"),
                DistanceConstraint: _dereq_("./constraints/DistanceConstraint"),
                Equation: _dereq_("./equations/Equation"),
                EventEmitter: _dereq_("./events/EventEmitter"),
                FrictionEquation: _dereq_("./equations/FrictionEquation"),
                FrictionEquationPool: _dereq_("./utils/FrictionEquationPool"),
                GearConstraint: _dereq_("./constraints/GearConstraint"),
                GSSolver: _dereq_("./solver/GSSolver"),
                Heightfield: _dereq_("./shapes/Heightfield"),
                Line: _dereq_("./shapes/Line"),
                LockConstraint: _dereq_("./constraints/LockConstraint"),
                Material: _dereq_("./material/Material"),
                Narrowphase: _dereq_("./collision/Narrowphase"),
                NaiveBroadphase: _dereq_("./collision/NaiveBroadphase"),
                Particle: _dereq_("./shapes/Particle"),
                Plane: _dereq_("./shapes/Plane"),
                Pool: _dereq_("./utils/Pool"),
                RevoluteConstraint: _dereq_("./constraints/RevoluteConstraint"),
                PrismaticConstraint: _dereq_("./constraints/PrismaticConstraint"),
                Ray: _dereq_("./collision/Ray"),
                RaycastResult: _dereq_("./collision/RaycastResult"),
                Box: _dereq_("./shapes/Box"),
                RotationalVelocityEquation: _dereq_("./equations/RotationalVelocityEquation"),
                SAPBroadphase: _dereq_("./collision/SAPBroadphase"),
                Shape: _dereq_("./shapes/Shape"),
                Solver: _dereq_("./solver/Solver"),
                Spring: _dereq_("./objects/Spring"),
                TopDownVehicle: _dereq_("./objects/TopDownVehicle"),
                LinearSpring: _dereq_("./objects/LinearSpring"),
                RotationalSpring: _dereq_("./objects/RotationalSpring"),
                Utils: _dereq_("./utils/Utils"),
                World: _dereq_("./world/World"),
                vec2: _dereq_("./math/vec2"),
                version: _dereq_("../package.json").version
            };
            Object.defineProperty(p2, "Rectangle", {
                get: function() {
                    console.warn("The Rectangle class has been renamed to Box.");
                    return this.Box;
                }
            });
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        } ],
        37: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), Shape = _dereq_("./Shape"), Convex = _dereq_("./Convex");
            module.exports = Box;
            function Box(options) {
                if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
                    options = {
                        width: arguments[0],
                        height: arguments[1]
                    };
                    console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })");
                }
                options = options || {};
                var width = this.width = options.width || 1;
                var height = this.height = options.height || 1;
                var verts = [ vec2.fromValues(-width / 2, -height / 2), vec2.fromValues(width / 2, -height / 2), vec2.fromValues(width / 2, height / 2), vec2.fromValues(-width / 2, height / 2) ];
                var axes = [ vec2.fromValues(1, 0), vec2.fromValues(0, 1) ];
                options.vertices = verts;
                options.axes = axes;
                options.type = Shape.BOX;
                Convex.call(this, options);
            }
            Box.prototype = new Convex();
            Box.prototype.constructor = Box;
            Box.prototype.computeMomentOfInertia = function(mass) {
                var w = this.width, h = this.height;
                return mass * (h * h + w * w) / 12;
            };
            Box.prototype.updateBoundingRadius = function() {
                var w = this.width, h = this.height;
                this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
            };
            var corner1 = vec2.create(), corner2 = vec2.create(), corner3 = vec2.create(), corner4 = vec2.create();
            Box.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
            Box.prototype.updateArea = function() {
                this.area = this.width * this.height;
            };
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        } ],
        38: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2");
            module.exports = Capsule;
            function Capsule(options) {
                if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
                    options = {
                        length: arguments[0],
                        radius: arguments[1]
                    };
                    console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })");
                }
                options = options || {};
                this.length = options.length || 1;
                this.radius = options.radius || 1;
                options.type = Shape.CAPSULE;
                Shape.call(this, options);
            }
            Capsule.prototype = new Shape();
            Capsule.prototype.constructor = Capsule;
            Capsule.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius, w = this.length + r, h = r * 2;
                return mass * (h * h + w * w) / 12;
            };
            Capsule.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2;
            };
            Capsule.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
            };
            var r = vec2.create();
            Capsule.prototype.computeAABB = function(out, position, angle) {
                var radius = this.radius;
                vec2.set(r, this.length / 2, 0);
                if (angle !== 0) {
                    vec2.rotate(r, r, angle);
                }
                vec2.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
                vec2.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
                vec2.add(out.lowerBound, out.lowerBound, position);
                vec2.add(out.upperBound, out.upperBound, position);
            };
            var intersectCapsule_hitPointWorld = vec2.create();
            var intersectCapsule_normal = vec2.create();
            var intersectCapsule_l0 = vec2.create();
            var intersectCapsule_l1 = vec2.create();
            var intersectCapsule_unit_y = vec2.fromValues(0, 1);
            Capsule.prototype.raycast = function(result, ray, position, angle) {
                var from = ray.from;
                var to = ray.to;
                var direction = ray.direction;
                var hitPointWorld = intersectCapsule_hitPointWorld;
                var normal = intersectCapsule_normal;
                var l0 = intersectCapsule_l0;
                var l1 = intersectCapsule_l1;
                var halfLen = this.length / 2;
                for (var i = 0; i < 2; i++) {
                    var y = this.radius * (i * 2 - 1);
                    vec2.set(l0, -halfLen, y);
                    vec2.set(l1, halfLen, y);
                    vec2.toGlobalFrame(l0, l0, position, angle);
                    vec2.toGlobalFrame(l1, l1, position, angle);
                    var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);
                    if (delta >= 0) {
                        vec2.rotate(normal, intersectCapsule_unit_y, angle);
                        vec2.scale(normal, normal, i * 2 - 1);
                        ray.reportIntersection(result, delta, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
                var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
                for (var i = 0; i < 2; i++) {
                    vec2.set(l0, halfLen * (i * 2 - 1), 0);
                    vec2.toGlobalFrame(l0, l0, position, angle);
                    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
                    var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
                    var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
                    var delta = Math.pow(b, 2) - 4 * a * c;
                    if (delta < 0) {
                        continue;
                    } else if (delta === 0) {
                        vec2.lerp(hitPointWorld, from, to, delta);
                        if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                            vec2.sub(normal, hitPointWorld, l0);
                            vec2.normalize(normal, normal);
                            ray.reportIntersection(result, delta, normal, -1);
                            if (result.shouldStop(ray)) {
                                return;
                            }
                        }
                    } else {
                        var sqrtDelta = Math.sqrt(delta);
                        var inv2a = 1 / (2 * a);
                        var d1 = (-b - sqrtDelta) * inv2a;
                        var d2 = (-b + sqrtDelta) * inv2a;
                        if (d1 >= 0 && d1 <= 1) {
                            vec2.lerp(hitPointWorld, from, to, d1);
                            if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                                vec2.sub(normal, hitPointWorld, l0);
                                vec2.normalize(normal, normal);
                                ray.reportIntersection(result, d1, normal, -1);
                                if (result.shouldStop(ray)) {
                                    return;
                                }
                            }
                        }
                        if (d2 >= 0 && d2 <= 1) {
                            vec2.lerp(hitPointWorld, from, to, d2);
                            if (vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                                vec2.sub(normal, hitPointWorld, l0);
                                vec2.normalize(normal, normal);
                                ray.reportIntersection(result, d2, normal, -1);
                                if (result.shouldStop(ray)) {
                                    return;
                                }
                            }
                        }
                    }
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        39: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2");
            module.exports = Circle;
            function Circle(options) {
                if (typeof arguments[0] === "number") {
                    options = {
                        radius: arguments[0]
                    };
                    console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })");
                }
                options = options || {};
                this.radius = options.radius || 1;
                options.type = Shape.CIRCLE;
                Shape.call(this, options);
            }
            Circle.prototype = new Shape();
            Circle.prototype.constructor = Circle;
            Circle.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius;
                return mass * r * r / 2;
            };
            Circle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius;
            };
            Circle.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius;
            };
            Circle.prototype.computeAABB = function(out, position, angle) {
                var r = this.radius;
                vec2.set(out.upperBound, r, r);
                vec2.set(out.lowerBound, -r, -r);
                if (position) {
                    vec2.add(out.lowerBound, out.lowerBound, position);
                    vec2.add(out.upperBound, out.upperBound, position);
                }
            };
            var Ray_intersectSphere_intersectionPoint = vec2.create();
            var Ray_intersectSphere_normal = vec2.create();
            Circle.prototype.raycast = function(result, ray, position, angle) {
                var from = ray.from, to = ray.to, r = this.radius;
                var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
                var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
                var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
                var delta = Math.pow(b, 2) - 4 * a * c;
                var intersectionPoint = Ray_intersectSphere_intersectionPoint;
                var normal = Ray_intersectSphere_normal;
                if (delta < 0) {
                    return;
                } else if (delta === 0) {
                    vec2.lerp(intersectionPoint, from, to, delta);
                    vec2.sub(normal, intersectionPoint, position);
                    vec2.normalize(normal, normal);
                    ray.reportIntersection(result, delta, normal, -1);
                } else {
                    var sqrtDelta = Math.sqrt(delta);
                    var inv2a = 1 / (2 * a);
                    var d1 = (-b - sqrtDelta) * inv2a;
                    var d2 = (-b + sqrtDelta) * inv2a;
                    if (d1 >= 0 && d1 <= 1) {
                        vec2.lerp(intersectionPoint, from, to, d1);
                        vec2.sub(normal, intersectionPoint, position);
                        vec2.normalize(normal, normal);
                        ray.reportIntersection(result, d1, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                    if (d2 >= 0 && d2 <= 1) {
                        vec2.lerp(intersectionPoint, from, to, d2);
                        vec2.sub(normal, intersectionPoint, position);
                        vec2.normalize(normal, normal);
                        ray.reportIntersection(result, d2, normal, -1);
                    }
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        40: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2"), polyk = _dereq_("../math/polyk"), decomp = _dereq_("poly-decomp");
            module.exports = Convex;
            function Convex(options) {
                if (Array.isArray(arguments[0])) {
                    options = {
                        vertices: arguments[0],
                        axes: arguments[1]
                    };
                    console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })");
                }
                options = options || {};
                this.vertices = [];
                var vertices = options.vertices !== undefined ? options.vertices : [];
                for (var i = 0; i < vertices.length; i++) {
                    var v = vec2.create();
                    vec2.copy(v, vertices[i]);
                    this.vertices.push(v);
                }
                this.axes = [];
                if (options.axes) {
                    for (var i = 0; i < options.axes.length; i++) {
                        var axis = vec2.create();
                        vec2.copy(axis, options.axes[i]);
                        this.axes.push(axis);
                    }
                } else {
                    for (var i = 0; i < this.vertices.length; i++) {
                        var worldPoint0 = this.vertices[i];
                        var worldPoint1 = this.vertices[(i + 1) % this.vertices.length];
                        var normal = vec2.create();
                        vec2.sub(normal, worldPoint1, worldPoint0);
                        vec2.rotate90cw(normal, normal);
                        vec2.normalize(normal, normal);
                        this.axes.push(normal);
                    }
                }
                this.centerOfMass = vec2.fromValues(0, 0);
                this.triangles = [];
                if (this.vertices.length) {
                    this.updateTriangles();
                    this.updateCenterOfMass();
                }
                this.boundingRadius = 0;
                options.type = Shape.CONVEX;
                Shape.call(this, options);
                this.updateBoundingRadius();
                this.updateArea();
                if (this.area < 0) {
                    throw new Error("Convex vertices must be given in conter-clockwise winding.");
                }
            }
            Convex.prototype = new Shape();
            Convex.prototype.constructor = Convex;
            var tmpVec1 = vec2.create();
            var tmpVec2 = vec2.create();
            Convex.prototype.projectOntoLocalAxis = function(localAxis, result) {
                var max = null, min = null, v, value, localAxis = tmpVec1;
                for (var i = 0; i < this.vertices.length; i++) {
                    v = this.vertices[i];
                    value = vec2.dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                vec2.set(result, min, max);
            };
            Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result) {
                var worldAxis = tmpVec2;
                this.projectOntoLocalAxis(localAxis, result);
                if (shapeAngle !== 0) {
                    vec2.rotate(worldAxis, localAxis, shapeAngle);
                } else {
                    worldAxis = localAxis;
                }
                var offset = vec2.dot(shapeOffset, worldAxis);
                vec2.set(result, result[0] + offset, result[1] + offset);
            };
            Convex.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                var polykVerts = [];
                for (var i = 0; i < this.vertices.length; i++) {
                    var v = this.vertices[i];
                    polykVerts.push(v[0], v[1]);
                }
                var triangles = polyk.Triangulate(polykVerts);
                for (var i = 0; i < triangles.length; i += 3) {
                    var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
                    this.triangles.push([ id1, id2, id3 ]);
                }
            };
            var updateCenterOfMass_centroid = vec2.create(), updateCenterOfMass_centroid_times_mass = vec2.create(), updateCenterOfMass_a = vec2.create(), updateCenterOfMass_b = vec2.create(), updateCenterOfMass_c = vec2.create(), updateCenterOfMass_ac = vec2.create(), updateCenterOfMass_ca = vec2.create(), updateCenterOfMass_cb = vec2.create(), updateCenterOfMass_n = vec2.create();
            Convex.prototype.updateCenterOfMass = function() {
                var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, n = updateCenterOfMass_n, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, ac = updateCenterOfMass_ac, ca = updateCenterOfMass_ca, cb = updateCenterOfMass_cb, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
                vec2.set(cm, 0, 0);
                var totalArea = 0;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    vec2.centroid(centroid, a, b, c);
                    var m = Convex.triangleArea(a, b, c);
                    totalArea += m;
                    vec2.scale(centroid_times_mass, centroid, m);
                    vec2.add(cm, cm, centroid_times_mass);
                }
                vec2.scale(cm, cm, 1 / totalArea);
            };
            Convex.prototype.computeMomentOfInertia = function(mass) {
                var denom = 0, numer = 0, N = this.vertices.length;
                for (var j = N - 1, i = 0; i < N; j = i, i++) {
                    var p0 = this.vertices[j];
                    var p1 = this.vertices[i];
                    var a = Math.abs(vec2.crossLength(p0, p1));
                    var b = vec2.dot(p1, p1) + vec2.dot(p1, p0) + vec2.dot(p0, p0);
                    denom += a * b;
                    numer += a;
                }
                return mass / 6 * (denom / numer);
            };
            Convex.prototype.updateBoundingRadius = function() {
                var verts = this.vertices, r2 = 0;
                for (var i = 0; i !== verts.length; i++) {
                    var l2 = vec2.squaredLength(verts[i]);
                    if (l2 > r2) {
                        r2 = l2;
                    }
                }
                this.boundingRadius = Math.sqrt(r2);
            };
            Convex.triangleArea = function(a, b, c) {
                return ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) * .5;
            };
            Convex.prototype.updateArea = function() {
                this.updateTriangles();
                this.area = 0;
                var triangles = this.triangles, verts = this.vertices;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    var m = Convex.triangleArea(a, b, c);
                    this.area += m;
                }
            };
            Convex.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
            var intersectConvex_rayStart = vec2.create();
            var intersectConvex_rayEnd = vec2.create();
            var intersectConvex_normal = vec2.create();
            Convex.prototype.raycast = function(result, ray, position, angle) {
                var rayStart = intersectConvex_rayStart;
                var rayEnd = intersectConvex_rayEnd;
                var normal = intersectConvex_normal;
                var vertices = this.vertices;
                vec2.toLocalFrame(rayStart, ray.from, position, angle);
                vec2.toLocalFrame(rayEnd, ray.to, position, angle);
                var n = vertices.length;
                for (var i = 0; i < n && !result.shouldStop(ray); i++) {
                    var q1 = vertices[i];
                    var q2 = vertices[(i + 1) % n];
                    var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
                    if (delta >= 0) {
                        vec2.sub(normal, q2, q1);
                        vec2.rotate(normal, normal, -Math.PI / 2 + angle);
                        vec2.normalize(normal, normal);
                        ray.reportIntersection(result, delta, normal, i);
                    }
                }
            };
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        } ],
        41: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2"), Utils = _dereq_("../utils/Utils");
            module.exports = Heightfield;
            function Heightfield(options) {
                if (Array.isArray(arguments[0])) {
                    options = {
                        heights: arguments[0]
                    };
                    if (typeof arguments[1] === "object") {
                        for (var key in arguments[1]) {
                            options[key] = arguments[1][key];
                        }
                    }
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })");
                }
                options = options || {};
                this.heights = options.heights ? options.heights.slice(0) : [];
                this.maxValue = options.maxValue || null;
                this.minValue = options.minValue || null;
                this.elementWidth = options.elementWidth || .1;
                if (options.maxValue === undefined || options.minValue === undefined) {
                    this.updateMaxMinValues();
                }
                options.type = Shape.HEIGHTFIELD;
                Shape.call(this, options);
            }
            Heightfield.prototype = new Shape();
            Heightfield.prototype.constructor = Heightfield;
            Heightfield.prototype.updateMaxMinValues = function() {
                var data = this.heights;
                var maxValue = data[0];
                var minValue = data[0];
                for (var i = 0; i !== data.length; i++) {
                    var v = data[i];
                    if (v > maxValue) {
                        maxValue = v;
                    }
                    if (v < minValue) {
                        minValue = v;
                    }
                }
                this.maxValue = maxValue;
                this.minValue = minValue;
            };
            Heightfield.prototype.computeMomentOfInertia = function(mass) {
                return Number.MAX_VALUE;
            };
            Heightfield.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Heightfield.prototype.updateArea = function() {
                var data = this.heights, area = 0;
                for (var i = 0; i < data.length - 1; i++) {
                    area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
                }
                this.area = area;
            };
            var points = [ vec2.create(), vec2.create(), vec2.create(), vec2.create() ];
            Heightfield.prototype.computeAABB = function(out, position, angle) {
                vec2.set(points[0], 0, this.maxValue);
                vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
                vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);
                vec2.set(points[3], 0, this.minValue);
                out.setFromPoints(points, position, angle);
            };
            Heightfield.prototype.getLineSegment = function(start, end, i) {
                var data = this.heights;
                var width = this.elementWidth;
                vec2.set(start, i * width, data[i]);
                vec2.set(end, (i + 1) * width, data[i + 1]);
            };
            Heightfield.prototype.getSegmentIndex = function(position) {
                return Math.floor(position[0] / this.elementWidth);
            };
            Heightfield.prototype.getClampedSegmentIndex = function(position) {
                var i = this.getSegmentIndex(position);
                i = Math.min(this.heights.length, Math.max(i, 0));
                return i;
            };
            var intersectHeightfield_hitPointWorld = vec2.create();
            var intersectHeightfield_worldNormal = vec2.create();
            var intersectHeightfield_l0 = vec2.create();
            var intersectHeightfield_l1 = vec2.create();
            var intersectHeightfield_localFrom = vec2.create();
            var intersectHeightfield_localTo = vec2.create();
            var intersectHeightfield_unit_y = vec2.fromValues(0, 1);
            function getLineSegmentsIntersection(out, p0, p1, p2, p3) {
                var s1_x, s1_y, s2_x, s2_y;
                s1_x = p1[0] - p0[0];
                s1_y = p1[1] - p0[1];
                s2_x = p3[0] - p2[0];
                s2_y = p3[1] - p2[1];
                var s, t;
                s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
                t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                    var intX = p0[0] + t * s1_x;
                    var intY = p0[1] + t * s1_y;
                    out[0] = intX;
                    out[1] = intY;
                    return t;
                }
                return -1;
            }
            Heightfield.prototype.raycast = function(result, ray, position, angle) {
                var from = ray.from;
                var to = ray.to;
                var direction = ray.direction;
                var hitPointWorld = intersectHeightfield_hitPointWorld;
                var worldNormal = intersectHeightfield_worldNormal;
                var l0 = intersectHeightfield_l0;
                var l1 = intersectHeightfield_l1;
                var localFrom = intersectHeightfield_localFrom;
                var localTo = intersectHeightfield_localTo;
                vec2.toLocalFrame(localFrom, from, position, angle);
                vec2.toLocalFrame(localTo, to, position, angle);
                var i0 = this.getClampedSegmentIndex(localFrom);
                var i1 = this.getClampedSegmentIndex(localTo);
                if (i0 > i1) {
                    var tmp = i0;
                    i0 = i1;
                    i1 = tmp;
                }
                for (var i = 0; i < this.heights.length - 1; i++) {
                    this.getLineSegment(l0, l1, i);
                    var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
                    if (t >= 0) {
                        vec2.sub(worldNormal, l1, l0);
                        vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
                        vec2.normalize(worldNormal, worldNormal);
                        ray.reportIntersection(result, t, worldNormal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        } ],
        42: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2");
            module.exports = Line;
            function Line(options) {
                if (typeof arguments[0] === "number") {
                    options = {
                        length: arguments[0]
                    };
                    console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })");
                }
                options = options || {};
                this.length = options.length || 1;
                options.type = Shape.LINE;
                Shape.call(this, options);
            }
            Line.prototype = new Shape();
            Line.prototype.constructor = Line;
            Line.prototype.computeMomentOfInertia = function(mass) {
                return mass * Math.pow(this.length, 2) / 12;
            };
            Line.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2;
            };
            var points = [ vec2.create(), vec2.create() ];
            Line.prototype.computeAABB = function(out, position, angle) {
                var l2 = this.length / 2;
                vec2.set(points[0], -l2, 0);
                vec2.set(points[1], l2, 0);
                out.setFromPoints(points, position, angle, 0);
            };
            var raycast_hitPoint = vec2.create();
            var raycast_normal = vec2.create();
            var raycast_l0 = vec2.create();
            var raycast_l1 = vec2.create();
            var raycast_unit_y = vec2.fromValues(0, 1);
            Line.prototype.raycast = function(result, ray, position, angle) {
                var from = ray.from;
                var to = ray.to;
                var l0 = raycast_l0;
                var l1 = raycast_l1;
                var halfLen = this.length / 2;
                vec2.set(l0, -halfLen, 0);
                vec2.set(l1, halfLen, 0);
                vec2.toGlobalFrame(l0, l0, position, angle);
                vec2.toGlobalFrame(l1, l1, position, angle);
                var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);
                if (fraction >= 0) {
                    var normal = raycast_normal;
                    vec2.rotate(normal, raycast_unit_y, angle);
                    ray.reportIntersection(result, fraction, normal, -1);
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        43: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2");
            module.exports = Particle;
            function Particle(options) {
                options = options || {};
                options.type = Shape.PARTICLE;
                Shape.call(this, options);
            }
            Particle.prototype = new Shape();
            Particle.prototype.constructor = Particle;
            Particle.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Particle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0;
            };
            Particle.prototype.computeAABB = function(out, position, angle) {
                vec2.copy(out.lowerBound, position);
                vec2.copy(out.upperBound, position);
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        44: [ function(_dereq_, module, exports) {
            var Shape = _dereq_("./Shape"), vec2 = _dereq_("../math/vec2"), Utils = _dereq_("../utils/Utils");
            module.exports = Plane;
            function Plane(options) {
                options = options || {};
                options.type = Shape.PLANE;
                Shape.call(this, options);
            }
            Plane.prototype = new Shape();
            Plane.prototype.constructor = Plane;
            Plane.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Plane.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Plane.prototype.computeAABB = function(out, position, angle) {
                var a = angle % (2 * Math.PI);
                var set = vec2.set;
                var max = Number.MAX_VALUE;
                var lowerBound = out.lowerBound;
                var upperBound = out.upperBound;
                if (a === 0) {
                    set(lowerBound, -max, -max);
                    set(upperBound, max, 0);
                } else if (a === Math.PI / 2) {
                    set(lowerBound, 0, -max);
                    set(upperBound, max, max);
                } else if (a === Math.PI) {
                    set(lowerBound, -max, 0);
                    set(upperBound, max, max);
                } else if (a === 3 * Math.PI / 2) {
                    set(lowerBound, -max, -max);
                    set(upperBound, 0, max);
                } else {
                    set(lowerBound, -max, -max);
                    set(upperBound, max, max);
                }
                vec2.add(lowerBound, lowerBound, position);
                vec2.add(upperBound, upperBound, position);
            };
            Plane.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE;
            };
            var intersectPlane_planePointToFrom = vec2.create();
            var intersectPlane_dir_scaled_with_t = vec2.create();
            var intersectPlane_hitPoint = vec2.create();
            var intersectPlane_normal = vec2.create();
            var intersectPlane_len = vec2.create();
            Plane.prototype.raycast = function(result, ray, position, angle) {
                var from = ray.from;
                var to = ray.to;
                var direction = ray.direction;
                var planePointToFrom = intersectPlane_planePointToFrom;
                var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
                var hitPoint = intersectPlane_hitPoint;
                var normal = intersectPlane_normal;
                var len = intersectPlane_len;
                vec2.set(normal, 0, 1);
                vec2.rotate(normal, normal, angle);
                vec2.sub(len, from, position);
                var planeToFrom = vec2.dot(len, normal);
                vec2.sub(len, to, position);
                var planeToTo = vec2.dot(len, normal);
                if (planeToFrom * planeToTo > 0) {
                    return;
                }
                if (vec2.squaredDistance(from, to) < planeToFrom * planeToFrom) {
                    return;
                }
                var n_dot_dir = vec2.dot(normal, direction);
                vec2.sub(planePointToFrom, from, position);
                var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
                ray.reportIntersection(result, t, normal, -1);
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        } ],
        45: [ function(_dereq_, module, exports) {
            module.exports = Shape;
            var vec2 = _dereq_("../math/vec2");
            function Shape(options) {
                options = options || {};
                this.body = null;
                this.position = vec2.fromValues(0, 0);
                if (options.position) {
                    vec2.copy(this.position, options.position);
                }
                this.angle = options.angle || 0;
                this.type = options.type || 0;
                this.id = Shape.idCounter++;
                this.boundingRadius = 0;
                this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;
                this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
                this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;
                this.material = options.material || null;
                this.area = 0;
                this.sensor = options.sensor !== undefined ? options.sensor : false;
                if (this.type) {
                    this.updateBoundingRadius();
                }
                this.updateArea();
            }
            Shape.idCounter = 0;
            Shape.CIRCLE = 1;
            Shape.PARTICLE = 2;
            Shape.PLANE = 4;
            Shape.CONVEX = 8;
            Shape.LINE = 16;
            Shape.BOX = 32;
            Object.defineProperty(Shape, "RECTANGLE", {
                get: function() {
                    console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead.");
                    return Shape.BOX;
                }
            });
            Shape.CAPSULE = 64;
            Shape.HEIGHTFIELD = 128;
            Shape.prototype.computeMomentOfInertia = function(mass) {};
            Shape.prototype.updateBoundingRadius = function() {};
            Shape.prototype.updateArea = function() {};
            Shape.prototype.computeAABB = function(out, position, angle) {};
            Shape.prototype.raycast = function(result, ray, position, angle) {};
        }, {
            "../math/vec2": 30
        } ],
        46: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), Solver = _dereq_("./Solver"), Utils = _dereq_("../utils/Utils"), FrictionEquation = _dereq_("../equations/FrictionEquation");
            module.exports = GSSolver;
            function GSSolver(options) {
                Solver.call(this, options, Solver.GS);
                options = options || {};
                this.iterations = options.iterations || 10;
                this.tolerance = options.tolerance || 1e-7;
                this.arrayStep = 30;
                this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
                this.Bs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.invCs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.useZeroRHS = false;
                this.frictionIterations = 0;
                this.usedIterations = 0;
            }
            GSSolver.prototype = new Solver();
            GSSolver.prototype.constructor = GSSolver;
            function setArrayZero(array) {
                var l = array.length;
                while (l--) {
                    array[l] = +0;
                }
            }
            GSSolver.prototype.solve = function(h, world) {
                this.sortEquations();
                var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = world.bodies.length, add = vec2.add, set = vec2.set, useZeroRHS = this.useZeroRHS, lambda = this.lambda;
                this.usedIterations = 0;
                if (Neq) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.updateSolveMassProperties();
                    }
                }
                if (lambda.length < Neq) {
                    lambda = this.lambda = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.Bs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.invCs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                }
                setArrayZero(lambda);
                var invCs = this.invCs, Bs = this.Bs, lambda = this.lambda;
                for (var i = 0; i !== equations.length; i++) {
                    var c = equations[i];
                    if (c.timeStep !== h || c.needsUpdate) {
                        c.timeStep = h;
                        c.update();
                    }
                    Bs[i] = c.computeB(c.a, c.b, h);
                    invCs[i] = c.computeInvC(c.epsilon);
                }
                var q, B, c, deltalambdaTot, i, j;
                if (Neq !== 0) {
                    for (i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.resetConstraintVelocity();
                    }
                    if (maxFrictionIter) {
                        for (iter = 0; iter !== maxFrictionIter; iter++) {
                            deltalambdaTot = 0;
                            for (j = 0; j !== Neq; j++) {
                                c = equations[j];
                                var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                                deltalambdaTot += Math.abs(deltalambda);
                            }
                            this.usedIterations++;
                            if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                                break;
                            }
                        }
                        GSSolver.updateMultipliers(equations, lambda, 1 / h);
                        for (j = 0; j !== Neq; j++) {
                            var eq = equations[j];
                            if (eq instanceof FrictionEquation) {
                                var f = 0;
                                for (var k = 0; k !== eq.contactEquations.length; k++) {
                                    f += eq.contactEquations[k].multiplier;
                                }
                                f *= eq.frictionCoefficient / eq.contactEquations.length;
                                eq.maxForce = f;
                                eq.minForce = -f;
                            }
                        }
                    }
                    for (iter = 0; iter !== maxIter; iter++) {
                        deltalambdaTot = 0;
                        for (j = 0; j !== Neq; j++) {
                            c = equations[j];
                            var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                            deltalambdaTot += Math.abs(deltalambda);
                        }
                        this.usedIterations++;
                        if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                            break;
                        }
                    }
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].addConstraintVelocity();
                    }
                    GSSolver.updateMultipliers(equations, lambda, 1 / h);
                }
            };
            GSSolver.updateMultipliers = function(equations, lambda, invDt) {
                var l = equations.length;
                while (l--) {
                    equations[l].multiplier = lambda[l] * invDt;
                }
            };
            GSSolver.iterateEquation = function(j, eq, eps, Bs, invCs, lambda, useZeroRHS, dt, iter) {
                var B = Bs[j], invC = invCs[j], lambdaj = lambda[j], GWlambda = eq.computeGWlambda();
                var maxForce = eq.maxForce, minForce = eq.minForce;
                if (useZeroRHS) {
                    B = 0;
                }
                var deltalambda = invC * (B - GWlambda - eps * lambdaj);
                var lambdaj_plus_deltalambda = lambdaj + deltalambda;
                if (lambdaj_plus_deltalambda < minForce * dt) {
                    deltalambda = minForce * dt - lambdaj;
                } else if (lambdaj_plus_deltalambda > maxForce * dt) {
                    deltalambda = maxForce * dt - lambdaj;
                }
                lambda[j] += deltalambda;
                eq.addToWlambda(deltalambda);
                return deltalambda;
            };
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        } ],
        47: [ function(_dereq_, module, exports) {
            var Utils = _dereq_("../utils/Utils"), EventEmitter = _dereq_("../events/EventEmitter");
            module.exports = Solver;
            function Solver(options, type) {
                options = options || {};
                EventEmitter.call(this);
                this.type = type;
                this.equations = [];
                this.equationSortFunction = options.equationSortFunction || false;
            }
            Solver.prototype = new EventEmitter();
            Solver.prototype.constructor = Solver;
            Solver.prototype.solve = function(dt, world) {
                throw new Error("Solver.solve should be implemented by subclasses!");
            };
            var mockWorld = {
                bodies: []
            };
            Solver.prototype.solveIsland = function(dt, island) {
                this.removeAllEquations();
                if (island.equations.length) {
                    this.addEquations(island.equations);
                    mockWorld.bodies.length = 0;
                    island.getBodies(mockWorld.bodies);
                    if (mockWorld.bodies.length) {
                        this.solve(dt, mockWorld);
                    }
                }
            };
            Solver.prototype.sortEquations = function() {
                if (this.equationSortFunction) {
                    this.equations.sort(this.equationSortFunction);
                }
            };
            Solver.prototype.addEquation = function(eq) {
                if (eq.enabled) {
                    this.equations.push(eq);
                }
            };
            Solver.prototype.addEquations = function(eqs) {
                for (var i = 0, N = eqs.length; i !== N; i++) {
                    var eq = eqs[i];
                    if (eq.enabled) {
                        this.equations.push(eq);
                    }
                }
            };
            Solver.prototype.removeEquation = function(eq) {
                var i = this.equations.indexOf(eq);
                if (i !== -1) {
                    this.equations.splice(i, 1);
                }
            };
            Solver.prototype.removeAllEquations = function() {
                this.equations.length = 0;
            };
            Solver.GS = 1;
            Solver.ISLAND = 2;
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        } ],
        48: [ function(_dereq_, module, exports) {
            var ContactEquation = _dereq_("../equations/ContactEquation");
            var Pool = _dereq_("./Pool");
            module.exports = ContactEquationPool;
            function ContactEquationPool() {
                Pool.apply(this, arguments);
            }
            ContactEquationPool.prototype = new Pool();
            ContactEquationPool.prototype.constructor = ContactEquationPool;
            ContactEquationPool.prototype.create = function() {
                return new ContactEquation();
            };
            ContactEquationPool.prototype.destroy = function(equation) {
                equation.bodyA = equation.bodyB = null;
                return this;
            };
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        } ],
        49: [ function(_dereq_, module, exports) {
            var FrictionEquation = _dereq_("../equations/FrictionEquation");
            var Pool = _dereq_("./Pool");
            module.exports = FrictionEquationPool;
            function FrictionEquationPool() {
                Pool.apply(this, arguments);
            }
            FrictionEquationPool.prototype = new Pool();
            FrictionEquationPool.prototype.constructor = FrictionEquationPool;
            FrictionEquationPool.prototype.create = function() {
                return new FrictionEquation();
            };
            FrictionEquationPool.prototype.destroy = function(equation) {
                equation.bodyA = equation.bodyB = null;
                return this;
            };
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        } ],
        50: [ function(_dereq_, module, exports) {
            var IslandNode = _dereq_("../world/IslandNode");
            var Pool = _dereq_("./Pool");
            module.exports = IslandNodePool;
            function IslandNodePool() {
                Pool.apply(this, arguments);
            }
            IslandNodePool.prototype = new Pool();
            IslandNodePool.prototype.constructor = IslandNodePool;
            IslandNodePool.prototype.create = function() {
                return new IslandNode();
            };
            IslandNodePool.prototype.destroy = function(node) {
                node.reset();
                return this;
            };
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        } ],
        51: [ function(_dereq_, module, exports) {
            var Island = _dereq_("../world/Island");
            var Pool = _dereq_("./Pool");
            module.exports = IslandPool;
            function IslandPool() {
                Pool.apply(this, arguments);
            }
            IslandPool.prototype = new Pool();
            IslandPool.prototype.constructor = IslandPool;
            IslandPool.prototype.create = function() {
                return new Island();
            };
            IslandPool.prototype.destroy = function(island) {
                island.reset();
                return this;
            };
        }, {
            "../world/Island": 58,
            "./Pool": 55
        } ],
        52: [ function(_dereq_, module, exports) {
            var TupleDictionary = _dereq_("./TupleDictionary");
            var OverlapKeeperRecord = _dereq_("./OverlapKeeperRecord");
            var OverlapKeeperRecordPool = _dereq_("./OverlapKeeperRecordPool");
            var Utils = _dereq_("./Utils");
            module.exports = OverlapKeeper;
            function OverlapKeeper() {
                this.overlappingShapesLastState = new TupleDictionary();
                this.overlappingShapesCurrentState = new TupleDictionary();
                this.recordPool = new OverlapKeeperRecordPool({
                    size: 16
                });
                this.tmpDict = new TupleDictionary();
                this.tmpArray1 = [];
            }
            OverlapKeeper.prototype.tick = function() {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                var l = last.keys.length;
                while (l--) {
                    var key = last.keys[l];
                    var lastObject = last.getByKey(key);
                    var currentObject = current.getByKey(key);
                    if (lastObject) {
                        this.recordPool.release(lastObject);
                    }
                }
                last.reset();
                last.copy(current);
                current.reset();
            };
            OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                if (!current.get(shapeA.id, shapeB.id)) {
                    var data = this.recordPool.get();
                    data.set(bodyA, shapeA, bodyB, shapeB);
                    current.set(shapeA.id, shapeB.id, data);
                }
            };
            OverlapKeeper.prototype.getNewOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
            };
            OverlapKeeper.prototype.getEndOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
            };
            OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB) {
                var current = this.overlappingShapesCurrentState;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {
                        return true;
                    }
                }
                return false;
            };
            OverlapKeeper.prototype.getDiff = function(dictA, dictB, result) {
                var result = result || [];
                var last = dictA;
                var current = dictB;
                result.length = 0;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (!data) {
                        throw new Error("Key " + key + " had no data!");
                    }
                    var lastData = last.data[key];
                    if (!lastData) {
                        result.push(data);
                    }
                }
                return result;
            };
            OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB) {
                var idA = shapeA.id | 0, idB = shapeB.id | 0;
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                return !!!last.get(idA, idB) && !!current.get(idA, idB);
            };
            OverlapKeeper.prototype.getNewBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getEndBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getBodyDiff = function(overlaps, result) {
                result = result || [];
                var accumulator = this.tmpDict;
                var l = overlaps.length;
                while (l--) {
                    var data = overlaps[l];
                    accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
                }
                l = accumulator.keys.length;
                while (l--) {
                    var data = accumulator.getByKey(accumulator.keys[l]);
                    if (data) {
                        result.push(data.bodyA, data.bodyB);
                    }
                }
                accumulator.reset();
                return result;
            };
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        } ],
        53: [ function(_dereq_, module, exports) {
            module.exports = OverlapKeeperRecord;
            function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
                this.shapeA = shapeA;
                this.shapeB = shapeB;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB) {
                OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
            };
        }, {} ],
        54: [ function(_dereq_, module, exports) {
            var OverlapKeeperRecord = _dereq_("./OverlapKeeperRecord");
            var Pool = _dereq_("./Pool");
            module.exports = OverlapKeeperRecordPool;
            function OverlapKeeperRecordPool() {
                Pool.apply(this, arguments);
            }
            OverlapKeeperRecordPool.prototype = new Pool();
            OverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;
            OverlapKeeperRecordPool.prototype.create = function() {
                return new OverlapKeeperRecord();
            };
            OverlapKeeperRecordPool.prototype.destroy = function(record) {
                record.bodyA = record.bodyB = record.shapeA = record.shapeB = null;
                return this;
            };
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        } ],
        55: [ function(_dereq_, module, exports) {
            module.exports = Pool;
            function Pool(options) {
                options = options || {};
                this.objects = [];
                if (options.size !== undefined) {
                    this.resize(options.size);
                }
            }
            Pool.prototype.resize = function(size) {
                var objects = this.objects;
                while (objects.length > size) {
                    objects.pop();
                }
                while (objects.length < size) {
                    objects.push(this.create());
                }
                return this;
            };
            Pool.prototype.get = function() {
                var objects = this.objects;
                return objects.length ? objects.pop() : this.create();
            };
            Pool.prototype.release = function(object) {
                this.destroy(object);
                this.objects.push(object);
                return this;
            };
        }, {} ],
        56: [ function(_dereq_, module, exports) {
            var Utils = _dereq_("./Utils");
            module.exports = TupleDictionary;
            function TupleDictionary() {
                this.data = {};
                this.keys = [];
            }
            TupleDictionary.prototype.getKey = function(id1, id2) {
                id1 = id1 | 0;
                id2 = id2 | 0;
                if ((id1 | 0) === (id2 | 0)) {
                    return -1;
                }
                return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 65535 : id2 << 16 | id1 & 65535) | 0;
            };
            TupleDictionary.prototype.getByKey = function(key) {
                key = key | 0;
                return this.data[key];
            };
            TupleDictionary.prototype.get = function(i, j) {
                return this.data[this.getKey(i, j)];
            };
            TupleDictionary.prototype.set = function(i, j, value) {
                if (!value) {
                    throw new Error("No data!");
                }
                var key = this.getKey(i, j);
                if (!this.data[key]) {
                    this.keys.push(key);
                }
                this.data[key] = value;
                return key;
            };
            TupleDictionary.prototype.reset = function() {
                var data = this.data, keys = this.keys;
                var l = keys.length;
                while (l--) {
                    delete data[keys[l]];
                }
                keys.length = 0;
            };
            TupleDictionary.prototype.copy = function(dict) {
                this.reset();
                Utils.appendArray(this.keys, dict.keys);
                var l = dict.keys.length;
                while (l--) {
                    var key = dict.keys[l];
                    this.data[key] = dict.data[key];
                }
            };
        }, {
            "./Utils": 57
        } ],
        57: [ function(_dereq_, module, exports) {
            module.exports = Utils;
            function Utils() {}
            Utils.appendArray = function(a, b) {
                if (b.length < 15e4) {
                    a.push.apply(a, b);
                } else {
                    for (var i = 0, len = b.length; i !== len; ++i) {
                        a.push(b[i]);
                    }
                }
            };
            Utils.splice = function(array, index, howmany) {
                howmany = howmany || 1;
                for (var i = index, len = array.length - howmany; i < len; i++) {
                    array[i] = array[i + howmany];
                }
                array.length = len;
            };
            if (typeof P2_ARRAY_TYPE !== "undefined") {
                Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
            } else if (typeof Float32Array !== "undefined") {
                Utils.ARRAY_TYPE = Float32Array;
            } else {
                Utils.ARRAY_TYPE = Array;
            }
            Utils.extend = function(a, b) {
                for (var key in b) {
                    a[key] = b[key];
                }
            };
            Utils.defaults = function(options, defaults) {
                options = options || {};
                for (var key in defaults) {
                    if (!(key in options)) {
                        options[key] = defaults[key];
                    }
                }
                return options;
            };
        }, {} ],
        58: [ function(_dereq_, module, exports) {
            var Body = _dereq_("../objects/Body");
            module.exports = Island;
            function Island() {
                this.equations = [];
                this.bodies = [];
            }
            Island.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0;
            };
            var bodyIds = [];
            Island.prototype.getBodies = function(result) {
                var bodies = result || [], eqs = this.equations;
                bodyIds.length = 0;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    if (bodyIds.indexOf(eq.bodyA.id) === -1) {
                        bodies.push(eq.bodyA);
                        bodyIds.push(eq.bodyA.id);
                    }
                    if (bodyIds.indexOf(eq.bodyB.id) === -1) {
                        bodies.push(eq.bodyB);
                        bodyIds.push(eq.bodyB.id);
                    }
                }
                return bodies;
            };
            Island.prototype.wantsToSleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    if (b.type === Body.DYNAMIC && !b.wantsToSleep) {
                        return false;
                    }
                }
                return true;
            };
            Island.prototype.sleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    b.sleep();
                }
                return true;
            };
        }, {
            "../objects/Body": 31
        } ],
        59: [ function(_dereq_, module, exports) {
            var vec2 = _dereq_("../math/vec2"), Island = _dereq_("./Island"), IslandNode = _dereq_("./IslandNode"), IslandNodePool = _dereq_("./../utils/IslandNodePool"), IslandPool = _dereq_("./../utils/IslandPool"), Body = _dereq_("../objects/Body");
            module.exports = IslandManager;
            function IslandManager(options) {
                this.nodePool = new IslandNodePool({
                    size: 16
                });
                this.islandPool = new IslandPool({
                    size: 8
                });
                this.equations = [];
                this.islands = [];
                this.nodes = [];
                this.queue = [];
            }
            IslandManager.getUnvisitedNode = function(nodes) {
                var Nnodes = nodes.length;
                for (var i = 0; i !== Nnodes; i++) {
                    var node = nodes[i];
                    if (!node.visited && node.body.type === Body.DYNAMIC) {
                        return node;
                    }
                }
                return false;
            };
            IslandManager.prototype.visit = function(node, bds, eqs) {
                bds.push(node.body);
                var Neqs = node.equations.length;
                for (var i = 0; i !== Neqs; i++) {
                    var eq = node.equations[i];
                    if (eqs.indexOf(eq) === -1) {
                        eqs.push(eq);
                    }
                }
            };
            IslandManager.prototype.bfs = function(root, bds, eqs) {
                var queue = this.queue;
                queue.length = 0;
                queue.push(root);
                root.visited = true;
                this.visit(root, bds, eqs);
                while (queue.length) {
                    var node = queue.pop();
                    var child;
                    while (child = IslandManager.getUnvisitedNode(node.neighbors)) {
                        child.visited = true;
                        this.visit(child, bds, eqs);
                        if (child.body.type === Body.DYNAMIC) {
                            queue.push(child);
                        }
                    }
                }
            };
            IslandManager.prototype.split = function(world) {
                var bodies = world.bodies, nodes = this.nodes, equations = this.equations;
                while (nodes.length) {
                    this.nodePool.release(nodes.pop());
                }
                for (var i = 0; i !== bodies.length; i++) {
                    var node = this.nodePool.get();
                    node.body = bodies[i];
                    nodes.push(node);
                }
                for (var k = 0; k !== equations.length; k++) {
                    var eq = equations[k], i = bodies.indexOf(eq.bodyA), j = bodies.indexOf(eq.bodyB), ni = nodes[i], nj = nodes[j];
                    ni.neighbors.push(nj);
                    nj.neighbors.push(ni);
                    ni.equations.push(eq);
                    nj.equations.push(eq);
                }
                var islands = this.islands;
                for (var i = 0; i < islands.length; i++) {
                    this.islandPool.release(islands[i]);
                }
                islands.length = 0;
                var child;
                while (child = IslandManager.getUnvisitedNode(nodes)) {
                    var island = this.islandPool.get();
                    this.bfs(child, island.bodies, island.equations);
                    islands.push(island);
                }
                return islands;
            };
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        } ],
        60: [ function(_dereq_, module, exports) {
            module.exports = IslandNode;
            function IslandNode(body) {
                this.body = body;
                this.neighbors = [];
                this.equations = [];
                this.visited = false;
            }
            IslandNode.prototype.reset = function() {
                this.equations.length = 0;
                this.neighbors.length = 0;
                this.visited = false;
                this.body = null;
            };
        }, {} ],
        61: [ function(_dereq_, module, exports) {
            var GSSolver = _dereq_("../solver/GSSolver"), Solver = _dereq_("../solver/Solver"), Ray = _dereq_("../collision/Ray"), vec2 = _dereq_("../math/vec2"), Circle = _dereq_("../shapes/Circle"), Convex = _dereq_("../shapes/Convex"), Line = _dereq_("../shapes/Line"), Plane = _dereq_("../shapes/Plane"), Capsule = _dereq_("../shapes/Capsule"), Particle = _dereq_("../shapes/Particle"), EventEmitter = _dereq_("../events/EventEmitter"), Body = _dereq_("../objects/Body"), Shape = _dereq_("../shapes/Shape"), LinearSpring = _dereq_("../objects/LinearSpring"), Material = _dereq_("../material/Material"), ContactMaterial = _dereq_("../material/ContactMaterial"), DistanceConstraint = _dereq_("../constraints/DistanceConstraint"), Constraint = _dereq_("../constraints/Constraint"), LockConstraint = _dereq_("../constraints/LockConstraint"), RevoluteConstraint = _dereq_("../constraints/RevoluteConstraint"), PrismaticConstraint = _dereq_("../constraints/PrismaticConstraint"), GearConstraint = _dereq_("../constraints/GearConstraint"), pkg = _dereq_("../../package.json"), Broadphase = _dereq_("../collision/Broadphase"), AABB = _dereq_("../collision/AABB"), SAPBroadphase = _dereq_("../collision/SAPBroadphase"), Narrowphase = _dereq_("../collision/Narrowphase"), Utils = _dereq_("../utils/Utils"), OverlapKeeper = _dereq_("../utils/OverlapKeeper"), IslandManager = _dereq_("./IslandManager"), RotationalSpring = _dereq_("../objects/RotationalSpring");
            module.exports = World;
            function World(options) {
                EventEmitter.apply(this);
                options = options || {};
                this.springs = [];
                this.bodies = [];
                this.disabledBodyCollisionPairs = [];
                this.solver = options.solver || new GSSolver();
                this.narrowphase = new Narrowphase(this);
                this.islandManager = new IslandManager();
                this.gravity = vec2.fromValues(0, -9.78);
                if (options.gravity) {
                    vec2.copy(this.gravity, options.gravity);
                }
                this.frictionGravity = vec2.length(this.gravity) || 10;
                this.useWorldGravityAsFrictionGravity = true;
                this.useFrictionGravityOnZeroGravity = true;
                this.broadphase = options.broadphase || new SAPBroadphase();
                this.broadphase.setWorld(this);
                this.constraints = [];
                this.defaultMaterial = new Material();
                this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);
                this.lastTimeStep = 1 / 60;
                this.applySpringForces = true;
                this.applyDamping = true;
                this.applyGravity = true;
                this.solveConstraints = true;
                this.contactMaterials = [];
                this.time = 0;
                this.accumulator = 0;
                this.stepping = false;
                this.bodiesToBeRemoved = [];
                this.islandSplit = typeof options.islandSplit !== "undefined" ? !!options.islandSplit : true;
                this.emitImpactEvent = true;
                this._constraintIdCounter = 0;
                this._bodyIdCounter = 0;
                this.postStepEvent = {
                    type: "postStep"
                };
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                };
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                };
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                };
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                };
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                };
                this.sleepMode = World.NO_SLEEPING;
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                };
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                };
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                };
                this.overlappingShapesLastState = {
                    keys: []
                };
                this.overlappingShapesCurrentState = {
                    keys: []
                };
                this.overlapKeeper = new OverlapKeeper();
            }
            World.prototype = new Object(EventEmitter.prototype);
            World.prototype.constructor = World;
            World.NO_SLEEPING = 1;
            World.BODY_SLEEPING = 2;
            World.ISLAND_SLEEPING = 4;
            World.prototype.addConstraint = function(constraint) {
                this.constraints.push(constraint);
            };
            World.prototype.addContactMaterial = function(contactMaterial) {
                this.contactMaterials.push(contactMaterial);
            };
            World.prototype.removeContactMaterial = function(cm) {
                var idx = this.contactMaterials.indexOf(cm);
                if (idx !== -1) {
                    Utils.splice(this.contactMaterials, idx, 1);
                }
            };
            World.prototype.getContactMaterial = function(materialA, materialB) {
                var cmats = this.contactMaterials;
                for (var i = 0, N = cmats.length; i !== N; i++) {
                    var cm = cmats[i];
                    if (cm.materialA.id === materialA.id && cm.materialB.id === materialB.id || cm.materialA.id === materialB.id && cm.materialB.id === materialA.id) {
                        return cm;
                    }
                }
                return false;
            };
            World.prototype.removeConstraint = function(constraint) {
                var idx = this.constraints.indexOf(constraint);
                if (idx !== -1) {
                    Utils.splice(this.constraints, idx, 1);
                }
            };
            var step_r = vec2.create(), step_runit = vec2.create(), step_u = vec2.create(), step_f = vec2.create(), step_fhMinv = vec2.create(), step_velodt = vec2.create(), step_mg = vec2.create(), xiw = vec2.fromValues(0, 0), xjw = vec2.fromValues(0, 0), zero = vec2.fromValues(0, 0), interpvelo = vec2.fromValues(0, 0);
            World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
                maxSubSteps = maxSubSteps || 10;
                timeSinceLastCalled = timeSinceLastCalled || 0;
                if (timeSinceLastCalled === 0) {
                    this.internalStep(dt);
                    this.time += dt;
                } else {
                    this.accumulator += timeSinceLastCalled;
                    var substeps = 0;
                    while (this.accumulator >= dt && substeps < maxSubSteps) {
                        this.internalStep(dt);
                        this.time += dt;
                        this.accumulator -= dt;
                        substeps++;
                    }
                    var t = this.accumulator % dt / dt;
                    for (var j = 0; j !== this.bodies.length; j++) {
                        var b = this.bodies[j];
                        vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
                        b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
                    }
                }
            };
            var endOverlaps = [];
            World.prototype.internalStep = function(dt) {
                this.stepping = true;
                var that = this, Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, t0, t1, fhMinv = step_fhMinv, velodt = step_velodt, mg = step_mg, scale = vec2.scale, add = vec2.add, rotate = vec2.rotate, islandManager = this.islandManager;
                this.overlapKeeper.tick();
                this.lastTimeStep = dt;
                if (this.useWorldGravityAsFrictionGravity) {
                    var gravityLen = vec2.length(this.gravity);
                    if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                        this.frictionGravity = gravityLen;
                    }
                }
                if (this.applyGravity) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i], fi = b.force;
                        if (b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING) {
                            continue;
                        }
                        vec2.scale(mg, g, b.mass * b.gravityScale);
                        add(fi, fi, mg);
                    }
                }
                if (this.applySpringForces) {
                    for (var i = 0; i !== Nsprings; i++) {
                        var s = springs[i];
                        s.applyForce();
                    }
                }
                if (this.applyDamping) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        if (b.type === Body.DYNAMIC) {
                            b.applyDamping(dt);
                        }
                    }
                }
                var result = broadphase.getCollisionPairs(this);
                var ignoredPairs = this.disabledBodyCollisionPairs;
                for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
                    for (var j = result.length - 2; j >= 0; j -= 2) {
                        if (ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1] || ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1]) {
                            result.splice(j, 2);
                        }
                    }
                }
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    var c = constraints[i];
                    if (!c.collideConnected) {
                        for (var j = result.length - 2; j >= 0; j -= 2) {
                            if (c.bodyA === result[j] && c.bodyB === result[j + 1] || c.bodyB === result[j] && c.bodyA === result[j + 1]) {
                                result.splice(j, 2);
                            }
                        }
                    }
                }
                this.postBroadphaseEvent.pairs = result;
                this.emit(this.postBroadphaseEvent);
                this.postBroadphaseEvent.pairs = null;
                np.reset(this);
                for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
                    var bi = result[i], bj = result[i + 1];
                    for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                        var si = bi.shapes[k], xi = si.position, ai = si.angle;
                        for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                            var sj = bj.shapes[l], xj = sj.position, aj = sj.angle;
                            var cm = this.defaultContactMaterial;
                            if (si.material && sj.material) {
                                var tmp = this.getContactMaterial(si.material, sj.material);
                                if (tmp) {
                                    cm = tmp;
                                }
                            }
                            this.runNarrowphase(np, bi, si, xi, ai, bj, sj, xj, aj, cm, this.frictionGravity);
                        }
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    if (body._wakeUpAfterNarrowphase) {
                        body.wakeUp();
                        body._wakeUpAfterNarrowphase = false;
                    }
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(endOverlaps);
                    var e = this.endContactEvent;
                    var l = endOverlaps.length;
                    while (l--) {
                        var data = endOverlaps[l];
                        e.shapeA = data.shapeA;
                        e.shapeB = data.shapeB;
                        e.bodyA = data.bodyA;
                        e.bodyB = data.bodyB;
                        this.emit(e);
                    }
                    endOverlaps.length = 0;
                }
                var preSolveEvent = this.preSolveEvent;
                preSolveEvent.contactEquations = np.contactEquations;
                preSolveEvent.frictionEquations = np.frictionEquations;
                this.emit(preSolveEvent);
                preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    constraints[i].update();
                }
                if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
                    if (this.islandSplit) {
                        islandManager.equations.length = 0;
                        Utils.appendArray(islandManager.equations, np.contactEquations);
                        Utils.appendArray(islandManager.equations, np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            Utils.appendArray(islandManager.equations, constraints[i].equations);
                        }
                        islandManager.split(this);
                        for (var i = 0; i !== islandManager.islands.length; i++) {
                            var island = islandManager.islands[i];
                            if (island.equations.length) {
                                solver.solveIsland(dt, island);
                            }
                        }
                    } else {
                        solver.addEquations(np.contactEquations);
                        solver.addEquations(np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            solver.addEquations(constraints[i].equations);
                        }
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    body.integrate(dt);
                }
                for (var i = 0; i !== Nbodies; i++) {
                    bodies[i].setZeroForce();
                }
                if (this.emitImpactEvent && this.has("impact")) {
                    var ev = this.impactEvent;
                    for (var i = 0; i !== np.contactEquations.length; i++) {
                        var eq = np.contactEquations[i];
                        if (eq.firstImpact) {
                            ev.bodyA = eq.bodyA;
                            ev.bodyB = eq.bodyB;
                            ev.shapeA = eq.shapeA;
                            ev.shapeB = eq.shapeB;
                            ev.contactEquation = eq;
                            this.emit(ev);
                        }
                    }
                }
                if (this.sleepMode === World.BODY_SLEEPING) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, false, dt);
                    }
                } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, true, dt);
                    }
                    for (var i = 0; i < this.islandManager.islands.length; i++) {
                        var island = this.islandManager.islands[i];
                        if (island.wantsToSleep()) {
                            island.sleep();
                        }
                    }
                }
                this.stepping = false;
                var bodiesToBeRemoved = this.bodiesToBeRemoved;
                for (var i = 0; i !== bodiesToBeRemoved.length; i++) {
                    this.removeBody(bodiesToBeRemoved[i]);
                }
                bodiesToBeRemoved.length = 0;
                this.emit(this.postStepEvent);
            };
            World.prototype.runNarrowphase = function(np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
                if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
                    return;
                }
                vec2.rotate(xiw, xi, bi.angle);
                vec2.rotate(xjw, xj, bj.angle);
                vec2.add(xiw, xiw, bi.position);
                vec2.add(xjw, xjw, bj.position);
                var aiw = ai + bi.angle;
                var ajw = aj + bj.angle;
                np.enableFriction = cm.friction > 0;
                np.frictionCoefficient = cm.friction;
                var reducedMass;
                if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {
                    reducedMass = bj.mass;
                } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {
                    reducedMass = bi.mass;
                } else {
                    reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);
                }
                np.slipForce = cm.friction * glen * reducedMass;
                np.restitution = cm.restitution;
                np.surfaceVelocity = cm.surfaceVelocity;
                np.frictionStiffness = cm.frictionStiffness;
                np.frictionRelaxation = cm.frictionRelaxation;
                np.stiffness = cm.stiffness;
                np.relaxation = cm.relaxation;
                np.contactSkinSize = cm.contactSkinSize;
                np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                var resolver = np[si.type | sj.type], numContacts = 0;
                if (resolver) {
                    var sensor = si.sensor || sj.sensor;
                    var numFrictionBefore = np.frictionEquations.length;
                    if (si.type < sj.type) {
                        numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);
                    } else {
                        numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);
                    }
                    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
                    if (numContacts) {
                        if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                            var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
                            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                            if (speedSquaredB >= speedLimitSquaredB * 2) {
                                bi._wakeUpAfterNarrowphase = true;
                            }
                        }
                        if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                            var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
                            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                            if (speedSquaredA >= speedLimitSquaredA * 2) {
                                bj._wakeUpAfterNarrowphase = true;
                            }
                        }
                        this.overlapKeeper.setOverlapping(bi, si, bj, sj);
                        if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(si, sj)) {
                            var e = this.beginContactEvent;
                            e.shapeA = si;
                            e.shapeB = sj;
                            e.bodyA = bi;
                            e.bodyB = bj;
                            e.contactEquations.length = 0;
                            if (typeof numContacts === "number") {
                                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                                    e.contactEquations.push(np.contactEquations[i]);
                                }
                            }
                            this.emit(e);
                        }
                        if (typeof numContacts === "number" && numFrictionEquations > 1) {
                            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                                var f = np.frictionEquations[i];
                                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                            }
                        }
                    }
                }
            };
            World.prototype.addSpring = function(spring) {
                this.springs.push(spring);
                var evt = this.addSpringEvent;
                evt.spring = spring;
                this.emit(evt);
                evt.spring = null;
            };
            World.prototype.removeSpring = function(spring) {
                var idx = this.springs.indexOf(spring);
                if (idx !== -1) {
                    Utils.splice(this.springs, idx, 1);
                }
            };
            World.prototype.addBody = function(body) {
                if (this.bodies.indexOf(body) === -1) {
                    this.bodies.push(body);
                    body.world = this;
                    var evt = this.addBodyEvent;
                    evt.body = body;
                    this.emit(evt);
                    evt.body = null;
                }
            };
            World.prototype.removeBody = function(body) {
                if (this.stepping) {
                    this.bodiesToBeRemoved.push(body);
                } else {
                    body.world = null;
                    var idx = this.bodies.indexOf(body);
                    if (idx !== -1) {
                        Utils.splice(this.bodies, idx, 1);
                        this.removeBodyEvent.body = body;
                        body.resetConstraintVelocity();
                        this.emit(this.removeBodyEvent);
                        this.removeBodyEvent.body = null;
                    }
                }
            };
            World.prototype.getBodyById = function(id) {
                var bodies = this.bodies;
                for (var i = 0; i < bodies.length; i++) {
                    var b = bodies[i];
                    if (b.id === id) {
                        return b;
                    }
                }
                return false;
            };
            World.prototype.disableBodyCollision = function(bodyA, bodyB) {
                this.disabledBodyCollisionPairs.push(bodyA, bodyB);
            };
            World.prototype.enableBodyCollision = function(bodyA, bodyB) {
                var pairs = this.disabledBodyCollisionPairs;
                for (var i = 0; i < pairs.length; i += 2) {
                    if (pairs[i] === bodyA && pairs[i + 1] === bodyB || pairs[i + 1] === bodyA && pairs[i] === bodyB) {
                        pairs.splice(i, 2);
                        return;
                    }
                }
            };
            World.prototype.clear = function() {
                this.time = 0;
                if (this.solver && this.solver.equations.length) {
                    this.solver.removeAllEquations();
                }
                var cs = this.constraints;
                for (var i = cs.length - 1; i >= 0; i--) {
                    this.removeConstraint(cs[i]);
                }
                var bodies = this.bodies;
                for (var i = bodies.length - 1; i >= 0; i--) {
                    this.removeBody(bodies[i]);
                }
                var springs = this.springs;
                for (var i = springs.length - 1; i >= 0; i--) {
                    this.removeSpring(springs[i]);
                }
                var cms = this.contactMaterials;
                for (var i = cms.length - 1; i >= 0; i--) {
                    this.removeContactMaterial(cms[i]);
                }
                World.apply(this);
            };
            var hitTest_tmp1 = vec2.create(), hitTest_zero = vec2.fromValues(0, 0), hitTest_tmp2 = vec2.fromValues(0, 0);
            World.prototype.hitTest = function(worldPoint, bodies, precision) {
                precision = precision || 0;
                var pb = new Body({
                    position: worldPoint
                }), ps = new Particle(), px = worldPoint, pa = 0, x = hitTest_tmp1, zero = hitTest_zero, tmp = hitTest_tmp2;
                pb.addShape(ps);
                var n = this.narrowphase, result = [];
                for (var i = 0, N = bodies.length; i !== N; i++) {
                    var b = bodies[i];
                    for (var j = 0, NS = b.shapes.length; j !== NS; j++) {
                        var s = b.shapes[j];
                        vec2.rotate(x, s.position, b.angle);
                        vec2.add(x, x, b.position);
                        var a = s.angle + b.angle;
                        if (s instanceof Circle && n.circleParticle(b, s, x, a, pb, ps, px, pa, true) || s instanceof Convex && n.particleConvex(pb, ps, px, pa, b, s, x, a, true) || s instanceof Plane && n.particlePlane(pb, ps, px, pa, b, s, x, a, true) || s instanceof Capsule && n.particleCapsule(pb, ps, px, pa, b, s, x, a, true) || s instanceof Particle && vec2.squaredLength(vec2.sub(tmp, x, worldPoint)) < precision * precision) {
                            result.push(b);
                        }
                    }
                }
                return result;
            };
            World.prototype.setGlobalStiffness = function(stiffness) {
                var constraints = this.constraints;
                for (var i = 0; i !== constraints.length; i++) {
                    var c = constraints[i];
                    for (var j = 0; j !== c.equations.length; j++) {
                        var eq = c.equations[j];
                        eq.stiffness = stiffness;
                        eq.needsUpdate = true;
                    }
                }
                var contactMaterials = this.contactMaterials;
                for (var i = 0; i !== contactMaterials.length; i++) {
                    var c = contactMaterials[i];
                    c.stiffness = c.frictionStiffness = stiffness;
                }
                var c = this.defaultContactMaterial;
                c.stiffness = c.frictionStiffness = stiffness;
            };
            World.prototype.setGlobalRelaxation = function(relaxation) {
                for (var i = 0; i !== this.constraints.length; i++) {
                    var c = this.constraints[i];
                    for (var j = 0; j !== c.equations.length; j++) {
                        var eq = c.equations[j];
                        eq.relaxation = relaxation;
                        eq.needsUpdate = true;
                    }
                }
                for (var i = 0; i !== this.contactMaterials.length; i++) {
                    var c = this.contactMaterials[i];
                    c.relaxation = c.frictionRelaxation = relaxation;
                }
                var c = this.defaultContactMaterial;
                c.relaxation = c.frictionRelaxation = relaxation;
            };
            var tmpAABB = new AABB();
            var tmpArray = [];
            World.prototype.raycast = function(result, ray) {
                ray.getAABB(tmpAABB);
                this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
                ray.intersectBodies(result, tmpArray);
                tmpArray.length = 0;
                return result.hasHit();
            };
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        } ]
    }, {}, [ 36 ])(36);
});

(function() {
    var root = this;
    var PIXI = PIXI || {};
    PIXI.WEBGL_RENDERER = 0;
    PIXI.CANVAS_RENDERER = 1;
    PIXI.VERSION = "v2.2.8";
    PIXI._UID = 0;
    if (typeof Float32Array != "undefined") {
        PIXI.Float32Array = Float32Array;
        PIXI.Uint16Array = Uint16Array;
        PIXI.Uint32Array = Uint32Array;
        PIXI.ArrayBuffer = ArrayBuffer;
    } else {
        PIXI.Float32Array = Array;
        PIXI.Uint16Array = Array;
    }
    PIXI.PI_2 = Math.PI * 2;
    PIXI.RAD_TO_DEG = 180 / Math.PI;
    PIXI.DEG_TO_RAD = Math.PI / 180;
    PIXI.RETINA_PREFIX = "@2x";
    PIXI.defaultRenderOptions = {
        view: null,
        transparent: false,
        antialias: false,
        preserveDrawingBuffer: false,
        resolution: 1,
        clearBeforeRender: true,
        autoResize: false
    };
    PIXI.DisplayObject = function() {
        this.position = new PIXI.Point(0, 0);
        this.scale = new PIXI.Point(1, 1);
        this.transformCallback = null;
        this.transformCallbackContext = null;
        this.pivot = new PIXI.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this.worldTransform = new PIXI.Matrix();
        this.worldPosition = new PIXI.Point(0, 0);
        this.worldScale = new PIXI.Point(1, 1);
        this.worldRotation = 0;
        this._sr = 0;
        this._cr = 1;
        this.filterArea = null;
        this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
        this._currentBounds = null;
        this._mask = null;
        this._cacheAsBitmap = false;
        this._cacheIsDirty = false;
    };
    PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;
    PIXI.DisplayObject.prototype.destroy = function() {
        if (this.children) {
            var i = this.children.length;
            while (i--) {
                this.children[i].destroy();
            }
            this.children = [];
        }
        this.transformCallback = null;
        this.transformCallbackContext = null;
        this.hitArea = null;
        this.parent = null;
        this.stage = null;
        this.worldTransform = null;
        this.filterArea = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.renderable = false;
        this._destroyCachedSprite();
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var item = this;
            do {
                if (!item.visible) return false;
                item = item.parent;
            } while (item);
            return true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(value) {
            if (this._mask) this._mask.isMask = false;
            this._mask = value;
            if (this._mask) this._mask.isMask = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters;
        },
        set: function(value) {
            if (value) {
                var passes = [];
                for (var i = 0; i < value.length; i++) {
                    var filterPasses = value[i].passes;
                    for (var j = 0; j < filterPasses.length; j++) {
                        passes.push(filterPasses[j]);
                    }
                }
                this._filterBlock = {
                    target: this,
                    filterPasses: passes
                };
            }
            this._filters = value;
            if (this.blendMode && this.blendMode === PIXI.blendModes.MULTIPLY) {
                this.blendMode = PIXI.blendModes.NORMAL;
            }
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            if (this._cacheAsBitmap === value) {
                return;
            }
            if (value) {
                this._generateCachedSprite();
            } else {
                this._destroyCachedSprite();
            }
            this._cacheAsBitmap = value;
        }
    });
    PIXI.DisplayObject.prototype.updateTransform = function(parent) {
        if (!parent && !this.parent && !this.game) {
            return;
        }
        var p = this.parent;
        if (parent) {
            p = parent;
        } else if (!this.parent) {
            p = this.game.world;
        }
        var pt = p.worldTransform;
        var wt = this.worldTransform;
        var a, b, c, d, tx, ty;
        if (this.rotation % PIXI.PI_2) {
            if (this.rotation !== this.rotationCache) {
                this.rotationCache = this.rotation;
                this._sr = Math.sin(this.rotation);
                this._cr = Math.cos(this.rotation);
            }
            a = this._cr * this.scale.x;
            b = this._sr * this.scale.x;
            c = -this._sr * this.scale.y;
            d = this._cr * this.scale.y;
            tx = this.position.x;
            ty = this.position.y;
            if (this.pivot.x || this.pivot.y) {
                tx -= this.pivot.x * a + this.pivot.y * c;
                ty -= this.pivot.x * b + this.pivot.y * d;
            }
            wt.a = a * pt.a + b * pt.c;
            wt.b = a * pt.b + b * pt.d;
            wt.c = c * pt.a + d * pt.c;
            wt.d = c * pt.b + d * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        } else {
            a = this.scale.x;
            d = this.scale.y;
            tx = this.position.x - this.pivot.x * a;
            ty = this.position.y - this.pivot.y * d;
            wt.a = a * pt.a;
            wt.b = a * pt.b;
            wt.c = d * pt.c;
            wt.d = d * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        this.worldAlpha = this.alpha * p.worldAlpha;
        this.worldPosition.set(wt.tx, wt.ty);
        this.worldScale.set(Math.sqrt(wt.a * wt.a + wt.b * wt.b), Math.sqrt(wt.c * wt.c + wt.d * wt.d));
        this.worldRotation = Math.atan2(-wt.c, wt.d);
        this._currentBounds = null;
        if (this.transformCallback) {
            this.transformCallback.call(this.transformCallbackContext, wt, pt);
        }
    };
    PIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;
    PIXI.DisplayObject.prototype.getBounds = function(matrix) {
        matrix = matrix;
        return PIXI.EmptyRectangle;
    };
    PIXI.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(PIXI.identityMatrix);
    };
    PIXI.DisplayObject.prototype.setStageReference = function(stage) {
        this.stage = stage;
    };
    PIXI.DisplayObject.prototype.preUpdate = function() {};
    PIXI.DisplayObject.prototype.generateTexture = function(resolution, scaleMode, renderer) {
        var bounds = this.getLocalBounds();
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);
        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;
        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;
        renderTexture.render(this, PIXI.DisplayObject._tempMatrix);
        return renderTexture;
    };
    PIXI.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite();
    };
    PIXI.DisplayObject.prototype.toGlobal = function(position) {
        this.displayObjectUpdateTransform();
        return this.worldTransform.apply(position);
    };
    PIXI.DisplayObject.prototype.toLocal = function(position, from) {
        if (from) {
            position = from.toGlobal(position);
        }
        this.displayObjectUpdateTransform();
        return this.worldTransform.applyInverse(position);
    };
    PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession) {
        this._cachedSprite.worldAlpha = this.worldAlpha;
        if (renderSession.gl) {
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
        } else {
            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
        }
    };
    PIXI.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = false;
        var bounds = this.getLocalBounds();
        this.updateTransform();
        if (!this._cachedSprite) {
            var renderTexture = new PIXI.RenderTexture(bounds.width | 1, bounds.height | 1);
            this._cachedSprite = new PIXI.Sprite(renderTexture);
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.texture.resize(bounds.width | 1, bounds.height | 1);
        }
        var tempFilters = this._filters;
        this._filters = null;
        this._cachedSprite.filters = tempFilters;
        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;
        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;
        this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, true);
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._filters = tempFilters;
        this._cacheAsBitmap = true;
    };
    PIXI.DisplayObject.prototype._destroyCachedSprite = function() {
        if (!this._cachedSprite) return;
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.DisplayObject.prototype._renderWebGL = function(renderSession) {
        renderSession = renderSession;
    };
    PIXI.DisplayObject.prototype._renderCanvas = function(renderSession) {
        renderSession = renderSession;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    PIXI.DisplayObjectContainer = function() {
        PIXI.DisplayObject.call(this);
        this.children = [];
    };
    PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype);
    PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
            var width = this.getLocalBounds().width;
            if (width !== 0) {
                this.scale.x = value / width;
            } else {
                this.scale.x = 1;
            }
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
            var height = this.getLocalBounds().height;
            if (height !== 0) {
                this.scale.y = value / height;
            } else {
                this.scale.y = 1;
            }
            this._height = value;
        }
    });
    PIXI.DisplayObjectContainer.prototype.addChild = function(child) {
        return this.addChildAt(child, this.children.length);
    };
    PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index) {
        if (index >= 0 && index <= this.children.length) {
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.children.splice(index, 0, child);
            if (this.stage) child.setStageReference(this.stage);
            return child;
        } else {
            throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
        }
    };
    PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        if (index1 < 0 || index2 < 0) {
            throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
        }
        this.children[index1] = child2;
        this.children[index2] = child;
    };
    PIXI.DisplayObjectContainer.prototype.getChildIndex = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index;
    };
    PIXI.DisplayObjectContainer.prototype.setChildIndex = function(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error("The supplied index is out of bounds");
        }
        var currentIndex = this.getChildIndex(child);
        this.children.splice(currentIndex, 1);
        this.children.splice(index, 0, child);
    };
    PIXI.DisplayObjectContainer.prototype.getChildAt = function(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error("getChildAt: Supplied index " + index + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        }
        return this.children[index];
    };
    PIXI.DisplayObjectContainer.prototype.removeChild = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) return;
        return this.removeChildAt(index);
    };
    PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        if (this.stage) child.removeStageReference();
        child.parent = undefined;
        this.children.splice(index, 1);
        return child;
    };
    PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex) {
        var begin = beginIndex || 0;
        var end = typeof endIndex === "number" ? endIndex : this.children.length;
        var range = end - begin;
        if (range > 0 && range <= end) {
            var removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; i++) {
                var child = removed[i];
                if (this.stage) child.removeStageReference();
                child.parent = undefined;
            }
            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return [];
        } else {
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
        }
    };
    PIXI.DisplayObjectContainer.prototype.updateTransform = function() {
        if (!this.visible) {
            return;
        }
        this.displayObjectUpdateTransform();
        if (this._cacheAsBitmap) {
            return;
        }
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].updateTransform();
        }
    };
    PIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform;
    PIXI.DisplayObjectContainer.prototype.getBounds = function() {
        if (this.children.length === 0) return PIXI.EmptyRectangle;
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var childBounds;
        var childMaxX;
        var childMaxY;
        var childVisible = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            childVisible = true;
            childBounds = this.children[i].getBounds();
            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;
            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;
            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }
        if (!childVisible) return PIXI.EmptyRectangle;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var matrixCache = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        var bounds = this.getBounds();
        this.worldTransform = matrixCache;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage) {
        this.stage = stage;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].setStageReference(stage);
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].removeStageReference();
        }
        this.stage = null;
    };
    PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        var i;
        if (this._mask || this._filters) {
            if (this._filters) {
                renderSession.spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                renderSession.spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                renderSession.spriteBatch.start();
            }
            for (i = 0; i < this.children.length; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            renderSession.spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            renderSession.spriteBatch.start();
        } else {
            for (i = 0; i < this.children.length; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
        }
    };
    PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession);
        }
        for (var i = 0; i < this.children.length; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession);
        }
    };
    PIXI.Sprite = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.anchor = new PIXI.Point();
        this.texture = texture || PIXI.Texture.emptyTexture;
        this._width = 0;
        this._height = 0;
        this.tint = 16777215;
        this.cachedTint = -1;
        this.tintedTexture = null;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.shader = null;
        if (this.texture.baseTexture.hasLoaded) {
            this.onTextureUpdate();
        }
        this.renderable = true;
    };
    PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Sprite.prototype.constructor = PIXI.Sprite;
    Object.defineProperty(PIXI.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Sprite.prototype.setTexture = function(texture, destroyBase) {
        if (destroyBase !== undefined) {
            this.texture.baseTexture.destroy();
        }
        this.texture = texture;
        this.texture.valid = true;
    };
    PIXI.Sprite.prototype.onTextureUpdate = function() {
        if (this._width) this.scale.x = this._width / this.texture.frame.width;
        if (this._height) this.scale.y = this._height / this.texture.frame.height;
    };
    PIXI.Sprite.prototype.getBounds = function(matrix) {
        var width = this.texture.frame.width;
        var height = this.texture.frame.height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        if (b === 0 && c === 0) {
            if (a < 0) a *= -1;
            if (d < 0) d *= -1;
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
        } else {
            var x1 = a * w1 + c * h1 + tx;
            var y1 = d * h1 + b * w1 + ty;
            var x2 = a * w0 + c * h1 + tx;
            var y2 = d * h1 + b * w0 + ty;
            var x3 = a * w0 + c * h0 + tx;
            var y3 = d * h0 + b * w0 + ty;
            var x4 = a * w1 + c * h0 + tx;
            var y4 = d * h0 + b * w1 + ty;
            minX = x1 < minX ? x1 : minX;
            minX = x2 < minX ? x2 : minX;
            minX = x3 < minX ? x3 : minX;
            minX = x4 < minX ? x4 : minX;
            minY = y1 < minY ? y1 : minY;
            minY = y2 < minY ? y2 : minY;
            minY = y3 < minY ? y3 : minY;
            minY = y4 < minY ? y4 : minY;
            maxX = x1 > maxX ? x1 : maxX;
            maxX = x2 > maxX ? x2 : maxX;
            maxX = x3 > maxX ? x3 : maxX;
            maxX = x4 > maxX ? x4 : maxX;
            maxY = y1 > maxY ? y1 : maxY;
            maxY = y2 > maxY ? y2 : maxY;
            maxY = y3 > maxY ? y3 : maxY;
            maxY = y4 > maxY ? y4 : maxY;
        }
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.Sprite.prototype._renderWebGL = function(renderSession, matrix) {
        if (!this.visible || this.alpha <= 0 || !this.renderable) return;
        var wt = this.worldTransform;
        if (matrix) {
            wt = matrix;
        }
        if (this._mask || this._filters) {
            var spriteBatch = renderSession.spriteBatch;
            if (this._filters) {
                spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                spriteBatch.start();
            }
            spriteBatch.render(this);
            for (var i = 0; i < this.children.length; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            spriteBatch.start();
        } else {
            renderSession.spriteBatch.render(this);
            for (var i = 0; i < this.children.length; i++) {
                this.children[i]._renderWebGL(renderSession, wt);
            }
        }
    };
    PIXI.Sprite.prototype._renderCanvas = function(renderSession, matrix) {
        if (this.visible === false || this.alpha === 0 || this.renderable === false || this.texture.crop.width <= 0 || this.texture.crop.height <= 0) {
            return;
        }
        var wt = this.worldTransform;
        if (matrix) {
            wt = matrix;
        }
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession);
        }
        if (this.texture.valid) {
            var resolution = this.texture.baseTexture.resolution / renderSession.resolution;
            renderSession.context.globalAlpha = this.worldAlpha;
            if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {
                renderSession.scaleMode = this.texture.baseTexture.scaleMode;
                renderSession.context[renderSession.smoothProperty] = renderSession.scaleMode === PIXI.scaleModes.LINEAR;
            }
            var dx = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
            var dy = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
            if (renderSession.roundPixels) {
                renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderSession.resolution | 0, wt.ty * renderSession.resolution | 0);
                dx |= 0;
                dy |= 0;
            } else {
                renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderSession.resolution, wt.ty * renderSession.resolution);
            }
            var cw = this.texture.crop.width;
            var ch = this.texture.crop.height;
            dx /= resolution;
            dy /= resolution;
            if (this.tint !== 16777215) {
                if (this.texture.requiresReTint || this.cachedTint !== this.tint) {
                    this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
                    this.cachedTint = this.tint;
                }
                renderSession.context.drawImage(this.tintedTexture, 0, 0, cw, ch, dx, dy, cw / resolution, ch / resolution);
            } else {
                var cx = this.texture.crop.x;
                var cy = this.texture.crop.y;
                renderSession.context.drawImage(this.texture.baseTexture.source, cx, cy, cw, ch, dx, dy, cw / resolution, ch / resolution);
            }
        }
        for (var i = 0; i < this.children.length; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession);
        }
    };
    PIXI.Sprite.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
        return new PIXI.Sprite(texture);
    };
    PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode) {
        var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
        return new PIXI.Sprite(texture);
    };
    PIXI.SpriteBatch = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.textureThing = texture;
        this.ready = false;
    };
    PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.SpriteBatch.prototype.constructor = PIXI.SpriteBatch;
    PIXI.SpriteBatch.prototype.initWebGL = function(gl) {
        this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);
        this.ready = true;
    };
    PIXI.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
    };
    PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0 || !this.children.length) return;
        if (!this.ready) {
            this.initWebGL(renderSession.gl);
        }
        if (this.fastSpriteBatch.gl !== renderSession.gl) {
            this.fastSpriteBatch.setContext(renderSession.gl);
        }
        renderSession.spriteBatch.stop();
        renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);
        this.fastSpriteBatch.begin(this, renderSession);
        this.fastSpriteBatch.render(this);
        renderSession.spriteBatch.start();
    };
    PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession) {
        if (!this.visible || this.alpha <= 0 || !this.children.length) return;
        var context = renderSession.context;
        context.globalAlpha = this.worldAlpha;
        this.displayObjectUpdateTransform();
        var transform = this.worldTransform;
        var isRotated = true;
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            var texture = child.texture;
            var frame = texture.frame;
            context.globalAlpha = this.worldAlpha * child.alpha;
            if (child.rotation % (Math.PI * 2) === 0) {
                if (isRotated) {
                    context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
                    isRotated = false;
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * (-frame.width * child.scale.x) + child.position.x + .5 | 0, child.anchor.y * (-frame.height * child.scale.y) + child.position.y + .5 | 0, frame.width * child.scale.x, frame.height * child.scale.y);
            } else {
                if (!isRotated) isRotated = true;
                child.displayObjectUpdateTransform();
                var childTransform = child.worldTransform;
                if (renderSession.roundPixels) {
                    context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
                } else {
                    context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx, childTransform.ty);
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width + .5 | 0, child.anchor.y * -frame.height + .5 | 0, frame.width, frame.height);
            }
        }
    };
    PIXI.Stage = function(backgroundColor) {
        PIXI.DisplayObjectContainer.call(this);
        this.worldTransform = new PIXI.Matrix();
        this.stage = this;
        this.setBackgroundColor(backgroundColor);
    };
    PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Stage.prototype.constructor = PIXI.Stage;
    PIXI.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].updateTransform();
        }
    };
    PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        this.backgroundColor = backgroundColor || 0;
        this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
        var hex = this.backgroundColor.toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;
        this.backgroundColorString = "#" + hex;
    };
    PIXI.hex2rgb = function(hex) {
        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255 ];
    };
    PIXI.rgb2hex = function(rgb) {
        return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
    };
    PIXI.canUseNewCanvasBlendModes = function() {
        if (document === undefined) return false;
        var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
        var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
        var magenta = new Image();
        magenta.src = pngHead + "AP804Oa6" + pngEnd;
        var yellow = new Image();
        yellow.src = pngHead + "/wCKxvRF" + pngEnd;
        var canvas = PIXI.CanvasPool.create(this, 6, 1);
        var context = canvas.getContext("2d");
        context.globalCompositeOperation = "multiply";
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);
        if (!context.getImageData(2, 0, 1, 1)) {
            return false;
        }
        var data = context.getImageData(2, 0, 1, 1).data;
        PIXI.CanvasPool.remove(this);
        return data[0] === 255 && data[1] === 0 && data[2] === 0;
    };
    PIXI.getNextPowerOfTwo = function(number) {
        if (number > 0 && (number & number - 1) === 0) return number; else {
            var result = 1;
            while (result < number) result <<= 1;
            return result;
        }
    };
    PIXI.isPowerOfTwo = function(width, height) {
        return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
    };
    PIXI.PolyK = {};
    PIXI.PolyK.Triangulate = function(p) {
        var sign = true;
        var n = p.length >> 1;
        if (n < 3) return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++) avl.push(i);
        i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi === i0 || vi === i1 || vi === i2) continue;
                    if (PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0, i1, i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            } else if (i++ > 3 * al) {
                if (sign) {
                    tgs = [];
                    avl = [];
                    for (i = 0; i < n; i++) avl.push(i);
                    i = 0;
                    al = n;
                    sign = false;
                } else {
                    return null;
                }
            }
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    };
    PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
    };
    PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 === sign;
    };
    PIXI.CanvasPool = {
        create: function(parent, width, height) {
            var idx = PIXI.CanvasPool.getFirst();
            var canvas;
            if (idx === -1) {
                var container = {
                    parent: parent,
                    canvas: document.createElement("canvas")
                };
                PIXI.CanvasPool.pool.push(container);
                canvas = container.canvas;
            } else {
                PIXI.CanvasPool.pool[idx].parent = parent;
                canvas = PIXI.CanvasPool.pool[idx].canvas;
            }
            if (width !== undefined) {
                canvas.width = width;
                canvas.height = height;
            }
            return canvas;
        },
        getFirst: function() {
            var pool = PIXI.CanvasPool.pool;
            for (var i = 0; i < pool.length; i++) {
                if (pool[i].parent === null) {
                    return i;
                }
            }
            return -1;
        },
        remove: function(parent) {
            var pool = PIXI.CanvasPool.pool;
            for (var i = 0; i < pool.length; i++) {
                if (pool[i].parent === parent) {
                    pool[i].parent = null;
                }
            }
        },
        removeByCanvas: function(canvas) {
            var pool = PIXI.CanvasPool.pool;
            for (var i = 0; i < pool.length; i++) {
                if (pool[i].canvas === canvas) {
                    pool[i].parent = null;
                }
            }
        },
        getTotal: function() {
            var pool = PIXI.CanvasPool.pool;
            var c = 0;
            for (var i = 0; i < pool.length; i++) {
                if (pool[i].parent !== null) {
                    c++;
                }
            }
            return c;
        },
        getFree: function() {
            var pool = PIXI.CanvasPool.pool;
            var c = 0;
            for (var i = 0; i < pool.length; i++) {
                if (pool[i].parent === null) {
                    c++;
                }
            }
            return c;
        }
    };
    PIXI.CanvasPool.pool = [];
    PIXI.initDefaultShaders = function() {};
    PIXI.CompileVertexShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
    };
    PIXI.CompileFragmentShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
    };
    PIXI._CompileShader = function(gl, shaderSrc, shaderType) {
        var src = shaderSrc;
        if (Array.isArray(shaderSrc)) {
            src = shaderSrc.join("\n");
        }
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            window.console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    };
    PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc) {
        var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
        var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            window.console.log("Could not initialise shaders");
        }
        return shaderProgram;
    };
    PIXI.PixiShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.textureCount = 0;
        this.firstRun = true;
        this.dirty = true;
        this.attributes = [];
        this.init();
    };
    PIXI.PixiShader.prototype.constructor = PIXI.PixiShader;
    PIXI.PixiShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
        for (var key in this.uniforms) {
            this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
        }
        this.initUniforms();
        this.program = program;
    };
    PIXI.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var gl = this.gl;
        var uniform;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            var type = uniform.type;
            if (type === "sampler2D") {
                uniform._init = false;
                if (uniform.value !== null) {
                    this.initSampler2D(uniform);
                }
            } else if (type === "mat2" || type === "mat3" || type === "mat4") {
                uniform.glMatrix = true;
                uniform.glValueLength = 1;
                if (type === "mat2") {
                    uniform.glFunc = gl.uniformMatrix2fv;
                } else if (type === "mat3") {
                    uniform.glFunc = gl.uniformMatrix3fv;
                } else if (type === "mat4") {
                    uniform.glFunc = gl.uniformMatrix4fv;
                }
            } else {
                uniform.glFunc = gl["uniform" + type];
                if (type === "2f" || type === "2i") {
                    uniform.glValueLength = 2;
                } else if (type === "3f" || type === "3i") {
                    uniform.glValueLength = 3;
                } else if (type === "4f" || type === "4i") {
                    uniform.glValueLength = 4;
                } else {
                    uniform.glValueLength = 1;
                }
            }
        }
    };
    PIXI.PixiShader.prototype.initSampler2D = function(uniform) {
        if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded) {
            return;
        }
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + this.textureCount]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);
        if (uniform.textureData) {
            var data = uniform.textureData;
            var magFilter = data.magFilter ? data.magFilter : gl.LINEAR;
            var minFilter = data.minFilter ? data.minFilter : gl.LINEAR;
            var wrapS = data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE;
            var wrapT = data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE;
            var format = data.luminance ? gl.LUMINANCE : gl.RGBA;
            if (data.repeat) {
                wrapS = gl.REPEAT;
                wrapT = gl.REPEAT;
            }
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
            if (data.width) {
                var width = data.width ? data.width : 512;
                var height = data.height ? data.height : 2;
                var border = data.border ? data.border : 0;
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
        }
        gl.uniform1i(uniform.uniformLocation, this.textureCount);
        uniform._init = true;
        this.textureCount++;
    };
    PIXI.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var uniform;
        var gl = this.gl;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            if (uniform.glValueLength === 1) {
                if (uniform.glMatrix === true) {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
                } else {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
                }
            } else if (uniform.glValueLength === 2) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
            } else if (uniform.glValueLength === 3) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
            } else if (uniform.glValueLength === 4) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
            } else if (uniform.type === "sampler2D") {
                if (uniform._init) {
                    gl.activeTexture(gl["TEXTURE" + this.textureCount]);
                    if (uniform.value.baseTexture._dirty[gl.id]) {
                        PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture);
                    } else {
                        gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);
                    }
                    gl.uniform1i(uniform.uniformLocation, this.textureCount);
                    this.textureCount++;
                } else {
                    this.initSampler2D(uniform);
                }
            }
        }
    };
    PIXI.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}" ];
    PIXI.PixiFastShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ];
        this.textureCount = 0;
        this.init();
    };
    PIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader;
    PIXI.PixiFastShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.uMatrix = gl.getUniformLocation(program, "uMatrix");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aPositionCoord = gl.getAttribLocation(program, "aPositionCoord");
        this.aScale = gl.getAttribLocation(program, "aScale");
        this.aRotation = gl.getAttribLocation(program, "aRotation");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ];
        this.program = program;
    };
    PIXI.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.StripShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ];
        this.init();
    };
    PIXI.StripShader.prototype.constructor = PIXI.StripShader;
    PIXI.StripShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.attributes = [ this.aVertexPosition, this.aTextureCoord ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.PrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ];
        this.init();
    };
    PIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader;
    PIXI.PrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.flipY = gl.getUniformLocation(program, "flipY");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.ComplexPrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ];
        this.init();
    };
    PIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader;
    PIXI.ComplexPrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.color = gl.getUniformLocation(program, "color");
        this.flipY = gl.getUniformLocation(program, "flipY");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.WebGLGraphics = function() {};
    PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader, webGLData;
        if (graphics.dirty) {
            PIXI.WebGLGraphics.updateGraphics(graphics, gl);
        }
        var webGL = graphics._webGL[gl.id];
        for (var i = 0; i < webGL.data.length; i++) {
            if (webGL.data[i].mode === 1) {
                webGLData = webGL.data[i];
                renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);
            } else {
                webGLData = webGL.data[i];
                renderSession.shaderManager.setShader(shader);
                shader = renderSession.shaderManager.primitiveShader;
                gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
                gl.uniform1f(shader.flipY, 1);
                gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
                gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
                gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
                gl.uniform1f(shader.alpha, graphics.worldAlpha);
                gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
                gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
                gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            }
        }
    };
    PIXI.WebGLGraphics.updateGraphics = function(graphics, gl) {
        var webGL = graphics._webGL[gl.id];
        if (!webGL) webGL = graphics._webGL[gl.id] = {
            lastIndex: 0,
            data: [],
            gl: gl
        };
        graphics.dirty = false;
        var i;
        if (graphics.clearDirty) {
            graphics.clearDirty = false;
            for (i = 0; i < webGL.data.length; i++) {
                var graphicsData = webGL.data[i];
                graphicsData.reset();
                PIXI.WebGLGraphics.graphicsDataPool.push(graphicsData);
            }
            webGL.data = [];
            webGL.lastIndex = 0;
        }
        var webGLData;
        for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            if (data.type === PIXI.Graphics.POLY) {
                data.points = data.shape.points.slice();
                if (data.shape.closed) {
                    if (data.points[0] !== data.points[data.points.length - 2] || data.points[1] !== data.points[data.points.length - 1]) {
                        data.points.push(data.points[0], data.points[1]);
                    }
                }
                if (data.fill) {
                    if (data.points.length >= 6) {
                        if (data.points.length < 6 * 2) {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                            var canDrawUsingSimple = PIXI.WebGLGraphics.buildPoly(data, webGLData);
                            if (!canDrawUsingSimple) {
                                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                                PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                            }
                        } else {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                            PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                        }
                    }
                }
                if (data.lineWidth > 0) {
                    webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                    PIXI.WebGLGraphics.buildLine(data, webGLData);
                }
            } else {
                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                if (data.type === PIXI.Graphics.RECT) {
                    PIXI.WebGLGraphics.buildRectangle(data, webGLData);
                } else if (data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP) {
                    PIXI.WebGLGraphics.buildCircle(data, webGLData);
                } else if (data.type === PIXI.Graphics.RREC) {
                    PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
                }
            }
            webGL.lastIndex++;
        }
        for (i = 0; i < webGL.data.length; i++) {
            webGLData = webGL.data[i];
            if (webGLData.dirty) webGLData.upload();
        }
    };
    PIXI.WebGLGraphics.switchMode = function(webGL, type) {
        var webGLData;
        if (!webGL.data.length) {
            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        } else {
            webGLData = webGL.data[webGL.data.length - 1];
            if (webGLData.mode !== type || type === 1) {
                webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
                webGLData.mode = type;
                webGL.data.push(webGLData);
            }
        }
        webGLData.dirty = true;
        return webGLData;
    };
    PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) {
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vertPos = verts.length / 6;
            verts.push(x, y);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y);
            verts.push(r, g, b, alpha);
            verts.push(x, y + height);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);
            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [ x, y, x + width, y, x + width, y + height, x, y + height, x, y ];
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData) {
        var rrectData = graphicsData.shape;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        var recPoints = [];
        recPoints.push(x, y + radius);
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            var triangles = PIXI.PolyK.Triangulate(recPoints);
            var i = 0;
            for (i = 0; i < triangles.length; i += 3) {
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i + 1] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
            }
            for (i = 0; i < recPoints.length; i++) {
                verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
            }
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = recPoints;
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
        var xa, ya, xb, yb, x, y, n = 20, points = [];
        function getPt(n1, n2, perc) {
            var diff = n2 - n1;
            return n1 + diff * perc;
        }
        var j = 0;
        for (var i = 0; i <= n; i++) {
            j = i / n;
            xa = getPt(fromX, cpX, j);
            ya = getPt(fromY, cpY, j);
            xb = getPt(cpX, toX, j);
            yb = getPt(cpY, toY, j);
            x = getPt(xa, xb, j);
            y = getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    };
    PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) {
        var circleData = graphicsData.shape;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        if (graphicsData.type === PIXI.Graphics.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        } else {
            width = circleData.width;
            height = circleData.height;
        }
        var totalSegs = 40;
        var seg = Math.PI * 2 / totalSegs;
        var i = 0;
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            indices.push(vecPos);
            for (i = 0; i < totalSegs + 1; i++) {
                verts.push(x, y, r, g, b, alpha);
                verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
                indices.push(vecPos++, vecPos++);
            }
            indices.push(vecPos - 1);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [];
            for (i = 0; i < totalSegs + 1; i++) {
                graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
            }
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) {
        var i = 0;
        var points = graphicsData.points;
        if (points.length === 0) return;
        if (graphicsData.lineWidth % 2) {
            for (i = 0; i < points.length; i++) {
                points[i] += .5;
            }
        }
        var firstPoint = new PIXI.Point(points[0], points[1]);
        var lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
            points = points.slice();
            points.pop();
            points.pop();
            lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
            var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * .5;
            var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * .5;
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
        var width = graphicsData.lineWidth / 2;
        var color = PIXI.hex2rgb(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
        var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
        var a1, b1, c1, a2, b2, c2;
        var denom, pdist, dist;
        p1x = points[0];
        p1y = points[1];
        p2x = points[2];
        p2y = points[3];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
        for (i = 1; i < length - 1; i++) {
            p1x = points[(i - 1) * 2];
            p1y = points[(i - 1) * 2 + 1];
            p2x = points[i * 2];
            p2y = points[i * 2 + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[(i + 1) * 2 + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            a1 = -perpy + p1y - (-perpy + p2y);
            b1 = -perpx + p2x - (-perpx + p1x);
            c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
            a2 = -perp2y + p3y - (-perp2y + p2y);
            b2 = -perp2x + p2x - (-perp2x + p3x);
            c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
            denom = a1 * b2 - a2 * b1;
            if (Math.abs(denom) < .1) {
                denom += 10.1;
                verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
                verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);
                continue;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
            if (pdist > 140 * 140) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x + perp3x, p2y + perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                indexCount++;
            } else {
                verts.push(px, py);
                verts.push(r, g, b, alpha);
                verts.push(p2x - (px - p2x), p2y - (py - p2y));
                verts.push(r, g, b, alpha);
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
        indices.push(indexStart);
        for (i = 0; i < indexCount; i++) {
            indices.push(indexStart++);
        }
        indices.push(indexStart - 1);
    };
    PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points.slice();
        if (points.length < 6) return;
        var indices = webGLData.indices;
        webGLData.points = points;
        webGLData.alpha = graphicsData.fillAlpha;
        webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var x, y;
        for (var i = 0; i < points.length; i += 2) {
            x = points[i];
            y = points[i + 1];
            minX = x < minX ? x : minX;
            maxX = x > maxX ? x : maxX;
            minY = y < minY ? y : minY;
            maxY = y > maxY ? y : maxY;
        }
        points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY);
        var length = points.length / 2;
        for (i = 0; i < length; i++) {
            indices.push(i);
        }
    };
    PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        if (points.length < 6) return;
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var triangles = PIXI.PolyK.Triangulate(points);
        if (!triangles) return false;
        var vertPos = verts.length / 6;
        var i = 0;
        for (i = 0; i < triangles.length; i += 3) {
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i + 1] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
        }
        for (i = 0; i < length; i++) {
            verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha);
        }
        return true;
    };
    PIXI.WebGLGraphics.graphicsDataPool = [];
    PIXI.WebGLGraphicsData = function(gl) {
        this.gl = gl;
        this.color = [ 0, 0, 0 ];
        this.points = [];
        this.indices = [];
        this.buffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.mode = 1;
        this.alpha = 1;
        this.dirty = true;
    };
    PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [];
        this.indices = [];
    };
    PIXI.WebGLGraphicsData.prototype.upload = function() {
        var gl = this.gl;
        this.glPoints = new PIXI.Float32Array(this.points);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);
        this.glIndicies = new PIXI.Uint16Array(this.indices);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);
        this.dirty = false;
    };
    PIXI.glContexts = [];
    PIXI.instances = [];
    PIXI.WebGLRenderer = function(width, height, options) {
        if (options) {
            for (var i in PIXI.defaultRenderOptions) {
                if (options[i] === undefined) options[i] = PIXI.defaultRenderOptions[i];
            }
        } else {
            options = PIXI.defaultRenderOptions;
        }
        if (!PIXI.defaultRenderer) {
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.WEBGL_RENDERER;
        this.resolution = options.resolution;
        this.transparent = options.transparent;
        this.autoResize = options.autoResize || false;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this.width = width || 800;
        this.height = height || 600;
        this.view = options.view || document.createElement("canvas");
        this._contextOptions = {
            alpha: this.transparent,
            antialias: options.antialias,
            premultipliedAlpha: this.transparent && this.transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer
        };
        this.projection = new PIXI.Point();
        this.offset = new PIXI.Point(0, 0);
        this.shaderManager = new PIXI.WebGLShaderManager();
        this.spriteBatch = new PIXI.WebGLSpriteBatch();
        this.maskManager = new PIXI.WebGLMaskManager();
        this.filterManager = new PIXI.WebGLFilterManager();
        this.stencilManager = new PIXI.WebGLStencilManager();
        this.blendModeManager = new PIXI.WebGLBlendModeManager();
        this.renderSession = {};
        this.renderSession.gl = this.gl;
        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.blendModeManager = this.blendModeManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.stencilManager = this.stencilManager;
        this.renderSession.renderer = this;
        this.renderSession.resolution = this.resolution;
        this.initContext();
        this.mapBlendModes();
    };
    PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;
    PIXI.WebGLRenderer.prototype.initContext = function() {
        var gl = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        this.gl = gl;
        if (!gl) {
            throw new Error("This browser does not support webGL. Try using the canvas renderer");
        }
        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;
        PIXI.glContexts[this.glContextId] = gl;
        PIXI.instances[this.glContextId] = this;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        this.shaderManager.setContext(gl);
        this.spriteBatch.setContext(gl);
        this.maskManager.setContext(gl);
        this.filterManager.setContext(gl);
        this.blendModeManager.setContext(gl);
        this.stencilManager.setContext(gl);
        this.renderSession.gl = this.gl;
        this.resize(this.width, this.height);
    };
    PIXI.WebGLRenderer.prototype.render = function(stage) {
        if (this.contextLost) return;
        if (this.__stage !== stage) {
            this.__stage = stage;
        }
        stage.updateTransform();
        var gl = this.gl;
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (this.clearBeforeRender) {
            if (this.transparent) {
                gl.clearColor(0, 0, 0, 0);
            } else {
                gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        this.renderDisplayObject(stage, this.projection);
    };
    PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer, matrix) {
        this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);
        this.renderSession.drawCount = 0;
        this.renderSession.flipY = buffer ? -1 : 1;
        this.renderSession.projection = projection;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, buffer);
        displayObject._renderWebGL(this.renderSession, matrix);
        this.spriteBatch.end();
    };
    PIXI.WebGLRenderer.prototype.resize = function(width, height) {
        this.width = width * this.resolution;
        this.height = height * this.resolution;
        this.view.width = this.width;
        this.view.height = this.height;
        if (this.autoResize) {
            this.view.style.width = this.width / this.resolution + "px";
            this.view.style.height = this.height / this.resolution + "px";
        }
        this.gl.viewport(0, 0, this.width, this.height);
        this.projection.x = this.width / 2 / this.resolution;
        this.projection.y = -this.height / 2 / this.resolution;
    };
    PIXI.WebGLRenderer.prototype.updateTexture = function(texture) {
        if (!texture.hasLoaded) {
            return;
        }
        var gl = this.gl;
        if (!texture._glTextures[gl.id]) {
            texture._glTextures[gl.id] = gl.createTexture();
        }
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        if (texture.mipmap && PIXI.isPowerOfTwo(texture.width, texture.height)) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
        } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        if (!texture._powerOf2) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }
        texture._dirty[gl.id] = false;
        return texture._glTextures[gl.id];
    };
    PIXI.WebGLRenderer.prototype.destroy = function() {
        PIXI.glContexts[this.glContextId] = null;
        this.projection = null;
        this.offset = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();
        this.shaderManager = null;
        this.spriteBatch = null;
        this.maskManager = null;
        this.filterManager = null;
        this.gl = null;
        this.renderSession = null;
        PIXI.CanvasPool.remove(this);
        PIXI.instances[this.glContextId] = null;
        PIXI.WebGLRenderer.glContextId--;
    };
    PIXI.WebGLRenderer.prototype.mapBlendModes = function() {
        var gl = this.gl;
        if (!PIXI.blendModesWebGL) {
            PIXI.blendModesWebGL = [];
            PIXI.blendModesWebGL[PIXI.blendModes.NORMAL] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.ADD] = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY] = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SCREEN] = [ gl.SRC_ALPHA, gl.ONE ];
            PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DARKEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HUE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SATURATION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        }
    };
    PIXI.WebGLRenderer.glContextId = 0;
    PIXI.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999;
    };
    PIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager;
    PIXI.WebGLBlendModeManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode) {
        if (this.currentBlendMode === blendMode) return false;
        this.currentBlendMode = blendMode;
        var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        return true;
    };
    PIXI.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLMaskManager = function() {};
    PIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager;
    PIXI.WebGLMaskManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession) {
        var gl = renderSession.gl;
        if (maskData.dirty) {
            PIXI.WebGLGraphics.updateGraphics(maskData, gl);
        }
        if (!maskData._webGL[gl.id].data.length) return;
        renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession) {
        var gl = this.gl;
        renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLStencilManager = function() {
        this.stencilStack = [];
        this.reverse = true;
        this.count = 0;
    };
    PIXI.WebGLStencilManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.bindGraphics(graphics, webGLData, renderSession);
        if (this.stencilStack.length === 0) {
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            this.reverse = true;
            this.count = 0;
        }
        this.stencilStack.push(webGLData);
        var level = this.count;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.ALWAYS, 0, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
        if (webGLData.mode === 1) {
            gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
            this.reverse = !this.reverse;
        } else {
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
        }
        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        this.count++;
    };
    PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession) {
        this._currentGraphics = graphics;
        var gl = this.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader;
        if (webGLData.mode === 1) {
            shader = renderSession.shaderManager.complexPrimitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniform1f(shader.flipY, renderSession.flipY);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform3fv(shader.color, webGLData.color);
            gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        } else {
            shader = renderSession.shaderManager.primitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform1f(shader.flipY, renderSession.flipY);
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform1f(shader.alpha, graphics.worldAlpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        }
    };
    PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.stencilStack.pop();
        this.count--;
        if (this.stencilStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            var level = this.count;
            this.bindGraphics(graphics, webGLData, renderSession);
            gl.colorMask(false, false, false, false);
            if (webGLData.mode === 1) {
                this.reverse = !this.reverse;
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                gl.stencilFunc(gl.ALWAYS, 0, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
                gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            } else {
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            }
            gl.colorMask(true, true, true, true);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
    };
    PIXI.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null;
        this.gl = null;
    };
    PIXI.WebGLShaderManager = function() {
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var i = 0; i < this.maxAttibs; i++) {
            this.attribState[i] = false;
        }
        this.stack = [];
    };
    PIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager;
    PIXI.WebGLShaderManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.primitiveShader = new PIXI.PrimitiveShader(gl);
        this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);
        this.defaultShader = new PIXI.PixiShader(gl);
        this.fastShader = new PIXI.PixiFastShader(gl);
        this.stripShader = new PIXI.StripShader(gl);
        this.setShader(this.defaultShader);
    };
    PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs) {
        var i;
        for (i = 0; i < this.tempAttribState.length; i++) {
            this.tempAttribState[i] = false;
        }
        for (i = 0; i < attribs.length; i++) {
            var attribId = attribs[i];
            this.tempAttribState[attribId] = true;
        }
        var gl = this.gl;
        for (i = 0; i < this.attribState.length; i++) {
            if (this.attribState[i] !== this.tempAttribState[i]) {
                this.attribState[i] = this.tempAttribState[i];
                if (this.tempAttribState[i]) {
                    gl.enableVertexAttribArray(i);
                } else {
                    gl.disableVertexAttribArray(i);
                }
            }
        }
    };
    PIXI.WebGLShaderManager.prototype.setShader = function(shader) {
        if (this._currentId === shader._UID) return false;
        this._currentId = shader._UID;
        this.currentShader = shader;
        this.gl.useProgram(shader.program);
        this.setAttribs(shader.attributes);
        return true;
    };
    PIXI.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null;
        this.tempAttribState = null;
        this.primitiveShader.destroy();
        this.complexPrimitiveShader.destroy();
        this.defaultShader.destroy();
        this.fastShader.destroy();
        this.stripShader.destroy();
        this.gl = null;
    };
    PIXI.WebGLSpriteBatch = function() {
        this.vertSize = 5;
        this.size = 2e3;
        var numVerts = this.size * 4 * 4 * this.vertSize;
        var numIndices = this.size * 6;
        this.vertices = new PIXI.ArrayBuffer(numVerts);
        this.positions = new PIXI.Float32Array(this.vertices);
        this.colors = new PIXI.Uint32Array(this.vertices);
        this.indices = new PIXI.Uint16Array(numIndices);
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.dirty = true;
        this.textures = [];
        this.blendModes = [];
        this.shaders = [];
        this.sprites = [];
        this.defaultShader = new PIXI.AbstractFilter([ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ]);
    };
    PIXI.WebGLSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
        this.currentBlendMode = 99999;
        var shader = new PIXI.PixiShader(gl);
        shader.fragmentSrc = this.defaultShader.fragmentSrc;
        shader.uniforms = {};
        shader.init();
        this.defaultShader.shaders[gl.id] = shader;
    };
    PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.defaultShader;
        this.start();
    };
    PIXI.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLSpriteBatch.prototype.render = function(sprite, matrix) {
        var texture = sprite.texture;
        var wt = sprite.worldTransform;
        if (matrix) {
            wt = matrix;
        }
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        var uvs = texture._uvs;
        if (!uvs) {
            return;
        }
        var aX = sprite.anchor.x;
        var aY = sprite.anchor.y;
        var w0, w1, h0, h1;
        if (texture.trim) {
            var trim = texture.trim;
            w1 = trim.x - aX * trim.width;
            w0 = w1 + texture.crop.width;
            h1 = trim.y - aY * trim.height;
            h0 = h1 + texture.crop.height;
        } else {
            w0 = texture.frame.width * (1 - aX);
            w1 = texture.frame.width * -aX;
            h0 = texture.frame.height * (1 - aY);
            h1 = texture.frame.height * -aY;
        }
        var i = this.currentBatchSize * 4 * this.vertSize;
        var resolution = texture.baseTexture.resolution;
        var a = wt.a / resolution;
        var b = wt.b / resolution;
        var c = wt.c / resolution;
        var d = wt.d / resolution;
        var tx = wt.tx;
        var ty = wt.ty;
        var colors = this.colors;
        var positions = this.positions;
        if (this.renderSession.roundPixels) {
            positions[i] = a * w1 + c * h1 + tx | 0;
            positions[i + 1] = d * h1 + b * w1 + ty | 0;
            positions[i + 5] = a * w0 + c * h1 + tx | 0;
            positions[i + 6] = d * h1 + b * w0 + ty | 0;
            positions[i + 10] = a * w0 + c * h0 + tx | 0;
            positions[i + 11] = d * h0 + b * w0 + ty | 0;
            positions[i + 15] = a * w1 + c * h0 + tx | 0;
            positions[i + 16] = d * h0 + b * w1 + ty | 0;
        } else {
            positions[i] = a * w1 + c * h1 + tx;
            positions[i + 1] = d * h1 + b * w1 + ty;
            positions[i + 5] = a * w0 + c * h1 + tx;
            positions[i + 6] = d * h1 + b * w0 + ty;
            positions[i + 10] = a * w0 + c * h0 + tx;
            positions[i + 11] = d * h0 + b * w0 + ty;
            positions[i + 15] = a * w1 + c * h0 + tx;
            positions[i + 16] = d * h0 + b * w1 + ty;
        }
        positions[i + 2] = uvs.x0;
        positions[i + 3] = uvs.y0;
        positions[i + 7] = uvs.x1;
        positions[i + 8] = uvs.y1;
        positions[i + 12] = uvs.x2;
        positions[i + 13] = uvs.y2;
        positions[i + 17] = uvs.x3;
        positions[i + 18] = uvs.y3;
        var tint = sprite.tint;
        colors[i + 4] = colors[i + 9] = colors[i + 14] = colors[i + 19] = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16) + (sprite.worldAlpha * 255 << 24);
        this.sprites[this.currentBatchSize++] = sprite;
    };
    PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(sprite) {
        var texture = sprite.tilingTexture;
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        if (!sprite._uvs) {
            sprite._uvs = new PIXI.TextureUvs();
        }
        var uvs = sprite._uvs;
        var w = texture.baseTexture.width;
        var h = texture.baseTexture.height;
        sprite.tilePosition.x %= w * sprite.tileScaleOffset.x;
        sprite.tilePosition.y %= h * sprite.tileScaleOffset.y;
        var offsetX = sprite.tilePosition.x / (w * sprite.tileScaleOffset.x);
        var offsetY = sprite.tilePosition.y / (h * sprite.tileScaleOffset.y);
        var scaleX = sprite.width / w / (sprite.tileScale.x * sprite.tileScaleOffset.x);
        var scaleY = sprite.height / h / (sprite.tileScale.y * sprite.tileScaleOffset.y);
        uvs.x0 = 0 - offsetX;
        uvs.y0 = 0 - offsetY;
        uvs.x1 = 1 * scaleX - offsetX;
        uvs.y1 = 0 - offsetY;
        uvs.x2 = 1 * scaleX - offsetX;
        uvs.y2 = 1 * scaleY - offsetY;
        uvs.x3 = 0 - offsetX;
        uvs.y3 = 1 * scaleY - offsetY;
        var tint = sprite.tint;
        var color = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16) + (sprite.worldAlpha * 255 << 24);
        var positions = this.positions;
        var colors = this.colors;
        var width = sprite.width;
        var height = sprite.height;
        var aX = sprite.anchor.x;
        var aY = sprite.anchor.y;
        var w0 = width * (1 - aX);
        var w1 = width * -aX;
        var h0 = height * (1 - aY);
        var h1 = height * -aY;
        var i = this.currentBatchSize * 4 * this.vertSize;
        var resolution = texture.baseTexture.resolution;
        var wt = sprite.worldTransform;
        var a = wt.a / resolution;
        var b = wt.b / resolution;
        var c = wt.c / resolution;
        var d = wt.d / resolution;
        var tx = wt.tx;
        var ty = wt.ty;
        positions[i++] = a * w1 + c * h1 + tx;
        positions[i++] = d * h1 + b * w1 + ty;
        positions[i++] = uvs.x0;
        positions[i++] = uvs.y0;
        colors[i++] = color;
        positions[i++] = a * w0 + c * h1 + tx;
        positions[i++] = d * h1 + b * w0 + ty;
        positions[i++] = uvs.x1;
        positions[i++] = uvs.y1;
        colors[i++] = color;
        positions[i++] = a * w0 + c * h0 + tx;
        positions[i++] = d * h0 + b * w0 + ty;
        positions[i++] = uvs.x2;
        positions[i++] = uvs.y2;
        colors[i++] = color;
        positions[i++] = a * w1 + c * h0 + tx;
        positions[i++] = d * h0 + b * w1 + ty;
        positions[i++] = uvs.x3;
        positions[i++] = uvs.y3;
        colors[i++] = color;
        this.sprites[this.currentBatchSize++] = sprite;
    };
    PIXI.WebGLSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) {
            return;
        }
        var gl = this.gl;
        var shader;
        if (this.dirty) {
            this.dirty = false;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            shader = this.defaultShader.shaders[gl.id];
            var stride = this.vertSize * 4;
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
        }
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.positions.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        var nextTexture, nextBlendMode, nextShader;
        var batchSize = 0;
        var start = 0;
        var currentBaseTexture = null;
        var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;
        var currentShader = null;
        var blendSwap = false;
        var shaderSwap = false;
        var sprite;
        for (var i = 0, j = this.currentBatchSize; i < j; i++) {
            sprite = this.sprites[i];
            if (sprite.tilingTexture) {
                nextTexture = sprite.tilingTexture.baseTexture;
            } else {
                nextTexture = sprite.texture.baseTexture;
            }
            nextBlendMode = sprite.blendMode;
            nextShader = sprite.shader || this.defaultShader;
            blendSwap = currentBlendMode !== nextBlendMode;
            shaderSwap = currentShader !== nextShader;
            if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap) {
                this.renderBatch(currentBaseTexture, batchSize, start);
                start = i;
                batchSize = 0;
                currentBaseTexture = nextTexture;
                if (blendSwap) {
                    currentBlendMode = nextBlendMode;
                    this.renderSession.blendModeManager.setBlendMode(currentBlendMode);
                }
                if (shaderSwap) {
                    currentShader = nextShader;
                    shader = currentShader.shaders[gl.id];
                    if (!shader) {
                        shader = new PIXI.PixiShader(gl);
                        shader.fragmentSrc = currentShader.fragmentSrc;
                        shader.uniforms = currentShader.uniforms;
                        shader.init();
                        currentShader.shaders[gl.id] = shader;
                    }
                    this.renderSession.shaderManager.setShader(shader);
                    if (shader.dirty) {
                        shader.syncUniforms();
                    }
                    var projection = this.renderSession.projection;
                    gl.uniform2f(shader.projectionVector, projection.x, projection.y);
                    var offsetVector = this.renderSession.offset;
                    gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);
                }
            }
            batchSize++;
        }
        this.renderBatch(currentBaseTexture, batchSize, start);
        this.currentBatchSize = 0;
    };
    PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex) {
        if (size === 0) {
            return;
        }
        var gl = this.gl;
        if (texture._dirty[gl.id]) {
            this.renderSession.renderer.updateTexture(texture);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }
        gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLSpriteBatch.prototype.stop = function() {
        this.flush();
        this.dirty = true;
    };
    PIXI.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = true;
    };
    PIXI.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null;
        this.indices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.currentBaseTexture = null;
        this.gl = null;
    };
    PIXI.WebGLFastSpriteBatch = function(gl) {
        this.vertSize = 10;
        this.maxSize = 6e3;
        this.size = this.maxSize;
        var numVerts = this.size * 4 * this.vertSize;
        var numIndices = this.maxSize * 6;
        this.vertices = new PIXI.Float32Array(numVerts);
        this.indices = new PIXI.Uint16Array(numIndices);
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.currentBlendMode = 0;
        this.renderSession = null;
        this.shader = null;
        this.matrix = null;
        this.setContext(gl);
    };
    PIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch;
    PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
    };
    PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = spriteBatch.worldTransform.toArray(true);
        this.start();
    };
    PIXI.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch) {
        var children = spriteBatch.children;
        var sprite = children[0];
        if (!sprite.texture._uvs) return;
        this.currentBaseTexture = sprite.texture.baseTexture;
        if (sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode) {
            this.flush();
            this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
        }
        for (var i = 0, j = children.length; i < j; i++) {
            this.renderSprite(children[i]);
        }
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite) {
        if (!sprite.visible) return;
        if (sprite.texture.baseTexture !== this.currentBaseTexture) {
            this.flush();
            this.currentBaseTexture = sprite.texture.baseTexture;
            if (!sprite.texture._uvs) return;
        }
        var uvs, vertices = this.vertices, width, height, w0, w1, h0, h1, index;
        uvs = sprite.texture._uvs;
        width = sprite.texture.frame.width;
        height = sprite.texture.frame.height;
        if (sprite.texture.trim) {
            var trim = sprite.texture.trim;
            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + sprite.texture.crop.width;
            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + sprite.texture.crop.height;
        } else {
            w0 = sprite.texture.frame.width * (1 - sprite.anchor.x);
            w1 = sprite.texture.frame.width * -sprite.anchor.x;
            h0 = sprite.texture.frame.height * (1 - sprite.anchor.y);
            h1 = sprite.texture.frame.height * -sprite.anchor.y;
        }
        index = this.currentBatchSize * 4 * this.vertSize;
        vertices[index++] = w1;
        vertices[index++] = h1;
        vertices[index++] = sprite.position.x;
        vertices[index++] = sprite.position.y;
        vertices[index++] = sprite.scale.x;
        vertices[index++] = sprite.scale.y;
        vertices[index++] = sprite.rotation;
        vertices[index++] = uvs.x0;
        vertices[index++] = uvs.y1;
        vertices[index++] = sprite.alpha;
        vertices[index++] = w0;
        vertices[index++] = h1;
        vertices[index++] = sprite.position.x;
        vertices[index++] = sprite.position.y;
        vertices[index++] = sprite.scale.x;
        vertices[index++] = sprite.scale.y;
        vertices[index++] = sprite.rotation;
        vertices[index++] = uvs.x1;
        vertices[index++] = uvs.y1;
        vertices[index++] = sprite.alpha;
        vertices[index++] = w0;
        vertices[index++] = h0;
        vertices[index++] = sprite.position.x;
        vertices[index++] = sprite.position.y;
        vertices[index++] = sprite.scale.x;
        vertices[index++] = sprite.scale.y;
        vertices[index++] = sprite.rotation;
        vertices[index++] = uvs.x2;
        vertices[index++] = uvs.y2;
        vertices[index++] = sprite.alpha;
        vertices[index++] = w1;
        vertices[index++] = h0;
        vertices[index++] = sprite.position.x;
        vertices[index++] = sprite.position.y;
        vertices[index++] = sprite.scale.x;
        vertices[index++] = sprite.scale.y;
        vertices[index++] = sprite.rotation;
        vertices[index++] = uvs.x3;
        vertices[index++] = uvs.y3;
        vertices[index++] = sprite.alpha;
        this.currentBatchSize++;
        if (this.currentBatchSize >= this.size) {
            this.flush();
        }
    };
    PIXI.WebGLFastSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var gl = this.gl;
        if (!this.currentBaseTexture._glTextures[gl.id]) this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl);
        gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.start = function() {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var projection = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);
        gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);
        var stride = this.vertSize * 4;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
        gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
        gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);
    };
    PIXI.WebGLFilterManager = function() {
        this.filterStack = [];
        this.offsetX = 0;
        this.offsetY = 0;
    };
    PIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager;
    PIXI.WebGLFilterManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.texturePool = [];
        this.initShaderBuffers();
    };
    PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer) {
        this.renderSession = renderSession;
        this.defaultShader = renderSession.shaderManager.defaultShader;
        var projection = this.renderSession.projection;
        this.width = projection.x * 2;
        this.height = -projection.y * 2;
        this.buffer = buffer;
    };
    PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock) {
        var gl = this.gl;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();
        this.filterStack.push(filterBlock);
        var filter = filterBlock.filterPasses[0];
        this.offsetX += filterBlock._filterArea.x;
        this.offsetY += filterBlock._filterArea.y;
        var texture = this.texturePool.pop();
        if (!texture) {
            texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        } else {
            texture.resize(this.width, this.height);
        }
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        var filterArea = filterBlock._filterArea;
        var padding = filter.padding;
        filterArea.x -= padding;
        filterArea.y -= padding;
        filterArea.width += padding * 2;
        filterArea.height += padding * 2;
        if (filterArea.x < 0) filterArea.x = 0;
        if (filterArea.width > this.width) filterArea.width = this.width;
        if (filterArea.y < 0) filterArea.y = 0;
        if (filterArea.height > this.height) filterArea.height = this.height;
        gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);
        gl.viewport(0, 0, filterArea.width, filterArea.height);
        projection.x = filterArea.width / 2;
        projection.y = -filterArea.height / 2;
        offset.x = -filterArea.x;
        offset.y = -filterArea.y;
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        filterBlock._glFilterTexture = texture;
    };
    PIXI.WebGLFilterManager.prototype.popFilter = function() {
        var gl = this.gl;
        var filterBlock = this.filterStack.pop();
        var filterArea = filterBlock._filterArea;
        var texture = filterBlock._glFilterTexture;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        if (filterBlock.filterPasses.length > 1) {
            gl.viewport(0, 0, filterArea.width, filterArea.height);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            this.vertexArray[0] = 0;
            this.vertexArray[1] = filterArea.height;
            this.vertexArray[2] = filterArea.width;
            this.vertexArray[3] = filterArea.height;
            this.vertexArray[4] = 0;
            this.vertexArray[5] = 0;
            this.vertexArray[6] = filterArea.width;
            this.vertexArray[7] = 0;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            this.uvArray[2] = filterArea.width / this.width;
            this.uvArray[5] = filterArea.height / this.height;
            this.uvArray[6] = filterArea.width / this.width;
            this.uvArray[7] = filterArea.height / this.height;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
            var inputTexture = texture;
            var outputTexture = this.texturePool.pop();
            if (!outputTexture) outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
            outputTexture.resize(this.width, this.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.BLEND);
            for (var i = 0; i < filterBlock.filterPasses.length - 1; i++) {
                var filterPass = filterBlock.filterPasses[i];
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);
                this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);
                var temp = inputTexture;
                inputTexture = outputTexture;
                outputTexture = temp;
            }
            gl.enable(gl.BLEND);
            texture = inputTexture;
            this.texturePool.push(outputTexture);
        }
        var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1];
        this.offsetX -= filterArea.x;
        this.offsetY -= filterArea.y;
        var sizeX = this.width;
        var sizeY = this.height;
        var offsetX = 0;
        var offsetY = 0;
        var buffer = this.buffer;
        if (this.filterStack.length === 0) {
            gl.colorMask(true, true, true, true);
        } else {
            var currentFilter = this.filterStack[this.filterStack.length - 1];
            filterArea = currentFilter._filterArea;
            sizeX = filterArea.width;
            sizeY = filterArea.height;
            offsetX = filterArea.x;
            offsetY = filterArea.y;
            buffer = currentFilter._glFilterTexture.frameBuffer;
        }
        projection.x = sizeX / 2;
        projection.y = -sizeY / 2;
        offset.x = offsetX;
        offset.y = offsetY;
        filterArea = filterBlock._filterArea;
        var x = filterArea.x - offsetX;
        var y = filterArea.y - offsetY;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = x;
        this.vertexArray[1] = y + filterArea.height;
        this.vertexArray[2] = x + filterArea.width;
        this.vertexArray[3] = y + filterArea.height;
        this.vertexArray[4] = x;
        this.vertexArray[5] = y;
        this.vertexArray[6] = x + filterArea.width;
        this.vertexArray[7] = y;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = filterArea.width / this.width;
        this.uvArray[5] = filterArea.height / this.height;
        this.uvArray[6] = filterArea.width / this.width;
        this.uvArray[7] = filterArea.height / this.height;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
        gl.viewport(0, 0, sizeX * this.renderSession.resolution, sizeY * this.renderSession.resolution);
        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        this.applyFilterPass(filter, filterArea, sizeX, sizeY);
        this.texturePool.push(texture);
        filterBlock._glFilterTexture = null;
    };
    PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height) {
        var gl = this.gl;
        var shader = filter.shaders[gl.id];
        if (!shader) {
            shader = new PIXI.PixiShader(gl);
            shader.fragmentSrc = filter.fragmentSrc;
            shader.uniforms = filter.uniforms;
            shader.init();
            filter.shaders[gl.id] = shader;
        }
        this.renderSession.shaderManager.setShader(shader);
        gl.uniform2f(shader.projectionVector, width / 2, -height / 2);
        gl.uniform2f(shader.offsetVector, 0, 0);
        if (filter.uniforms.dimensions) {
            filter.uniforms.dimensions.value[0] = this.width;
            filter.uniforms.dimensions.value[1] = this.height;
            filter.uniforms.dimensions.value[2] = this.vertexArray[0];
            filter.uniforms.dimensions.value[3] = this.vertexArray[5];
        }
        shader.syncUniforms();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var gl = this.gl;
        this.vertexBuffer = gl.createBuffer();
        this.uvBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.vertexArray = new PIXI.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);
        this.uvArray = new PIXI.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);
        this.colorArray = new PIXI.Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), gl.STATIC_DRAW);
    };
    PIXI.WebGLFilterManager.prototype.destroy = function() {
        var gl = this.gl;
        this.filterStack = null;
        this.offsetX = 0;
        this.offsetY = 0;
        for (var i = 0; i < this.texturePool.length; i++) {
            this.texturePool[i].destroy();
        }
        this.texturePool = null;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.uvBuffer);
        gl.deleteBuffer(this.colorBuffer);
        gl.deleteBuffer(this.indexBuffer);
    };
    PIXI.FilterTexture = function(gl, width, height, scaleMode) {
        this.gl = gl;
        this.frameBuffer = gl.createFramebuffer();
        this.texture = gl.createTexture();
        scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        this.renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
        this.resize(width, height);
    };
    PIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture;
    PIXI.FilterTexture.prototype.clear = function() {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };
    PIXI.FilterTexture.prototype.resize = function(width, height) {
        if (this.width === width && this.height === height) return;
        this.width = width;
        this.height = height;
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    };
    PIXI.FilterTexture.prototype.destroy = function() {
        var gl = this.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        gl.deleteTexture(this.texture);
        this.frameBuffer = null;
        this.texture = null;
    };
    PIXI.CanvasBuffer = function(width, height) {
        this.width = width;
        this.height = height;
        this.canvas = PIXI.CanvasPool.create(this, this.width, this.height);
        this.context = this.canvas.getContext("2d");
        this.canvas.width = width;
        this.canvas.height = height;
    };
    PIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer;
    PIXI.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
    };
    PIXI.CanvasBuffer.prototype.resize = function(width, height) {
        this.width = this.canvas.width = width;
        this.height = this.canvas.height = height;
    };
    PIXI.CanvasBuffer.prototype.destroy = function() {
        PIXI.CanvasPool.remove(this);
    };
    PIXI.CanvasMaskManager = function() {};
    PIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager;
    PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession) {
        var context = renderSession.context;
        context.save();
        var cacheAlpha = maskData.alpha;
        var transform = maskData.worldTransform;
        var resolution = renderSession.resolution;
        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
        PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);
        context.clip();
        maskData.worldAlpha = cacheAlpha;
    };
    PIXI.CanvasMaskManager.prototype.popMask = function(renderSession) {
        renderSession.context.restore();
    };
    PIXI.CanvasTinter = function() {};
    PIXI.CanvasTinter.getTintedTexture = function(sprite, color) {
        var canvas = sprite.tintedTexture || PIXI.CanvasPool.create(this);
        PIXI.CanvasTinter.tintMethod(sprite.texture, color, canvas);
        return canvas;
    };
    PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var crop = texture.crop;
        if (canvas.width !== crop.width || canvas.height !== crop.height) {
            canvas.width = crop.width;
            canvas.height = crop.height;
        }
        context.clearRect(0, 0, crop.width, crop.height);
        context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, crop.width, crop.height);
        context.globalCompositeOperation = "multiply";
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    };
    PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var crop = texture.crop;
        canvas.width = crop.width;
        canvas.height = crop.height;
        context.globalCompositeOperation = "copy";
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        var rgbValues = PIXI.hex2rgb(color);
        var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];
        var pixelData = context.getImageData(0, 0, crop.width, crop.height);
        var pixels = pixelData.data;
        for (var i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
            if (!PIXI.CanvasTinter.canHandleAlpha) {
                var alpha = pixels[i + 3];
                pixels[i + 0] /= 255 / alpha;
                pixels[i + 1] /= 255 / alpha;
                pixels[i + 2] /= 255 / alpha;
            }
        }
        context.putImageData(pixelData, 0, 0);
    };
    PIXI.CanvasTinter.checkInverseAlpha = function() {
        var canvas = new PIXI.CanvasBuffer(2, 1);
        canvas.context.fillStyle = "rgba(10, 20, 30, 0.5)";
        canvas.context.fillRect(0, 0, 1, 1);
        var s1 = canvas.context.getImageData(0, 0, 1, 1);
        if (s1 === null) {
            return false;
        }
        canvas.context.putImageData(s1, 1, 0);
        var s2 = canvas.context.getImageData(1, 0, 1, 1);
        return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
    };
    PIXI.CanvasTinter.canHandleAlpha = PIXI.CanvasTinter.checkInverseAlpha();
    PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();
    PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel;
    PIXI.CanvasRenderer = function(width, height, options) {
        if (options) {
            for (var i in PIXI.defaultRenderOptions) {
                if (options[i] === undefined) options[i] = PIXI.defaultRenderOptions[i];
            }
        } else {
            options = PIXI.defaultRenderOptions;
        }
        if (!PIXI.defaultRenderer) {
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.CANVAS_RENDERER;
        this.resolution = options.resolution;
        this.clearBeforeRender = options.clearBeforeRender;
        this.transparent = options.transparent;
        this.autoResize = options.autoResize || false;
        this.width = width || 800;
        this.height = height || 600;
        this.width *= this.resolution;
        this.height *= this.resolution;
        this.view = options.view || PIXI.CanvasPool.create(this, this.width, this.height);
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        });
        this.refresh = true;
        this.view.width = this.width * this.resolution;
        this.view.height = this.height * this.resolution;
        this.count = 0;
        this.maskManager = new PIXI.CanvasMaskManager();
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null,
            roundPixels: false
        };
        this.mapBlendModes();
        this.resize(width, height);
        if ("imageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "imageSmoothingEnabled"; else if ("webkitImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "webkitImageSmoothingEnabled"; else if ("mozImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "mozImageSmoothingEnabled"; else if ("oImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "oImageSmoothingEnabled"; else if ("msImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "msImageSmoothingEnabled";
    };
    PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;
    PIXI.CanvasRenderer.prototype.render = function(stage) {
        stage.updateTransform();
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.globalAlpha = 1;
        this.renderSession.currentBlendMode = PIXI.blendModes.NORMAL;
        this.context.globalCompositeOperation = PIXI.blendModesCanvas[PIXI.blendModes.NORMAL];
        if (navigator.isCocoonJS && this.view.screencanvas) {
            this.context.fillStyle = "black";
            this.context.clear();
        }
        if (this.clearBeforeRender) {
            if (this.transparent) {
                this.context.clearRect(0, 0, this.width, this.height);
            } else {
                this.context.fillStyle = stage.backgroundColorString;
                this.context.fillRect(0, 0, this.width, this.height);
            }
        }
        this.renderDisplayObject(stage);
    };
    PIXI.CanvasRenderer.prototype.destroy = function(removeView) {
        if (removeView === undefined) {
            removeView = true;
        }
        if (removeView && this.view.parent) {
            this.view.parent.removeChild(this.view);
        }
        this.view = null;
        this.context = null;
        this.maskManager = null;
        this.renderSession = null;
    };
    PIXI.CanvasRenderer.prototype.resize = function(width, height) {
        this.width = width * this.resolution;
        this.height = height * this.resolution;
        this.view.width = this.width;
        this.view.height = this.height;
        if (this.autoResize) {
            this.view.style.width = this.width / this.resolution + "px";
            this.view.style.height = this.height / this.resolution + "px";
        }
    };
    PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context, matrix) {
        this.renderSession.context = context || this.context;
        this.renderSession.resolution = this.resolution;
        displayObject._renderCanvas(this.renderSession, matrix);
    };
    PIXI.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!PIXI.blendModesCanvas) {
            PIXI.blendModesCanvas = [];
            if (PIXI.canUseNewCanvasBlendModes()) {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "screen";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "overlay";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "darken";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "lighten";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "hue";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "color";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
            } else {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
            }
        }
    };
    PIXI.CanvasGraphics = function() {};
    PIXI.CanvasGraphics.renderGraphics = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        if (graphics.dirty) {
            this.updateGraphicsTint(graphics);
            graphics.dirty = false;
        }
        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;
            var fillColor = data._fillTint;
            var lineColor = data._lineTint;
            context.lineWidth = data.lineWidth;
            if (data.type === PIXI.Graphics.POLY) {
                context.beginPath();
                var points = shape.points;
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (shape.closed) {
                    context.lineTo(points[0], points[1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(shape.x, shape.y, shape.width, shape.height);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);
                }
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.ELIP) {
                var w = shape.width * 2;
                var h = shape.height * 2;
                var x = shape.x - w / 2;
                var y = shape.y - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = "#" + ("00000" + (fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeStyle = "#" + ("00000" + (lineColor | 0).toString(16)).substr(-6);
                    context.stroke();
                }
            }
        }
    };
    PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) {
        var len = graphics.graphicsData.length;
        if (len === 0) {
            return;
        }
        context.beginPath();
        for (var i = 0; i < len; i++) {
            var data = graphics.graphicsData[i];
            var shape = data.shape;
            if (data.type === PIXI.Graphics.POLY) {
                var points = shape.points;
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                context.rect(shape.x, shape.y, shape.width, shape.height);
                context.closePath();
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type === PIXI.Graphics.ELIP) {
                var w = shape.width * 2;
                var h = shape.height * 2;
                var x = shape.x - w / 2;
                var y = shape.y - h / 2;
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = shape.x;
                var ry = shape.y;
                var width = shape.width;
                var height = shape.height;
                var radius = shape.radius;
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
            }
        }
    };
    PIXI.CanvasGraphics.updateGraphicsTint = function(graphics) {
        if (graphics.tint === 16777215) {
            return;
        }
        var tintR = (graphics.tint >> 16 & 255) / 255;
        var tintG = (graphics.tint >> 8 & 255) / 255;
        var tintB = (graphics.tint & 255) / 255;
        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var fillColor = data.fillColor | 0;
            var lineColor = data.lineColor | 0;
            data._fillTint = ((fillColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 255) / 255 * tintG * 255 << 8) + (fillColor & 255) / 255 * tintB * 255;
            data._lineTint = ((lineColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 255) / 255 * tintG * 255 << 8) + (lineColor & 255) / 255 * tintB * 255;
        }
    };
    PIXI.BaseTextureCache = {};
    PIXI.BaseTextureCacheIdGenerator = 0;
    PIXI.BaseTexture = function(source, scaleMode) {
        this.resolution = 1;
        this.width = 100;
        this.height = 100;
        this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.hasLoaded = false;
        this.source = source;
        this._UID = PIXI._UID++;
        this.premultipliedAlpha = true;
        this._glTextures = [];
        this.mipmap = false;
        this._dirty = [ true, true, true, true ];
        if (!source) {
            return;
        }
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
            this.hasLoaded = true;
            this.width = this.source.naturalWidth || this.source.width;
            this.height = this.source.naturalHeight || this.source.height;
            this.dirty();
        }
        this.imageUrl = null;
        this._powerOf2 = false;
    };
    PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;
    PIXI.BaseTexture.prototype.forceLoaded = function(width, height) {
        this.hasLoaded = true;
        this.width = width;
        this.height = height;
        this.dirty();
    };
    PIXI.BaseTexture.prototype.destroy = function() {
        if (this.imageUrl) {
            delete PIXI.BaseTextureCache[this.imageUrl];
            delete PIXI.TextureCache[this.imageUrl];
            this.imageUrl = null;
            if (!navigator.isCocoonJS) this.source.src = "";
        } else if (this.source && this.source._pixiId) {
            PIXI.CanvasPool.removeByCanvas(this.source);
            delete PIXI.BaseTextureCache[this.source._pixiId];
        }
        this.source = null;
        this.unloadFromGPU();
    };
    PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc) {
        this.hasLoaded = false;
        this.source.src = null;
        this.source.src = newSrc;
    };
    PIXI.BaseTexture.prototype.dirty = function() {
        for (var i = 0; i < this._glTextures.length; i++) {
            this._dirty[i] = true;
        }
    };
    PIXI.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var i = this._glTextures.length - 1; i >= 0; i--) {
            var glTexture = this._glTextures[i];
            var gl = PIXI.glContexts[i];
            if (gl && glTexture) {
                gl.deleteTexture(glTexture);
            }
        }
        this._glTextures.length = 0;
        this.dirty();
    };
    PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var baseTexture = PIXI.BaseTextureCache[imageUrl];
        if (crossorigin === undefined && imageUrl.indexOf("data:") === -1) crossorigin = true;
        if (!baseTexture) {
            var image = new Image();
            if (crossorigin) {
                image.crossOrigin = "";
            }
            image.src = imageUrl;
            baseTexture = new PIXI.BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;
            PIXI.BaseTextureCache[imageUrl] = baseTexture;
            if (imageUrl.indexOf(PIXI.RETINA_PREFIX + ".") !== -1) {
                baseTexture.resolution = 2;
            }
        }
        return baseTexture;
    };
    PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode) {
        if (!canvas._pixiId) {
            canvas._pixiId = "canvas_" + PIXI.TextureCacheIdGenerator++;
        }
        if (canvas.width === 0) {
            canvas.width = 1;
        }
        if (canvas.height === 0) {
            canvas.height = 1;
        }
        var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];
        if (!baseTexture) {
            baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
            PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.TextureCache = {};
    PIXI.FrameCache = {};
    PIXI.TextureSilentFail = false;
    PIXI.TextureCacheIdGenerator = 0;
    PIXI.Texture = function(baseTexture, frame, crop, trim) {
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new PIXI.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof PIXI.Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        this.baseTexture = baseTexture;
        this.frame = frame;
        this.trim = trim;
        this.valid = false;
        this.isTiling = false;
        this.requiresUpdate = false;
        this.requiresReTint = false;
        this._uvs = null;
        this.width = 0;
        this.height = 0;
        this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1);
        if (baseTexture.hasLoaded) {
            if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            this.setFrame(frame);
        }
    };
    PIXI.Texture.prototype.constructor = PIXI.Texture;
    PIXI.Texture.prototype.onBaseTextureLoaded = function() {
        var baseTexture = this.baseTexture;
        if (this.noFrame) {
            this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        }
        this.setFrame(this.frame);
    };
    PIXI.Texture.prototype.destroy = function(destroyBase) {
        if (destroyBase) this.baseTexture.destroy();
        this.valid = false;
    };
    PIXI.Texture.prototype.setFrame = function(frame) {
        this.noFrame = false;
        this.frame = frame;
        this.width = frame.width;
        this.height = frame.height;
        this.crop.x = frame.x;
        this.crop.y = frame.y;
        this.crop.width = frame.width;
        this.crop.height = frame.height;
        if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) {
            if (!PIXI.TextureSilentFail) {
                throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            }
            this.valid = false;
            return;
        }
        this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
        if (this.trim) {
            this.width = this.trim.width;
            this.height = this.trim.height;
            this.frame.width = this.trim.width;
            this.frame.height = this.trim.height;
        }
        if (this.valid) this._updateUvs();
    };
    PIXI.Texture.prototype._updateUvs = function() {
        if (!this._uvs) this._uvs = new PIXI.TextureUvs();
        var frame = this.crop;
        var tw = this.baseTexture.width;
        var th = this.baseTexture.height;
        this._uvs.x0 = frame.x / tw;
        this._uvs.y0 = frame.y / th;
        this._uvs.x1 = (frame.x + frame.width) / tw;
        this._uvs.y1 = frame.y / th;
        this._uvs.x2 = (frame.x + frame.width) / tw;
        this._uvs.y2 = (frame.y + frame.height) / th;
        this._uvs.x3 = frame.x / tw;
        this._uvs.y3 = (frame.y + frame.height) / th;
    };
    PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var texture = PIXI.TextureCache[imageUrl];
        if (!texture) {
            texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
            PIXI.TextureCache[imageUrl] = texture;
        }
        return texture;
    };
    PIXI.Texture.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
        return texture;
    };
    PIXI.Texture.fromCanvas = function(canvas, scaleMode) {
        var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);
        return new PIXI.Texture(baseTexture);
    };
    PIXI.Texture.addTextureToCache = function(texture, id) {
        PIXI.TextureCache[id] = texture;
    };
    PIXI.Texture.removeTextureFromCache = function(id) {
        var texture = PIXI.TextureCache[id];
        delete PIXI.TextureCache[id];
        delete PIXI.BaseTextureCache[id];
        return texture;
    };
    PIXI.TextureUvs = function() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.x3 = 0;
        this.y3 = 0;
    };
    PIXI.RenderTexture = function(width, height, renderer, scaleMode, resolution) {
        this.width = width || 100;
        this.height = height || 100;
        this.resolution = resolution || 1;
        this.frame = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);
        this.crop = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);
        this.baseTexture = new PIXI.BaseTexture();
        this.baseTexture.width = this.width * this.resolution;
        this.baseTexture.height = this.height * this.resolution;
        this.baseTexture._glTextures = [];
        this.baseTexture.resolution = this.resolution;
        this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.baseTexture.hasLoaded = true;
        PIXI.Texture.call(this, this.baseTexture, new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution));
        this.renderer = renderer || PIXI.defaultRenderer;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            this.baseTexture._dirty[gl.id] = false;
            this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);
            this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;
            this.render = this.renderWebGL;
            this.projection = new PIXI.Point(this.width * .5, -this.height * .5);
        } else {
            this.render = this.renderCanvas;
            this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution);
            this.baseTexture.source = this.textureBuffer.canvas;
        }
        this.valid = true;
        this.tempMatrix = new Phaser.Matrix();
        this._updateUvs();
    };
    PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
    PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;
    PIXI.RenderTexture.prototype.resize = function(width, height, updateBase) {
        if (width === this.width && height === this.height) return;
        this.valid = width > 0 && height > 0;
        this.width = width;
        this.height = height;
        this.frame.width = this.crop.width = width * this.resolution;
        this.frame.height = this.crop.height = height * this.resolution;
        if (updateBase) {
            this.baseTexture.width = this.width * this.resolution;
            this.baseTexture.height = this.height * this.resolution;
        }
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.projection.x = this.width / 2;
            this.projection.y = -this.height / 2;
        }
        if (!this.valid) return;
        this.textureBuffer.resize(this.width, this.height);
    };
    PIXI.RenderTexture.prototype.clear = function() {
        if (!this.valid) {
            return;
        }
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        }
        this.textureBuffer.clear();
    };
    PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear) {
        if (!this.valid || displayObject.alpha === 0) {
            return;
        }
        var wt = displayObject.worldTransform;
        wt.identity();
        wt.translate(0, this.projection.y * 2);
        if (matrix) {
            wt.append(matrix);
        }
        wt.scale(1, -1);
        for (var i = 0; i < displayObject.children.length; i++) {
            displayObject.children[i].updateTransform();
        }
        var gl = this.renderer.gl;
        gl.viewport(0, 0, this.width * this.resolution, this.height * this.resolution);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        if (clear) {
            this.textureBuffer.clear();
        }
        this.renderer.spriteBatch.dirty = true;
        this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer, matrix);
        this.renderer.spriteBatch.dirty = true;
    };
    PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear) {
        if (!this.valid || displayObject.alpha === 0) {
            return;
        }
        var wt = displayObject.worldTransform;
        wt.identity();
        if (matrix) {
            wt.append(matrix);
        }
        for (var i = 0; i < displayObject.children.length; i++) {
            displayObject.children[i].updateTransform();
        }
        if (clear) {
            this.textureBuffer.clear();
        }
        var realResolution = this.renderer.resolution;
        this.renderer.resolution = this.resolution;
        this.renderer.renderDisplayObject(displayObject, this.textureBuffer.context, matrix);
        this.renderer.resolution = realResolution;
    };
    PIXI.RenderTexture.prototype.getImage = function() {
        var image = new Image();
        image.src = this.getBase64();
        return image;
    };
    PIXI.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    };
    PIXI.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            var width = this.textureBuffer.width;
            var height = this.textureBuffer.height;
            var webGLPixels = new Uint8Array(4 * width * height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            var tempCanvas = new PIXI.CanvasBuffer(width, height);
            var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
            canvasData.data.set(webGLPixels);
            tempCanvas.context.putImageData(canvasData, 0, 0);
            return tempCanvas.canvas;
        } else {
            return this.textureBuffer.canvas;
        }
    };
    PIXI.AbstractFilter = function(fragmentSrc, uniforms) {
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = uniforms || {};
        this.fragmentSrc = fragmentSrc || [];
    };
    PIXI.AbstractFilter.prototype.constructor = PIXI.AbstractFilter;
    PIXI.AbstractFilter.prototype.syncUniforms = function() {
        for (var i = 0, j = this.shaders.length; i < j; i++) {
            this.shaders[i].dirty = true;
        }
    };
    PIXI.Strip = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.texture = texture;
        this.uvs = new PIXI.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]);
        this.vertices = new PIXI.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]);
        this.colors = new PIXI.Float32Array([ 1, 1, 1, 1 ]);
        this.indices = new PIXI.Uint16Array([ 0, 1, 2, 3 ]);
        this.dirty = true;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.canvasPadding = 0;
        this.drawMode = PIXI.Strip.DrawModes.TRIANGLE_STRIP;
    };
    PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Strip.prototype.constructor = PIXI.Strip;
    PIXI.Strip.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        renderSession.spriteBatch.stop();
        if (!this._vertexBuffer) this._initWebGL(renderSession);
        renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);
        this._renderStrip(renderSession);
        renderSession.spriteBatch.start();
    };
    PIXI.Strip.prototype._initWebGL = function(renderSession) {
        var gl = renderSession.gl;
        this._vertexBuffer = gl.createBuffer();
        this._indexBuffer = gl.createBuffer();
        this._uvBuffer = gl.createBuffer();
        this._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
    };
    PIXI.Strip.prototype._renderStrip = function(renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader;
        var drawMode = this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
        renderSession.blendModeManager.setBlendMode(this.blendMode);
        gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));
        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
        gl.uniform1f(shader.alpha, this.worldAlpha);
        if (!this.dirty) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            if (this.texture.baseTexture._dirty[gl.id]) {
                renderSession.renderer.updateTexture(this.texture.baseTexture);
            } else {
                gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]);
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        } else {
            this.dirty = false;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            if (this.texture.baseTexture._dirty[gl.id]) {
                renderSession.renderer.updateTexture(this.texture.baseTexture);
            } else {
                gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]);
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        }
        gl.drawElements(drawMode, this.indices.length, gl.UNSIGNED_SHORT, 0);
    };
    PIXI.Strip.prototype._renderCanvas = function(renderSession) {
        var context = renderSession.context;
        var transform = this.worldTransform;
        if (renderSession.roundPixels) {
            context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);
        } else {
            context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
        }
        if (this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP) {
            this._renderCanvasTriangleStrip(context);
        } else {
            this._renderCanvasTriangles(context);
        }
    };
    PIXI.Strip.prototype._renderCanvasTriangleStrip = function(context) {
        var vertices = this.vertices;
        var uvs = this.uvs;
        var length = vertices.length / 2;
        this.count++;
        for (var i = 0; i < length - 2; i++) {
            var index = i * 2;
            this._renderCanvasDrawTriangle(context, vertices, uvs, index, index + 2, index + 4);
        }
    };
    PIXI.Strip.prototype._renderCanvasTriangles = function(context) {
        var vertices = this.vertices;
        var uvs = this.uvs;
        var indices = this.indices;
        var length = indices.length;
        this.count++;
        for (var i = 0; i < length; i += 3) {
            var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
            this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
        }
    };
    PIXI.Strip.prototype._renderCanvasDrawTriangle = function(context, vertices, uvs, index0, index1, index2) {
        var textureSource = this.texture.baseTexture.source;
        var textureWidth = this.texture.width;
        var textureHeight = this.texture.height;
        var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
        var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];
        var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth;
        var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;
        if (this.canvasPadding > 0) {
            var paddingX = this.canvasPadding / this.worldTransform.a;
            var paddingY = this.canvasPadding / this.worldTransform.d;
            var centerX = (x0 + x1 + x2) / 3;
            var centerY = (y0 + y1 + y2) / 3;
            var normX = x0 - centerX;
            var normY = y0 - centerY;
            var dist = Math.sqrt(normX * normX + normY * normY);
            x0 = centerX + normX / dist * (dist + paddingX);
            y0 = centerY + normY / dist * (dist + paddingY);
            normX = x1 - centerX;
            normY = y1 - centerY;
            dist = Math.sqrt(normX * normX + normY * normY);
            x1 = centerX + normX / dist * (dist + paddingX);
            y1 = centerY + normY / dist * (dist + paddingY);
            normX = x2 - centerX;
            normY = y2 - centerY;
            dist = Math.sqrt(normX * normX + normY * normY);
            x2 = centerX + normX / dist * (dist + paddingX);
            y2 = centerY + normY / dist * (dist + paddingY);
        }
        context.save();
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();
        context.clip();
        var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
        var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
        var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
        var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
        var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
        var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
        var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
        context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
        context.drawImage(textureSource, 0, 0);
        context.restore();
    };
    PIXI.Strip.prototype.renderStripFlat = function(strip) {
        var context = this.context;
        var vertices = strip.vertices;
        var length = vertices.length / 2;
        this.count++;
        context.beginPath();
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = vertices[index], x1 = vertices[index + 2], x2 = vertices[index + 4];
            var y0 = vertices[index + 1], y1 = vertices[index + 3], y2 = vertices[index + 5];
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
        }
        context.fillStyle = "#FF0000";
        context.fill();
        context.closePath();
    };
    PIXI.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = true;
    };
    PIXI.Strip.prototype.getBounds = function(matrix) {
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2) {
            var rawX = vertices[i], rawY = vertices[i + 1];
            var x = a * rawX + c * rawY + tx;
            var y = d * rawY + b * rawX + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        if (minX === -Infinity || maxY === Infinity) {
            return PIXI.EmptyRectangle;
        }
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    };
    PIXI.Rope = function(texture, points) {
        PIXI.Strip.call(this, texture);
        this.points = points;
        this.vertices = new PIXI.Float32Array(points.length * 4);
        this.uvs = new PIXI.Float32Array(points.length * 4);
        this.colors = new PIXI.Float32Array(points.length * 2);
        this.indices = new PIXI.Uint16Array(points.length * 2);
        this.refresh();
    };
    PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype);
    PIXI.Rope.prototype.constructor = PIXI.Rope;
    PIXI.Rope.prototype.refresh = function() {
        var points = this.points;
        if (points.length < 1) return;
        var uvs = this.uvs;
        var lastPoint = points[0];
        var indices = this.indices;
        var colors = this.colors;
        this.count -= .2;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        colors[0] = 1;
        colors[1] = 1;
        indices[0] = 0;
        indices[1] = 1;
        var total = points.length, point, index, amount;
        for (var i = 1; i < total; i++) {
            point = points[i];
            index = i * 4;
            amount = i / (total - 1);
            if (i % 2) {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            } else {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            }
            index = i * 2;
            colors[index] = 1;
            colors[index + 1] = 1;
            index = i * 2;
            indices[index] = index;
            indices[index + 1] = index + 1;
            lastPoint = point;
        }
    };
    PIXI.Rope.prototype.updateTransform = function() {
        var points = this.points;
        if (points.length < 1) return;
        var lastPoint = points[0];
        var nextPoint;
        var perp = {
            x: 0,
            y: 0
        };
        this.count -= .2;
        var vertices = this.vertices;
        var total = points.length, point, index, ratio, perpLength, num;
        for (var i = 0; i < total; i++) {
            point = points[i];
            index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }
            perp.y = -(nextPoint.x - lastPoint.x);
            perp.x = nextPoint.y - lastPoint.y;
            ratio = (1 - i / (total - 1)) * 10;
            if (ratio > 1) ratio = 1;
            perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
            num = this.texture.height / 2;
            perp.x /= perpLength;
            perp.y /= perpLength;
            perp.x *= num;
            perp.y *= num;
            vertices[index] = point.x + perp.x;
            vertices[index + 1] = point.y + perp.y;
            vertices[index + 2] = point.x - perp.x;
            vertices[index + 3] = point.y - perp.y;
            lastPoint = point;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.Rope.prototype.setTexture = function(texture) {
        this.texture = texture;
    };
    PIXI.TilingSprite = function(texture, width, height) {
        PIXI.Sprite.call(this, texture);
        this._width = width || 128;
        this._height = height || 128;
        this.tileScale = new PIXI.Point(1, 1);
        this.tileScaleOffset = new PIXI.Point(1, 1);
        this.tilePosition = new PIXI.Point();
        this.renderable = true;
        this.tint = 16777215;
        this.textureDebug = false;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.canvasBuffer = null;
        this.tilingTexture = null;
        this.tilePattern = null;
        this.refreshTexture = true;
        this.frameWidth = 0;
        this.frameHeight = 0;
    };
    PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;
    PIXI.TilingSprite.prototype.setTexture = function(texture) {
        if (this.texture !== texture) {
            this.texture = texture;
            this.refreshTexture = true;
            this.cachedTint = 16777215;
        }
    };
    PIXI.TilingSprite.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0) {
            return;
        }
        if (this._mask) {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }
        if (this._filters) {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }
        if (this.refreshTexture) {
            this.generateTilingTexture(true);
            if (this.tilingTexture) {
                if (this.tilingTexture.needsUpdate) {
                    renderSession.renderer.updateTexture(this.tilingTexture.baseTexture);
                    this.tilingTexture.needsUpdate = false;
                }
            } else {
                return;
            }
        }
        renderSession.spriteBatch.renderTilingSprite(this);
        for (var i = 0; i < this.children.length; i++) {
            this.children[i]._renderWebGL(renderSession);
        }
        renderSession.spriteBatch.stop();
        if (this._filters) {
            renderSession.filterManager.popFilter();
        }
        if (this._mask) {
            renderSession.maskManager.popMask(this._mask, renderSession);
        }
        renderSession.spriteBatch.start();
    };
    PIXI.TilingSprite.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) {
            return;
        }
        var context = renderSession.context;
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession);
        }
        context.globalAlpha = this.worldAlpha;
        var wt = this.worldTransform;
        var resolution = renderSession.resolution;
        context.setTransform(wt.a * resolution, wt.b * resolution, wt.c * resolution, wt.d * resolution, wt.tx * resolution, wt.ty * resolution);
        if (this.refreshTexture) {
            this.generateTilingTexture(false);
            if (this.tilingTexture) {
                this.tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            } else {
                return;
            }
        }
        var sessionBlendMode = renderSession.currentBlendMode;
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        var tilePosition = this.tilePosition;
        var tileScale = this.tileScale;
        tilePosition.x %= this.tilingTexture.baseTexture.width;
        tilePosition.y %= this.tilingTexture.baseTexture.height;
        context.scale(tileScale.x, tileScale.y);
        context.translate(tilePosition.x + this.anchor.x * -this._width, tilePosition.y + this.anchor.y * -this._height);
        context.fillStyle = this.tilePattern;
        var tx = -tilePosition.x;
        var ty = -tilePosition.y;
        var tw = this._width / tileScale.x;
        var th = this._height / tileScale.y;
        if (renderSession.roundPixels) {
            tx |= 0;
            ty |= 0;
            tw |= 0;
            th |= 0;
        }
        context.fillRect(tx, ty, tw, th);
        context.scale(1 / tileScale.x, 1 / tileScale.y);
        context.translate(-tilePosition.x + this.anchor.x * this._width, -tilePosition.y + this.anchor.y * this._height);
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession);
        }
        for (var i = 0; i < this.children.length; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (sessionBlendMode !== this.blendMode) {
            renderSession.currentBlendMode = sessionBlendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[sessionBlendMode];
        }
    };
    PIXI.TilingSprite.prototype.onTextureUpdate = function() {};
    PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo) {
        if (!this.texture.baseTexture.hasLoaded) {
            return;
        }
        var texture = this.texture;
        var frame = texture.frame;
        var targetWidth = this._frame.sourceSizeW;
        var targetHeight = this._frame.sourceSizeH;
        var dx = 0;
        var dy = 0;
        if (this._frame.trimmed) {
            dx = this._frame.spriteSourceSizeX;
            dy = this._frame.spriteSourceSizeY;
        }
        if (forcePowerOfTwo) {
            targetWidth = PIXI.getNextPowerOfTwo(targetWidth);
            targetHeight = PIXI.getNextPowerOfTwo(targetHeight);
        }
        if (this.canvasBuffer) {
            this.canvasBuffer.resize(targetWidth, targetHeight);
            this.tilingTexture.baseTexture.width = targetWidth;
            this.tilingTexture.baseTexture.height = targetHeight;
            this.tilingTexture.needsUpdate = true;
        } else {
            this.canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);
            this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas);
            this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas);
            this.tilingTexture.isTiling = true;
            this.tilingTexture.needsUpdate = true;
        }
        if (this.textureDebug) {
            this.canvasBuffer.context.strokeStyle = "#00ff00";
            this.canvasBuffer.context.strokeRect(0, 0, targetWidth, targetHeight);
        }
        var w = texture.crop.width;
        var h = texture.crop.height;
        if (w !== targetWidth || h !== targetHeight) {
            w = targetWidth;
            h = targetHeight;
        }
        this.canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, dx, dy, w, h);
        this.tileScaleOffset.x = frame.width / targetWidth;
        this.tileScaleOffset.y = frame.height / targetHeight;
        this.refreshTexture = false;
        this.tilingTexture.baseTexture._powerOf2 = true;
    };
    PIXI.TilingSprite.prototype.getBounds = function() {
        var width = this._width;
        var height = this._height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.TilingSprite.prototype.destroy = function() {
        this.canvasBuffer.destroy();
        PIXI.Sprite.prototype.destroy.call(this);
        this.tileScale = null;
        this.tileScaleOffset = null;
        this.tilePosition = null;
        if (this.tilingTexture) {
            this.tilingTexture.destroy(true);
            this.tilingTexture = null;
        }
    };
    Object.defineProperty(PIXI.TilingSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(value) {
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.TilingSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(value) {
            this._height = value;
        }
    });
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== "undefined" && define.amd) {
        define("PIXI", function() {
            return root.PIXI = PIXI;
        }());
    } else {
        root.PIXI = PIXI;
    }
    return PIXI;
}).call(this);

(function() {
    var root = this;
    var Phaser = Phaser || {
        VERSION: "2.4.3",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        },
        PIXI: PIXI || {}
    };
    if (!Math.trunc) {
        Math.trunc = function trunc(x) {
            return x < 0 ? Math.ceil(x) : Math.floor(x);
        };
    }
    if (!Function.prototype.bind) {
        Function.prototype.bind = function() {
            var slice = Array.prototype.slice;
            return function(thisArg) {
                var target = this, boundArgs = slice.call(arguments, 1);
                if (typeof target !== "function") {
                    throw new TypeError();
                }
                function bound() {
                    var args = boundArgs.concat(slice.call(arguments));
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    if (proto) {
                        F.prototype = proto;
                    }
                    if (!(this instanceof F)) {
                        return new F();
                    }
                }(target.prototype);
                return bound;
            };
        }();
    }
    if (!Array.isArray) {
        Array.isArray = function(arg) {
            return Object.prototype.toString.call(arg) == "[object Array]";
        };
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
            "use strict";
            if (this === void 0 || this === null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function") {
                throw new TypeError();
            }
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    fun.call(thisArg, t[i], i, t);
                }
            }
        };
    }
    if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object") {
        var CheapArray = function(type) {
            var proto = new Array();
            window[type] = function(arg) {
                if (typeof arg === "number") {
                    Array.call(this, arg);
                    this.length = arg;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = 0;
                    }
                } else {
                    Array.call(this, arg.length);
                    this.length = arg.length;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = arg[i];
                    }
                }
            };
            window[type].prototype = proto;
            window[type].constructor = window[type];
        };
        CheapArray("Uint32Array");
        CheapArray("Int16Array");
    }
    if (!window.console) {
        window.console = {};
        window.console.log = window.console.assert = function() {};
        window.console.warn = window.console.assert = function() {};
    }
    Phaser.Utils = {
        getProperty: function(obj, prop) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                return obj[last];
            } else {
                return null;
            }
        },
        setProperty: function(obj, prop, value) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                obj[last] = value;
            }
            return obj;
        },
        chanceRoll: function(chance) {
            if (chance === undefined) {
                chance = 50;
            }
            return chance > 0 && Math.random() * 100 <= chance;
        },
        randomChoice: function(choice1, choice2) {
            return Math.random() < .5 ? choice1 : choice2;
        },
        parseDimension: function(size, dimension) {
            var f = 0;
            var px = 0;
            if (typeof size === "string") {
                if (size.substr(-1) === "%") {
                    f = parseInt(size, 10) / 100;
                    if (dimension === 0) {
                        px = window.innerWidth * f;
                    } else {
                        px = window.innerHeight * f;
                    }
                } else {
                    px = parseInt(size, 10);
                }
            } else {
                px = size;
            }
            return px;
        },
        pad: function(str, len, pad, dir) {
            if (len === undefined) {
                var len = 0;
            }
            if (pad === undefined) {
                var pad = " ";
            }
            if (dir === undefined) {
                var dir = 3;
            }
            var padlen = 0;
            if (len + 1 >= str.length) {
                switch (dir) {
                  case 1:
                    str = new Array(len + 1 - str.length).join(pad) + str;
                    break;

                  case 3:
                    var right = Math.ceil((padlen = len - str.length) / 2);
                    var left = padlen - right;
                    str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                    break;

                  default:
                    str = str + new Array(len + 1 - str.length).join(pad);
                    break;
                }
            }
            return str;
        },
        isPlainObject: function(obj) {
            if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
                return false;
            }
            try {
                if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            return true;
        },
        extend: function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i = 2;
            }
            if (length === i) {
                target = this;
                --i;
            }
            for (;i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue;
                        }
                        if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && Array.isArray(src) ? src : [];
                            } else {
                                clone = src && Phaser.Utils.isPlainObject(src) ? src : {};
                            }
                            target[name] = Phaser.Utils.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        },
        mixinPrototype: function(target, mixin, replace) {
            if (replace === undefined) {
                replace = false;
            }
            var mixinKeys = Object.keys(mixin);
            for (var i = 0; i < mixinKeys.length; i++) {
                var key = mixinKeys[i];
                var value = mixin[key];
                if (!replace && key in target) {
                    continue;
                } else {
                    if (value && (typeof value.get === "function" || typeof value.set === "function")) {
                        if (typeof value.clone === "function") {
                            target[key] = value.clone();
                        } else {
                            Object.defineProperty(target, key, value);
                        }
                    } else {
                        target[key] = value;
                    }
                }
            }
        },
        mixin: function(from, to) {
            if (!from || typeof from !== "object") {
                return to;
            }
            for (var key in from) {
                var o = from[key];
                if (o.childNodes || o.cloneNode) {
                    continue;
                }
                var type = typeof from[key];
                if (!from[key] || type !== "object") {
                    to[key] = from[key];
                } else {
                    if (typeof to[key] === type) {
                        to[key] = Phaser.Utils.mixin(from[key], to[key]);
                    } else {
                        to[key] = Phaser.Utils.mixin(from[key], new o.constructor());
                    }
                }
            }
            return to;
        }
    };
    Phaser.Circle = function(x, y, diameter) {
        x = x || 0;
        y = y || 0;
        diameter = diameter || 0;
        this.x = x;
        this.y = y;
        this._diameter = diameter;
        this._radius = 0;
        if (diameter > 0) {
            this._radius = diameter * .5;
        }
        this.type = Phaser.CIRCLE;
    };
    Phaser.Circle.prototype = {
        circumference: function() {
            return 2 * (Math.PI * this._radius);
        },
        random: function(out) {
            if (out === undefined) {
                out = new Phaser.Point();
            }
            var t = 2 * Math.PI * Math.random();
            var u = Math.random() + Math.random();
            var r = u > 1 ? 2 - u : u;
            var x = r * Math.cos(t);
            var y = r * Math.sin(t);
            out.x = this.x + x * this.radius;
            out.y = this.y + y * this.radius;
            return out;
        },
        getBounds: function() {
            return new Phaser.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
        },
        setTo: function(x, y, diameter) {
            this.x = x;
            this.y = y;
            this._diameter = diameter;
            this._radius = diameter * .5;
            return this;
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.diameter);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.diameter = this._diameter;
            return dest;
        },
        distance: function(dest, round) {
            var distance = Phaser.Math.distance(this.x, this.y, dest.x, dest.y);
            return round ? Math.round(distance) : distance;
        },
        clone: function(output) {
            if (output === undefined || output === null) {
                output = new Phaser.Circle(this.x, this.y, this.diameter);
            } else {
                output.setTo(this.x, this.y, this.diameter);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Circle.contains(this, x, y);
        },
        circumferencePoint: function(angle, asDegrees, out) {
            return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);
        },
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        }
    };
    Phaser.Circle.prototype.constructor = Phaser.Circle;
    Object.defineProperty(Phaser.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter;
        },
        set: function(value) {
            if (value > 0) {
                this._diameter = value;
                this._radius = value * .5;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "radius", {
        get: function() {
            return this._radius;
        },
        set: function(value) {
            if (value > 0) {
                this._radius = value;
                this._diameter = value * 2;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius;
        },
        set: function(value) {
            if (value > this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.x - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius;
        },
        set: function(value) {
            if (value < this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius;
        },
        set: function(value) {
            if (value > this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.y - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius;
        },
        set: function(value) {
            if (value < this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "area", {
        get: function() {
            if (this._radius > 0) {
                return Math.PI * this._radius * this._radius;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "empty", {
        get: function() {
            return this._diameter === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0);
            }
        }
    });
    Phaser.Circle.contains = function(a, x, y) {
        if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom) {
            var dx = (a.x - x) * (a.x - x);
            var dy = (a.y - y) * (a.y - y);
            return dx + dy <= a.radius * a.radius;
        } else {
            return false;
        }
    };
    Phaser.Circle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.diameter == b.diameter;
    };
    Phaser.Circle.intersects = function(a, b) {
        return Phaser.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
    };
    Phaser.Circle.circumferencePoint = function(a, angle, asDegrees, out) {
        if (asDegrees === undefined) {
            asDegrees = false;
        }
        if (out === undefined) {
            out = new Phaser.Point();
        }
        if (asDegrees === true) {
            angle = Phaser.Math.degToRad(angle);
        }
        out.x = a.x + a.radius * Math.cos(angle);
        out.y = a.y + a.radius * Math.sin(angle);
        return out;
    };
    Phaser.Circle.intersectsRectangle = function(c, r) {
        var cx = Math.abs(c.x - r.x - r.halfWidth);
        var xDist = r.halfWidth + c.radius;
        if (cx > xDist) {
            return false;
        }
        var cy = Math.abs(c.y - r.y - r.halfHeight);
        var yDist = r.halfHeight + c.radius;
        if (cy > yDist) {
            return false;
        }
        if (cx <= r.halfWidth || cy <= r.halfHeight) {
            return true;
        }
        var xCornerDist = cx - r.halfWidth;
        var yCornerDist = cy - r.halfHeight;
        var xCornerDistSq = xCornerDist * xCornerDist;
        var yCornerDistSq = yCornerDist * yCornerDist;
        var maxCornerDistSq = c.radius * c.radius;
        return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
    };
    PIXI.Circle = Phaser.Circle;
    Phaser.Ellipse = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = Phaser.ELLIPSE;
    };
    Phaser.Ellipse.prototype = {
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        getBounds: function() {
            return new Phaser.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        clone: function(output) {
            if (output === undefined || output === null) {
                output = new Phaser.Ellipse(this.x, this.y, this.width, this.height);
            } else {
                output.setTo(this.x, this.y, this.width, this.height);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Ellipse.contains(this, x, y);
        },
        random: function(out) {
            if (out === undefined) {
                out = new Phaser.Point();
            }
            var p = Math.random() * Math.PI * 2;
            var r = Math.random();
            out.x = Math.sqrt(r) * Math.cos(p);
            out.y = Math.sqrt(r) * Math.sin(p);
            out.x = this.x + out.x * this.width / 2;
            out.y = this.y + out.y * this.height / 2;
            return out;
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        }
    };
    Phaser.Ellipse.prototype.constructor = Phaser.Ellipse;
    Object.defineProperty(Phaser.Ellipse.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value < this.x) {
                this.width = 0;
            } else {
                this.width = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            this.y = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value < this.y) {
                this.height = 0;
            } else {
                this.height = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "empty", {
        get: function() {
            return this.width === 0 || this.height === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Ellipse.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        var normx = (x - a.x) / a.width - .5;
        var normy = (y - a.y) / a.height - .5;
        normx *= normx;
        normy *= normy;
        return normx + normy < .25;
    };
    PIXI.Ellipse = Phaser.Ellipse;
    Phaser.Line = function(x1, y1, x2, y2) {
        x1 = x1 || 0;
        y1 = y1 || 0;
        x2 = x2 || 0;
        y2 = y2 || 0;
        this.start = new Phaser.Point(x1, y1);
        this.end = new Phaser.Point(x2, y2);
        this.type = Phaser.LINE;
    };
    Phaser.Line.prototype = {
        setTo: function(x1, y1, x2, y2) {
            this.start.setTo(x1, y1);
            this.end.setTo(x2, y2);
            return this;
        },
        fromSprite: function(startSprite, endSprite, useCenter) {
            if (useCenter === undefined) {
                useCenter = false;
            }
            if (useCenter) {
                return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y);
            }
            return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);
        },
        fromAngle: function(x, y, angle, length) {
            this.start.setTo(x, y);
            this.end.setTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
            return this;
        },
        rotate: function(angle, asDegrees) {
            var cx = (this.start.x + this.end.x) / 2;
            var cy = (this.start.y + this.end.y) / 2;
            this.start.rotate(cx, cy, angle, asDegrees);
            this.end.rotate(cx, cy, angle, asDegrees);
            return this;
        },
        rotateAround: function(x, y, angle, asDegrees) {
            this.start.rotate(x, y, angle, asDegrees);
            this.end.rotate(x, y, angle, asDegrees);
            return this;
        },
        intersects: function(line, asSegment, result) {
            return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);
        },
        reflect: function(line) {
            return Phaser.Line.reflect(this, line);
        },
        midPoint: function(out) {
            if (out === undefined) {
                out = new Phaser.Point();
            }
            out.x = (this.start.x + this.end.x) / 2;
            out.y = (this.start.y + this.end.y) / 2;
            return out;
        },
        centerOn: function(x, y) {
            var cx = (this.start.x + this.end.x) / 2;
            var cy = (this.start.y + this.end.y) / 2;
            var tx = x - cx;
            var ty = y - cy;
            this.start.add(tx, ty);
            this.end.add(tx, ty);
        },
        pointOnLine: function(x, y) {
            return (x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y);
        },
        pointOnSegment: function(x, y) {
            var xMin = Math.min(this.start.x, this.end.x);
            var xMax = Math.max(this.start.x, this.end.x);
            var yMin = Math.min(this.start.y, this.end.y);
            var yMax = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax);
        },
        random: function(out) {
            if (out === undefined) {
                out = new Phaser.Point();
            }
            var t = Math.random();
            out.x = this.start.x + t * (this.end.x - this.start.x);
            out.y = this.start.y + t * (this.end.y - this.start.y);
            return out;
        },
        coordinatesOnLine: function(stepRate, results) {
            if (stepRate === undefined) {
                stepRate = 1;
            }
            if (results === undefined) {
                results = [];
            }
            var x1 = Math.round(this.start.x);
            var y1 = Math.round(this.start.y);
            var x2 = Math.round(this.end.x);
            var y2 = Math.round(this.end.y);
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            results.push([ x1, y1 ]);
            var i = 1;
            while (!(x1 == x2 && y1 == y2)) {
                var e2 = err << 1;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
                if (i % stepRate === 0) {
                    results.push([ x1, y1 ]);
                }
                i++;
            }
            return results;
        },
        clone: function(output) {
            if (output === undefined || output === null) {
                output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y);
            } else {
                output.setTo(this.start.x, this.start.y, this.end.x, this.end.y);
            }
            return output;
        }
    };
    Object.defineProperty(Phaser.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "normalX", {
        get: function() {
            return Math.cos(this.angle - 1.5707963267948966);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "normalY", {
        get: function() {
            return Math.sin(this.angle - 1.5707963267948966);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "normalAngle", {
        get: function() {
            return Phaser.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
        }
    });
    Phaser.Line.intersectsPoints = function(a, b, e, f, asSegment, result) {
        if (asSegment === undefined) {
            asSegment = true;
        }
        if (result === undefined) {
            result = new Phaser.Point();
        }
        var a1 = b.y - a.y;
        var a2 = f.y - e.y;
        var b1 = a.x - b.x;
        var b2 = e.x - f.x;
        var c1 = b.x * a.y - a.x * b.y;
        var c2 = f.x * e.y - e.x * f.y;
        var denom = a1 * b2 - a2 * b1;
        if (denom === 0) {
            return null;
        }
        result.x = (b1 * c2 - b2 * c1) / denom;
        result.y = (a2 * c1 - a1 * c2) / denom;
        if (asSegment) {
            var uc = (f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y);
            var ua = ((f.x - e.x) * (a.y - e.y) - (f.y - e.y) * (a.x - e.x)) / uc;
            var ub = ((b.x - a.x) * (a.y - e.y) - (b.y - a.y) * (a.x - e.x)) / uc;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return result;
            } else {
                return null;
            }
        }
        return result;
    };
    Phaser.Line.intersects = function(a, b, asSegment, result) {
        return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);
    };
    Phaser.Line.reflect = function(a, b) {
        return 2 * b.normalAngle - 3.141592653589793 - a.angle;
    };
    Phaser.Matrix = function(a, b, c, d, tx, ty) {
        a = a || 1;
        b = b || 0;
        c = c || 0;
        d = d || 1;
        tx = tx || 0;
        ty = ty || 0;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        this.type = Phaser.MATRIX;
    };
    Phaser.Matrix.prototype = {
        fromArray: function(array) {
            return this.setTo(array[0], array[1], array[3], array[4], array[2], array[5]);
        },
        setTo: function(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            return this;
        },
        clone: function(output) {
            if (output === undefined || output === null) {
                output = new Phaser.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
            } else {
                output.a = this.a;
                output.b = this.b;
                output.c = this.c;
                output.d = this.d;
                output.tx = this.tx;
                output.ty = this.ty;
            }
            return output;
        },
        copyTo: function(matrix) {
            matrix.copyFrom(this);
            return matrix;
        },
        copyFrom: function(matrix) {
            this.a = matrix.a;
            this.b = matrix.b;
            this.c = matrix.c;
            this.d = matrix.d;
            this.tx = matrix.tx;
            this.ty = matrix.ty;
            return this;
        },
        toArray: function(transpose, array) {
            if (array === undefined) {
                array = new PIXI.Float32Array(9);
            }
            if (transpose) {
                array[0] = this.a;
                array[1] = this.b;
                array[2] = 0;
                array[3] = this.c;
                array[4] = this.d;
                array[5] = 0;
                array[6] = this.tx;
                array[7] = this.ty;
                array[8] = 1;
            } else {
                array[0] = this.a;
                array[1] = this.c;
                array[2] = this.tx;
                array[3] = this.b;
                array[4] = this.d;
                array[5] = this.ty;
                array[6] = 0;
                array[7] = 0;
                array[8] = 1;
            }
            return array;
        },
        apply: function(pos, newPos) {
            if (newPos === undefined) {
                newPos = new Phaser.Point();
            }
            newPos.x = this.a * pos.x + this.c * pos.y + this.tx;
            newPos.y = this.b * pos.x + this.d * pos.y + this.ty;
            return newPos;
        },
        applyInverse: function(pos, newPos) {
            if (newPos === undefined) {
                newPos = new Phaser.Point();
            }
            var id = 1 / (this.a * this.d + this.c * -this.b);
            var x = pos.x;
            var y = pos.y;
            newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
            newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
            return newPos;
        },
        translate: function(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        },
        scale: function(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            return this;
        },
        rotate: function(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            return this;
        },
        append: function(matrix) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            this.a = matrix.a * a1 + matrix.b * c1;
            this.b = matrix.a * b1 + matrix.b * d1;
            this.c = matrix.c * a1 + matrix.d * c1;
            this.d = matrix.c * b1 + matrix.d * d1;
            this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
            this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
            return this;
        },
        identity: function() {
            return this.setTo(1, 0, 0, 1, 0, 0);
        }
    };
    Phaser.identityMatrix = new Phaser.Matrix();
    PIXI.Matrix = Phaser.Matrix;
    PIXI.identityMatrix = Phaser.identityMatrix;
    Phaser.Point = function(x, y) {
        x = x || 0;
        y = y || 0;
        this.x = x;
        this.y = y;
        this.type = Phaser.POINT;
    };
    Phaser.Point.prototype = {
        copyFrom: function(source) {
            return this.setTo(source.x, source.y);
        },
        invert: function() {
            return this.setTo(this.y, this.x);
        },
        setTo: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        set: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        add: function(x, y) {
            this.x += x;
            this.y += y;
            return this;
        },
        subtract: function(x, y) {
            this.x -= x;
            this.y -= y;
            return this;
        },
        multiply: function(x, y) {
            this.x *= x;
            this.y *= y;
            return this;
        },
        divide: function(x, y) {
            this.x /= x;
            this.y /= y;
            return this;
        },
        clampX: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            return this;
        },
        clampY: function(min, max) {
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clamp: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clone: function(output) {
            if (output === undefined || output === null) {
                output = new Phaser.Point(this.x, this.y);
            } else {
                output.setTo(this.x, this.y);
            }
            return output;
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            return dest;
        },
        distance: function(dest, round) {
            return Phaser.Point.distance(this, dest, round);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        angle: function(a, asDegrees) {
            if (asDegrees === undefined) {
                asDegrees = false;
            }
            if (asDegrees) {
                return Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x));
            } else {
                return Math.atan2(a.y - this.y, a.x - this.x);
            }
        },
        rotate: function(x, y, angle, asDegrees, distance) {
            return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function(magnitude) {
            return this.normalize().multiply(magnitude, magnitude);
        },
        normalize: function() {
            if (!this.isZero()) {
                var m = this.getMagnitude();
                this.x /= m;
                this.y /= m;
            }
            return this;
        },
        isZero: function() {
            return this.x === 0 && this.y === 0;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        perp: function() {
            return this.setTo(-this.y, this.x);
        },
        rperp: function() {
            return this.setTo(this.y, -this.x);
        },
        normalRightHand: function() {
            return this.setTo(this.y * -1, this.x);
        },
        floor: function() {
            return this.setTo(Math.floor(this.x), Math.floor(this.y));
        },
        ceil: function() {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        }
    };
    Phaser.Point.prototype.constructor = Phaser.Point;
    Phaser.Point.add = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        return out;
    };
    Phaser.Point.subtract = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        return out;
    };
    Phaser.Point.multiply = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        return out;
    };
    Phaser.Point.divide = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        return out;
    };
    Phaser.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };
    Phaser.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
    };
    Phaser.Point.negative = function(a, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(-a.x, -a.y);
    };
    Phaser.Point.multiplyAdd = function(a, b, s, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + b.x * s, a.y + b.y * s);
    };
    Phaser.Point.interpolate = function(a, b, f, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);
    };
    Phaser.Point.perp = function(a, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(-a.y, a.x);
    };
    Phaser.Point.rperp = function(a, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(a.y, -a.x);
    };
    Phaser.Point.distance = function(a, b, round) {
        var distance = Phaser.Math.distance(a.x, a.y, b.x, b.y);
        return round ? Math.round(distance) : distance;
    };
    Phaser.Point.project = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        var amt = a.dot(b) / b.getMagnitudeSq();
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.projectUnit = function(a, b, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        var amt = a.dot(b);
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.normalRightHand = function(a, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        return out.setTo(a.y * -1, a.x);
    };
    Phaser.Point.normalize = function(a, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        var m = a.getMagnitude();
        if (m !== 0) {
            out.setTo(a.x / m, a.y / m);
        }
        return out;
    };
    Phaser.Point.rotate = function(a, x, y, angle, asDegrees, distance) {
        if (asDegrees) {
            angle = Phaser.Math.degToRad(angle);
        }
        if (distance === undefined) {
            a.subtract(x, y);
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var tx = c * a.x - s * a.y;
            var ty = s * a.x + c * a.y;
            a.x = tx + x;
            a.y = ty + y;
        } else {
            var t = angle + Math.atan2(a.y - y, a.x - x);
            a.x = x + distance * Math.cos(t);
            a.y = y + distance * Math.sin(t);
        }
        return a;
    };
    Phaser.Point.centroid = function(points, out) {
        if (out === undefined) {
            out = new Phaser.Point();
        }
        if (Object.prototype.toString.call(points) !== "[object Array]") {
            throw new Error("Phaser.Point. Parameter 'points' must be an array");
        }
        var pointslength = points.length;
        if (pointslength < 1) {
            throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        }
        if (pointslength === 1) {
            out.copyFrom(points[0]);
            return out;
        }
        for (var i = 0; i < pointslength; i++) {
            Phaser.Point.add(out, points[i], out);
        }
        out.divide(pointslength, pointslength);
        return out;
    };
    Phaser.Point.parse = function(obj, xProp, yProp) {
        xProp = xProp || "x";
        yProp = yProp || "y";
        var point = new Phaser.Point();
        if (obj[xProp]) {
            point.x = parseInt(obj[xProp], 10);
        }
        if (obj[yProp]) {
            point.y = parseInt(obj[yProp], 10);
        }
        return point;
    };
    PIXI.Point = Phaser.Point;
    Phaser.Polygon = function() {
        this.area = 0;
        this._points = [];
        if (arguments.length > 0) {
            this.setTo.apply(this, arguments);
        }
        this.closed = true;
        this.type = Phaser.POLYGON;
    };
    Phaser.Polygon.prototype = {
        toNumberArray: function(output) {
            if (output === undefined) {
                output = [];
            }
            for (var i = 0; i < this._points.length; i++) {
                if (typeof this._points[i] === "number") {
                    output.push(this._points[i]);
                    output.push(this._points[i + 1]);
                    i++;
                } else {
                    output.push(this._points[i].x);
                    output.push(this._points[i].y);
                }
            }
            return output;
        },
        flatten: function() {
            this._points = this.toNumberArray();
            return this;
        },
        clone: function(output) {
            var points = this._points.slice();
            if (output === undefined || output === null) {
                output = new Phaser.Polygon(points);
            } else {
                output.setTo(points);
            }
            return output;
        },
        contains: function(x, y) {
            var length = this._points.length;
            var inside = false;
            for (var i = -1, j = length - 1; ++i < length; j = i) {
                var ix = this._points[i].x;
                var iy = this._points[i].y;
                var jx = this._points[j].x;
                var jy = this._points[j].y;
                if ((iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix) {
                    inside = !inside;
                }
            }
            return inside;
        },
        setTo: function(points) {
            this.area = 0;
            this._points = [];
            if (arguments.length > 0) {
                if (!Array.isArray(points)) {
                    points = Array.prototype.slice.call(arguments);
                }
                var y0 = Number.MAX_VALUE;
                for (var i = 0, len = points.length; i < len; i++) {
                    if (typeof points[i] === "number") {
                        var p = new PIXI.Point(points[i], points[i + 1]);
                        i++;
                    } else {
                        var p = new PIXI.Point(points[i].x, points[i].y);
                    }
                    this._points.push(p);
                    if (p.y < y0) {
                        y0 = p.y;
                    }
                }
                this.calculateArea(y0);
            }
            return this;
        },
        calculateArea: function(y0) {
            var p1;
            var p2;
            var avgHeight;
            var width;
            for (var i = 0, len = this._points.length; i < len; i++) {
                p1 = this._points[i];
                if (i === len - 1) {
                    p2 = this._points[0];
                } else {
                    p2 = this._points[i + 1];
                }
                avgHeight = (p1.y - y0 + (p2.y - y0)) / 2;
                width = p1.x - p2.x;
                this.area += avgHeight * width;
            }
            return this.area;
        }
    };
    Phaser.Polygon.prototype.constructor = Phaser.Polygon;
    Object.defineProperty(Phaser.Polygon.prototype, "points", {
        get: function() {
            return this._points;
        },
        set: function(points) {
            if (points != null) {
                this.setTo(points);
            } else {
                this.setTo();
            }
        }
    });
    PIXI.Polygon = Phaser.Polygon;
    Phaser.Rectangle = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = Phaser.RECTANGLE;
    };
    Phaser.Rectangle.prototype = {
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        scale: function(x, y) {
            if (y === undefined) {
                y = x;
            }
            this.width *= x;
            this.height *= y;
            return this;
        },
        centerOn: function(x, y) {
            this.centerX = x;
            this.centerY = y;
            return this;
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
        },
        floorAll: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height);
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
        },
        ceilAll: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.width = Math.ceil(this.width);
            this.height = Math.ceil(this.height);
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        inflate: function(dx, dy) {
            return Phaser.Rectangle.inflate(this, dx, dy);
        },
        size: function(output) {
            return Phaser.Rectangle.size(this, output);
        },
        resize: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
        },
        clone: function(output) {
            return Phaser.Rectangle.clone(this, output);
        },
        contains: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        containsRect: function(b) {
            return Phaser.Rectangle.containsRect(b, this);
        },
        equals: function(b) {
            return Phaser.Rectangle.equals(this, b);
        },
        intersection: function(b, out) {
            return Phaser.Rectangle.intersection(this, b, out);
        },
        intersects: function(b) {
            return Phaser.Rectangle.intersects(this, b);
        },
        intersectsRaw: function(left, right, top, bottom, tolerance) {
            return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);
        },
        union: function(b, out) {
            return Phaser.Rectangle.union(this, b, out);
        },
        random: function(out) {
            if (out === undefined) {
                out = new Phaser.Point();
            }
            out.x = this.randomX;
            out.y = this.randomY;
            return out;
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        }
    };
    Object.defineProperty(Phaser.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value <= this.y) {
                this.height = 0;
            } else {
                this.height = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottomLeft", {
        get: function() {
            return new Phaser.Point(this.x, this.bottom);
        },
        set: function(value) {
            this.x = value.x;
            this.bottom = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new Phaser.Point(this.right, this.bottom);
        },
        set: function(value) {
            this.right = value.x;
            this.bottom = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            if (value >= this.right) {
                this.width = 0;
            } else {
                this.width = this.right - value;
            }
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value <= this.x) {
                this.width = 0;
            } else {
                this.width = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "perimeter", {
        get: function() {
            return this.width * 2 + this.height * 2;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth;
        },
        set: function(value) {
            this.x = value - this.halfWidth;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight;
        },
        set: function(value) {
            this.y = value - this.halfHeight;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            if (value >= this.bottom) {
                this.height = 0;
                this.y = value;
            } else {
                this.height = this.bottom - value;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topLeft", {
        get: function() {
            return new Phaser.Point(this.x, this.y);
        },
        set: function(value) {
            this.x = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topRight", {
        get: function() {
            return new Phaser.Point(this.x + this.width, this.y);
        },
        set: function(value) {
            this.right = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Rectangle.prototype.constructor = Phaser.Rectangle;
    Phaser.Rectangle.inflate = function(a, dx, dy) {
        a.x -= dx;
        a.width += 2 * dx;
        a.y -= dy;
        a.height += 2 * dy;
        return a;
    };
    Phaser.Rectangle.inflatePoint = function(a, point) {
        return Phaser.Rectangle.inflate(a, point.x, point.y);
    };
    Phaser.Rectangle.size = function(a, output) {
        if (output === undefined || output === null) {
            output = new Phaser.Point(a.width, a.height);
        } else {
            output.setTo(a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.clone = function(a, output) {
        if (output === undefined || output === null) {
            output = new Phaser.Rectangle(a.x, a.y, a.width, a.height);
        } else {
            output.setTo(a.x, a.y, a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        return x >= a.x && x < a.right && y >= a.y && y < a.bottom;
    };
    Phaser.Rectangle.containsRaw = function(rx, ry, rw, rh, x, y) {
        return x >= rx && x < rx + rw && y >= ry && y < ry + rh;
    };
    Phaser.Rectangle.containsPoint = function(a, point) {
        return Phaser.Rectangle.contains(a, point.x, point.y);
    };
    Phaser.Rectangle.containsRect = function(a, b) {
        if (a.volume > b.volume) {
            return false;
        }
        return a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
    };
    Phaser.Rectangle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
    };
    Phaser.Rectangle.sameDimensions = function(a, b) {
        return a.width === b.width && a.height === b.height;
    };
    Phaser.Rectangle.intersection = function(a, b, output) {
        if (output === undefined) {
            output = new Phaser.Rectangle();
        }
        if (Phaser.Rectangle.intersects(a, b)) {
            output.x = Math.max(a.x, b.x);
            output.y = Math.max(a.y, b.y);
            output.width = Math.min(a.right, b.right) - output.x;
            output.height = Math.min(a.bottom, b.bottom) - output.y;
        }
        return output;
    };
    Phaser.Rectangle.intersects = function(a, b) {
        if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) {
            return false;
        }
        return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    };
    Phaser.Rectangle.intersectsRaw = function(a, left, right, top, bottom, tolerance) {
        if (tolerance === undefined) {
            tolerance = 0;
        }
        return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);
    };
    Phaser.Rectangle.union = function(a, b, output) {
        if (output === undefined) {
            output = new Phaser.Rectangle();
        }
        return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
    };
    Phaser.Rectangle.aabb = function(points, out) {
        if (out === undefined) {
            out = new Phaser.Rectangle();
        }
        var xMax = Number.MIN_VALUE, xMin = Number.MAX_VALUE, yMax = Number.MIN_VALUE, yMin = Number.MAX_VALUE;
        points.forEach(function(point) {
            if (point.x > xMax) {
                xMax = point.x;
            }
            if (point.x < xMin) {
                xMin = point.x;
            }
            if (point.y > yMax) {
                yMax = point.y;
            }
            if (point.y < yMin) {
                yMin = point.y;
            }
        });
        out.setTo(xMin, yMin, xMax - xMin, yMax - yMin);
        return out;
    };
    PIXI.Rectangle = Phaser.Rectangle;
    PIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0);
    Phaser.RoundedRectangle = function(x, y, width, height, radius) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (width === undefined) {
            width = 0;
        }
        if (height === undefined) {
            height = 0;
        }
        if (radius === undefined) {
            radius = 20;
        }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.radius = radius || 20;
        this.type = Phaser.ROUNDEDRECTANGLE;
    };
    Phaser.RoundedRectangle.prototype = {
        clone: function() {
            return new Phaser.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        },
        contains: function(x, y) {
            if (this.width <= 0 || this.height <= 0) {
                return false;
            }
            var x1 = this.x;
            if (x >= x1 && x <= x1 + this.width) {
                var y1 = this.y;
                if (y >= y1 && y <= y1 + this.height) {
                    return true;
                }
            }
            return false;
        }
    };
    Phaser.RoundedRectangle.prototype.constructor = Phaser.RoundedRectangle;
    PIXI.RoundedRectangle = Phaser.RoundedRectangle;
    Phaser.Camera = function(game, id, x, y, width, height) {
        this.game = game;
        this.world = game.world;
        this.id = 0;
        this.view = new Phaser.Rectangle(x, y, width, height);
        this.bounds = new Phaser.Rectangle(x, y, width, height);
        this.deadzone = null;
        this.visible = true;
        this.roundPx = true;
        this.atLimit = {
            x: false,
            y: false
        };
        this.target = null;
        this.displayObject = null;
        this.scale = null;
        this.totalInView = 0;
        this._targetPosition = new Phaser.Point();
        this._edge = 0;
        this._position = new Phaser.Point();
    };
    Phaser.Camera.FOLLOW_LOCKON = 0;
    Phaser.Camera.FOLLOW_PLATFORMER = 1;
    Phaser.Camera.FOLLOW_TOPDOWN = 2;
    Phaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    Phaser.Camera.prototype = {
        preUpdate: function() {
            this.totalInView = 0;
        },
        follow: function(target, style) {
            if (style === undefined) {
                style = Phaser.Camera.FOLLOW_LOCKON;
            }
            this.target = target;
            var helper;
            switch (style) {
              case Phaser.Camera.FOLLOW_PLATFORMER:
                var w = this.width / 8;
                var h = this.height / 3;
                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * .25, w, h);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN:
                helper = Math.max(this.width, this.height) / 4;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:
                helper = Math.max(this.width, this.height) / 8;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_LOCKON:
                this.deadzone = null;
                break;

              default:
                this.deadzone = null;
                break;
            }
        },
        unfollow: function() {
            this.target = null;
        },
        focusOn: function(displayObject) {
            this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));
        },
        focusOnXY: function(x, y) {
            this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));
        },
        update: function() {
            if (this.target) {
                this.updateTarget();
            }
            if (this.bounds) {
                this.checkBounds();
            }
            if (this.roundPx) {
                this.view.floor();
            }
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y;
        },
        updateTarget: function() {
            this._targetPosition.copyFrom(this.target);
            if (this.target.parent) {
                this._targetPosition.multiply(this.target.parent.worldTransform.a, this.target.parent.worldTransform.d);
            }
            if (this.deadzone) {
                this._edge = this._targetPosition.x - this.view.x;
                if (this._edge < this.deadzone.left) {
                    this.view.x = this._targetPosition.x - this.deadzone.left;
                } else if (this._edge > this.deadzone.right) {
                    this.view.x = this._targetPosition.x - this.deadzone.right;
                }
                this._edge = this._targetPosition.y - this.view.y;
                if (this._edge < this.deadzone.top) {
                    this.view.y = this._targetPosition.y - this.deadzone.top;
                } else if (this._edge > this.deadzone.bottom) {
                    this.view.y = this._targetPosition.y - this.deadzone.bottom;
                }
            } else {
                this.view.x = this._targetPosition.x - this.view.halfWidth;
                this.view.y = this._targetPosition.y - this.view.halfHeight;
            }
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds);
        },
        checkBounds: function() {
            this.atLimit.x = false;
            this.atLimit.y = false;
            if (this.view.x <= this.bounds.x) {
                this.atLimit.x = true;
                this.view.x = this.bounds.x;
            }
            if (this.view.right >= this.bounds.right) {
                this.atLimit.x = true;
                this.view.x = this.bounds.right - this.width;
            }
            if (this.view.y <= this.bounds.top) {
                this.atLimit.y = true;
                this.view.y = this.bounds.top;
            }
            if (this.view.bottom >= this.bounds.bottom) {
                this.atLimit.y = true;
                this.view.y = this.bounds.bottom - this.height;
            }
        },
        setPosition: function(x, y) {
            this.view.x = x;
            this.view.y = y;
            if (this.bounds) {
                this.checkBounds();
            }
        },
        setSize: function(width, height) {
            this.view.width = width;
            this.view.height = height;
        },
        reset: function() {
            this.target = null;
            this.view.x = 0;
            this.view.y = 0;
        }
    };
    Phaser.Camera.prototype.constructor = Phaser.Camera;
    Object.defineProperty(Phaser.Camera.prototype, "x", {
        get: function() {
            return this.view.x;
        },
        set: function(value) {
            this.view.x = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "y", {
        get: function() {
            return this.view.y;
        },
        set: function(value) {
            this.view.y = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "position", {
        get: function() {
            this._position.set(this.view.centerX, this.view.centerY);
            return this._position;
        },
        set: function(value) {
            if (typeof value.x !== "undefined") {
                this.view.x = value.x;
            }
            if (typeof value.y !== "undefined") {
                this.view.y = value.y;
            }
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "width", {
        get: function() {
            return this.view.width;
        },
        set: function(value) {
            this.view.width = value;
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "height", {
        get: function() {
            return this.view.height;
        },
        set: function(value) {
            this.view.height = value;
        }
    });
    Phaser.Create = function(game) {
        this.game = game;
        this.bmd = game.make.bitmapData();
        this.canvas = this.bmd.canvas;
        this.ctx = this.bmd.context;
        this.palettes = [ {
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
        }, {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
        }, {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
        } ];
    };
    Phaser.Create.PALETTE_ARNE = 0;
    Phaser.Create.PALETTE_JMP = 1;
    Phaser.Create.PALETTE_CGA = 2;
    Phaser.Create.PALETTE_C64 = 3;
    Phaser.Create.PALETTE_JAPANESE_MACHINE = 4;
    Phaser.Create.prototype = {
        texture: function(key, data, pixelWidth, pixelHeight, palette) {
            if (pixelWidth === undefined) {
                pixelWidth = 8;
            }
            if (pixelHeight === undefined) {
                pixelHeight = pixelWidth;
            }
            if (palette === undefined) {
                palette = 0;
            }
            var w = data[0].length * pixelWidth;
            var h = data.length * pixelHeight;
            this.bmd.resize(w, h);
            this.bmd.clear();
            for (var y = 0; y < data.length; y++) {
                var row = data[y];
                for (var x = 0; x < row.length; x++) {
                    var d = row[x];
                    if (d !== "." && d !== " ") {
                        this.ctx.fillStyle = this.palettes[palette][d];
                        this.ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
                    }
                }
            }
            return this.bmd.generateTexture(key);
        },
        grid: function(key, width, height, cellWidth, cellHeight, color) {
            this.bmd.resize(width, height);
            this.ctx.fillStyle = color;
            for (var y = 0; y < height; y += cellHeight) {
                this.ctx.fillRect(0, y, width, 1);
            }
            for (var x = 0; x < width; x += cellWidth) {
                this.ctx.fillRect(x, 0, 1, height);
            }
            return this.bmd.generateTexture(key);
        }
    };
    Phaser.Create.prototype.constructor = Phaser.Create;
    Phaser.State = function() {
        this.game = null;
        this.key = "";
        this.add = null;
        this.make = null;
        this.camera = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.sound = null;
        this.scale = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.particles = null;
        this.physics = null;
        this.rnd = null;
    };
    Phaser.State.prototype = {
        init: function() {},
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        preRender: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        resumed: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    };
    Phaser.State.prototype.constructor = Phaser.State;
    Phaser.StateManager = function(game, pendingState) {
        this.game = game;
        this.states = {};
        this._pendingState = null;
        if (typeof pendingState !== "undefined" && pendingState !== null) {
            this._pendingState = pendingState;
        }
        this._clearWorld = false;
        this._clearCache = false;
        this._created = false;
        this._args = [];
        this.current = "";
        this.onStateChange = new Phaser.Signal();
        this.onInitCallback = null;
        this.onPreloadCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onResizeCallback = null;
        this.onPreRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onLoadRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
        this.onShutDownCallback = null;
    };
    Phaser.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this);
            this.game.onResume.add(this.resume, this);
            if (this._pendingState !== null && typeof this._pendingState !== "string") {
                this.add("default", this._pendingState, true);
            }
        },
        add: function(key, state, autoStart) {
            if (autoStart === undefined) {
                autoStart = false;
            }
            var newState;
            if (state instanceof Phaser.State) {
                newState = state;
            } else if (typeof state === "object") {
                newState = state;
                newState.game = this.game;
            } else if (typeof state === "function") {
                newState = new state(this.game);
            }
            this.states[key] = newState;
            if (autoStart) {
                if (this.game.isBooted) {
                    this.start(key);
                } else {
                    this._pendingState = key;
                }
            }
            return newState;
        },
        remove: function(key) {
            if (this.current === key) {
                this.callbackContext = null;
                this.onInitCallback = null;
                this.onShutDownCallback = null;
                this.onPreloadCallback = null;
                this.onLoadRenderCallback = null;
                this.onLoadUpdateCallback = null;
                this.onCreateCallback = null;
                this.onUpdateCallback = null;
                this.onPreRenderCallback = null;
                this.onRenderCallback = null;
                this.onResizeCallback = null;
                this.onPausedCallback = null;
                this.onResumedCallback = null;
                this.onPauseUpdateCallback = null;
            }
            delete this.states[key];
        },
        start: function(key, clearWorld, clearCache) {
            if (clearWorld === undefined) {
                clearWorld = true;
            }
            if (clearCache === undefined) {
                clearCache = false;
            }
            if (this.checkState(key)) {
                this._pendingState = key;
                this._clearWorld = clearWorld;
                this._clearCache = clearCache;
                if (arguments.length > 3) {
                    this._args = Array.prototype.splice.call(arguments, 3);
                }
            }
        },
        restart: function(clearWorld, clearCache) {
            if (clearWorld === undefined) {
                clearWorld = true;
            }
            if (clearCache === undefined) {
                clearCache = false;
            }
            this._pendingState = this.current;
            this._clearWorld = clearWorld;
            this._clearCache = clearCache;
            if (arguments.length > 2) {
                this._args = Array.prototype.splice.call(arguments, 2);
            }
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                var previousStateKey = this.current;
                this.clearCurrentState();
                this.setCurrentState(this._pendingState);
                this.onStateChange.dispatch(this.current, previousStateKey);
                if (this.current !== this._pendingState) {
                    return;
                } else {
                    this._pendingState = null;
                }
                if (this.onPreloadCallback) {
                    this.game.load.reset(true);
                    this.onPreloadCallback.call(this.callbackContext, this.game);
                    if (this.game.load.totalQueuedFiles() === 0 && this.game.load.totalQueuedPacks() === 0) {
                        this.loadComplete();
                    } else {
                        this.game.load.start();
                    }
                } else {
                    this.loadComplete();
                }
            }
        },
        clearCurrentState: function() {
            if (this.current) {
                if (this.onShutDownCallback) {
                    this.onShutDownCallback.call(this.callbackContext, this.game);
                }
                this.game.tweens.removeAll();
                this.game.camera.reset();
                this.game.input.reset(true);
                this.game.physics.clear();
                this.game.time.removeAll();
                this.game.scale.reset(this._clearWorld);
                if (this.game.debug) {
                    this.game.debug.reset();
                }
                if (this._clearWorld) {
                    this.game.world.shutdown();
                    if (this._clearCache === true) {
                        this.game.cache.destroy();
                    }
                }
            }
        },
        checkState: function(key) {
            if (this.states[key]) {
                var valid = false;
                if (this.states[key]["preload"] || this.states[key]["create"] || this.states[key]["update"] || this.states[key]["render"]) {
                    valid = true;
                }
                if (valid === false) {
                    console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render");
                    return false;
                }
                return true;
            } else {
                console.warn("Phaser.StateManager - No state found with the key: " + key);
                return false;
            }
        },
        link: function(key) {
            this.states[key].game = this.game;
            this.states[key].add = this.game.add;
            this.states[key].make = this.game.make;
            this.states[key].camera = this.game.camera;
            this.states[key].cache = this.game.cache;
            this.states[key].input = this.game.input;
            this.states[key].load = this.game.load;
            this.states[key].math = this.game.math;
            this.states[key].sound = this.game.sound;
            this.states[key].scale = this.game.scale;
            this.states[key].state = this;
            this.states[key].stage = this.game.stage;
            this.states[key].time = this.game.time;
            this.states[key].tweens = this.game.tweens;
            this.states[key].world = this.game.world;
            this.states[key].particles = this.game.particles;
            this.states[key].rnd = this.game.rnd;
            this.states[key].physics = this.game.physics;
            this.states[key].key = key;
        },
        unlink: function(key) {
            if (this.states[key]) {
                this.states[key].game = null;
                this.states[key].add = null;
                this.states[key].make = null;
                this.states[key].camera = null;
                this.states[key].cache = null;
                this.states[key].input = null;
                this.states[key].load = null;
                this.states[key].math = null;
                this.states[key].sound = null;
                this.states[key].scale = null;
                this.states[key].state = null;
                this.states[key].stage = null;
                this.states[key].time = null;
                this.states[key].tweens = null;
                this.states[key].world = null;
                this.states[key].particles = null;
                this.states[key].rnd = null;
                this.states[key].physics = null;
            }
        },
        setCurrentState: function(key) {
            this.callbackContext = this.states[key];
            this.link(key);
            this.onInitCallback = this.states[key]["init"] || this.dummy;
            this.onPreloadCallback = this.states[key]["preload"] || null;
            this.onLoadRenderCallback = this.states[key]["loadRender"] || null;
            this.onLoadUpdateCallback = this.states[key]["loadUpdate"] || null;
            this.onCreateCallback = this.states[key]["create"] || null;
            this.onUpdateCallback = this.states[key]["update"] || null;
            this.onPreRenderCallback = this.states[key]["preRender"] || null;
            this.onRenderCallback = this.states[key]["render"] || null;
            this.onResizeCallback = this.states[key]["resize"] || null;
            this.onPausedCallback = this.states[key]["paused"] || null;
            this.onResumedCallback = this.states[key]["resumed"] || null;
            this.onPauseUpdateCallback = this.states[key]["pauseUpdate"] || null;
            this.onShutDownCallback = this.states[key]["shutdown"] || this.dummy;
            if (this.current !== "") {
                this.game.physics.reset();
            }
            this.current = key;
            this._created = false;
            this.onInitCallback.apply(this.callbackContext, this._args);
            if (key === this._pendingState) {
                this._args = [];
            }
            this.game._kickstart = true;
        },
        getCurrentState: function() {
            return this.states[this.current];
        },
        loadComplete: function() {
            if (this._created === false && this.onCreateCallback) {
                this._created = true;
                this.onCreateCallback.call(this.callbackContext, this.game);
            } else {
                this._created = true;
            }
        },
        pause: function() {
            if (this._created && this.onPausedCallback) {
                this.onPausedCallback.call(this.callbackContext, this.game);
            }
        },
        resume: function() {
            if (this._created && this.onResumedCallback) {
                this.onResumedCallback.call(this.callbackContext, this.game);
            }
        },
        update: function() {
            if (this._created) {
                if (this.onUpdateCallback) {
                    this.onUpdateCallback.call(this.callbackContext, this.game);
                }
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        pauseUpdate: function() {
            if (this._created) {
                if (this.onPauseUpdateCallback) {
                    this.onPauseUpdateCallback.call(this.callbackContext, this.game);
                }
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        preRender: function(elapsedTime) {
            if (this._created && this.onPreRenderCallback) {
                this.onPreRenderCallback.call(this.callbackContext, this.game, elapsedTime);
            }
        },
        resize: function(width, height) {
            if (this.onResizeCallback) {
                this.onResizeCallback.call(this.callbackContext, width, height);
            }
        },
        render: function() {
            if (this._created) {
                if (this.onRenderCallback) {
                    if (this.game.renderType === Phaser.CANVAS) {
                        this.game.context.save();
                        this.game.context.setTransform(1, 0, 0, 1, 0, 0);
                        this.onRenderCallback.call(this.callbackContext, this.game);
                        this.game.context.restore();
                    } else {
                        this.onRenderCallback.call(this.callbackContext, this.game);
                    }
                }
            } else {
                if (this.onLoadRenderCallback) {
                    this.onLoadRenderCallback.call(this.callbackContext, this.game);
                }
            }
        },
        destroy: function() {
            this.clearCurrentState();
            this.callbackContext = null;
            this.onInitCallback = null;
            this.onShutDownCallback = null;
            this.onPreloadCallback = null;
            this.onLoadRenderCallback = null;
            this.onLoadUpdateCallback = null;
            this.onCreateCallback = null;
            this.onUpdateCallback = null;
            this.onRenderCallback = null;
            this.onPausedCallback = null;
            this.onResumedCallback = null;
            this.onPauseUpdateCallback = null;
            this.game = null;
            this.states = {};
            this._pendingState = null;
            this.current = "";
        }
    };
    Phaser.StateManager.prototype.constructor = Phaser.StateManager;
    Object.defineProperty(Phaser.StateManager.prototype, "created", {
        get: function() {
            return this._created;
        }
    });
    Phaser.Signal = function() {};
    Phaser.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: false,
        _shouldPropagate: true,
        active: true,
        _boundDispatch: true,
        validateListener: function(listener, fnName) {
            if (typeof listener !== "function") {
                throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
            }
        },
        _registerListener: function(listener, isOnce, listenerContext, priority, args) {
            var prevIndex = this._indexOfListener(listener, listenerContext);
            var binding;
            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
                }
            } else {
                binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority, args);
                this._addBinding(binding);
            }
            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }
            return binding;
        },
        _addBinding: function(binding) {
            if (!this._bindings) {
                this._bindings = [];
            }
            var n = this._bindings.length;
            do {
                n--;
            } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },
        _indexOfListener: function(listener, context) {
            if (!this._bindings) {
                return -1;
            }
            if (context === undefined) {
                context = null;
            }
            var n = this._bindings.length;
            var cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },
        has: function(listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },
        add: function(listener, listenerContext, priority) {
            this.validateListener(listener, "add");
            var args = [];
            if (arguments.length > 3) {
                for (var i = 3; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            return this._registerListener(listener, false, listenerContext, priority, args);
        },
        addOnce: function(listener, listenerContext, priority) {
            this.validateListener(listener, "addOnce");
            var args = [];
            if (arguments.length > 3) {
                for (var i = 3; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            return this._registerListener(listener, true, listenerContext, priority, args);
        },
        remove: function(listener, context) {
            this.validateListener(listener, "remove");
            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy();
                this._bindings.splice(i, 1);
            }
            return listener;
        },
        removeAll: function(context) {
            if (context === undefined) {
                context = null;
            }
            if (!this._bindings) {
                return;
            }
            var n = this._bindings.length;
            while (n--) {
                if (context) {
                    if (this._bindings[n].context === context) {
                        this._bindings[n]._destroy();
                        this._bindings.splice(n, 1);
                    }
                } else {
                    this._bindings[n]._destroy();
                }
            }
            if (!context) {
                this._bindings.length = 0;
            }
        },
        getNumListeners: function() {
            return this._bindings ? this._bindings.length : 0;
        },
        halt: function() {
            this._shouldPropagate = false;
        },
        dispatch: function() {
            if (!this.active || !this._bindings) {
                return;
            }
            var paramsArr = Array.prototype.slice.call(arguments);
            var n = this._bindings.length;
            var bindings;
            if (this.memorize) {
                this._prevParams = paramsArr;
            }
            if (!n) {
                return;
            }
            bindings = this._bindings.slice();
            this._shouldPropagate = true;
            do {
                n--;
            } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },
        forget: function() {
            if (this._prevParams) {
                this._prevParams = null;
            }
        },
        dispose: function() {
            this.removeAll();
            this._bindings = null;
            if (this._prevParams) {
                this._prevParams = null;
            }
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    };
    Object.defineProperty(Phaser.Signal.prototype, "boundDispatch", {
        get: function() {
            var _this = this;
            return this._boundDispatch || (this._boundDispatch = function() {
                return _this.dispatch.apply(_this, arguments);
            });
        }
    });
    Phaser.Signal.prototype.constructor = Phaser.Signal;
    Phaser.SignalBinding = function(signal, listener, isOnce, listenerContext, priority, args) {
        this._listener = listener;
        if (isOnce) {
            this._isOnce = true;
        }
        if (listenerContext != null) {
            this.context = listenerContext;
        }
        this._signal = signal;
        if (priority) {
            this._priority = priority;
        }
        if (args && args.length) {
            this._args = args;
        }
    };
    Phaser.SignalBinding.prototype = {
        context: null,
        _isOnce: false,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: true,
        params: null,
        execute: function(paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                if (this._args) {
                    params = params.concat(this._args);
                }
                handlerReturn = this._listener.apply(this.context, params);
                this.callCount++;
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    };
    Phaser.SignalBinding.prototype.constructor = Phaser.SignalBinding;
    Phaser.Filter = function(game, uniforms, fragmentSrc) {
        this.game = game;
        this.type = Phaser.WEBGL_FILTER;
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.prevPoint = new Phaser.Point();
        var d = new Date();
        this.uniforms = {
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            time: {
                type: "1f",
                value: 0
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            date: {
                type: "4fv",
                value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ]
            },
            sampleRate: {
                type: "1f",
                value: 44100
            },
            iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: true
                }
            },
            iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: true
                }
            },
            iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: true
                }
            },
            iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: true
                }
            }
        };
        if (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        }
        this.fragmentSrc = fragmentSrc || "";
    };
    Phaser.Filter.prototype = {
        init: function() {},
        setResolution: function(width, height) {
            this.uniforms.resolution.value.x = width;
            this.uniforms.resolution.value.y = height;
        },
        update: function(pointer) {
            if (typeof pointer !== "undefined") {
                var x = pointer.x / this.game.width;
                var y = 1 - pointer.y / this.game.height;
                if (x !== this.prevPoint.x || y !== this.prevPoint.y) {
                    this.uniforms.mouse.value.x = x.toFixed(2);
                    this.uniforms.mouse.value.y = y.toFixed(2);
                    this.prevPoint.set(x, y);
                }
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        destroy: function() {
            this.game = null;
        }
    };
    Phaser.Filter.prototype.constructor = Phaser.Filter;
    Object.defineProperty(Phaser.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x;
        },
        set: function(value) {
            this.uniforms.resolution.value.x = value;
        }
    });
    Object.defineProperty(Phaser.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y;
        },
        set: function(value) {
            this.uniforms.resolution.value.y = value;
        }
    });
    Phaser.Plugin = function(game, parent) {
        if (parent === undefined) {
            parent = null;
        }
        this.game = game;
        this.parent = parent;
        this.active = false;
        this.visible = false;
        this.hasPreUpdate = false;
        this.hasUpdate = false;
        this.hasPostUpdate = false;
        this.hasRender = false;
        this.hasPostRender = false;
    };
    Phaser.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null;
            this.parent = null;
            this.active = false;
            this.visible = false;
        }
    };
    Phaser.Plugin.prototype.constructor = Phaser.Plugin;
    Phaser.PluginManager = function(game) {
        this.game = game;
        this.plugins = [];
        this._len = 0;
        this._i = 0;
    };
    Phaser.PluginManager.prototype = {
        add: function(plugin) {
            var args = Array.prototype.splice.call(arguments, 1);
            var result = false;
            if (typeof plugin === "function") {
                plugin = new plugin(this.game, this);
            } else {
                plugin.game = this.game;
                plugin.parent = this;
            }
            if (typeof plugin["preUpdate"] === "function") {
                plugin.hasPreUpdate = true;
                result = true;
            }
            if (typeof plugin["update"] === "function") {
                plugin.hasUpdate = true;
                result = true;
            }
            if (typeof plugin["postUpdate"] === "function") {
                plugin.hasPostUpdate = true;
                result = true;
            }
            if (typeof plugin["render"] === "function") {
                plugin.hasRender = true;
                result = true;
            }
            if (typeof plugin["postRender"] === "function") {
                plugin.hasPostRender = true;
                result = true;
            }
            if (result) {
                if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate) {
                    plugin.active = true;
                }
                if (plugin.hasRender || plugin.hasPostRender) {
                    plugin.visible = true;
                }
                this._len = this.plugins.push(plugin);
                if (typeof plugin["init"] === "function") {
                    plugin.init.apply(plugin, args);
                }
                return plugin;
            } else {
                return null;
            }
        },
        remove: function(plugin) {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i] === plugin) {
                    plugin.destroy();
                    this.plugins.splice(this._i, 1);
                    this._len--;
                    return;
                }
            }
        },
        removeAll: function() {
            this._i = this._len;
            while (this._i--) {
                this.plugins[this._i].destroy();
            }
            this.plugins.length = 0;
            this._len = 0;
        },
        preUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) {
                    this.plugins[this._i].preUpdate();
                }
            }
        },
        update: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) {
                    this.plugins[this._i].update();
                }
            }
        },
        postUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) {
                    this.plugins[this._i].postUpdate();
                }
            }
        },
        render: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) {
                    this.plugins[this._i].render();
                }
            }
        },
        postRender: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) {
                    this.plugins[this._i].postRender();
                }
            }
        },
        destroy: function() {
            this.removeAll();
            this.game = null;
        }
    };
    Phaser.PluginManager.prototype.constructor = Phaser.PluginManager;
    Phaser.Stage = function(game) {
        this.game = game;
        PIXI.Stage.call(this, 0);
        this.name = "_stage_root";
        this.disableVisibilityChange = false;
        this.exists = true;
        this.currentRenderOrderID = 0;
        this._hiddenVar = "hidden";
        this._onChange = null;
        this._backgroundColor = 0;
        if (game.config) {
            this.parseConfig(game.config);
        }
    };
    Phaser.Stage.prototype = Object.create(PIXI.Stage.prototype);
    Phaser.Stage.prototype.constructor = Phaser.Stage;
    Phaser.Stage.prototype.parseConfig = function(config) {
        if (config["disableVisibilityChange"]) {
            this.disableVisibilityChange = config["disableVisibilityChange"];
        }
        if (config["backgroundColor"]) {
            this.backgroundColor = config["backgroundColor"];
        }
    };
    Phaser.Stage.prototype.boot = function() {
        Phaser.DOM.getOffset(this.game.canvas, this.offset);
        Phaser.Canvas.setUserSelect(this.game.canvas, "none");
        Phaser.Canvas.setTouchAction(this.game.canvas, "none");
        this.checkVisibility();
    };
    Phaser.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].preUpdate();
        }
    };
    Phaser.Stage.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Stage.prototype.postUpdate = function() {
        if (this.game.world.camera.target) {
            this.game.world.camera.target.postUpdate();
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                if (this.children[i] !== this.game.world.camera.target) {
                    this.children[i].postUpdate();
                }
            }
        } else {
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                this.children[i].postUpdate();
            }
        }
    };
    Phaser.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].updateTransform();
        }
    };
    Phaser.Stage.prototype.checkVisibility = function() {
        if (document.webkitHidden !== undefined) {
            this._hiddenVar = "webkitvisibilitychange";
        } else if (document.mozHidden !== undefined) {
            this._hiddenVar = "mozvisibilitychange";
        } else if (document.msHidden !== undefined) {
            this._hiddenVar = "msvisibilitychange";
        } else if (document.hidden !== undefined) {
            this._hiddenVar = "visibilitychange";
        } else {
            this._hiddenVar = null;
        }
        var _this = this;
        this._onChange = function(event) {
            return _this.visibilityChange(event);
        };
        if (this._hiddenVar) {
            document.addEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onblur = this._onChange;
        window.onfocus = this._onChange;
        window.onpagehide = this._onChange;
        window.onpageshow = this._onChange;
        if (this.game.device.cocoonJSApp) {
            CocoonJS.App.onSuspended.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "pause"
                });
            });
            CocoonJS.App.onActivated.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "resume"
                });
            });
        }
    };
    Phaser.Stage.prototype.visibilityChange = function(event) {
        if (event.type === "pagehide" || event.type === "blur" || event.type === "pageshow" || event.type === "focus") {
            if (event.type === "pagehide" || event.type === "blur") {
                this.game.focusLoss(event);
            } else if (event.type === "pageshow" || event.type === "focus") {
                this.game.focusGain(event);
            }
            return;
        }
        if (this.disableVisibilityChange) {
            return;
        }
        if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || event.type === "pause") {
            this.game.gamePaused(event);
        } else {
            this.game.gameResumed(event);
        }
    };
    Phaser.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        var rgb = Phaser.Color.valueToColor(backgroundColor);
        this._backgroundColor = Phaser.Color.getColor(rgb.r, rgb.g, rgb.b);
        this.backgroundColorSplit = [ rgb.r / 255, rgb.g / 255, rgb.b / 255 ];
        this.backgroundColorString = Phaser.Color.RGBtoString(rgb.r, rgb.g, rgb.b, 255, "#");
    };
    Phaser.Stage.prototype.destroy = function() {
        if (this._hiddenVar) {
            document.removeEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onpagehide = null;
        window.onpageshow = null;
        window.onblur = null;
        window.onfocus = null;
    };
    Object.defineProperty(Phaser.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor;
        },
        set: function(color) {
            if (!this.game.transparent) {
                this.setBackgroundColor(color);
            }
        }
    });
    Object.defineProperty(Phaser.Stage.prototype, "smoothed", {
        get: function() {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
        },
        set: function(value) {
            if (value) {
                PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR;
            } else {
                PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST;
            }
        }
    });
    Phaser.Group = function(game, parent, name, addToStage, enableBody, physicsBodyType) {
        if (addToStage === undefined) {
            addToStage = false;
        }
        if (enableBody === undefined) {
            enableBody = false;
        }
        if (physicsBodyType === undefined) {
            physicsBodyType = Phaser.Physics.ARCADE;
        }
        this.game = game;
        if (parent === undefined) {
            parent = game.world;
        }
        this.name = name || "group";
        this.z = 0;
        PIXI.DisplayObjectContainer.call(this);
        if (addToStage) {
            this.game.stage.addChild(this);
            this.z = this.game.stage.children.length;
        } else {
            if (parent) {
                parent.addChild(this);
                this.z = parent.children.length;
            }
        }
        this.type = Phaser.GROUP;
        this.physicsType = Phaser.GROUP;
        this.alive = true;
        this.exists = true;
        this.ignoreDestroy = false;
        this.pendingDestroy = false;
        this.classType = Phaser.Sprite;
        this.cursor = null;
        this.enableBody = enableBody;
        this.enableBodyDebug = false;
        this.physicsBodyType = physicsBodyType;
        this.physicsSortDirection = null;
        this.onDestroy = new Phaser.Signal();
        this.cursorIndex = 0;
        this.fixedToCamera = false;
        this.cameraOffset = new Phaser.Point();
        this.hash = [];
        this._sortProperty = "z";
    };
    Phaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    Phaser.Group.prototype.constructor = Phaser.Group;
    Phaser.Group.RETURN_NONE = 0;
    Phaser.Group.RETURN_TOTAL = 1;
    Phaser.Group.RETURN_CHILD = 2;
    Phaser.Group.SORT_ASCENDING = -1;
    Phaser.Group.SORT_DESCENDING = 1;
    Phaser.Group.prototype.add = function(child, silent) {
        if (silent === undefined) {
            silent = false;
        }
        if (child.parent !== this) {
            this.addChild(child);
            child.z = this.children.length;
            if (this.enableBody && child.body === null) {
                this.game.physics.enable(child, this.physicsBodyType);
            } else if (child.body) {
                this.addToHash(child);
            }
            if (!silent && child.events) {
                child.events.onAddedToGroup$dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.addToHash = function(child) {
        if (child.parent === this) {
            var index = this.hash.indexOf(child);
            if (index === -1) {
                this.hash.push(child);
                return true;
            }
        }
        return false;
    };
    Phaser.Group.prototype.removeFromHash = function(child) {
        if (child) {
            var index = this.hash.indexOf(child);
            if (index !== -1) {
                this.hash.splice(index, 1);
                return true;
            }
        }
        return false;
    };
    Phaser.Group.prototype.addMultiple = function(children, silent) {
        if (children instanceof Phaser.Group) {
            children.moveAll(this, silent);
        } else if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                this.add(children[i], silent);
            }
        }
        return children;
    };
    Phaser.Group.prototype.addAt = function(child, index, silent) {
        if (silent === undefined) {
            silent = false;
        }
        if (child.parent !== this) {
            this.addChildAt(child, index);
            this.updateZ();
            if (this.enableBody && child.body === null) {
                this.game.physics.enable(child, this.physicsBodyType);
            } else if (child.body) {
                this.addToHash(child);
            }
            if (!silent && child.events) {
                child.events.onAddedToGroup$dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.getAt = function(index) {
        if (index < 0 || index >= this.children.length) {
            return -1;
        } else {
            return this.getChildAt(index);
        }
    };
    Phaser.Group.prototype.create = function(x, y, key, frame, exists) {
        if (exists === undefined) {
            exists = true;
        }
        var child = new this.classType(this.game, x, y, key, frame);
        child.exists = exists;
        child.visible = exists;
        child.alive = exists;
        this.addChild(child);
        child.z = this.children.length;
        if (this.enableBody) {
            this.game.physics.enable(child, this.physicsBodyType, this.enableBodyDebug);
        }
        if (child.events) {
            child.events.onAddedToGroup$dispatch(child, this);
        }
        if (this.cursor === null) {
            this.cursor = child;
        }
        return child;
    };
    Phaser.Group.prototype.createMultiple = function(quantity, key, frame, exists) {
        if (exists === undefined) {
            exists = false;
        }
        for (var i = 0; i < quantity; i++) {
            this.create(0, 0, key, frame, exists);
        }
    };
    Phaser.Group.prototype.updateZ = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].z = i;
        }
    };
    Phaser.Group.prototype.resetCursor = function(index) {
        if (index === undefined) {
            index = 0;
        }
        if (index > this.children.length - 1) {
            index = 0;
        }
        if (this.cursor) {
            this.cursorIndex = index;
            this.cursor = this.children[this.cursorIndex];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.next = function() {
        if (this.cursor) {
            if (this.cursorIndex >= this.children.length - 1) {
                this.cursorIndex = 0;
            } else {
                this.cursorIndex++;
            }
            this.cursor = this.children[this.cursorIndex];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.previous = function() {
        if (this.cursor) {
            if (this.cursorIndex === 0) {
                this.cursorIndex = this.children.length - 1;
            } else {
                this.cursorIndex--;
            }
            this.cursor = this.children[this.cursorIndex];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.swap = function(child1, child2) {
        this.swapChildren(child1, child2);
        this.updateZ();
    };
    Phaser.Group.prototype.bringToTop = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length) {
            this.remove(child, false, true);
            this.add(child, true);
        }
        return child;
    };
    Phaser.Group.prototype.sendToBack = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            this.remove(child, false, true);
            this.addAt(child, 0, true);
        }
        return child;
    };
    Phaser.Group.prototype.moveUp = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length - 1) {
            var a = this.getIndex(child);
            var b = this.getAt(a + 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.moveDown = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            var a = this.getIndex(child);
            var b = this.getAt(a - 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.xy = function(index, x, y) {
        if (index < 0 || index > this.children.length) {
            return -1;
        } else {
            this.getChildAt(index).x = x;
            this.getChildAt(index).y = y;
        }
    };
    Phaser.Group.prototype.reverse = function() {
        this.children.reverse();
        this.updateZ();
    };
    Phaser.Group.prototype.getIndex = function(child) {
        return this.children.indexOf(child);
    };
    Phaser.Group.prototype.replace = function(oldChild, newChild) {
        var index = this.getIndex(oldChild);
        if (index !== -1) {
            if (newChild.parent) {
                if (newChild.parent instanceof Phaser.Group) {
                    newChild.parent.remove(newChild);
                } else {
                    newChild.parent.removeChild(newChild);
                }
            }
            this.remove(oldChild);
            this.addAt(newChild, index);
            return oldChild;
        }
    };
    Phaser.Group.prototype.hasProperty = function(child, key) {
        var len = key.length;
        if (len === 1 && key[0] in child) {
            return true;
        } else if (len === 2 && key[0] in child && key[1] in child[key[0]]) {
            return true;
        } else if (len === 3 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]]) {
            return true;
        } else if (len === 4 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]]) {
            return true;
        }
        return false;
    };
    Phaser.Group.prototype.setProperty = function(child, key, value, operation, force) {
        if (force === undefined) {
            force = false;
        }
        operation = operation || 0;
        if (!this.hasProperty(child, key) && (!force || operation > 0)) {
            return false;
        }
        var len = key.length;
        if (len === 1) {
            if (operation === 0) {
                child[key[0]] = value;
            } else if (operation == 1) {
                child[key[0]] += value;
            } else if (operation == 2) {
                child[key[0]] -= value;
            } else if (operation == 3) {
                child[key[0]] *= value;
            } else if (operation == 4) {
                child[key[0]] /= value;
            }
        } else if (len === 2) {
            if (operation === 0) {
                child[key[0]][key[1]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]] /= value;
            }
        } else if (len === 3) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]] /= value;
            }
        } else if (len === 4) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]][key[3]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]][key[3]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]][key[3]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]][key[3]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]][key[3]] /= value;
            }
        }
        return true;
    };
    Phaser.Group.prototype.checkProperty = function(child, key, value, force) {
        if (force === undefined) {
            force = false;
        }
        if (!Phaser.Utils.getProperty(child, key) && force) {
            return false;
        }
        if (Phaser.Utils.getProperty(child, key) !== value) {
            return false;
        }
        return true;
    };
    Phaser.Group.prototype.set = function(child, key, value, checkAlive, checkVisible, operation, force) {
        if (force === undefined) {
            force = false;
        }
        key = key.split(".");
        if (checkAlive === undefined) {
            checkAlive = false;
        }
        if (checkVisible === undefined) {
            checkVisible = false;
        }
        if ((checkAlive === false || checkAlive && child.alive) && (checkVisible === false || checkVisible && child.visible)) {
            return this.setProperty(child, key, value, operation, force);
        }
    };
    Phaser.Group.prototype.setAll = function(key, value, checkAlive, checkVisible, operation, force) {
        if (checkAlive === undefined) {
            checkAlive = false;
        }
        if (checkVisible === undefined) {
            checkVisible = false;
        }
        if (force === undefined) {
            force = false;
        }
        key = key.split(".");
        operation = operation || 0;
        for (var i = 0; i < this.children.length; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                this.setProperty(this.children[i], key, value, operation, force);
            }
        }
    };
    Phaser.Group.prototype.setAllChildren = function(key, value, checkAlive, checkVisible, operation, force) {
        if (checkAlive === undefined) {
            checkAlive = false;
        }
        if (checkVisible === undefined) {
            checkVisible = false;
        }
        if (force === undefined) {
            force = false;
        }
        operation = operation || 0;
        for (var i = 0; i < this.children.length; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (this.children[i] instanceof Phaser.Group) {
                    this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force);
                } else {
                    this.setProperty(this.children[i], key.split("."), value, operation, force);
                }
            }
        }
    };
    Phaser.Group.prototype.checkAll = function(key, value, checkAlive, checkVisible, force) {
        if (checkAlive === undefined) {
            checkAlive = false;
        }
        if (checkVisible === undefined) {
            checkVisible = false;
        }
        if (force === undefined) {
            force = false;
        }
        for (var i = 0; i < this.children.length; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (!this.checkProperty(this.children[i], key, value, force)) {
                    return false;
                }
            }
        }
        return true;
    };
    Phaser.Group.prototype.addAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 1);
    };
    Phaser.Group.prototype.subAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 2);
    };
    Phaser.Group.prototype.multiplyAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 3);
    };
    Phaser.Group.prototype.divideAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 4);
    };
    Phaser.Group.prototype.callAllExists = function(callback, existsValue) {
        var args;
        if (arguments.length > 2) {
            args = [];
            for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
        }
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].exists === existsValue && this.children[i][callback]) {
                this.children[i][callback].apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.callbackFromArray = function(child, callback, length) {
        if (length == 1) {
            if (child[callback[0]]) {
                return child[callback[0]];
            }
        } else if (length == 2) {
            if (child[callback[0]][callback[1]]) {
                return child[callback[0]][callback[1]];
            }
        } else if (length == 3) {
            if (child[callback[0]][callback[1]][callback[2]]) {
                return child[callback[0]][callback[1]][callback[2]];
            }
        } else if (length == 4) {
            if (child[callback[0]][callback[1]][callback[2]][callback[3]]) {
                return child[callback[0]][callback[1]][callback[2]][callback[3]];
            }
        } else {
            if (child[callback]) {
                return child[callback];
            }
        }
        return false;
    };
    Phaser.Group.prototype.callAll = function(method, context) {
        if (method === undefined) {
            return;
        }
        method = method.split(".");
        var methodLength = method.length;
        if (context === undefined || context === null || context === "") {
            context = null;
        } else {
            if (typeof context === "string") {
                context = context.split(".");
                var contextLength = context.length;
            }
        }
        var args;
        if (arguments.length > 2) {
            args = [];
            for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
        }
        var callback = null;
        var callbackContext = null;
        for (var i = 0; i < this.children.length; i++) {
            callback = this.callbackFromArray(this.children[i], method, methodLength);
            if (context && callback) {
                callbackContext = this.callbackFromArray(this.children[i], context, contextLength);
                if (callback) {
                    callback.apply(callbackContext, args);
                }
            } else if (callback) {
                callback.apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.preUpdate = function() {
        if (this.pendingDestroy) {
            this.destroy();
            return false;
        }
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Group.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Group.prototype.postUpdate = function() {
        if (this.fixedToCamera) {
            this.x = this.game.camera.view.x + this.cameraOffset.x;
            this.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Group.prototype.filter = function(predicate, checkExists) {
        var index = -1;
        var length = this.children.length;
        var results = [];
        while (++index < length) {
            var child = this.children[index];
            if (!checkExists || checkExists && child.exists) {
                if (predicate(child, index, this.children)) {
                    results.push(child);
                }
            }
        }
        return new Phaser.ArraySet(results);
    };
    Phaser.Group.prototype.forEach = function(callback, callbackContext, checkExists) {
        if (checkExists === undefined) {
            checkExists = false;
        }
        if (arguments.length <= 3) {
            for (var i = 0; i < this.children.length; i++) {
                if (!checkExists || checkExists && this.children[i].exists) {
                    callback.call(callbackContext, this.children[i]);
                }
            }
        } else {
            var args = [ null ];
            for (var i = 3; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            for (var i = 0; i < this.children.length; i++) {
                if (!checkExists || checkExists && this.children[i].exists) {
                    args[0] = this.children[i];
                    callback.apply(callbackContext, args);
                }
            }
        }
    };
    Phaser.Group.prototype.forEachExists = function(callback, callbackContext) {
        var args;
        if (arguments.length > 2) {
            args = [ null ];
            for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
        }
        this.iterate("exists", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachAlive = function(callback, callbackContext) {
        var args;
        if (arguments.length > 2) {
            args = [ null ];
            for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
        }
        this.iterate("alive", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachDead = function(callback, callbackContext) {
        var args;
        if (arguments.length > 2) {
            args = [ null ];
            for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
        }
        this.iterate("alive", false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.sort = function(key, order) {
        if (this.children.length < 2) {
            return;
        }
        if (key === undefined) {
            key = "z";
        }
        if (order === undefined) {
            order = Phaser.Group.SORT_ASCENDING;
        }
        this._sortProperty = key;
        if (order === Phaser.Group.SORT_ASCENDING) {
            this.children.sort(this.ascendingSortHandler.bind(this));
        } else {
            this.children.sort(this.descendingSortHandler.bind(this));
        }
        this.updateZ();
    };
    Phaser.Group.prototype.customSort = function(sortHandler, context) {
        if (this.children.length < 2) {
            return;
        }
        this.children.sort(sortHandler.bind(context));
        this.updateZ();
    };
    Phaser.Group.prototype.ascendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return -1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return 1;
        } else {
            if (a.z < b.z) {
                return -1;
            } else {
                return 1;
            }
        }
    };
    Phaser.Group.prototype.descendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return 1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return -1;
        } else {
            return 0;
        }
    };
    Phaser.Group.prototype.iterate = function(key, value, returnType, callback, callbackContext, args) {
        if (returnType === Phaser.Group.RETURN_TOTAL && this.children.length === 0) {
            return 0;
        }
        var total = 0;
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i][key] === value) {
                total++;
                if (callback) {
                    if (args) {
                        args[0] = this.children[i];
                        callback.apply(callbackContext, args);
                    } else {
                        callback.call(callbackContext, this.children[i]);
                    }
                }
                if (returnType === Phaser.Group.RETURN_CHILD) {
                    return this.children[i];
                }
            }
        }
        if (returnType === Phaser.Group.RETURN_TOTAL) {
            return total;
        }
        return null;
    };
    Phaser.Group.prototype.getFirstExists = function(exists) {
        if (typeof exists !== "boolean") {
            exists = true;
        }
        return this.iterate("exists", exists, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getTop = function() {
        if (this.children.length > 0) {
            return this.children[this.children.length - 1];
        }
    };
    Phaser.Group.prototype.getBottom = function() {
        if (this.children.length > 0) {
            return this.children[0];
        }
    };
    Phaser.Group.prototype.countLiving = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.countDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.getRandom = function(startIndex, length) {
        if (this.children.length === 0) {
            return null;
        }
        startIndex = startIndex || 0;
        length = length || this.children.length;
        return Phaser.ArrayUtils.getRandomItem(this.children, startIndex, length);
    };
    Phaser.Group.prototype.remove = function(child, destroy, silent) {
        if (destroy === undefined) {
            destroy = false;
        }
        if (silent === undefined) {
            silent = false;
        }
        if (this.children.length === 0 || this.children.indexOf(child) === -1) {
            return false;
        }
        if (!silent && child.events && !child.destroyPhase) {
            child.events.onRemovedFromGroup$dispatch(child, this);
        }
        var removed = this.removeChild(child);
        this.removeFromHash(child);
        this.updateZ();
        if (this.cursor === child) {
            this.next();
        }
        if (destroy && removed) {
            removed.destroy(true);
        }
        return true;
    };
    Phaser.Group.prototype.moveAll = function(group, silent) {
        if (silent === undefined) {
            silent = false;
        }
        if (this.children.length > 0 && group instanceof Phaser.Group) {
            do {
                group.add(this.children[0], silent);
            } while (this.children.length > 0);
            this.hash = [];
            this.cursor = null;
        }
        return group;
    };
    Phaser.Group.prototype.removeAll = function(destroy, silent) {
        if (destroy === undefined) {
            destroy = false;
        }
        if (silent === undefined) {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        do {
            if (!silent && this.children[0].events) {
                this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
            }
            var removed = this.removeChild(this.children[0]);
            this.removeFromHash(removed);
            if (destroy && removed) {
                removed.destroy(true);
            }
        } while (this.children.length > 0);
        this.hash = [];
        this.cursor = null;
    };
    Phaser.Group.prototype.removeBetween = function(startIndex, endIndex, destroy, silent) {
        if (endIndex === undefined) {
            endIndex = this.children.length - 1;
        }
        if (destroy === undefined) {
            destroy = false;
        }
        if (silent === undefined) {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length) {
            return false;
        }
        var i = endIndex;
        while (i >= startIndex) {
            if (!silent && this.children[i].events) {
                this.children[i].events.onRemovedFromGroup$dispatch(this.children[i], this);
            }
            var removed = this.removeChild(this.children[i]);
            this.removeFromHash(removed);
            if (destroy && removed) {
                removed.destroy(true);
            }
            if (this.cursor === this.children[i]) {
                this.cursor = null;
            }
            i--;
        }
        this.updateZ();
    };
    Phaser.Group.prototype.destroy = function(destroyChildren, soft) {
        if (this.game === null || this.ignoreDestroy) {
            return;
        }
        if (destroyChildren === undefined) {
            destroyChildren = true;
        }
        if (soft === undefined) {
            soft = false;
        }
        this.onDestroy.dispatch(this, destroyChildren, soft);
        this.removeAll(destroyChildren);
        this.cursor = null;
        this.filters = null;
        this.pendingDestroy = false;
        if (!soft) {
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this.game = null;
            this.exists = false;
        }
    };
    Object.defineProperty(Phaser.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", true, Phaser.Group.RETURN_TOTAL);
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "length", {
        get: function() {
            return this.children.length;
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Phaser.World = function(game) {
        Phaser.Group.call(this, game, null, "__world", false);
        this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height);
        this.camera = null;
        this._definedSize = false;
        this._width = game.width;
        this._height = game.height;
        this.game.state.onStateChange.add(this.stateChange, this);
    };
    Phaser.World.prototype = Object.create(Phaser.Group.prototype);
    Phaser.World.prototype.constructor = Phaser.World;
    Phaser.World.prototype.boot = function() {
        this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this;
        this.camera.scale = this.scale;
        this.game.camera = this.camera;
        this.game.stage.addChild(this);
    };
    Phaser.World.prototype.stateChange = function() {
        this.x = 0;
        this.y = 0;
        this.camera.reset();
    };
    Phaser.World.prototype.setBounds = function(x, y, width, height) {
        this._definedSize = true;
        this._width = width;
        this._height = height;
        this.bounds.setTo(x, y, width, height);
        this.x = x;
        this.y = y;
        if (this.camera.bounds) {
            this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height));
        }
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.resize = function(width, height) {
        if (this._definedSize) {
            if (width < this._width) {
                width = this._width;
            }
            if (height < this._height) {
                height = this._height;
            }
        }
        this.bounds.width = width;
        this.bounds.height = height;
        this.game.camera.setBoundsToWorld();
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.shutdown = function() {
        this.destroy(true, true);
    };
    Phaser.World.prototype.wrap = function(sprite, padding, useBounds, horizontal, vertical) {
        if (padding === undefined) {
            padding = 0;
        }
        if (useBounds === undefined) {
            useBounds = false;
        }
        if (horizontal === undefined) {
            horizontal = true;
        }
        if (vertical === undefined) {
            vertical = true;
        }
        if (!useBounds) {
            if (horizontal && sprite.x + padding < this.bounds.x) {
                sprite.x = this.bounds.right + padding;
            } else if (horizontal && sprite.x - padding > this.bounds.right) {
                sprite.x = this.bounds.left - padding;
            }
            if (vertical && sprite.y + padding < this.bounds.top) {
                sprite.y = this.bounds.bottom + padding;
            } else if (vertical && sprite.y - padding > this.bounds.bottom) {
                sprite.y = this.bounds.top - padding;
            }
        } else {
            sprite.getBounds();
            if (horizontal) {
                if (sprite.x + sprite._currentBounds.width < this.bounds.x) {
                    sprite.x = this.bounds.right;
                } else if (sprite.x > this.bounds.right) {
                    sprite.x = this.bounds.left;
                }
            }
            if (vertical) {
                if (sprite.y + sprite._currentBounds.height < this.bounds.top) {
                    sprite.y = this.bounds.bottom;
                } else if (sprite.y > this.bounds.bottom) {
                    sprite.y = this.bounds.top;
                }
            }
        }
    };
    Object.defineProperty(Phaser.World.prototype, "width", {
        get: function() {
            return this.bounds.width;
        },
        set: function(value) {
            if (value < this.game.width) {
                value = this.game.width;
            }
            this.bounds.width = value;
            this._width = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "height", {
        get: function() {
            return this.bounds.height;
        },
        set: function(value) {
            if (value < this.game.height) {
                value = this.game.height;
            }
            this.bounds.height = value;
            this._height = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomX", {
        get: function() {
            if (this.bounds.x < 0) {
                return this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x));
            } else {
                return this.game.rnd.between(this.bounds.x, this.bounds.width);
            }
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomY", {
        get: function() {
            if (this.bounds.y < 0) {
                return this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y));
            } else {
                return this.game.rnd.between(this.bounds.y, this.bounds.height);
            }
        }
    });
    Phaser.FlexGrid = function(manager, width, height) {
        this.game = manager.game;
        this.manager = manager;
        this.width = width;
        this.height = height;
        this.boundsCustom = new Phaser.Rectangle(0, 0, width, height);
        this.boundsFluid = new Phaser.Rectangle(0, 0, width, height);
        this.boundsFull = new Phaser.Rectangle(0, 0, width, height);
        this.boundsNone = new Phaser.Rectangle(0, 0, width, height);
        this.positionCustom = new Phaser.Point(0, 0);
        this.positionFluid = new Phaser.Point(0, 0);
        this.positionFull = new Phaser.Point(0, 0);
        this.positionNone = new Phaser.Point(0, 0);
        this.scaleCustom = new Phaser.Point(1, 1);
        this.scaleFluid = new Phaser.Point(1, 1);
        this.scaleFluidInversed = new Phaser.Point(1, 1);
        this.scaleFull = new Phaser.Point(1, 1);
        this.scaleNone = new Phaser.Point(1, 1);
        this.customWidth = 0;
        this.customHeight = 0;
        this.customOffsetX = 0;
        this.customOffsetY = 0;
        this.ratioH = width / height;
        this.ratioV = height / width;
        this.multiplier = 0;
        this.layers = [];
    };
    Phaser.FlexGrid.prototype = {
        setSize: function(width, height) {
            this.width = width;
            this.height = height;
            this.ratioH = width / height;
            this.ratioV = height / width;
            this.scaleNone = new Phaser.Point(1, 1);
            this.boundsNone.width = this.width;
            this.boundsNone.height = this.height;
            this.refresh();
        },
        createCustomLayer: function(width, height, children, addToWorld) {
            if (addToWorld === undefined) {
                addToWorld = true;
            }
            this.customWidth = width;
            this.customHeight = height;
            this.boundsCustom.width = width;
            this.boundsCustom.height = height;
            var layer = new Phaser.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
            if (addToWorld) {
                this.game.world.add(layer);
            }
            this.layers.push(layer);
            if (typeof children !== "undefined" && typeof children !== null) {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFluidLayer: function(children, addToWorld) {
            if (addToWorld === undefined) {
                addToWorld = true;
            }
            var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            if (addToWorld) {
                this.game.world.add(layer);
            }
            this.layers.push(layer);
            if (typeof children !== "undefined" && typeof children !== null) {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFullLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFixedLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        reset: function() {
            var i = this.layers.length;
            while (i--) {
                if (!this.layers[i].persist) {
                    this.layers[i].position = null;
                    this.layers[i].scale = null;
                    this.layers.slice(i, 1);
                }
            }
        },
        onResize: function(width, height) {
            this.ratioH = width / height;
            this.ratioV = height / width;
            this.refresh(width, height);
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width);
            this.boundsFluid.width = Math.round(this.width * this.multiplier);
            this.boundsFluid.height = Math.round(this.height * this.multiplier);
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height);
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height);
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height);
            this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x);
            this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y);
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y);
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        fitSprite: function(sprite) {
            this.manager.scaleSprite(sprite);
            sprite.x = this.manager.bounds.centerX;
            sprite.y = this.manager.bounds.centerY;
        },
        debug: function() {
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16);
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", false);
        }
    };
    Phaser.FlexGrid.prototype.constructor = Phaser.FlexGrid;
    Phaser.FlexLayer = function(manager, position, bounds, scale) {
        Phaser.Group.call(this, manager.game, null, "__flexLayer" + manager.game.rnd.uuid(), false);
        this.manager = manager.manager;
        this.grid = manager;
        this.persist = false;
        this.position = position;
        this.bounds = bounds;
        this.scale = scale;
        this.topLeft = bounds.topLeft;
        this.topMiddle = new Phaser.Point(bounds.halfWidth, 0);
        this.topRight = bounds.topRight;
        this.bottomLeft = bounds.bottomLeft;
        this.bottomMiddle = new Phaser.Point(bounds.halfWidth, bounds.bottom);
        this.bottomRight = bounds.bottomRight;
    };
    Phaser.FlexLayer.prototype = Object.create(Phaser.Group.prototype);
    Phaser.FlexLayer.prototype.constructor = Phaser.FlexLayer;
    Phaser.FlexLayer.prototype.resize = function() {};
    Phaser.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16);
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", false);
        this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    };
    Phaser.ScaleManager = function(game, width, height) {
        this.game = game;
        this.dom = Phaser.DOM;
        this.grid = null;
        this.width = 0;
        this.height = 0;
        this.minWidth = null;
        this.maxWidth = null;
        this.minHeight = null;
        this.maxHeight = null;
        this.offset = new Phaser.Point();
        this.forceLandscape = false;
        this.forcePortrait = false;
        this.incorrectOrientation = false;
        this._pageAlignHorizontally = false;
        this._pageAlignVertically = false;
        this.onOrientationChange = new Phaser.Signal();
        this.enterIncorrectOrientation = new Phaser.Signal();
        this.leaveIncorrectOrientation = new Phaser.Signal();
        this.fullScreenTarget = null;
        this._createdFullScreenTarget = null;
        this.onFullScreenInit = new Phaser.Signal();
        this.onFullScreenChange = new Phaser.Signal();
        this.onFullScreenError = new Phaser.Signal();
        this.screenOrientation = this.dom.getScreenOrientation();
        this.scaleFactor = new Phaser.Point(1, 1);
        this.scaleFactorInversed = new Phaser.Point(1, 1);
        this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        };
        this.bounds = new Phaser.Rectangle();
        this.aspectRatio = 0;
        this.sourceAspectRatio = 0;
        this.event = null;
        this.windowConstraints = {
            right: "layout",
            bottom: ""
        };
        this.compatibility = {
            supportsFullScreen: false,
            orientationFallback: null,
            noMargins: false,
            scrollTo: null,
            forceMinimumDocumentHeight: false,
            canExpandParent: true,
            clickTrampoline: ""
        };
        this._scaleMode = Phaser.ScaleManager.NO_SCALE;
        this._fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;
        this.parentIsWindow = false;
        this.parentNode = null;
        this.parentScaleFactor = new Phaser.Point(1, 1);
        this.trackParentInterval = 2e3;
        this.onSizeChange = new Phaser.Signal();
        this.onResize = null;
        this.onResizeContext = null;
        this._pendingScaleMode = null;
        this._fullScreenRestore = null;
        this._gameSize = new Phaser.Rectangle();
        this._userScaleFactor = new Phaser.Point(1, 1);
        this._userScaleTrim = new Phaser.Point(0, 0);
        this._lastUpdate = 0;
        this._updateThrottle = 0;
        this._updateThrottleReset = 100;
        this._parentBounds = new Phaser.Rectangle();
        this._tempBounds = new Phaser.Rectangle();
        this._lastReportedCanvasSize = new Phaser.Rectangle();
        this._lastReportedGameSize = new Phaser.Rectangle();
        this._booted = false;
        if (game.config) {
            this.parseConfig(game.config);
        }
        this.setupScale(width, height);
    };
    Phaser.ScaleManager.EXACT_FIT = 0;
    Phaser.ScaleManager.NO_SCALE = 1;
    Phaser.ScaleManager.SHOW_ALL = 2;
    Phaser.ScaleManager.RESIZE = 3;
    Phaser.ScaleManager.USER_SCALE = 4;
    Phaser.ScaleManager.prototype = {
        boot: function() {
            var compat = this.compatibility;
            compat.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS;
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    compat.scrollTo = new Phaser.Point(0, 1);
                } else {
                    compat.scrollTo = new Phaser.Point(0, 0);
                }
            }
            if (this.game.device.desktop) {
                compat.orientationFallback = "screen";
                compat.clickTrampoline = "when-not-mouse";
            } else {
                compat.orientationFallback = "";
                compat.clickTrampoline = "";
            }
            var _this = this;
            this._orientationChange = function(event) {
                return _this.orientationChange(event);
            };
            this._windowResize = function(event) {
                return _this.windowResize(event);
            };
            window.addEventListener("orientationchange", this._orientationChange, false);
            window.addEventListener("resize", this._windowResize, false);
            if (this.compatibility.supportsFullScreen) {
                this._fullScreenChange = function(event) {
                    return _this.fullScreenChange(event);
                };
                this._fullScreenError = function(event) {
                    return _this.fullScreenError(event);
                };
                document.addEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("MSFullscreenChange", this._fullScreenChange, false);
                document.addEventListener("fullscreenchange", this._fullScreenChange, false);
                document.addEventListener("webkitfullscreenerror", this._fullScreenError, false);
                document.addEventListener("mozfullscreenerror", this._fullScreenError, false);
                document.addEventListener("MSFullscreenError", this._fullScreenError, false);
                document.addEventListener("fullscreenerror", this._fullScreenError, false);
            }
            this.game.onResume.add(this._gameResumed, this);
            this.dom.getOffset(this.game.canvas, this.offset);
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
            this.setGameSize(this.game.width, this.game.height);
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
            this.grid = new Phaser.FlexGrid(this, this.width, this.height);
            this._booted = true;
            if (this._pendingScaleMode) {
                this.scaleMode = this._pendingScaleMode;
                this._pendingScaleMode = null;
            }
        },
        parseConfig: function(config) {
            if (config["scaleMode"]) {
                if (this._booted) {
                    this.scaleMode = config["scaleMode"];
                } else {
                    this._pendingScaleMode = config["scaleMode"];
                }
            }
            if (config["fullScreenScaleMode"]) {
                this.fullScreenScaleMode = config["fullScreenScaleMode"];
            }
            if (config["fullScreenTarget"]) {
                this.fullScreenTarget = config["fullScreenTarget"];
            }
        },
        setupScale: function(width, height) {
            var target;
            var rect = new Phaser.Rectangle();
            if (this.game.parent !== "") {
                if (typeof this.game.parent === "string") {
                    target = document.getElementById(this.game.parent);
                } else if (this.game.parent && this.game.parent.nodeType === 1) {
                    target = this.game.parent;
                }
            }
            if (!target) {
                this.parentNode = null;
                this.parentIsWindow = true;
                rect.width = this.dom.visualBounds.width;
                rect.height = this.dom.visualBounds.height;
                this.offset.set(0, 0);
            } else {
                this.parentNode = target;
                this.parentIsWindow = false;
                this.getParentBounds(this._parentBounds);
                rect.width = this._parentBounds.width;
                rect.height = this._parentBounds.height;
                this.offset.set(this._parentBounds.x, this._parentBounds.y);
            }
            var newWidth = 0;
            var newHeight = 0;
            if (typeof width === "number") {
                newWidth = width;
            } else {
                this.parentScaleFactor.x = parseInt(width, 10) / 100;
                newWidth = rect.width * this.parentScaleFactor.x;
            }
            if (typeof height === "number") {
                newHeight = height;
            } else {
                this.parentScaleFactor.y = parseInt(height, 10) / 100;
                newHeight = rect.height * this.parentScaleFactor.y;
            }
            this._gameSize.setTo(0, 0, newWidth, newHeight);
            this.updateDimensions(newWidth, newHeight, false);
        },
        _gameResumed: function() {
            this.queueUpdate(true);
        },
        setGameSize: function(width, height) {
            this._gameSize.setTo(0, 0, width, height);
            if (this.currentScaleMode !== Phaser.ScaleManager.RESIZE) {
                this.updateDimensions(width, height, true);
            }
            this.queueUpdate(true);
        },
        setUserScale: function(hScale, vScale, hTrim, vTrim) {
            this._userScaleFactor.setTo(hScale, vScale);
            this._userScaleTrim.setTo(hTrim | 0, vTrim | 0);
            this.queueUpdate(true);
        },
        setResizeCallback: function(callback, context) {
            this.onResize = callback;
            this.onResizeContext = context;
        },
        signalSizeChange: function() {
            if (!Phaser.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !Phaser.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var width = this.width;
                var height = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, width, height);
                this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height);
                this.grid.onResize(width, height);
                this.onSizeChange.dispatch(this, width, height);
                if (this.currentScaleMode === Phaser.ScaleManager.RESIZE) {
                    this.game.state.resize(width, height);
                    this.game.load.resize(width, height);
                }
            }
        },
        setMinMax: function(minWidth, minHeight, maxWidth, maxHeight) {
            this.minWidth = minWidth;
            this.minHeight = minHeight;
            if (typeof maxWidth !== "undefined") {
                this.maxWidth = maxWidth;
            }
            if (typeof maxHeight !== "undefined") {
                this.maxHeight = maxHeight;
            }
        },
        preUpdate: function() {
            if (this.game.time.time < this._lastUpdate + this._updateThrottle) {
                return;
            }
            var prevThrottle = this._updateThrottle;
            this._updateThrottleReset = prevThrottle >= 400 ? 0 : 100;
            this.dom.getOffset(this.game.canvas, this.offset);
            var prevWidth = this._parentBounds.width;
            var prevHeight = this._parentBounds.height;
            var bounds = this.getParentBounds(this._parentBounds);
            var boundsChanged = bounds.width !== prevWidth || bounds.height !== prevHeight;
            var orientationChanged = this.updateOrientationState();
            if (boundsChanged || orientationChanged) {
                if (this.onResize) {
                    this.onResize.call(this.onResizeContext, this, bounds);
                }
                this.updateLayout();
                this.signalSizeChange();
            }
            var throttle = this._updateThrottle * 2;
            if (this._updateThrottle < prevThrottle) {
                throttle = Math.min(prevThrottle, this._updateThrottleReset);
            }
            this._updateThrottle = Phaser.Math.clamp(throttle, 25, this.trackParentInterval);
            this._lastUpdate = this.game.time.time;
        },
        pauseUpdate: function() {
            this.preUpdate();
            this._updateThrottle = this.trackParentInterval;
        },
        updateDimensions: function(width, height, resize) {
            this.width = width * this.parentScaleFactor.x;
            this.height = height * this.parentScaleFactor.y;
            this.game.width = this.width;
            this.game.height = this.height;
            this.sourceAspectRatio = this.width / this.height;
            this.updateScalingAndBounds();
            if (resize) {
                this.game.renderer.resize(this.width, this.height);
                this.game.camera.setSize(this.width, this.height);
                this.game.world.resize(this.width, this.height);
            }
        },
        updateScalingAndBounds: function() {
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height;
            this.scaleFactorInversed.x = this.width / this.game.width;
            this.scaleFactorInversed.y = this.height / this.game.height;
            this.aspectRatio = this.width / this.height;
            if (this.game.canvas) {
                this.dom.getOffset(this.game.canvas, this.offset);
            }
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
            if (this.game.input && this.game.input.scale) {
                this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
            }
        },
        forceOrientation: function(forceLandscape, forcePortrait) {
            if (forcePortrait === undefined) {
                forcePortrait = false;
            }
            this.forceLandscape = forceLandscape;
            this.forcePortrait = forcePortrait;
            this.queueUpdate(true);
        },
        classifyOrientation: function(orientation) {
            if (orientation === "portrait-primary" || orientation === "portrait-secondary") {
                return "portrait";
            } else if (orientation === "landscape-primary" || orientation === "landscape-secondary") {
                return "landscape";
            } else {
                return null;
            }
        },
        updateOrientationState: function() {
            var previousOrientation = this.screenOrientation;
            var previouslyIncorrect = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
            this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var changed = previousOrientation !== this.screenOrientation;
            var correctnessChanged = previouslyIncorrect !== this.incorrectOrientation;
            if (correctnessChanged) {
                if (this.incorrectOrientation) {
                    this.enterIncorrectOrientation.dispatch();
                } else {
                    this.leaveIncorrectOrientation.dispatch();
                }
            }
            if (changed || correctnessChanged) {
                this.onOrientationChange.dispatch(this, previousOrientation, previouslyIncorrect);
            }
            return changed || correctnessChanged;
        },
        orientationChange: function(event) {
            this.event = event;
            this.queueUpdate(true);
        },
        windowResize: function(event) {
            this.event = event;
            this.queueUpdate(true);
        },
        scrollTop: function() {
            var scrollTo = this.compatibility.scrollTo;
            if (scrollTo) {
                window.scrollTo(scrollTo.x, scrollTo.y);
            }
        },
        refresh: function() {
            this.scrollTop();
            this.queueUpdate(true);
        },
        updateLayout: function() {
            var scaleMode = this.currentScaleMode;
            if (scaleMode === Phaser.ScaleManager.RESIZE) {
                this.reflowGame();
                return;
            }
            this.scrollTop();
            if (this.compatibility.forceMinimumDocumentHeight) {
                document.documentElement.style.minHeight = window.innerHeight + "px";
            }
            if (this.incorrectOrientation) {
                this.setMaximum();
            } else {
                if (scaleMode === Phaser.ScaleManager.EXACT_FIT) {
                    this.setExactFit();
                } else if (scaleMode === Phaser.ScaleManager.SHOW_ALL) {
                    if (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent) {
                        this.setShowAll(true);
                        this.resetCanvas();
                        this.setShowAll();
                    } else {
                        this.setShowAll();
                    }
                } else if (scaleMode === Phaser.ScaleManager.NO_SCALE) {
                    this.width = this.game.width;
                    this.height = this.game.height;
                } else if (scaleMode === Phaser.ScaleManager.USER_SCALE) {
                    this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x;
                    this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y;
                }
            }
            if (!this.compatibility.canExpandParent && (scaleMode === Phaser.ScaleManager.SHOW_ALL || scaleMode === Phaser.ScaleManager.USER_SCALE)) {
                var bounds = this.getParentBounds(this._tempBounds);
                this.width = Math.min(this.width, bounds.width);
                this.height = Math.min(this.height, bounds.height);
            }
            this.width = this.width | 0;
            this.height = this.height | 0;
            this.reflowCanvas();
        },
        getParentBounds: function(target) {
            var bounds = target || new Phaser.Rectangle();
            var parentNode = this.boundingParent;
            var visualBounds = this.dom.visualBounds;
            var layoutBounds = this.dom.layoutBounds;
            if (!parentNode) {
                bounds.setTo(0, 0, visualBounds.width, visualBounds.height);
            } else {
                var clientRect = parentNode.getBoundingClientRect();
                bounds.setTo(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
                var wc = this.windowConstraints;
                if (wc.right) {
                    var windowBounds = wc.right === "layout" ? layoutBounds : visualBounds;
                    bounds.right = Math.min(bounds.right, windowBounds.width);
                }
                if (wc.bottom) {
                    var windowBounds = wc.bottom === "layout" ? layoutBounds : visualBounds;
                    bounds.bottom = Math.min(bounds.bottom, windowBounds.height);
                }
            }
            bounds.setTo(Math.round(bounds.x), Math.round(bounds.y), Math.round(bounds.width), Math.round(bounds.height));
            return bounds;
        },
        alignCanvas: function(horizontal, vertical) {
            var parentBounds = this.getParentBounds(this._tempBounds);
            var canvas = this.game.canvas;
            var margin = this.margin;
            if (horizontal) {
                margin.left = margin.right = 0;
                var canvasBounds = canvas.getBoundingClientRect();
                if (this.width < parentBounds.width && !this.incorrectOrientation) {
                    var currentEdge = canvasBounds.left - parentBounds.x;
                    var targetEdge = parentBounds.width / 2 - this.width / 2;
                    targetEdge = Math.max(targetEdge, 0);
                    var offset = targetEdge - currentEdge;
                    margin.left = Math.round(offset);
                }
                canvas.style.marginLeft = margin.left + "px";
                if (margin.left !== 0) {
                    margin.right = -(parentBounds.width - canvasBounds.width - margin.left);
                    canvas.style.marginRight = margin.right + "px";
                }
            }
            if (vertical) {
                margin.top = margin.bottom = 0;
                var canvasBounds = canvas.getBoundingClientRect();
                if (this.height < parentBounds.height && !this.incorrectOrientation) {
                    var currentEdge = canvasBounds.top - parentBounds.y;
                    var targetEdge = parentBounds.height / 2 - this.height / 2;
                    targetEdge = Math.max(targetEdge, 0);
                    var offset = targetEdge - currentEdge;
                    margin.top = Math.round(offset);
                }
                canvas.style.marginTop = margin.top + "px";
                if (margin.top !== 0) {
                    margin.bottom = -(parentBounds.height - canvasBounds.height - margin.top);
                    canvas.style.marginBottom = margin.bottom + "px";
                }
            }
            margin.x = margin.left;
            margin.y = margin.top;
        },
        reflowGame: function() {
            this.resetCanvas("", "");
            var bounds = this.getParentBounds(this._tempBounds);
            this.updateDimensions(bounds.width, bounds.height, true);
        },
        reflowCanvas: function() {
            if (!this.incorrectOrientation) {
                this.width = Phaser.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width);
                this.height = Phaser.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height);
            }
            this.resetCanvas();
            if (!this.compatibility.noMargins) {
                if (this.isFullScreen && this._createdFullScreenTarget) {
                    this.alignCanvas(true, true);
                } else {
                    this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically);
                }
            }
            this.updateScalingAndBounds();
        },
        resetCanvas: function(cssWidth, cssHeight) {
            if (cssWidth === undefined) {
                cssWidth = this.width + "px";
            }
            if (cssHeight === undefined) {
                cssHeight = this.height + "px";
            }
            var canvas = this.game.canvas;
            if (!this.compatibility.noMargins) {
                canvas.style.marginLeft = "";
                canvas.style.marginTop = "";
                canvas.style.marginRight = "";
                canvas.style.marginBottom = "";
            }
            canvas.style.width = cssWidth;
            canvas.style.height = cssHeight;
        },
        queueUpdate: function(force) {
            if (force) {
                this._parentBounds.width = 0;
                this._parentBounds.height = 0;
            }
            this._updateThrottle = this._updateThrottleReset;
        },
        reset: function(clearWorld) {
            if (clearWorld) {
                this.grid.reset();
            }
        },
        setMaximum: function() {
            this.width = this.dom.visualBounds.width;
            this.height = this.dom.visualBounds.height;
        },
        setShowAll: function(expanding) {
            var bounds = this.getParentBounds(this._tempBounds);
            var width = bounds.width;
            var height = bounds.height;
            var multiplier;
            if (expanding) {
                multiplier = Math.max(height / this.game.height, width / this.game.width);
            } else {
                multiplier = Math.min(height / this.game.height, width / this.game.width);
            }
            this.width = Math.round(this.game.width * multiplier);
            this.height = Math.round(this.game.height * multiplier);
        },
        setExactFit: function() {
            var bounds = this.getParentBounds(this._tempBounds);
            this.width = bounds.width;
            this.height = bounds.height;
            if (this.isFullScreen) {
                return;
            }
            if (this.maxWidth) {
                this.width = Math.min(this.width, this.maxWidth);
            }
            if (this.maxHeight) {
                this.height = Math.min(this.height, this.maxHeight);
            }
        },
        createFullScreenTarget: function() {
            var fsTarget = document.createElement("div");
            fsTarget.style.margin = "0";
            fsTarget.style.padding = "0";
            fsTarget.style.background = "#000";
            return fsTarget;
        },
        startFullScreen: function(antialias, allowTrampoline) {
            if (this.isFullScreen) {
                return false;
            }
            if (!this.compatibility.supportsFullScreen) {
                var _this = this;
                setTimeout(function() {
                    _this.fullScreenError();
                }, 10);
                return;
            }
            if (this.compatibility.clickTrampoline === "when-not-mouse") {
                var input = this.game.input;
                if (input.activePointer && input.activePointer !== input.mousePointer && (allowTrampoline || allowTrampoline !== false)) {
                    input.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [ antialias, false ]);
                    return;
                }
            }
            if (typeof antialias !== "undefined" && this.game.renderType === Phaser.CANVAS) {
                this.game.stage.smoothed = antialias;
            }
            var fsTarget = this.fullScreenTarget;
            if (!fsTarget) {
                this.cleanupCreatedTarget();
                this._createdFullScreenTarget = this.createFullScreenTarget();
                fsTarget = this._createdFullScreenTarget;
            }
            var initData = {
                targetElement: fsTarget
            };
            this.onFullScreenInit.dispatch(this, initData);
            if (this._createdFullScreenTarget) {
                var canvas = this.game.canvas;
                var parent = canvas.parentNode;
                parent.insertBefore(fsTarget, canvas);
                fsTarget.appendChild(canvas);
            }
            if (this.game.device.fullscreenKeyboard) {
                fsTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
            } else {
                fsTarget[this.game.device.requestFullscreen]();
            }
            return true;
        },
        stopFullScreen: function() {
            if (!this.isFullScreen || !this.compatibility.supportsFullScreen) {
                return false;
            }
            document[this.game.device.cancelFullscreen]();
            return true;
        },
        cleanupCreatedTarget: function() {
            var fsTarget = this._createdFullScreenTarget;
            if (fsTarget && fsTarget.parentNode) {
                var parent = fsTarget.parentNode;
                parent.insertBefore(this.game.canvas, fsTarget);
                parent.removeChild(fsTarget);
            }
            this._createdFullScreenTarget = null;
        },
        prepScreenMode: function(enteringFullscreen) {
            var createdTarget = !!this._createdFullScreenTarget;
            var fsTarget = this._createdFullScreenTarget || this.fullScreenTarget;
            if (enteringFullscreen) {
                if (createdTarget || this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) {
                    if (fsTarget !== this.game.canvas) {
                        this._fullScreenRestore = {
                            targetWidth: fsTarget.style.width,
                            targetHeight: fsTarget.style.height
                        };
                        fsTarget.style.width = "100%";
                        fsTarget.style.height = "100%";
                    }
                }
            } else {
                if (this._fullScreenRestore) {
                    fsTarget.style.width = this._fullScreenRestore.targetWidth;
                    fsTarget.style.height = this._fullScreenRestore.targetHeight;
                    this._fullScreenRestore = null;
                }
                this.updateDimensions(this._gameSize.width, this._gameSize.height, true);
                this.resetCanvas();
            }
        },
        fullScreenChange: function(event) {
            this.event = event;
            if (this.isFullScreen) {
                this.prepScreenMode(true);
                this.updateLayout();
                this.queueUpdate(true);
            } else {
                this.prepScreenMode(false);
                this.cleanupCreatedTarget();
                this.updateLayout();
                this.queueUpdate(true);
            }
            this.onFullScreenChange.dispatch(this, this.width, this.height);
        },
        fullScreenError: function(event) {
            this.event = event;
            this.cleanupCreatedTarget();
            console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API");
            this.onFullScreenError.dispatch(this);
        },
        scaleSprite: function(sprite, width, height, letterBox) {
            if (width === undefined) {
                width = this.width;
            }
            if (height === undefined) {
                height = this.height;
            }
            if (letterBox === undefined) {
                letterBox = false;
            }
            if (!sprite || !sprite["scale"]) {
                return sprite;
            }
            sprite.scale.x = 1;
            sprite.scale.y = 1;
            if (sprite.width <= 0 || sprite.height <= 0 || width <= 0 || height <= 0) {
                return sprite;
            }
            var scaleX1 = width;
            var scaleY1 = sprite.height * width / sprite.width;
            var scaleX2 = sprite.width * height / sprite.height;
            var scaleY2 = height;
            var scaleOnWidth = scaleX2 > width;
            if (scaleOnWidth) {
                scaleOnWidth = letterBox;
            } else {
                scaleOnWidth = !letterBox;
            }
            if (scaleOnWidth) {
                sprite.width = Math.floor(scaleX1);
                sprite.height = Math.floor(scaleY1);
            } else {
                sprite.width = Math.floor(scaleX2);
                sprite.height = Math.floor(scaleY2);
            }
            return sprite;
        },
        destroy: function() {
            this.game.onResume.remove(this._gameResumed, this);
            window.removeEventListener("orientationchange", this._orientationChange, false);
            window.removeEventListener("resize", this._windowResize, false);
            if (this.compatibility.supportsFullScreen) {
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("MSFullscreenChange", this._fullScreenChange, false);
                document.removeEventListener("fullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("webkitfullscreenerror", this._fullScreenError, false);
                document.removeEventListener("mozfullscreenerror", this._fullScreenError, false);
                document.removeEventListener("MSFullscreenError", this._fullScreenError, false);
                document.removeEventListener("fullscreenerror", this._fullScreenError, false);
            }
        }
    };
    Phaser.ScaleManager.prototype.constructor = Phaser.ScaleManager;
    Object.defineProperty(Phaser.ScaleManager.prototype, "boundingParent", {
        get: function() {
            if (this.parentIsWindow || this.isFullScreen && !this._createdFullScreenTarget) {
                return null;
            }
            var parentNode = this.game.canvas && this.game.canvas.parentNode;
            return parentNode || null;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode;
        },
        set: function(value) {
            if (value !== this._scaleMode) {
                if (!this.isFullScreen) {
                    this.updateDimensions(this._gameSize.width, this._gameSize.height, true);
                    this.queueUpdate(true);
                }
                this._scaleMode = value;
            }
            return this._scaleMode;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function() {
            return this._fullScreenScaleMode;
        },
        set: function(value) {
            if (value !== this._fullScreenScaleMode) {
                if (this.isFullScreen) {
                    this.prepScreenMode(false);
                    this._fullScreenScaleMode = value;
                    this.prepScreenMode(true);
                    this.queueUpdate(true);
                } else {
                    this._fullScreenScaleMode = value;
                }
            }
            return this._fullScreenScaleMode;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "currentScaleMode", {
        get: function() {
            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function() {
            return this._pageAlignHorizontally;
        },
        set: function(value) {
            if (value !== this._pageAlignHorizontally) {
                this._pageAlignHorizontally = value;
                this.queueUpdate(true);
            }
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "pageAlignVertically", {
        get: function() {
            return this._pageAlignVertically;
        },
        set: function(value) {
            if (value !== this._pageAlignVertically) {
                this._pageAlignVertically = value;
                this.queueUpdate(true);
            }
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return !!(document["fullscreenElement"] || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"]);
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return this.classifyOrientation(this.screenOrientation) === "portrait";
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return this.classifyOrientation(this.screenOrientation) === "landscape";
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isGamePortrait", {
        get: function() {
            return this.height > this.width;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isGameLandscape", {
        get: function() {
            return this.width > this.height;
        }
    });
    Phaser.Game = function(width, height, renderer, parent, state, transparent, antialias, physicsConfig) {
        this.id = Phaser.GAMES.push(this) - 1;
        this.config = null;
        this.physicsConfig = physicsConfig;
        this.parent = "";
        this.width = 800;
        this.height = 600;
        this.resolution = 1;
        this._width = 800;
        this._height = 600;
        this.transparent = false;
        this.antialias = true;
        this.preserveDrawingBuffer = false;
        this.renderer = null;
        this.renderType = Phaser.AUTO;
        this.state = null;
        this.isBooted = false;
        this.isRunning = false;
        this.raf = null;
        this.add = null;
        this.make = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.net = null;
        this.scale = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.physics = null;
        this.plugins = null;
        this.rnd = null;
        this.device = Phaser.Device;
        this.camera = null;
        this.canvas = null;
        this.context = null;
        this.debug = null;
        this.particles = null;
        this.create = null;
        this.lockRender = false;
        this.stepping = false;
        this.pendingStep = false;
        this.stepCount = 0;
        this.onPause = null;
        this.onResume = null;
        this.onBlur = null;
        this.onFocus = null;
        this._paused = false;
        this._codePaused = false;
        this.currentUpdateID = 0;
        this.updatesThisFrame = 1;
        this._deltaTime = 0;
        this._lastCount = 0;
        this._spiraling = 0;
        this._kickstart = true;
        this.fpsProblemNotifier = new Phaser.Signal();
        this.forceSingleUpdate = false;
        this._nextFpsNotification = 0;
        if (arguments.length === 1 && typeof arguments[0] === "object") {
            this.parseConfig(arguments[0]);
        } else {
            this.config = {
                enableDebug: true
            };
            if (typeof width !== "undefined") {
                this._width = width;
            }
            if (typeof height !== "undefined") {
                this._height = height;
            }
            if (typeof renderer !== "undefined") {
                this.renderType = renderer;
            }
            if (typeof parent !== "undefined") {
                this.parent = parent;
            }
            if (typeof transparent !== "undefined") {
                this.transparent = transparent;
            }
            if (typeof antialias !== "undefined") {
                this.antialias = antialias;
            }
            this.rnd = new Phaser.RandomDataGenerator([ (Date.now() * Math.random()).toString() ]);
            this.state = new Phaser.StateManager(this, state);
        }
        this.device.whenReady(this.boot, this);
        return this;
    };
    Phaser.Game.prototype = {
        parseConfig: function(config) {
            this.config = config;
            if (config["enableDebug"] === undefined) {
                this.config.enableDebug = true;
            }
            if (config["width"]) {
                this._width = config["width"];
            }
            if (config["height"]) {
                this._height = config["height"];
            }
            if (config["renderer"]) {
                this.renderType = config["renderer"];
            }
            if (config["parent"]) {
                this.parent = config["parent"];
            }
            if (config["transparent"]) {
                this.transparent = config["transparent"];
            }
            if (config["antialias"]) {
                this.antialias = config["antialias"];
            }
            if (config["resolution"]) {
                this.resolution = config["resolution"];
            }
            if (config["preserveDrawingBuffer"]) {
                this.preserveDrawingBuffer = config["preserveDrawingBuffer"];
            }
            if (config["physicsConfig"]) {
                this.physicsConfig = config["physicsConfig"];
            }
            var seed = [ (Date.now() * Math.random()).toString() ];
            if (config["seed"]) {
                seed = config["seed"];
            }
            this.rnd = new Phaser.RandomDataGenerator(seed);
            var state = null;
            if (config["state"]) {
                state = config["state"];
            }
            this.state = new Phaser.StateManager(this, state);
        },
        boot: function() {
            if (this.isBooted) {
                return;
            }
            this.onPause = new Phaser.Signal();
            this.onResume = new Phaser.Signal();
            this.onBlur = new Phaser.Signal();
            this.onFocus = new Phaser.Signal();
            this.isBooted = true;
            this.math = Phaser.Math;
            this.scale = new Phaser.ScaleManager(this, this._width, this._height);
            this.stage = new Phaser.Stage(this);
            this.setUpRenderer();
            this.world = new Phaser.World(this);
            this.add = new Phaser.GameObjectFactory(this);
            this.make = new Phaser.GameObjectCreator(this);
            this.cache = new Phaser.Cache(this);
            this.load = new Phaser.Loader(this);
            this.time = new Phaser.Time(this);
            this.tweens = new Phaser.TweenManager(this);
            this.input = new Phaser.Input(this);
            this.sound = new Phaser.SoundManager(this);
            this.physics = new Phaser.Physics(this, this.physicsConfig);
            this.particles = new Phaser.Particles(this);
            this.create = new Phaser.Create(this);
            this.plugins = new Phaser.PluginManager(this);
            this.net = new Phaser.Net(this);
            this.time.boot();
            this.stage.boot();
            this.world.boot();
            this.scale.boot();
            this.input.boot();
            this.sound.boot();
            this.state.boot();
            if (this.config["enableDebug"]) {
                this.debug = new Phaser.Utils.Debug(this);
                this.debug.boot();
            } else {
                this.debug = {
                    preUpdate: function() {},
                    update: function() {},
                    reset: function() {}
                };
            }
            this.showDebugHeader();
            this.isRunning = true;
            if (this.config && this.config["forceSetTimeOut"]) {
                this.raf = new Phaser.RequestAnimationFrame(this, this.config["forceSetTimeOut"]);
            } else {
                this.raf = new Phaser.RequestAnimationFrame(this, false);
            }
            this._kickstart = true;
            if (window["focus"]) {
                if (!window["PhaserGlobal"] || window["PhaserGlobal"] && !window["PhaserGlobal"].stopFocus) {
                    window.focus();
                }
            }
            this.raf.start();
        },
        showDebugHeader: function() {
            if (window["PhaserGlobal"] && window["PhaserGlobal"].hideBanner) {
                return;
            }
            var v = Phaser.VERSION;
            var r = "Canvas";
            var a = "HTML Audio";
            var c = 1;
            if (this.renderType === Phaser.WEBGL) {
                r = "WebGL";
                c++;
            } else if (this.renderType == Phaser.HEADLESS) {
                r = "Headless";
            }
            if (this.device.webAudio) {
                a = "WebAudio";
                c++;
            }
            if (this.device.chrome) {
                var args = [ "%c %c %c Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + "  %c %c " + "%c http://phaser.io %c♥%c♥%c♥", "background: #9854d8", "background: #6c2ca7", "color: #ffffff; background: #450f78;", "background: #6c2ca7", "background: #9854d8", "background: #ffffff" ];
                for (var i = 0; i < 3; i++) {
                    if (i < c) {
                        args.push("color: #ff2424; background: #fff");
                    } else {
                        args.push("color: #959595; background: #fff");
                    }
                }
                console.log.apply(console, args);
            } else if (window["console"]) {
                console.log("Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + " | http://phaser.io");
            }
        },
        setUpRenderer: function() {
            this.canvas = Phaser.Canvas.create(this, this.width, this.height, this.config["canvasID"], true);
            if (this.config["canvasStyle"]) {
                this.canvas.style = this.config["canvasStyle"];
            } else {
                this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
            }
            if (this.device.cocoonJS) {
                if (this.renderType === Phaser.CANVAS) {
                    this.canvas.screencanvas = true;
                } else {
                    this.canvas.screencanvas = false;
                }
            }
            if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || this.renderType === Phaser.AUTO && this.device.webGL === false) {
                if (this.device.canvas) {
                    if (this.renderType === Phaser.AUTO) {
                        this.renderType = Phaser.CANVAS;
                    }
                    this.renderer = new PIXI.CanvasRenderer(this.width, this.height, {
                        view: this.canvas,
                        transparent: this.transparent,
                        resolution: this.resolution,
                        clearBeforeRender: true
                    });
                    this.context = this.renderer.context;
                } else {
                    throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                }
            } else {
                this.renderType = Phaser.WEBGL;
                this.renderer = new PIXI.WebGLRenderer(this.width, this.height, {
                    view: this.canvas,
                    transparent: this.transparent,
                    resolution: this.resolution,
                    antialias: this.antialias,
                    preserveDrawingBuffer: this.preserveDrawingBuffer
                });
                this.context = null;
                this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), false);
                this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), false);
            }
            if (this.renderType !== Phaser.HEADLESS) {
                this.stage.smoothed = this.antialias;
                Phaser.Canvas.addToDOM(this.canvas, this.parent, false);
                Phaser.Canvas.setTouchAction(this.canvas);
            }
        },
        contextLost: function(event) {
            event.preventDefault();
            this.renderer.contextLost = true;
        },
        contextRestored: function() {
            this.renderer.initContext();
            this.cache.clearGLTextures();
            this.renderer.contextLost = false;
        },
        update: function(time) {
            this.time.update(time);
            if (this._kickstart) {
                this.updateLogic(1 / this.time.desiredFps);
                this.stage.updateTransform();
                this.updateRender(this.time.slowMotion * this.time.desiredFps);
                this._kickstart = false;
                return;
            }
            if (this._spiraling > 1 && !this.forceSingleUpdate) {
                if (this.time.time > this._nextFpsNotification) {
                    this._nextFpsNotification = this.time.time + 1e3 * 10;
                    this.fpsProblemNotifier.dispatch();
                }
                this._deltaTime = 0;
                this._spiraling = 0;
                this.updateRender(this.time.slowMotion * this.time.desiredFps);
            } else {
                var slowStep = this.time.slowMotion * 1e3 / this.time.desiredFps;
                this._deltaTime += Math.max(Math.min(slowStep * 3, this.time.elapsed), 0);
                var count = 0;
                this.updatesThisFrame = Math.floor(this._deltaTime / slowStep);
                if (this.forceSingleUpdate) {
                    this.updatesThisFrame = Math.min(1, this.updatesThisFrame);
                }
                while (this._deltaTime >= slowStep) {
                    this._deltaTime -= slowStep;
                    this.currentUpdateID = count;
                    this.updateLogic(1 / this.time.desiredFps);
                    this.stage.updateTransform();
                    count++;
                    if (this.forceSingleUpdate && count === 1) {
                        break;
                    }
                }
                if (count > this._lastCount) {
                    this._spiraling++;
                } else if (count < this._lastCount) {
                    this._spiraling = 0;
                }
                this._lastCount = count;
                this.updateRender(this._deltaTime / slowStep);
            }
        },
        updateLogic: function(timeStep) {
            if (!this._paused && !this.pendingStep) {
                if (this.stepping) {
                    this.pendingStep = true;
                }
                this.scale.preUpdate();
                this.debug.preUpdate();
                this.world.camera.preUpdate();
                this.physics.preUpdate();
                this.state.preUpdate(timeStep);
                this.plugins.preUpdate(timeStep);
                this.stage.preUpdate();
                this.state.update();
                this.stage.update();
                this.tweens.update(timeStep);
                this.sound.update();
                this.input.update();
                this.physics.update();
                this.particles.update();
                this.plugins.update();
                this.stage.postUpdate();
                this.plugins.postUpdate();
            } else {
                this.scale.pauseUpdate();
                this.state.pauseUpdate();
                this.debug.preUpdate();
            }
        },
        updateRender: function(elapsedTime) {
            if (this.lockRender) {
                return;
            }
            this.state.preRender(elapsedTime);
            this.renderer.render(this.stage);
            this.plugins.render(elapsedTime);
            this.state.render(elapsedTime);
            this.plugins.postRender(elapsedTime);
        },
        enableStep: function() {
            this.stepping = true;
            this.pendingStep = false;
            this.stepCount = 0;
        },
        disableStep: function() {
            this.stepping = false;
            this.pendingStep = false;
        },
        step: function() {
            this.pendingStep = false;
            this.stepCount++;
        },
        destroy: function() {
            this.raf.stop();
            this.state.destroy();
            this.sound.destroy();
            this.scale.destroy();
            this.stage.destroy();
            this.input.destroy();
            this.physics.destroy();
            this.state = null;
            this.cache = null;
            this.input = null;
            this.load = null;
            this.sound = null;
            this.stage = null;
            this.time = null;
            this.world = null;
            this.isBooted = false;
            this.renderer.destroy(false);
            Phaser.Canvas.removeFromDOM(this.canvas);
            Phaser.GAMES[this.id] = null;
        },
        gamePaused: function(event) {
            if (!this._paused) {
                this._paused = true;
                this.time.gamePaused();
                this.sound.setMute();
                this.onPause.dispatch(event);
                if (this.device.cordova && this.device.iOS) {
                    this.lockRender = true;
                }
            }
        },
        gameResumed: function(event) {
            if (this._paused && !this._codePaused) {
                this._paused = false;
                this.time.gameResumed();
                this.input.reset();
                this.sound.unsetMute();
                this.onResume.dispatch(event);
                if (this.device.cordova && this.device.iOS) {
                    this.lockRender = false;
                }
            }
        },
        focusLoss: function(event) {
            this.onBlur.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gamePaused(event);
            }
        },
        focusGain: function(event) {
            this.onFocus.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gameResumed(event);
            }
        }
    };
    Phaser.Game.prototype.constructor = Phaser.Game;
    Object.defineProperty(Phaser.Game.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(value) {
            if (value === true) {
                if (this._paused === false) {
                    this._paused = true;
                    this.sound.setMute();
                    this.time.gamePaused();
                    this.onPause.dispatch(this);
                }
                this._codePaused = true;
            } else {
                if (this._paused) {
                    this._paused = false;
                    this.input.reset();
                    this.sound.unsetMute();
                    this.time.gameResumed();
                    this.onResume.dispatch(this);
                }
                this._codePaused = false;
            }
        }
    });
    Phaser.Input = function(game) {
        this.game = game;
        this.hitCanvas = null;
        this.hitContext = null;
        this.moveCallbacks = [];
        this.pollRate = 0;
        this.enabled = true;
        this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE;
        this.position = null;
        this.speed = null;
        this.circle = null;
        this.scale = null;
        this.maxPointers = -1;
        this.tapRate = 200;
        this.doubleTapRate = 300;
        this.holdRate = 2e3;
        this.justPressedRate = 200;
        this.justReleasedRate = 200;
        this.recordPointerHistory = false;
        this.recordRate = 100;
        this.recordLimit = 100;
        this.pointer1 = null;
        this.pointer2 = null;
        this.pointer3 = null;
        this.pointer4 = null;
        this.pointer5 = null;
        this.pointer6 = null;
        this.pointer7 = null;
        this.pointer8 = null;
        this.pointer9 = null;
        this.pointer10 = null;
        this.pointers = [];
        this.activePointer = null;
        this.mousePointer = null;
        this.mouse = null;
        this.keyboard = null;
        this.touch = null;
        this.mspointer = null;
        this.gamepad = null;
        this.resetLocked = false;
        this.onDown = null;
        this.onUp = null;
        this.onTap = null;
        this.onHold = null;
        this.minPriorityID = 0;
        this.interactiveItems = new Phaser.ArraySet();
        this._localPoint = new Phaser.Point();
        this._pollCounter = 0;
        this._oldPosition = null;
        this._x = 0;
        this._y = 0;
    };
    Phaser.Input.MOUSE_OVERRIDES_TOUCH = 0;
    Phaser.Input.TOUCH_OVERRIDES_MOUSE = 1;
    Phaser.Input.MOUSE_TOUCH_COMBINE = 2;
    Phaser.Input.MAX_POINTERS = 10;
    Phaser.Input.prototype = {
        boot: function() {
            this.mousePointer = new Phaser.Pointer(this.game, 0);
            this.addPointer();
            this.addPointer();
            this.mouse = new Phaser.Mouse(this.game);
            this.touch = new Phaser.Touch(this.game);
            this.mspointer = new Phaser.MSPointer(this.game);
            if (Phaser.Keyboard) {
                this.keyboard = new Phaser.Keyboard(this.game);
            }
            if (Phaser.Gamepad) {
                this.gamepad = new Phaser.Gamepad(this.game);
            }
            this.onDown = new Phaser.Signal();
            this.onUp = new Phaser.Signal();
            this.onTap = new Phaser.Signal();
            this.onHold = new Phaser.Signal();
            this.scale = new Phaser.Point(1, 1);
            this.speed = new Phaser.Point();
            this.position = new Phaser.Point();
            this._oldPosition = new Phaser.Point();
            this.circle = new Phaser.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1);
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = true;
            if (this.keyboard) {
                this.keyboard.start();
            }
            var _this = this;
            this._onClickTrampoline = function(event) {
                _this.onClickTrampoline(event);
            };
            this.game.canvas.addEventListener("click", this._onClickTrampoline, false);
        },
        destroy: function() {
            this.mouse.stop();
            this.touch.stop();
            this.mspointer.stop();
            if (this.keyboard) {
                this.keyboard.stop();
            }
            if (this.gamepad) {
                this.gamepad.stop();
            }
            this.moveCallbacks = [];
            PIXI.CanvasPool.remove(this);
            this.game.canvas.removeEventListener("click", this._onClickTrampoline);
        },
        addMoveCallback: function(callback, context) {
            this.moveCallbacks.push({
                callback: callback,
                context: context
            });
        },
        deleteMoveCallback: function(callback, context) {
            var i = this.moveCallbacks.length;
            while (i--) {
                if (this.moveCallbacks[i].callback === callback && this.moveCallbacks[i].context === context) {
                    this.moveCallbacks.splice(i, 1);
                    return;
                }
            }
        },
        addPointer: function() {
            if (this.pointers.length >= Phaser.Input.MAX_POINTERS) {
                console.warn("Phaser.Input.addPointer: Maximum limit of " + Phaser.Input.MAX_POINTERS + " pointers reached.");
                return null;
            }
            var id = this.pointers.length + 1;
            var pointer = new Phaser.Pointer(this.game, id);
            this.pointers.push(pointer);
            this["pointer" + id] = pointer;
            return pointer;
        },
        update: function() {
            if (this.keyboard) {
                this.keyboard.update();
            }
            if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
                this._pollCounter++;
                return;
            }
            this.speed.x = this.position.x - this._oldPosition.x;
            this.speed.y = this.position.y - this._oldPosition.y;
            this._oldPosition.copyFrom(this.position);
            this.mousePointer.update();
            if (this.gamepad && this.gamepad.active) {
                this.gamepad.update();
            }
            for (var i = 0; i < this.pointers.length; i++) {
                this.pointers[i].update();
            }
            this._pollCounter = 0;
        },
        reset: function(hard) {
            if (!this.game.isBooted || this.resetLocked) {
                return;
            }
            if (hard === undefined) {
                hard = false;
            }
            this.mousePointer.reset();
            if (this.keyboard) {
                this.keyboard.reset(hard);
            }
            if (this.gamepad) {
                this.gamepad.reset();
            }
            for (var i = 0; i < this.pointers.length; i++) {
                this.pointers[i].reset();
            }
            if (this.game.canvas.style.cursor !== "none") {
                this.game.canvas.style.cursor = "inherit";
            }
            if (hard) {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onTap.dispose();
                this.onHold.dispose();
                this.onDown = new Phaser.Signal();
                this.onUp = new Phaser.Signal();
                this.onTap = new Phaser.Signal();
                this.onHold = new Phaser.Signal();
                this.moveCallbacks = [];
            }
            this._pollCounter = 0;
        },
        resetSpeed: function(x, y) {
            this._oldPosition.setTo(x, y);
            this.speed.setTo(0, 0);
        },
        startPointer: function(event) {
            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) {
                return null;
            }
            if (!this.pointer1.active) {
                return this.pointer1.start(event);
            }
            if (!this.pointer2.active) {
                return this.pointer2.start(event);
            }
            for (var i = 2; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (!pointer.active) {
                    return pointer.start(event);
                }
            }
            return null;
        },
        updatePointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier === event.identifier) {
                return this.pointer1.move(event);
            }
            if (this.pointer2.active && this.pointer2.identifier === event.identifier) {
                return this.pointer2.move(event);
            }
            for (var i = 2; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (pointer.active && pointer.identifier === event.identifier) {
                    return pointer.move(event);
                }
            }
            return null;
        },
        stopPointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier === event.identifier) {
                return this.pointer1.stop(event);
            }
            if (this.pointer2.active && this.pointer2.identifier === event.identifier) {
                return this.pointer2.stop(event);
            }
            for (var i = 2; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (pointer.active && pointer.identifier === event.identifier) {
                    return pointer.stop(event);
                }
            }
            return null;
        },
        countActivePointers: function(limit) {
            if (limit === undefined) {
                limit = this.pointers.length;
            }
            var count = limit;
            for (var i = 0; i < this.pointers.length && count > 0; i++) {
                var pointer = this.pointers[i];
                if (pointer.active) {
                    count--;
                }
            }
            return limit - count;
        },
        getPointer: function(isActive) {
            if (isActive === undefined) {
                isActive = false;
            }
            for (var i = 0; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (pointer.active === isActive) {
                    return pointer;
                }
            }
            return null;
        },
        getPointerFromIdentifier: function(identifier) {
            for (var i = 0; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (pointer.identifier === identifier) {
                    return pointer;
                }
            }
            return null;
        },
        getPointerFromId: function(pointerId) {
            for (var i = 0; i < this.pointers.length; i++) {
                var pointer = this.pointers[i];
                if (pointer.pointerId === pointerId) {
                    return pointer;
                }
            }
            return null;
        },
        getLocalPosition: function(displayObject, pointer, output) {
            if (output === undefined) {
                output = new Phaser.Point();
            }
            var wt = displayObject.worldTransform;
            var id = 1 / (wt.a * wt.d + wt.c * -wt.b);
            return output.setTo(wt.d * id * pointer.x + -wt.c * id * pointer.y + (wt.ty * wt.c - wt.tx * wt.d) * id, wt.a * id * pointer.y + -wt.b * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.b) * id);
        },
        hitTest: function(displayObject, pointer, localPoint) {
            if (!displayObject.worldVisible) {
                return false;
            }
            this.getLocalPosition(displayObject, pointer, this._localPoint);
            localPoint.copyFrom(this._localPoint);
            if (displayObject.hitArea && displayObject.hitArea.contains) {
                return displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y);
            } else if (displayObject instanceof Phaser.TileSprite) {
                var width = displayObject.width;
                var height = displayObject.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            } else if (displayObject instanceof PIXI.Sprite) {
                var width = displayObject.texture.frame.width;
                var height = displayObject.texture.frame.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            } else if (displayObject instanceof Phaser.Graphics) {
                for (var i = 0; i < displayObject.graphicsData.length; i++) {
                    var data = displayObject.graphicsData[i];
                    if (!data.fill) {
                        continue;
                    }
                    if (data.shape && data.shape.contains(this._localPoint.x, this._localPoint.y)) {
                        return true;
                    }
                }
            }
            for (var i = 0, len = displayObject.children.length; i < len; i++) {
                if (this.hitTest(displayObject.children[i], pointer, localPoint)) {
                    return true;
                }
            }
            return false;
        },
        onClickTrampoline: function() {
            this.activePointer.processClickTrampolines();
        }
    };
    Phaser.Input.prototype.constructor = Phaser.Input;
    Object.defineProperty(Phaser.Input.prototype, "x", {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "y", {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalInactivePointers", {
        get: function() {
            return this.pointers.length - this.countActivePointers();
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalActivePointers", {
        get: function() {
            return this.countActivePointers();
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y;
        }
    });
    Phaser.Mouse = function(game) {
        this.game = game;
        this.input = game.input;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseUpCallback = null;
        this.mouseOutCallback = null;
        this.mouseOverCallback = null;
        this.mouseWheelCallback = null;
        this.capture = false;
        this.button = -1;
        this.wheelDelta = 0;
        this.enabled = true;
        this.locked = false;
        this.stopOnGameOut = false;
        this.pointerLock = new Phaser.Signal();
        this.event = null;
        this._onMouseDown = null;
        this._onMouseMove = null;
        this._onMouseUp = null;
        this._onMouseOut = null;
        this._onMouseOver = null;
        this._onMouseWheel = null;
        this._wheelEvent = null;
    };
    Phaser.Mouse.NO_BUTTON = -1;
    Phaser.Mouse.LEFT_BUTTON = 0;
    Phaser.Mouse.MIDDLE_BUTTON = 1;
    Phaser.Mouse.RIGHT_BUTTON = 2;
    Phaser.Mouse.BACK_BUTTON = 3;
    Phaser.Mouse.FORWARD_BUTTON = 4;
    Phaser.Mouse.WHEEL_UP = 1;
    Phaser.Mouse.WHEEL_DOWN = -1;
    Phaser.Mouse.prototype = {
        start: function() {
            if (this.game.device.android && this.game.device.chrome === false) {
                return;
            }
            if (this._onMouseDown !== null) {
                return;
            }
            var _this = this;
            this._onMouseDown = function(event) {
                return _this.onMouseDown(event);
            };
            this._onMouseMove = function(event) {
                return _this.onMouseMove(event);
            };
            this._onMouseUp = function(event) {
                return _this.onMouseUp(event);
            };
            this._onMouseUpGlobal = function(event) {
                return _this.onMouseUpGlobal(event);
            };
            this._onMouseOut = function(event) {
                return _this.onMouseOut(event);
            };
            this._onMouseOver = function(event) {
                return _this.onMouseOver(event);
            };
            this._onMouseWheel = function(event) {
                return _this.onMouseWheel(event);
            };
            var canvas = this.game.canvas;
            canvas.addEventListener("mousedown", this._onMouseDown, true);
            canvas.addEventListener("mousemove", this._onMouseMove, true);
            canvas.addEventListener("mouseup", this._onMouseUp, true);
            if (!this.game.device.cocoonJS) {
                window.addEventListener("mouseup", this._onMouseUpGlobal, true);
                canvas.addEventListener("mouseover", this._onMouseOver, true);
                canvas.addEventListener("mouseout", this._onMouseOut, true);
            }
            var wheelEvent = this.game.device.wheelEvent;
            if (wheelEvent) {
                canvas.addEventListener(wheelEvent, this._onMouseWheel, true);
                if (wheelEvent === "mousewheel") {
                    this._wheelEvent = new WheelEventProxy(-1 / 40, 1);
                } else if (wheelEvent === "DOMMouseScroll") {
                    this._wheelEvent = new WheelEventProxy(1, 1);
                }
            }
        },
        onMouseDown: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.mouseDownCallback) {
                this.mouseDownCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event["identifier"] = 0;
            this.input.mousePointer.start(event);
        },
        onMouseMove: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.mouseMoveCallback) {
                this.mouseMoveCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event["identifier"] = 0;
            this.input.mousePointer.move(event);
        },
        onMouseUp: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.mouseUpCallback) {
                this.mouseUpCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event["identifier"] = 0;
            this.input.mousePointer.stop(event);
        },
        onMouseUpGlobal: function(event) {
            if (!this.input.mousePointer.withinGame) {
                if (this.mouseUpCallback) {
                    this.mouseUpCallback.call(this.callbackContext, event);
                }
                event["identifier"] = 0;
                this.input.mousePointer.stop(event);
            }
        },
        onMouseOut: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.input.mousePointer.withinGame = false;
            if (this.mouseOutCallback) {
                this.mouseOutCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            if (this.stopOnGameOut) {
                event["identifier"] = 0;
                this.input.mousePointer.stop(event);
            }
        },
        onMouseOver: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.input.mousePointer.withinGame = true;
            if (this.mouseOverCallback) {
                this.mouseOverCallback.call(this.callbackContext, event);
            }
        },
        onMouseWheel: function(event) {
            if (this._wheelEvent) {
                event = this._wheelEvent.bindEvent(event);
            }
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.wheelDelta = Phaser.Math.clamp(-event.deltaY, -1, 1);
            if (this.mouseWheelCallback) {
                this.mouseWheelCallback.call(this.callbackContext, event);
            }
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var element = this.game.canvas;
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
                var _this = this;
                this._pointerLockChange = function(event) {
                    return _this.pointerLockChange(event);
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true);
            }
        },
        pointerLockChange: function(event) {
            var element = this.game.canvas;
            if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                this.locked = true;
                this.pointerLock.dispatch(true, event);
            } else {
                this.locked = false;
                this.pointerLock.dispatch(false, event);
            }
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        },
        stop: function() {
            var canvas = this.game.canvas;
            canvas.removeEventListener("mousedown", this._onMouseDown, true);
            canvas.removeEventListener("mousemove", this._onMouseMove, true);
            canvas.removeEventListener("mouseup", this._onMouseUp, true);
            canvas.removeEventListener("mouseover", this._onMouseOver, true);
            canvas.removeEventListener("mouseout", this._onMouseOut, true);
            var wheelEvent = this.game.device.wheelEvent;
            if (wheelEvent) {
                canvas.removeEventListener(wheelEvent, this._onMouseWheel, true);
            }
            window.removeEventListener("mouseup", this._onMouseUpGlobal, true);
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        }
    };
    Phaser.Mouse.prototype.constructor = Phaser.Mouse;
    function WheelEventProxy(scaleFactor, deltaMode) {
        this._scaleFactor = scaleFactor;
        this._deltaMode = deltaMode;
        this.originalEvent = null;
    }
    WheelEventProxy.prototype = {};
    WheelEventProxy.prototype.constructor = WheelEventProxy;
    WheelEventProxy.prototype.bindEvent = function(event) {
        if (!WheelEventProxy._stubsGenerated && event) {
            var makeBinder = function(name) {
                return function() {
                    var v = this.originalEvent[name];
                    return typeof v !== "function" ? v : v.bind(this.originalEvent);
                };
            };
            for (var prop in event) {
                if (!(prop in WheelEventProxy.prototype)) {
                    Object.defineProperty(WheelEventProxy.prototype, prop, {
                        get: makeBinder(prop)
                    });
                }
            }
            WheelEventProxy._stubsGenerated = true;
        }
        this.originalEvent = event;
        return this;
    };
    Object.defineProperties(WheelEventProxy.prototype, {
        type: {
            value: "wheel"
        },
        deltaMode: {
            get: function() {
                return this._deltaMode;
            }
        },
        deltaY: {
            get: function() {
                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
            }
        },
        deltaX: {
            get: function() {
                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
            }
        },
        deltaZ: {
            value: 0
        }
    });
    Phaser.MSPointer = function(game) {
        this.game = game;
        this.input = game.input;
        this.callbackContext = this.game;
        this.pointerDownCallback = null;
        this.pointerMoveCallback = null;
        this.pointerUpCallback = null;
        this.capture = true;
        this.button = -1;
        this.event = null;
        this.enabled = true;
        this._onMSPointerDown = null;
        this._onMSPointerMove = null;
        this._onMSPointerUp = null;
        this._onMSPointerUpGlobal = null;
        this._onMSPointerOut = null;
        this._onMSPointerOver = null;
    };
    Phaser.MSPointer.prototype = {
        start: function() {
            if (this._onMSPointerDown !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.mspointer) {
                this._onMSPointerDown = function(event) {
                    return _this.onPointerDown(event);
                };
                this._onMSPointerMove = function(event) {
                    return _this.onPointerMove(event);
                };
                this._onMSPointerUp = function(event) {
                    return _this.onPointerUp(event);
                };
                this._onMSPointerUpGlobal = function(event) {
                    return _this.onPointerUpGlobal(event);
                };
                this._onMSPointerOut = function(event) {
                    return _this.onPointerOut(event);
                };
                this._onMSPointerOver = function(event) {
                    return _this.onPointerOver(event);
                };
                var canvas = this.game.canvas;
                canvas.addEventListener("MSPointerDown", this._onMSPointerDown, false);
                canvas.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                canvas.addEventListener("MSPointerUp", this._onMSPointerUp, false);
                canvas.addEventListener("pointerdown", this._onMSPointerDown, false);
                canvas.addEventListener("pointermove", this._onMSPointerMove, false);
                canvas.addEventListener("pointerup", this._onMSPointerUp, false);
                canvas.style["-ms-content-zooming"] = "none";
                canvas.style["-ms-touch-action"] = "none";
                if (!this.game.device.cocoonJS) {
                    window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, true);
                    canvas.addEventListener("MSPointerOver", this._onMSPointerOver, true);
                    canvas.addEventListener("MSPointerOut", this._onMSPointerOut, true);
                    window.addEventListener("pointerup", this._onMSPointerUpGlobal, true);
                    canvas.addEventListener("pointerover", this._onMSPointerOver, true);
                    canvas.addEventListener("pointerout", this._onMSPointerOut, true);
                }
            }
        },
        onPointerDown: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.pointerDownCallback) {
                this.pointerDownCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event.identifier = event.pointerId;
            if (event.pointerType === "mouse" || event.pointerType === 4) {
                this.input.mousePointer.start(event);
            } else {
                this.input.startPointer(event);
            }
        },
        onPointerMove: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.pointerMoveCallback) {
                this.pointerMoveCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event.identifier = event.pointerId;
            if (event.pointerType === "mouse" || event.pointerType === 4) {
                this.input.mousePointer.move(event);
            } else {
                this.input.updatePointer(event);
            }
        },
        onPointerUp: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.pointerUpCallback) {
                this.pointerUpCallback.call(this.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            event.identifier = event.pointerId;
            if (event.pointerType === "mouse" || event.pointerType === 4) {
                this.input.mousePointer.stop(event);
            } else {
                this.input.stopPointer(event);
            }
        },
        onPointerUpGlobal: function(event) {
            if ((event.pointerType === "mouse" || event.pointerType === 4) && !this.input.mousePointer.withinGame) {
                this.onPointerUp(event);
            } else {
                var pointer = this.input.getPointerFromIdentifier(event.identifier);
                if (pointer && pointer.withinGame) {
                    this.onPointerUp(event);
                }
            }
        },
        onPointerOut: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (event.pointerType === "mouse" || event.pointerType === 4) {
                this.input.mousePointer.withinGame = false;
            } else {
                var pointer = this.input.getPointerFromIdentifier(event.identifier);
                if (pointer) {
                    pointer.withinGame = false;
                }
            }
            if (this.input.mouse.mouseOutCallback) {
                this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, event);
            }
            if (!this.input.enabled || !this.enabled) {
                return;
            }
            if (this.input.mouse.stopOnGameOut) {
                event["identifier"] = 0;
                if (pointer) {
                    pointer.stop(event);
                } else {
                    this.input.mousePointer.stop(event);
                }
            }
        },
        onPointerOver: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (event.pointerType === "mouse" || event.pointerType === 4) {
                this.input.mousePointer.withinGame = true;
            } else {
                var pointer = this.input.getPointerFromIdentifier(event.identifier);
                if (pointer) {
                    pointer.withinGame = true;
                }
            }
            if (this.input.mouse.mouseOverCallback) {
                this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, event);
            }
        },
        stop: function() {
            var canvas = this.game.canvas;
            canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
            canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
            canvas.removeEventListener("MSPointerOver", this._onMSPointerOver);
            canvas.removeEventListener("MSPointerOut", this._onMSPointerOut);
            canvas.removeEventListener("pointerdown", this._onMSPointerDown);
            canvas.removeEventListener("pointermove", this._onMSPointerMove);
            canvas.removeEventListener("pointerup", this._onMSPointerUp);
            canvas.removeEventListener("pointerover", this._onMSPointerOver);
            canvas.removeEventListener("pointerout", this._onMSPointerOut);
            window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal);
            window.removeEventListener("pointerup", this._onMSPointerUpGlobal);
        }
    };
    Phaser.MSPointer.prototype.constructor = Phaser.MSPointer;
    Phaser.DeviceButton = function(parent, buttonCode) {
        this.parent = parent;
        this.game = parent.game;
        this.event = null;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = 0;
        this.repeats = 0;
        this.altKey = false;
        this.shiftKey = false;
        this.ctrlKey = false;
        this.value = 0;
        this.buttonCode = buttonCode;
        this.onDown = new Phaser.Signal();
        this.onUp = new Phaser.Signal();
        this.onFloat = new Phaser.Signal();
    };
    Phaser.DeviceButton.prototype = {
        start: function(event, value) {
            if (this.isDown) {
                return;
            }
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.time;
            this.duration = 0;
            this.repeats = 0;
            this.event = event;
            this.value = value;
            if (event) {
                this.altKey = event.altKey;
                this.shiftKey = event.shiftKey;
                this.ctrlKey = event.ctrlKey;
            }
            this.onDown.dispatch(this, value);
        },
        stop: function(event, value) {
            if (this.isUp) {
                return;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.time;
            this.event = event;
            this.value = value;
            if (event) {
                this.altKey = event.altKey;
                this.shiftKey = event.shiftKey;
                this.ctrlKey = event.ctrlKey;
            }
            this.onUp.dispatch(this, value);
        },
        padFloat: function(value) {
            this.value = value;
            this.onFloat.dispatch(this, value);
        },
        justPressed: function(duration) {
            duration = duration || 250;
            return this.isDown && this.timeDown + duration > this.game.time.time;
        },
        justReleased: function(duration) {
            duration = duration || 250;
            return this.isUp && this.timeUp + duration > this.game.time.time;
        },
        reset: function() {
            this.isDown = false;
            this.isUp = true;
            this.timeDown = this.game.time.time;
            this.duration = 0;
            this.repeats = 0;
            this.altKey = false;
            this.shiftKey = false;
            this.ctrlKey = false;
        },
        destroy: function() {
            this.onDown.dispose();
            this.onUp.dispose();
            this.onFloat.dispose();
            this.parent = null;
            this.game = null;
        }
    };
    Phaser.DeviceButton.prototype.constructor = Phaser.DeviceButton;
    Object.defineProperty(Phaser.DeviceButton.prototype, "duration", {
        get: function() {
            if (this.isUp) {
                return -1;
            }
            return this.game.time.time - this.timeDown;
        }
    });
    Phaser.Pointer = function(game, id) {
        this.game = game;
        this.id = id;
        this.type = Phaser.POINTER;
        this.exists = true;
        this.identifier = 0;
        this.pointerId = null;
        this.target = null;
        this.button = null;
        this.leftButton = new Phaser.DeviceButton(this, Phaser.Pointer.LEFT_BUTTON);
        this.middleButton = new Phaser.DeviceButton(this, Phaser.Pointer.MIDDLE_BUTTON);
        this.rightButton = new Phaser.DeviceButton(this, Phaser.Pointer.RIGHT_BUTTON);
        this.backButton = new Phaser.DeviceButton(this, Phaser.Pointer.BACK_BUTTON);
        this.forwardButton = new Phaser.DeviceButton(this, Phaser.Pointer.FORWARD_BUTTON);
        this.eraserButton = new Phaser.DeviceButton(this, Phaser.Pointer.ERASER_BUTTON);
        this._holdSent = false;
        this._history = [];
        this._nextDrop = 0;
        this._stateReset = false;
        this.withinGame = false;
        this.clientX = -1;
        this.clientY = -1;
        this.pageX = -1;
        this.pageY = -1;
        this.screenX = -1;
        this.screenY = -1;
        this.rawMovementX = 0;
        this.rawMovementY = 0;
        this.movementX = 0;
        this.movementY = 0;
        this.x = -1;
        this.y = -1;
        this.isMouse = id === 0;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.timeUp = 0;
        this.previousTapTime = 0;
        this.totalTouches = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = false;
        this.dirty = false;
        this.position = new Phaser.Point();
        this.positionDown = new Phaser.Point();
        this.positionUp = new Phaser.Point();
        this.circle = new Phaser.Circle(0, 0, 44);
        this._clickTrampolines = null;
        this._trampolineTargetObject = null;
    };
    Phaser.Pointer.NO_BUTTON = 0;
    Phaser.Pointer.LEFT_BUTTON = 1;
    Phaser.Pointer.RIGHT_BUTTON = 2;
    Phaser.Pointer.MIDDLE_BUTTON = 4;
    Phaser.Pointer.BACK_BUTTON = 8;
    Phaser.Pointer.FORWARD_BUTTON = 16;
    Phaser.Pointer.ERASER_BUTTON = 32;
    Phaser.Pointer.prototype = {
        resetButtons: function() {
            this.isDown = false;
            this.isUp = true;
            if (this.isMouse) {
                this.leftButton.reset();
                this.middleButton.reset();
                this.rightButton.reset();
                this.backButton.reset();
                this.forwardButton.reset();
                this.eraserButton.reset();
            }
        },
        processButtonsDown: function(buttons, event) {
            if (Phaser.Pointer.LEFT_BUTTON & buttons) {
                this.leftButton.start(event);
            }
            if (Phaser.Pointer.RIGHT_BUTTON & buttons) {
                this.rightButton.start(event);
            }
            if (Phaser.Pointer.MIDDLE_BUTTON & buttons) {
                this.middleButton.start(event);
            }
            if (Phaser.Pointer.BACK_BUTTON & buttons) {
                this.backButton.start(event);
            }
            if (Phaser.Pointer.FORWARD_BUTTON & buttons) {
                this.forwardButton.start(event);
            }
            if (Phaser.Pointer.ERASER_BUTTON & buttons) {
                this.eraserButton.start(event);
            }
        },
        processButtonsUp: function(button, event) {
            if (button === Phaser.Mouse.LEFT_BUTTON) {
                this.leftButton.stop(event);
            }
            if (button === Phaser.Mouse.RIGHT_BUTTON) {
                this.rightButton.stop(event);
            }
            if (button === Phaser.Mouse.MIDDLE_BUTTON) {
                this.middleButton.stop(event);
            }
            if (button === Phaser.Mouse.BACK_BUTTON) {
                this.backButton.stop(event);
            }
            if (button === Phaser.Mouse.FORWARD_BUTTON) {
                this.forwardButton.stop(event);
            }
            if (button === 5) {
                this.eraserButton.stop(event);
            }
        },
        updateButtons: function(event) {
            this.button = event.button;
            var down = event.type.toLowerCase().substr(-4) === "down";
            if (event.buttons !== undefined) {
                if (down) {
                    this.processButtonsDown(event.buttons, event);
                } else {
                    this.processButtonsUp(event.button, event);
                }
            } else {
                if (down) {
                    this.leftButton.start(event);
                } else {
                    this.leftButton.stop(event);
                    this.rightButton.stop(event);
                }
            }
            if (event.ctrlKey && this.leftButton.isDown) {
                this.rightButton.start(event);
            }
            this.isUp = true;
            this.isDown = false;
            if (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) {
                this.isUp = false;
                this.isDown = true;
            }
        },
        start: function(event) {
            if (event["pointerId"]) {
                this.pointerId = event.pointerId;
            }
            this.identifier = event.identifier;
            this.target = event.target;
            if (this.isMouse) {
                this.updateButtons(event);
            } else {
                this.isDown = true;
                this.isUp = false;
            }
            this.active = true;
            this.withinGame = true;
            this.dirty = false;
            this._history = [];
            this._clickTrampolines = null;
            this._trampolineTargetObject = null;
            this.msSinceLastClick = this.game.time.time - this.timeDown;
            this.timeDown = this.game.time.time;
            this._holdSent = false;
            this.move(event, true);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.totalActivePointers === 0) {
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.x, this.y);
                this.game.input.onDown.dispatch(this, event);
                this.game.input.resetSpeed(this.x, this.y);
            }
            this._stateReset = false;
            this.totalTouches++;
            if (this.targetObject !== null) {
                this.targetObject._touchedHandler(this);
            }
            return this;
        },
        update: function() {
            if (this.active) {
                if (this.dirty) {
                    if (this.game.input.interactiveItems.total > 0) {
                        this.processInteractiveObjects(false);
                    }
                    this.dirty = false;
                }
                if (this._holdSent === false && this.duration >= this.game.input.holdRate) {
                    if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.totalActivePointers === 0) {
                        this.game.input.onHold.dispatch(this);
                    }
                    this._holdSent = true;
                }
                if (this.game.input.recordPointerHistory && this.game.time.time >= this._nextDrop) {
                    this._nextDrop = this.game.time.time + this.game.input.recordRate;
                    this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    });
                    if (this._history.length > this.game.input.recordLimit) {
                        this._history.shift();
                    }
                }
            }
        },
        move: function(event, fromClick) {
            var input = this.game.input;
            if (input.pollLocked) {
                return;
            }
            if (fromClick === undefined) {
                fromClick = false;
            }
            if (event.button !== undefined) {
                this.button = event.button;
            }
            if (fromClick && this.isMouse) {
                this.updateButtons(event);
            }
            this.clientX = event.clientX;
            this.clientY = event.clientY;
            this.pageX = event.pageX;
            this.pageY = event.pageY;
            this.screenX = event.screenX;
            this.screenY = event.screenY;
            if (this.isMouse && input.mouse.locked && !fromClick) {
                this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                this.movementX += this.rawMovementX;
                this.movementY += this.rawMovementY;
            }
            this.x = (this.pageX - this.game.scale.offset.x) * input.scale.x;
            this.y = (this.pageY - this.game.scale.offset.y) * input.scale.y;
            this.position.setTo(this.x, this.y);
            this.circle.x = this.x;
            this.circle.y = this.y;
            if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0) {
                input.activePointer = this;
                input.x = this.x;
                input.y = this.y;
                input.position.setTo(input.x, input.y);
                input.circle.x = input.x;
                input.circle.y = input.y;
            }
            this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
            if (this.game.paused) {
                return this;
            }
            var i = input.moveCallbacks.length;
            while (i--) {
                input.moveCallbacks[i].callback.call(input.moveCallbacks[i].context, this, this.x, this.y, fromClick);
            }
            if (this.targetObject !== null && this.targetObject.isDragged === true) {
                if (this.targetObject.update(this) === false) {
                    this.targetObject = null;
                }
            } else if (input.interactiveItems.total > 0) {
                this.processInteractiveObjects(fromClick);
            }
            return this;
        },
        processInteractiveObjects: function(fromClick) {
            var highestRenderOrderID = Number.MAX_VALUE;
            var highestInputPriorityID = -1;
            var candidateTarget = null;
            var currentNode = this.game.input.interactiveItems.first;
            while (currentNode) {
                currentNode.checked = false;
                if (currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, false)) {
                    currentNode.checked = true;
                    if (fromClick && currentNode.checkPointerDown(this, true) || !fromClick && currentNode.checkPointerOver(this, true)) {
                        highestRenderOrderID = currentNode.sprite.renderOrderID;
                        highestInputPriorityID = currentNode.priorityID;
                        candidateTarget = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            }
            var currentNode = this.game.input.interactiveItems.first;
            while (currentNode) {
                if (!currentNode.checked && currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, true)) {
                    if (fromClick && currentNode.checkPointerDown(this, false) || !fromClick && currentNode.checkPointerOver(this, false)) {
                        highestRenderOrderID = currentNode.sprite.renderOrderID;
                        highestInputPriorityID = currentNode.priorityID;
                        candidateTarget = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            }
            if (candidateTarget === null) {
                if (this.targetObject) {
                    this.targetObject._pointerOutHandler(this);
                    this.targetObject = null;
                }
            } else {
                if (this.targetObject === null) {
                    this.targetObject = candidateTarget;
                    candidateTarget._pointerOverHandler(this);
                } else {
                    if (this.targetObject === candidateTarget) {
                        if (candidateTarget.update(this) === false) {
                            this.targetObject = null;
                        }
                    } else {
                        this.targetObject._pointerOutHandler(this);
                        this.targetObject = candidateTarget;
                        this.targetObject._pointerOverHandler(this);
                    }
                }
            }
            return this.targetObject !== null;
        },
        leave: function(event) {
            this.withinGame = false;
            this.move(event, false);
        },
        stop: function(event) {
            if (this._stateReset && this.withinGame) {
                event.preventDefault();
                return;
            }
            this.timeUp = this.game.time.time;
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.totalActivePointers === 0) {
                this.game.input.onUp.dispatch(this, event);
                if (this.duration >= 0 && this.duration <= this.game.input.tapRate) {
                    if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate) {
                        this.game.input.onTap.dispatch(this, true);
                    } else {
                        this.game.input.onTap.dispatch(this, false);
                    }
                    this.previousTapTime = this.timeUp;
                }
            }
            if (this.isMouse) {
                this.updateButtons(event);
            } else {
                this.isDown = false;
                this.isUp = true;
            }
            if (this.id > 0) {
                this.active = false;
            }
            this.withinGame = this.game.scale.bounds.contains(event.pageX, event.pageY);
            this.pointerId = null;
            this.identifier = null;
            this.positionUp.setTo(this.x, this.y);
            if (this.isMouse === false) {
                this.game.input.currentPointers--;
            }
            this.game.input.interactiveItems.callAll("_releasedHandler", this);
            if (this._clickTrampolines) {
                this._trampolineTargetObject = this.targetObject;
            }
            this.targetObject = null;
            return this;
        },
        justPressed: function(duration) {
            duration = duration || this.game.input.justPressedRate;
            return this.isDown === true && this.timeDown + duration > this.game.time.time;
        },
        justReleased: function(duration) {
            duration = duration || this.game.input.justReleasedRate;
            return this.isUp && this.timeUp + duration > this.game.time.time;
        },
        addClickTrampoline: function(name, callback, callbackContext, callbackArgs) {
            if (!this.isDown) {
                return;
            }
            var trampolines = this._clickTrampolines = this._clickTrampolines || [];
            for (var i = 0; i < trampolines.length; i++) {
                if (trampolines[i].name === name) {
                    trampolines.splice(i, 1);
                    break;
                }
            }
            trampolines.push({
                name: name,
                targetObject: this.targetObject,
                callback: callback,
                callbackContext: callbackContext,
                callbackArgs: callbackArgs
            });
        },
        processClickTrampolines: function() {
            var trampolines = this._clickTrampolines;
            if (!trampolines) {
                return;
            }
            for (var i = 0; i < trampolines.length; i++) {
                var trampoline = trampolines[i];
                if (trampoline.targetObject === this._trampolineTargetObject) {
                    trampoline.callback.apply(trampoline.callbackContext, trampoline.callbackArgs);
                }
            }
            this._clickTrampolines = null;
            this._trampolineTargetObject = null;
        },
        reset: function() {
            if (this.isMouse === false) {
                this.active = false;
            }
            this.pointerId = null;
            this.identifier = null;
            this.dirty = false;
            this.totalTouches = 0;
            this._holdSent = false;
            this._history.length = 0;
            this._stateReset = true;
            this.resetButtons();
            if (this.targetObject) {
                this.targetObject._releasedHandler(this);
            }
            this.targetObject = null;
        },
        resetMovement: function() {
            this.movementX = 0;
            this.movementY = 0;
        }
    };
    Phaser.Pointer.prototype.constructor = Phaser.Pointer;
    Object.defineProperty(Phaser.Pointer.prototype, "duration", {
        get: function() {
            if (this.isUp) {
                return -1;
            }
            return this.game.time.time - this.timeDown;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y;
        }
    });
    Phaser.Touch = function(game) {
        this.game = game;
        this.enabled = true;
        this.touchLockCallbacks = [];
        this.callbackContext = this.game;
        this.touchStartCallback = null;
        this.touchMoveCallback = null;
        this.touchEndCallback = null;
        this.touchEnterCallback = null;
        this.touchLeaveCallback = null;
        this.touchCancelCallback = null;
        this.preventDefault = true;
        this.event = null;
        this._onTouchStart = null;
        this._onTouchMove = null;
        this._onTouchEnd = null;
        this._onTouchEnter = null;
        this._onTouchLeave = null;
        this._onTouchCancel = null;
        this._onTouchMove = null;
    };
    Phaser.Touch.prototype = {
        start: function() {
            if (this._onTouchStart !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.touch) {
                this._onTouchStart = function(event) {
                    return _this.onTouchStart(event);
                };
                this._onTouchMove = function(event) {
                    return _this.onTouchMove(event);
                };
                this._onTouchEnd = function(event) {
                    return _this.onTouchEnd(event);
                };
                this._onTouchEnter = function(event) {
                    return _this.onTouchEnter(event);
                };
                this._onTouchLeave = function(event) {
                    return _this.onTouchLeave(event);
                };
                this._onTouchCancel = function(event) {
                    return _this.onTouchCancel(event);
                };
                this.game.canvas.addEventListener("touchstart", this._onTouchStart, false);
                this.game.canvas.addEventListener("touchmove", this._onTouchMove, false);
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, false);
                this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false);
                if (!this.game.device.cocoonJS) {
                    this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
                    this.game.canvas.addEventListener("touchleave", this._onTouchLeave, false);
                }
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(event) {
                event.preventDefault();
            };
            document.addEventListener("touchmove", this._documentTouchMove, false);
        },
        addTouchLockCallback: function(callback, context) {
            this.touchLockCallbacks.push({
                callback: callback,
                context: context
            });
        },
        removeTouchLockCallback: function(callback, context) {
            var i = this.touchLockCallbacks.length;
            while (i--) {
                if (this.touchLockCallbacks[i].callback === callback && this.touchLockCallbacks[i].context === context) {
                    this.touchLockCallbacks.splice(i, 1);
                    return true;
                }
            }
            return false;
        },
        onTouchStart: function(event) {
            var i = this.touchLockCallbacks.length;
            while (i--) {
                if (this.touchLockCallbacks[i].callback.call(this.touchLockCallbacks[i].context, this, event)) {
                    this.touchLockCallbacks.splice(i, 1);
                }
            }
            this.event = event;
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this.touchStartCallback) {
                this.touchStartCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.startPointer(event.changedTouches[i]);
            }
        },
        onTouchCancel: function(event) {
            this.event = event;
            if (this.touchCancelCallback) {
                this.touchCancelCallback.call(this.callbackContext, event);
            }
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        onTouchEnter: function(event) {
            this.event = event;
            if (this.touchEnterCallback) {
                this.touchEnterCallback.call(this.callbackContext, event);
            }
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchLeave: function(event) {
            this.event = event;
            if (this.touchLeaveCallback) {
                this.touchLeaveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchMove: function(event) {
            this.event = event;
            if (this.touchMoveCallback) {
                this.touchMoveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.updatePointer(event.changedTouches[i]);
            }
        },
        onTouchEnd: function(event) {
            this.event = event;
            if (this.touchEndCallback) {
                this.touchEndCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        stop: function() {
            if (this.game.device.touch) {
                this.game.canvas.removeEventListener("touchstart", this._onTouchStart);
                this.game.canvas.removeEventListener("touchmove", this._onTouchMove);
                this.game.canvas.removeEventListener("touchend", this._onTouchEnd);
                this.game.canvas.removeEventListener("touchenter", this._onTouchEnter);
                this.game.canvas.removeEventListener("touchleave", this._onTouchLeave);
                this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel);
            }
        }
    };
    Phaser.Touch.prototype.constructor = Phaser.Touch;
    Phaser.InputHandler = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.enabled = false;
        this.checked = false;
        this.priorityID = 0;
        this.useHandCursor = false;
        this._setHandCursor = false;
        this.isDragged = false;
        this.allowHorizontalDrag = true;
        this.allowVerticalDrag = true;
        this.bringToTop = false;
        this.snapOffset = null;
        this.snapOnDrag = false;
        this.snapOnRelease = false;
        this.snapX = 0;
        this.snapY = 0;
        this.snapOffsetX = 0;
        this.snapOffsetY = 0;
        this.pixelPerfectOver = false;
        this.pixelPerfectClick = false;
        this.pixelPerfectAlpha = 255;
        this.draggable = false;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.consumePointerEvent = false;
        this.scaleLayer = false;
        this.dragOffset = new Phaser.Point();
        this.dragFromCenter = false;
        this.dragStartPoint = new Phaser.Point();
        this.snapPoint = new Phaser.Point();
        this._dragPoint = new Phaser.Point();
        this._dragPhase = false;
        this._wasEnabled = false;
        this._tempPoint = new Phaser.Point();
        this._pointerData = [];
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
        });
    };
    Phaser.InputHandler.prototype = {
        start: function(priority, useHandCursor) {
            priority = priority || 0;
            if (useHandCursor === undefined) {
                useHandCursor = false;
            }
            if (this.enabled === false) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = useHandCursor;
                this.priorityID = priority;
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i] = {
                        id: i,
                        x: 0,
                        y: 0,
                        isDown: false,
                        isUp: false,
                        isOver: false,
                        isOut: false,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: false
                    };
                }
                this.snapOffset = new Phaser.Point();
                this.enabled = true;
                this._wasEnabled = true;
            }
            this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);
            this.flagged = false;
            return this.sprite;
        },
        addedToGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this._wasEnabled && !this.enabled) {
                this.start();
            }
        },
        removedFromGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this.enabled) {
                this._wasEnabled = true;
                this.stop();
            } else {
                this._wasEnabled = false;
            }
        },
        reset: function() {
            this.enabled = false;
            this.flagged = false;
            for (var i = 0; i < 10; i++) {
                this._pointerData[i] = {
                    id: i,
                    x: 0,
                    y: 0,
                    isDown: false,
                    isUp: false,
                    isOver: false,
                    isOut: false,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: false
                };
            }
        },
        stop: function() {
            if (this.enabled === false) {
                return;
            } else {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
            }
        },
        destroy: function() {
            if (this.sprite) {
                if (this._setHandCursor) {
                    this.game.canvas.style.cursor = "default";
                    this._setHandCursor = false;
                }
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
                this._pointerData.length = 0;
                this.boundsRect = null;
                this.boundsSprite = null;
                this.sprite = null;
            }
        },
        validForInput: function(highestID, highestRenderID, includePixelPerfect) {
            if (includePixelPerfect === undefined) {
                includePixelPerfect = true;
            }
            if (this.sprite.scale.x === 0 || this.sprite.scale.y === 0 || this.priorityID < this.game.input.minPriorityID) {
                return false;
            }
            if (!includePixelPerfect && (this.pixelPerfectClick || this.pixelPerfectOver)) {
                return false;
            }
            if (this.priorityID > highestID || this.priorityID === highestID && this.sprite.renderOrderID < highestRenderID) {
                return true;
            }
            return false;
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].x;
        },
        pointerY: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].y;
        },
        pointerDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDown;
        },
        pointerUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isUp;
        },
        pointerTimeDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeDown;
        },
        pointerTimeUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeUp;
        },
        pointerOver: function(index) {
            if (this.enabled) {
                if (index === undefined) {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOver) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOver;
                }
            }
            return false;
        },
        pointerOut: function(index) {
            if (this.enabled) {
                if (index === undefined) {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOut) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOut;
                }
            }
            return false;
        },
        pointerTimeOver: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOver;
        },
        pointerTimeOut: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOut;
        },
        pointerDragged: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDragged;
        },
        checkPointerDown: function(pointer, fastTest) {
            if (!pointer.isDown || !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (fastTest === undefined) {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectClick) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPointerOver: function(pointer, fastTest) {
            if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (fastTest === undefined) {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectOver) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPixel: function(x, y, pointer) {
            if (this.sprite.texture.baseTexture.source) {
                if (x === null && y === null) {
                    this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);
                    var x = this._tempPoint.x;
                    var y = this._tempPoint.y;
                }
                if (this.sprite.anchor.x !== 0) {
                    x -= -this.sprite.texture.frame.width * this.sprite.anchor.x;
                }
                if (this.sprite.anchor.y !== 0) {
                    y -= -this.sprite.texture.frame.height * this.sprite.anchor.y;
                }
                x += this.sprite.texture.frame.x;
                y += this.sprite.texture.frame.y;
                if (this.sprite.texture.trim) {
                    x -= this.sprite.texture.trim.x;
                    y -= this.sprite.texture.trim.y;
                    if (x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom) {
                        this._dx = x;
                        this._dy = y;
                        return false;
                    }
                }
                this._dx = x;
                this._dy = y;
                this.game.input.hitContext.clearRect(0, 0, 1, 1);
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);
                var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (rgb.data[3] >= this.pixelPerfectAlpha) {
                    return true;
                }
            }
            return false;
        },
        update: function(pointer) {
            if (this.sprite === null || this.sprite.parent === undefined) {
                return;
            }
            if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) {
                this._pointerOutHandler(pointer);
                return false;
            }
            if (this.draggable && this._draggedPointerID === pointer.id) {
                return this.updateDrag(pointer);
            } else if (this._pointerData[pointer.id].isOver) {
                if (this.checkPointerOver(pointer)) {
                    this._pointerData[pointer.id].x = pointer.x - this.sprite.x;
                    this._pointerData[pointer.id].y = pointer.y - this.sprite.y;
                    return true;
                } else {
                    this._pointerOutHandler(pointer);
                    return false;
                }
            }
        },
        _pointerOverHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            var data = this._pointerData[pointer.id];
            if (data.isOver === false || pointer.dirty) {
                data.isOver = true;
                data.isOut = false;
                data.timeOver = this.game.time.time;
                data.x = pointer.x - this.sprite.x;
                data.y = pointer.y - this.sprite.y;
                if (this.useHandCursor && data.isDragged === false) {
                    this.game.canvas.style.cursor = "pointer";
                    this._setHandCursor = true;
                }
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputOver$dispatch(this.sprite, pointer);
                }
            }
        },
        _pointerOutHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            var data = this._pointerData[pointer.id];
            data.isOver = false;
            data.isOut = true;
            data.timeOut = this.game.time.time;
            if (this.useHandCursor && data.isDragged === false) {
                this.game.canvas.style.cursor = "default";
                this._setHandCursor = false;
            }
            if (this.sprite && this.sprite.events) {
                this.sprite.events.onInputOut$dispatch(this.sprite, pointer);
            }
        },
        _touchedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            var data = this._pointerData[pointer.id];
            if (!data.isDown && data.isOver) {
                if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer)) {
                    return;
                }
                data.isDown = true;
                data.isUp = false;
                data.timeDown = this.game.time.time;
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputDown$dispatch(this.sprite, pointer);
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged === false) {
                    this.startDrag(pointer);
                }
                if (this.bringToTop) {
                    this.sprite.bringToTop();
                }
            }
            return this.consumePointerEvent;
        },
        _releasedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            var data = this._pointerData[pointer.id];
            if (data.isDown && pointer.isUp) {
                data.isDown = false;
                data.isUp = true;
                data.timeUp = this.game.time.time;
                data.downDuration = data.timeUp - data.timeDown;
                var isOver = this.checkPointerOver(pointer);
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputUp$dispatch(this.sprite, pointer, isOver);
                    if (isOver) {
                        isOver = this.checkPointerOver(pointer);
                    }
                }
                data.isOver = isOver;
                if (!isOver && this.useHandCursor) {
                    this.game.canvas.style.cursor = "default";
                    this._setHandCursor = false;
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged && this._draggedPointerID === pointer.id) {
                    this.stopDrag(pointer);
                }
            }
        },
        updateDrag: function(pointer) {
            if (pointer.isUp) {
                this.stopDrag(pointer);
                return false;
            }
            var px = this.globalToLocalX(pointer.x) + this._dragPoint.x + this.dragOffset.x;
            var py = this.globalToLocalY(pointer.y) + this._dragPoint.y + this.dragOffset.y;
            if (this.sprite.fixedToCamera) {
                if (this.allowHorizontalDrag) {
                    this.sprite.cameraOffset.x = px;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.cameraOffset.y = py;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                    this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y);
                }
            } else {
                if (this.allowHorizontalDrag) {
                    this.sprite.x = px;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.y = py;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                    this.snapPoint.set(this.sprite.x, this.sprite.y);
                }
            }
            this.sprite.events.onDragUpdate.dispatch(this.sprite, pointer, px, py, this.snapPoint);
            return true;
        },
        justOver: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOver && this.overDuration(pointer) < delay;
        },
        justOut: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOut && this.game.time.time - this._pointerData[pointer].timeOut < delay;
        },
        justPressed: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isDown && this.downDuration(pointer) < delay;
        },
        justReleased: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isUp && this.game.time.time - this._pointerData[pointer].timeUp < delay;
        },
        overDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isOver) {
                return this.game.time.time - this._pointerData[pointer].timeOver;
            }
            return -1;
        },
        downDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isDown) {
                return this.game.time.time - this._pointerData[pointer].timeDown;
            }
            return -1;
        },
        enableDrag: function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
            if (lockCenter === undefined) {
                lockCenter = false;
            }
            if (bringToTop === undefined) {
                bringToTop = false;
            }
            if (pixelPerfect === undefined) {
                pixelPerfect = false;
            }
            if (alphaThreshold === undefined) {
                alphaThreshold = 255;
            }
            if (boundsRect === undefined) {
                boundsRect = null;
            }
            if (boundsSprite === undefined) {
                boundsSprite = null;
            }
            this._dragPoint = new Phaser.Point();
            this.draggable = true;
            this.bringToTop = bringToTop;
            this.dragOffset = new Phaser.Point();
            this.dragFromCenter = lockCenter;
            this.pixelPerfectClick = pixelPerfect;
            this.pixelPerfectAlpha = alphaThreshold;
            if (boundsRect) {
                this.boundsRect = boundsRect;
            }
            if (boundsSprite) {
                this.boundsSprite = boundsSprite;
            }
        },
        disableDrag: function() {
            if (this._pointerData) {
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i].isDragged = false;
                }
            }
            this.draggable = false;
            this.isDragged = false;
            this._draggedPointerID = -1;
        },
        startDrag: function(pointer) {
            var x = this.sprite.x;
            var y = this.sprite.y;
            this.isDragged = true;
            this._draggedPointerID = pointer.id;
            this._pointerData[pointer.id].isDragged = true;
            if (this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    this.sprite.centerOn(pointer.x, pointer.y);
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                } else {
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                }
            } else {
                if (this.dragFromCenter) {
                    var bounds = this.sprite.getBounds();
                    this.sprite.x = this.globalToLocalX(pointer.x) + (this.sprite.x - bounds.centerX);
                    this.sprite.y = this.globalToLocalY(pointer.y) + (this.sprite.y - bounds.centerY);
                }
                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(pointer.x), this.sprite.y - this.globalToLocalY(pointer.y));
            }
            this.updateDrag(pointer);
            if (this.bringToTop) {
                this._dragPhase = true;
                this.sprite.bringToTop();
            }
            this.dragStartPoint.set(x, y);
            this.sprite.events.onDragStart$dispatch(this.sprite, pointer, x, y);
        },
        globalToLocalX: function(x) {
            if (this.scaleLayer) {
                x -= this.game.scale.grid.boundsFluid.x;
                x *= this.game.scale.grid.scaleFluidInversed.x;
            }
            return x;
        },
        globalToLocalY: function(y) {
            if (this.scaleLayer) {
                y -= this.game.scale.grid.boundsFluid.y;
                y *= this.game.scale.grid.scaleFluidInversed.y;
            }
            return y;
        },
        stopDrag: function(pointer) {
            this.isDragged = false;
            this._draggedPointerID = -1;
            this._pointerData[pointer.id].isDragged = false;
            this._dragPhase = false;
            if (this.snapOnRelease) {
                if (this.sprite.fixedToCamera) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                } else {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            }
            this.sprite.events.onDragStop$dispatch(this.sprite, pointer);
            if (this.checkPointerOver(pointer) === false) {
                this._pointerOutHandler(pointer);
            }
        },
        setDragLock: function(allowHorizontal, allowVertical) {
            if (allowHorizontal === undefined) {
                allowHorizontal = true;
            }
            if (allowVertical === undefined) {
                allowVertical = true;
            }
            this.allowHorizontalDrag = allowHorizontal;
            this.allowVerticalDrag = allowVertical;
        },
        enableSnap: function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
            if (onDrag === undefined) {
                onDrag = true;
            }
            if (onRelease === undefined) {
                onRelease = false;
            }
            if (snapOffsetX === undefined) {
                snapOffsetX = 0;
            }
            if (snapOffsetY === undefined) {
                snapOffsetY = 0;
            }
            this.snapX = snapX;
            this.snapY = snapY;
            this.snapOffsetX = snapOffsetX;
            this.snapOffsetY = snapOffsetY;
            this.snapOnDrag = onDrag;
            this.snapOnRelease = onRelease;
        },
        disableSnap: function() {
            this.snapOnDrag = false;
            this.snapOnRelease = false;
        },
        checkBoundsRect: function() {
            if (this.sprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsRect.left) {
                    this.sprite.cameraOffset.x = this.boundsRect.left;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsRect.top) {
                    this.sprite.cameraOffset.y = this.boundsRect.top;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;
                }
            } else {
                if (this.sprite.left < this.boundsRect.left) {
                    this.sprite.x = this.boundsRect.x + this.sprite.offsetX;
                } else if (this.sprite.right > this.boundsRect.right) {
                    this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX);
                }
                if (this.sprite.top < this.boundsRect.top) {
                    this.sprite.y = this.boundsRect.top + this.sprite.offsetY;
                } else if (this.sprite.bottom > this.boundsRect.bottom) {
                    this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY);
                }
            }
        },
        checkBoundsSprite: function() {
            if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x) {
                    this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width) {
                    this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y) {
                    this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height) {
                    this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height;
                }
            } else {
                if (this.sprite.left < this.boundsSprite.left) {
                    this.sprite.x = this.boundsSprite.left + this.sprite.offsetX;
                } else if (this.sprite.right > this.boundsSprite.right) {
                    this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX);
                }
                if (this.sprite.top < this.boundsSprite.top) {
                    this.sprite.y = this.boundsSprite.top + this.sprite.offsetY;
                } else if (this.sprite.bottom > this.boundsSprite.bottom) {
                    this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY);
                }
            }
        }
    };
    Phaser.InputHandler.prototype.constructor = Phaser.InputHandler;
    Phaser.Gamepad = function(game) {
        this.game = game;
        this._gamepadIndexMap = {};
        this._rawPads = [];
        this._active = false;
        this.enabled = true;
        this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") != -1 || !!navigator.getGamepads;
        this._prevRawGamepadTypes = [];
        this._prevTimestamps = [];
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this._ongamepadconnected = null;
        this._gamepaddisconnected = null;
        this._gamepads = [ new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this) ];
    };
    Phaser.Gamepad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
                this.callbackContext = context;
            }
        },
        start: function() {
            if (this._active) {
                return;
            }
            this._active = true;
            var _this = this;
            this._onGamepadConnected = function(event) {
                return _this.onGamepadConnected(event);
            };
            this._onGamepadDisconnected = function(event) {
                return _this.onGamepadDisconnected(event);
            };
            window.addEventListener("gamepadconnected", this._onGamepadConnected, false);
            window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, false);
        },
        onGamepadConnected: function(event) {
            var newPad = event.gamepad;
            this._rawPads.push(newPad);
            this._gamepads[newPad.index].connect(newPad);
        },
        onGamepadDisconnected: function(event) {
            var removedPad = event.gamepad;
            for (var i in this._rawPads) {
                if (this._rawPads[i].index === removedPad.index) {
                    this._rawPads.splice(i, 1);
                }
            }
            this._gamepads[removedPad.index].disconnect();
        },
        update: function() {
            this._pollGamepads();
            this.pad1.pollStatus();
            this.pad2.pollStatus();
            this.pad3.pollStatus();
            this.pad4.pollStatus();
        },
        _pollGamepads: function() {
            if (navigator["getGamepads"]) {
                var rawGamepads = navigator.getGamepads();
            } else if (navigator["webkitGetGamepads"]) {
                var rawGamepads = navigator.webkitGetGamepads();
            } else if (navigator["webkitGamepads"]) {
                var rawGamepads = navigator.webkitGamepads();
            }
            if (rawGamepads) {
                this._rawPads = [];
                var gamepadsChanged = false;
                for (var i = 0; i < rawGamepads.length; i++) {
                    if (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i]) {
                        gamepadsChanged = true;
                        this._prevRawGamepadTypes[i] = typeof rawGamepads[i];
                    }
                    if (rawGamepads[i]) {
                        this._rawPads.push(rawGamepads[i]);
                    }
                    if (i === 3) {
                        break;
                    }
                }
                if (gamepadsChanged) {
                    var validConnections = {
                        rawIndices: {},
                        padIndices: {}
                    };
                    var singlePad;
                    for (var j = 0; j < this._gamepads.length; j++) {
                        singlePad = this._gamepads[j];
                        if (singlePad.connected) {
                            for (var k = 0; k < this._rawPads.length; k++) {
                                if (this._rawPads[k].index === singlePad.index) {
                                    validConnections.rawIndices[singlePad.index] = true;
                                    validConnections.padIndices[j] = true;
                                }
                            }
                        }
                    }
                    for (var l = 0; l < this._gamepads.length; l++) {
                        singlePad = this._gamepads[l];
                        if (validConnections.padIndices[l]) {
                            continue;
                        }
                        if (this._rawPads.length < 1) {
                            singlePad.disconnect();
                        }
                        for (var m = 0; m < this._rawPads.length; m++) {
                            if (validConnections.padIndices[l]) {
                                break;
                            }
                            var rawPad = this._rawPads[m];
                            if (rawPad) {
                                if (validConnections.rawIndices[rawPad.index]) {
                                    singlePad.disconnect();
                                    continue;
                                } else {
                                    singlePad.connect(rawPad);
                                    validConnections.rawIndices[rawPad.index] = true;
                                    validConnections.padIndices[l] = true;
                                }
                            } else {
                                singlePad.disconnect();
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(value) {
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].deadZone = value;
            }
        },
        stop: function() {
            this._active = false;
            window.removeEventListener("gamepadconnected", this._onGamepadConnected);
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function() {
            this.update();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].reset();
            }
        },
        justPressed: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justPressed(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justReleased(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        isDown: function(buttonCode) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].isDown(buttonCode) === true) {
                    return true;
                }
            }
            return false;
        },
        destroy: function() {
            this.stop();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].destroy();
            }
        }
    };
    Phaser.Gamepad.prototype.constructor = Phaser.Gamepad;
    Object.defineProperty(Phaser.Gamepad.prototype, "active", {
        get: function() {
            return this._active;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3];
        }
    });
    Phaser.Gamepad.BUTTON_0 = 0;
    Phaser.Gamepad.BUTTON_1 = 1;
    Phaser.Gamepad.BUTTON_2 = 2;
    Phaser.Gamepad.BUTTON_3 = 3;
    Phaser.Gamepad.BUTTON_4 = 4;
    Phaser.Gamepad.BUTTON_5 = 5;
    Phaser.Gamepad.BUTTON_6 = 6;
    Phaser.Gamepad.BUTTON_7 = 7;
    Phaser.Gamepad.BUTTON_8 = 8;
    Phaser.Gamepad.BUTTON_9 = 9;
    Phaser.Gamepad.BUTTON_10 = 10;
    Phaser.Gamepad.BUTTON_11 = 11;
    Phaser.Gamepad.BUTTON_12 = 12;
    Phaser.Gamepad.BUTTON_13 = 13;
    Phaser.Gamepad.BUTTON_14 = 14;
    Phaser.Gamepad.BUTTON_15 = 15;
    Phaser.Gamepad.AXIS_0 = 0;
    Phaser.Gamepad.AXIS_1 = 1;
    Phaser.Gamepad.AXIS_2 = 2;
    Phaser.Gamepad.AXIS_3 = 3;
    Phaser.Gamepad.AXIS_4 = 4;
    Phaser.Gamepad.AXIS_5 = 5;
    Phaser.Gamepad.AXIS_6 = 6;
    Phaser.Gamepad.AXIS_7 = 7;
    Phaser.Gamepad.AXIS_8 = 8;
    Phaser.Gamepad.AXIS_9 = 9;
    Phaser.Gamepad.XBOX360_A = 0;
    Phaser.Gamepad.XBOX360_B = 1;
    Phaser.Gamepad.XBOX360_X = 2;
    Phaser.Gamepad.XBOX360_Y = 3;
    Phaser.Gamepad.XBOX360_LEFT_BUMPER = 4;
    Phaser.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    Phaser.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    Phaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    Phaser.Gamepad.XBOX360_BACK = 8;
    Phaser.Gamepad.XBOX360_START = 9;
    Phaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.XBOX360_DPAD_LEFT = 14;
    Phaser.Gamepad.XBOX360_DPAD_RIGHT = 15;
    Phaser.Gamepad.XBOX360_DPAD_UP = 12;
    Phaser.Gamepad.XBOX360_DPAD_DOWN = 13;
    Phaser.Gamepad.XBOX360_STICK_LEFT_X = 0;
    Phaser.Gamepad.XBOX360_STICK_LEFT_Y = 1;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    Phaser.Gamepad.PS3XC_X = 0;
    Phaser.Gamepad.PS3XC_CIRCLE = 1;
    Phaser.Gamepad.PS3XC_SQUARE = 2;
    Phaser.Gamepad.PS3XC_TRIANGLE = 3;
    Phaser.Gamepad.PS3XC_L1 = 4;
    Phaser.Gamepad.PS3XC_R1 = 5;
    Phaser.Gamepad.PS3XC_L2 = 6;
    Phaser.Gamepad.PS3XC_R2 = 7;
    Phaser.Gamepad.PS3XC_SELECT = 8;
    Phaser.Gamepad.PS3XC_START = 9;
    Phaser.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.PS3XC_DPAD_UP = 12;
    Phaser.Gamepad.PS3XC_DPAD_DOWN = 13;
    Phaser.Gamepad.PS3XC_DPAD_LEFT = 14;
    Phaser.Gamepad.PS3XC_DPAD_RIGHT = 15;
    Phaser.Gamepad.PS3XC_STICK_LEFT_X = 0;
    Phaser.Gamepad.PS3XC_STICK_LEFT_Y = 1;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_X = 2;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_Y = 3;
    Phaser.SinglePad = function(game, padParent) {
        this.game = game;
        this.index = null;
        this.connected = false;
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this.deadZone = .26;
        this._padParent = padParent;
        this._rawPad = null;
        this._prevTimestamp = null;
        this._buttons = [];
        this._buttonsLen = 0;
        this._axes = [];
        this._axesLen = 0;
    };
    Phaser.SinglePad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
            }
        },
        getButton: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode];
            } else {
                return null;
            }
        },
        pollStatus: function() {
            if (!this.connected || !this.game.input.enabled || !this.game.input.gamepad.enabled || this._rawPad.timestamp && this._rawPad.timestamp === this._prevTimestamp) {
                return;
            }
            for (var i = 0; i < this._buttonsLen; i++) {
                var rawButtonVal = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i];
                if (rawButtonVal !== this._buttons[i].value) {
                    if (rawButtonVal === 1) {
                        this.processButtonDown(i, rawButtonVal);
                    } else if (rawButtonVal === 0) {
                        this.processButtonUp(i, rawButtonVal);
                    } else {
                        this.processButtonFloat(i, rawButtonVal);
                    }
                }
            }
            for (var index = 0; index < this._axesLen; index++) {
                var value = this._rawPad.axes[index];
                if (value > 0 && value > this.deadZone || value < 0 && value < -this.deadZone) {
                    this.processAxisChange(index, value);
                } else {
                    this.processAxisChange(index, 0);
                }
            }
            this._prevTimestamp = this._rawPad.timestamp;
        },
        connect: function(rawPad) {
            var triggerCallback = !this.connected;
            this.connected = true;
            this.index = rawPad.index;
            this._rawPad = rawPad;
            this._buttons = [];
            this._buttonsLen = rawPad.buttons.length;
            this._axes = [];
            this._axesLen = rawPad.axes.length;
            for (var a = 0; a < this._axesLen; a++) {
                this._axes[a] = rawPad.axes[a];
            }
            for (var buttonCode in rawPad.buttons) {
                buttonCode = parseInt(buttonCode, 10);
                this._buttons[buttonCode] = new Phaser.DeviceButton(this, buttonCode);
            }
            if (triggerCallback && this._padParent.onConnectCallback) {
                this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index);
            }
            if (triggerCallback && this.onConnectCallback) {
                this.onConnectCallback.call(this.callbackContext);
            }
        },
        disconnect: function() {
            var triggerCallback = this.connected;
            var disconnectingIndex = this.index;
            this.connected = false;
            this.index = null;
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            if (triggerCallback && this._padParent.onDisconnectCallback) {
                this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex);
            }
            if (triggerCallback && this.onDisconnectCallback) {
                this.onDisconnectCallback.call(this.callbackContext);
            }
        },
        destroy: function() {
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            this.onConnectCallback = null;
            this.onDisconnectCallback = null;
            this.onDownCallback = null;
            this.onUpCallback = null;
            this.onAxisCallback = null;
            this.onFloatCallback = null;
        },
        processAxisChange: function(index, value) {
            if (this._axes[index] === value) {
                return;
            }
            this._axes[index] = value;
            if (this._padParent.onAxisCallback) {
                this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, index, value);
            }
            if (this.onAxisCallback) {
                this.onAxisCallback.call(this.callbackContext, this, index, value);
            }
        },
        processButtonDown: function(buttonCode, value) {
            if (this._padParent.onDownCallback) {
                this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].start(null, value);
            }
        },
        processButtonUp: function(buttonCode, value) {
            if (this._padParent.onUpCallback) {
                this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].stop(null, value);
            }
        },
        processButtonFloat: function(buttonCode, value) {
            if (this._padParent.onFloatCallback) {
                this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onFloatCallback) {
                this.onFloatCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].padFloat(value);
            }
        },
        axis: function(axisCode) {
            if (this._axes[axisCode]) {
                return this._axes[axisCode];
            }
            return false;
        },
        isDown: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isDown;
            }
            return false;
        },
        isUp: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isUp;
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justReleased(duration);
            }
        },
        justPressed: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justPressed(duration);
            }
        },
        buttonValue: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].value;
            }
            return null;
        },
        reset: function() {
            for (var j = 0; j < this._axes.length; j++) {
                this._axes[j] = 0;
            }
        }
    };
    Phaser.SinglePad.prototype.constructor = Phaser.SinglePad;
    Phaser.Key = function(game, keycode) {
        this.game = game;
        this._enabled = true;
        this.event = null;
        this.isDown = false;
        this.isUp = true;
        this.altKey = false;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = -2500;
        this.repeats = 0;
        this.keyCode = keycode;
        this.onDown = new Phaser.Signal();
        this.onHoldCallback = null;
        this.onHoldContext = null;
        this.onUp = new Phaser.Signal();
        this._justDown = false;
        this._justUp = false;
    };
    Phaser.Key.prototype = {
        update: function() {
            if (!this._enabled) {
                return;
            }
            if (this.isDown) {
                this.duration = this.game.time.time - this.timeDown;
                this.repeats++;
                if (this.onHoldCallback) {
                    this.onHoldCallback.call(this.onHoldContext, this);
                }
            }
        },
        processKeyDown: function(event) {
            if (!this._enabled) {
                return;
            }
            this.event = event;
            if (this.isDown) {
                return;
            }
            this.altKey = event.altKey;
            this.ctrlKey = event.ctrlKey;
            this.shiftKey = event.shiftKey;
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.time;
            this.duration = 0;
            this.repeats = 0;
            this._justDown = true;
            this.onDown.dispatch(this);
        },
        processKeyUp: function(event) {
            if (!this._enabled) {
                return;
            }
            this.event = event;
            if (this.isUp) {
                return;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.time;
            this.duration = this.game.time.time - this.timeDown;
            this._justUp = true;
            this.onUp.dispatch(this);
        },
        reset: function(hard) {
            if (hard === undefined) {
                hard = true;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.time;
            this.duration = 0;
            this._enabled = true;
            this._justDown = false;
            this._justUp = false;
            if (hard) {
                this.onDown.removeAll();
                this.onUp.removeAll();
                this.onHoldCallback = null;
                this.onHoldContext = null;
            }
        },
        downDuration: function(duration) {
            if (duration === undefined) {
                duration = 50;
            }
            return this.isDown && this.duration < duration;
        },
        upDuration: function(duration) {
            if (duration === undefined) {
                duration = 50;
            }
            return !this.isDown && this.game.time.time - this.timeUp < duration;
        }
    };
    Object.defineProperty(Phaser.Key.prototype, "justDown", {
        get: function() {
            var current = this._justDown;
            this._justDown = false;
            return current;
        }
    });
    Object.defineProperty(Phaser.Key.prototype, "justUp", {
        get: function() {
            var current = this._justUp;
            this._justUp = false;
            return current;
        }
    });
    Object.defineProperty(Phaser.Key.prototype, "enabled", {
        get: function() {
            return this._enabled;
        },
        set: function(value) {
            value = !!value;
            if (value !== this._enabled) {
                if (!value) {
                    this.reset(false);
                }
                this._enabled = value;
            }
        }
    });
    Phaser.Key.prototype.constructor = Phaser.Key;
    Phaser.Keyboard = function(game) {
        this.game = game;
        this.enabled = true;
        this.event = null;
        this.pressEvent = null;
        this.callbackContext = this;
        this.onDownCallback = null;
        this.onPressCallback = null;
        this.onUpCallback = null;
        this._keys = [];
        this._capture = [];
        this._onKeyDown = null;
        this._onKeyPress = null;
        this._onKeyUp = null;
        this._i = 0;
        this._k = 0;
    };
    Phaser.Keyboard.prototype = {
        addCallbacks: function(context, onDown, onUp, onPress) {
            this.callbackContext = context;
            if (typeof onDown !== "undefined") {
                this.onDownCallback = onDown;
            }
            if (typeof onUp !== "undefined") {
                this.onUpCallback = onUp;
            }
            if (typeof onPress !== "undefined") {
                this.onPressCallback = onPress;
            }
        },
        addKey: function(keycode) {
            if (!this._keys[keycode]) {
                this._keys[keycode] = new Phaser.Key(this.game, keycode);
                this.addKeyCapture(keycode);
            }
            return this._keys[keycode];
        },
        addKeys: function(keys) {
            var output = {};
            for (var key in keys) {
                output[key] = this.addKey(keys[key]);
            }
            return output;
        },
        removeKey: function(keycode) {
            if (this._keys[keycode]) {
                this._keys[keycode] = null;
                this.removeKeyCapture(keycode);
            }
        },
        createCursorKeys: function() {
            return this.addKeys({
                up: Phaser.Keyboard.UP,
                down: Phaser.Keyboard.DOWN,
                left: Phaser.Keyboard.LEFT,
                right: Phaser.Keyboard.RIGHT
            });
        },
        start: function() {
            if (this.game.device.cocoonJS) {
                return;
            }
            if (this._onKeyDown !== null) {
                return;
            }
            var _this = this;
            this._onKeyDown = function(event) {
                return _this.processKeyDown(event);
            };
            this._onKeyUp = function(event) {
                return _this.processKeyUp(event);
            };
            this._onKeyPress = function(event) {
                return _this.processKeyPress(event);
            };
            window.addEventListener("keydown", this._onKeyDown, false);
            window.addEventListener("keyup", this._onKeyUp, false);
            window.addEventListener("keypress", this._onKeyPress, false);
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown);
            window.removeEventListener("keyup", this._onKeyUp);
            window.removeEventListener("keypress", this._onKeyPress);
            this._onKeyDown = null;
            this._onKeyUp = null;
            this._onKeyPress = null;
        },
        destroy: function() {
            this.stop();
            this.clearCaptures();
            this._keys.length = 0;
            this._i = 0;
        },
        addKeyCapture: function(keycode) {
            if (typeof keycode === "object") {
                for (var key in keycode) {
                    this._capture[keycode[key]] = true;
                }
            } else {
                this._capture[keycode] = true;
            }
        },
        removeKeyCapture: function(keycode) {
            delete this._capture[keycode];
        },
        clearCaptures: function() {
            this._capture = {};
        },
        update: function() {
            this._i = this._keys.length;
            while (this._i--) {
                if (this._keys[this._i]) {
                    this._keys[this._i].update();
                }
            }
        },
        processKeyDown: function(event) {
            this.event = event;
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyDown(event);
            this._k = event.keyCode;
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, event);
            }
        },
        processKeyPress: function(event) {
            this.pressEvent = event;
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this.onPressCallback) {
                this.onPressCallback.call(this.callbackContext, String.fromCharCode(event.charCode), event);
            }
        },
        processKeyUp: function(event) {
            this.event = event;
            if (!this.game.input.enabled || !this.enabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyUp(event);
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, event);
            }
        },
        reset: function(hard) {
            if (hard === undefined) {
                hard = true;
            }
            this.event = null;
            var i = this._keys.length;
            while (i--) {
                if (this._keys[i]) {
                    this._keys[i].reset(hard);
                }
            }
        },
        downDuration: function(keycode, duration) {
            if (this._keys[keycode]) {
                return this._keys[keycode].downDuration(duration);
            } else {
                return null;
            }
        },
        upDuration: function(keycode, duration) {
            if (this._keys[keycode]) {
                return this._keys[keycode].upDuration(duration);
            } else {
                return null;
            }
        },
        isDown: function(keycode) {
            if (this._keys[keycode]) {
                return this._keys[keycode].isDown;
            } else {
                return null;
            }
        }
    };
    Object.defineProperty(Phaser.Keyboard.prototype, "lastChar", {
        get: function() {
            if (this.event.charCode === 32) {
                return "";
            } else {
                return String.fromCharCode(this.pressEvent.charCode);
            }
        }
    });
    Object.defineProperty(Phaser.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k];
        }
    });
    Phaser.Keyboard.prototype.constructor = Phaser.Keyboard;
    Phaser.Keyboard.A = "A".charCodeAt(0);
    Phaser.Keyboard.B = "B".charCodeAt(0);
    Phaser.Keyboard.C = "C".charCodeAt(0);
    Phaser.Keyboard.D = "D".charCodeAt(0);
    Phaser.Keyboard.E = "E".charCodeAt(0);
    Phaser.Keyboard.F = "F".charCodeAt(0);
    Phaser.Keyboard.G = "G".charCodeAt(0);
    Phaser.Keyboard.H = "H".charCodeAt(0);
    Phaser.Keyboard.I = "I".charCodeAt(0);
    Phaser.Keyboard.J = "J".charCodeAt(0);
    Phaser.Keyboard.K = "K".charCodeAt(0);
    Phaser.Keyboard.L = "L".charCodeAt(0);
    Phaser.Keyboard.M = "M".charCodeAt(0);
    Phaser.Keyboard.N = "N".charCodeAt(0);
    Phaser.Keyboard.O = "O".charCodeAt(0);
    Phaser.Keyboard.P = "P".charCodeAt(0);
    Phaser.Keyboard.Q = "Q".charCodeAt(0);
    Phaser.Keyboard.R = "R".charCodeAt(0);
    Phaser.Keyboard.S = "S".charCodeAt(0);
    Phaser.Keyboard.T = "T".charCodeAt(0);
    Phaser.Keyboard.U = "U".charCodeAt(0);
    Phaser.Keyboard.V = "V".charCodeAt(0);
    Phaser.Keyboard.W = "W".charCodeAt(0);
    Phaser.Keyboard.X = "X".charCodeAt(0);
    Phaser.Keyboard.Y = "Y".charCodeAt(0);
    Phaser.Keyboard.Z = "Z".charCodeAt(0);
    Phaser.Keyboard.ZERO = "0".charCodeAt(0);
    Phaser.Keyboard.ONE = "1".charCodeAt(0);
    Phaser.Keyboard.TWO = "2".charCodeAt(0);
    Phaser.Keyboard.THREE = "3".charCodeAt(0);
    Phaser.Keyboard.FOUR = "4".charCodeAt(0);
    Phaser.Keyboard.FIVE = "5".charCodeAt(0);
    Phaser.Keyboard.SIX = "6".charCodeAt(0);
    Phaser.Keyboard.SEVEN = "7".charCodeAt(0);
    Phaser.Keyboard.EIGHT = "8".charCodeAt(0);
    Phaser.Keyboard.NINE = "9".charCodeAt(0);
    Phaser.Keyboard.NUMPAD_0 = 96;
    Phaser.Keyboard.NUMPAD_1 = 97;
    Phaser.Keyboard.NUMPAD_2 = 98;
    Phaser.Keyboard.NUMPAD_3 = 99;
    Phaser.Keyboard.NUMPAD_4 = 100;
    Phaser.Keyboard.NUMPAD_5 = 101;
    Phaser.Keyboard.NUMPAD_6 = 102;
    Phaser.Keyboard.NUMPAD_7 = 103;
    Phaser.Keyboard.NUMPAD_8 = 104;
    Phaser.Keyboard.NUMPAD_9 = 105;
    Phaser.Keyboard.NUMPAD_MULTIPLY = 106;
    Phaser.Keyboard.NUMPAD_ADD = 107;
    Phaser.Keyboard.NUMPAD_ENTER = 108;
    Phaser.Keyboard.NUMPAD_SUBTRACT = 109;
    Phaser.Keyboard.NUMPAD_DECIMAL = 110;
    Phaser.Keyboard.NUMPAD_DIVIDE = 111;
    Phaser.Keyboard.F1 = 112;
    Phaser.Keyboard.F2 = 113;
    Phaser.Keyboard.F3 = 114;
    Phaser.Keyboard.F4 = 115;
    Phaser.Keyboard.F5 = 116;
    Phaser.Keyboard.F6 = 117;
    Phaser.Keyboard.F7 = 118;
    Phaser.Keyboard.F8 = 119;
    Phaser.Keyboard.F9 = 120;
    Phaser.Keyboard.F10 = 121;
    Phaser.Keyboard.F11 = 122;
    Phaser.Keyboard.F12 = 123;
    Phaser.Keyboard.F13 = 124;
    Phaser.Keyboard.F14 = 125;
    Phaser.Keyboard.F15 = 126;
    Phaser.Keyboard.COLON = 186;
    Phaser.Keyboard.EQUALS = 187;
    Phaser.Keyboard.COMMA = 188;
    Phaser.Keyboard.UNDERSCORE = 189;
    Phaser.Keyboard.PERIOD = 190;
    Phaser.Keyboard.QUESTION_MARK = 191;
    Phaser.Keyboard.TILDE = 192;
    Phaser.Keyboard.OPEN_BRACKET = 219;
    Phaser.Keyboard.BACKWARD_SLASH = 220;
    Phaser.Keyboard.CLOSED_BRACKET = 221;
    Phaser.Keyboard.QUOTES = 222;
    Phaser.Keyboard.BACKSPACE = 8;
    Phaser.Keyboard.TAB = 9;
    Phaser.Keyboard.CLEAR = 12;
    Phaser.Keyboard.ENTER = 13;
    Phaser.Keyboard.SHIFT = 16;
    Phaser.Keyboard.CONTROL = 17;
    Phaser.Keyboard.ALT = 18;
    Phaser.Keyboard.CAPS_LOCK = 20;
    Phaser.Keyboard.ESC = 27;
    Phaser.Keyboard.SPACEBAR = 32;
    Phaser.Keyboard.PAGE_UP = 33;
    Phaser.Keyboard.PAGE_DOWN = 34;
    Phaser.Keyboard.END = 35;
    Phaser.Keyboard.HOME = 36;
    Phaser.Keyboard.LEFT = 37;
    Phaser.Keyboard.UP = 38;
    Phaser.Keyboard.RIGHT = 39;
    Phaser.Keyboard.DOWN = 40;
    Phaser.Keyboard.PLUS = 43;
    Phaser.Keyboard.MINUS = 44;
    Phaser.Keyboard.INSERT = 45;
    Phaser.Keyboard.DELETE = 46;
    Phaser.Keyboard.HELP = 47;
    Phaser.Keyboard.NUM_LOCK = 144;
    Phaser.Component = function() {};
    Phaser.Component.Angle = function() {};
    Phaser.Component.Angle.prototype = {
        angle: {
            get: function() {
                return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
            },
            set: function(value) {
                this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
            }
        }
    };
    Phaser.Component.Animation = function() {};
    Phaser.Component.Animation.prototype = {
        play: function(name, frameRate, loop, killOnComplete) {
            if (this.animations) {
                return this.animations.play(name, frameRate, loop, killOnComplete);
            }
        }
    };
    Phaser.Component.AutoCull = function() {};
    Phaser.Component.AutoCull.prototype = {
        autoCull: false,
        inCamera: {
            get: function() {
                if (!this.autoCull && !this.checkWorldBounds) {
                    this._bounds.copyFrom(this.getBounds());
                    this._bounds.x += this.game.camera.view.x;
                    this._bounds.y += this.game.camera.view.y;
                }
                return this.game.world.camera.view.intersects(this._bounds);
            }
        }
    };
    Phaser.Component.Bounds = function() {};
    Phaser.Component.Bounds.prototype = {
        offsetX: {
            get: function() {
                return this.anchor.x * this.width;
            }
        },
        offsetY: {
            get: function() {
                return this.anchor.y * this.height;
            }
        },
        left: {
            get: function() {
                return this.x - this.offsetX;
            }
        },
        right: {
            get: function() {
                return this.x + this.width - this.offsetX;
            }
        },
        top: {
            get: function() {
                return this.y - this.offsetY;
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height - this.offsetY;
            }
        }
    };
    Phaser.Component.BringToTop = function() {};
    Phaser.Component.BringToTop.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this);
        }
        return this;
    };
    Phaser.Component.BringToTop.prototype.sendToBack = function() {
        if (this.parent) {
            this.parent.sendToBack(this);
        }
        return this;
    };
    Phaser.Component.BringToTop.prototype.moveUp = function() {
        if (this.parent) {
            this.parent.moveUp(this);
        }
        return this;
    };
    Phaser.Component.BringToTop.prototype.moveDown = function() {
        if (this.parent) {
            this.parent.moveDown(this);
        }
        return this;
    };
    Phaser.Component.Core = function() {};
    Phaser.Component.Core.install = function(components) {
        Phaser.Utils.mixinPrototype(this, Phaser.Component.Core.prototype);
        this.components = {};
        for (var i = 0; i < components.length; i++) {
            var id = components[i];
            var replace = false;
            if (id === "Destroy") {
                replace = true;
            }
            Phaser.Utils.mixinPrototype(this, Phaser.Component[id].prototype, replace);
            this.components[id] = true;
        }
    };
    Phaser.Component.Core.init = function(game, x, y, key, frame) {
        this.game = game;
        this.key = key;
        this.position.set(x, y);
        this.world = new Phaser.Point(x, y);
        this.previousPosition = new Phaser.Point(x, y);
        this.events = new Phaser.Events(this);
        this._bounds = new Phaser.Rectangle();
        if (this.components.PhysicsBody) {
            this.body = this.body;
        }
        if (this.components.Animation) {
            this.animations = new Phaser.AnimationManager(this);
        }
        if (this.components.LoadTexture && key !== null) {
            this.loadTexture(key, frame);
        }
        if (this.components.FixedToCamera) {
            this.cameraOffset = new Phaser.Point(x, y);
        }
    };
    Phaser.Component.Core.preUpdate = function() {
        if (this.pendingDestroy) {
            this.destroy();
            return;
        }
        this.previousPosition.set(this.world.x, this.world.y);
        this.previousRotation = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this.renderOrderID = this.game.stage.currentRenderOrderID++;
        }
        if (this.texture) {
            this.texture.requiresReTint = false;
        }
        if (this.animations) {
            this.animations.update();
        }
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Component.Core.prototype = {
        game: null,
        name: "",
        components: {},
        z: 0,
        events: undefined,
        animations: undefined,
        key: "",
        world: null,
        debug: false,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: true,
        pendingDestroy: false,
        _bounds: null,
        _exists: true,
        exists: {
            get: function() {
                return this._exists;
            },
            set: function(value) {
                if (value) {
                    this._exists = true;
                    if (this.body && this.body.type === Phaser.Physics.P2JS) {
                        this.body.addToWorld();
                    }
                    this.visible = true;
                } else {
                    this._exists = false;
                    if (this.body && this.body.type === Phaser.Physics.P2JS) {
                        this.body.removeFromWorld();
                    }
                    this.visible = false;
                }
            }
        },
        update: function() {},
        postUpdate: function() {
            if (this.customRender) {
                this.key.render();
            }
            if (this.components.PhysicsBody) {
                Phaser.Component.PhysicsBody.postUpdate.call(this);
            }
            if (this.components.FixedToCamera) {
                Phaser.Component.FixedToCamera.postUpdate.call(this);
            }
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].postUpdate();
            }
        }
    };
    Phaser.Component.Crop = function() {};
    Phaser.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function(rect, copy) {
            if (copy === undefined) {
                copy = false;
            }
            if (rect) {
                if (copy && this.cropRect !== null) {
                    this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);
                } else if (copy && this.cropRect === null) {
                    this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);
                } else {
                    this.cropRect = rect;
                }
                this.updateCrop();
            } else {
                this._crop = null;
                this.cropRect = null;
                this.resetFrame();
            }
        },
        updateCrop: function() {
            if (!this.cropRect) {
                return;
            }
            this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);
            this._crop.x += this._frame.x;
            this._crop.y += this._frame.y;
            var cx = Math.max(this._frame.x, this._crop.x);
            var cy = Math.max(this._frame.y, this._crop.y);
            var cw = Math.min(this._frame.right, this._crop.right) - cx;
            var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
            this.texture.crop.x = cx;
            this.texture.crop.y = cy;
            this.texture.crop.width = cw;
            this.texture.crop.height = ch;
            this.texture.frame.width = Math.min(cw, this.cropRect.width);
            this.texture.frame.height = Math.min(ch, this.cropRect.height);
            this.texture.width = this.texture.frame.width;
            this.texture.height = this.texture.frame.height;
            this.texture._updateUvs();
        }
    };
    Phaser.Component.Delta = function() {};
    Phaser.Component.Delta.prototype = {
        deltaX: {
            get: function() {
                return this.world.x - this.previousPosition.x;
            }
        },
        deltaY: {
            get: function() {
                return this.world.y - this.previousPosition.y;
            }
        },
        deltaZ: {
            get: function() {
                return this.rotation - this.previousRotation;
            }
        }
    };
    Phaser.Component.Destroy = function() {};
    Phaser.Component.Destroy.prototype = {
        destroyPhase: false,
        destroy: function(destroyChildren) {
            if (this.game === null || this.destroyPhase) {
                return;
            }
            if (destroyChildren === undefined) {
                destroyChildren = true;
            }
            this.destroyPhase = true;
            if (this.events) {
                this.events.onDestroy$dispatch(this);
            }
            if (this.parent) {
                if (this.parent instanceof Phaser.Group) {
                    this.parent.remove(this);
                } else {
                    this.parent.removeChild(this);
                }
            }
            if (this.input) {
                this.input.destroy();
            }
            if (this.animations) {
                this.animations.destroy();
            }
            if (this.body) {
                this.body.destroy();
            }
            if (this.events) {
                this.events.destroy();
            }
            var i = this.children.length;
            if (destroyChildren) {
                while (i--) {
                    this.children[i].destroy(destroyChildren);
                }
            } else {
                while (i--) {
                    this.removeChild(this.children[i]);
                }
            }
            if (this._crop) {
                this._crop = null;
            }
            if (this._frame) {
                this._frame = null;
            }
            if (Phaser.Video && this.key instanceof Phaser.Video) {
                this.key.onChangeSource.remove(this.resizeFrame, this);
            }
            if (Phaser.BitmapText && this._glyphs) {
                this._glyphs = [];
            }
            this.alive = false;
            this.exists = false;
            this.visible = false;
            this.filters = null;
            this.mask = null;
            this.game = null;
            this.renderable = false;
            this.transformCallback = null;
            this.transformCallbackContext = null;
            this.hitArea = null;
            this.parent = null;
            this.stage = null;
            this.worldTransform = null;
            this.filterArea = null;
            this._bounds = null;
            this._currentBounds = null;
            this._mask = null;
            this._destroyCachedSprite();
            this.destroyPhase = false;
            this.pendingDestroy = false;
        }
    };
    Phaser.Events = function(sprite) {
        this.parent = sprite;
    };
    Phaser.Events.prototype = {
        destroy: function() {
            this._parent = null;
            if (this._onDestroy) {
                this._onDestroy.dispose();
            }
            if (this._onAddedToGroup) {
                this._onAddedToGroup.dispose();
            }
            if (this._onRemovedFromGroup) {
                this._onRemovedFromGroup.dispose();
            }
            if (this._onRemovedFromWorld) {
                this._onRemovedFromWorld.dispose();
            }
            if (this._onKilled) {
                this._onKilled.dispose();
            }
            if (this._onRevived) {
                this._onRevived.dispose();
            }
            if (this._onEnterBounds) {
                this._onEnterBounds.dispose();
            }
            if (this._onOutOfBounds) {
                this._onOutOfBounds.dispose();
            }
            if (this._onInputOver) {
                this._onInputOver.dispose();
            }
            if (this._onInputOut) {
                this._onInputOut.dispose();
            }
            if (this._onInputDown) {
                this._onInputDown.dispose();
            }
            if (this._onInputUp) {
                this._onInputUp.dispose();
            }
            if (this._onDragStart) {
                this._onDragStart.dispose();
            }
            if (this._onDragUpdate) {
                this._onDragUpdate.dispose();
            }
            if (this._onDragStop) {
                this._onDragStop.dispose();
            }
            if (this._onAnimationStart) {
                this._onAnimationStart.dispose();
            }
            if (this._onAnimationComplete) {
                this._onAnimationComplete.dispose();
            }
            if (this._onAnimationLoop) {
                this._onAnimationLoop.dispose();
            }
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    };
    Phaser.Events.prototype.constructor = Phaser.Events;
    for (var prop in Phaser.Events.prototype) {
        if (!Phaser.Events.prototype.hasOwnProperty(prop) || prop.indexOf("on") !== 0 || Phaser.Events.prototype[prop] !== null) {
            continue;
        }
        (function(prop, backing) {
            "use strict";
            Object.defineProperty(Phaser.Events.prototype, prop, {
                get: function() {
                    return this[backing] || (this[backing] = new Phaser.Signal());
                }
            });
            Phaser.Events.prototype[prop + "$dispatch"] = function() {
                return this[backing] ? this[backing].dispatch.apply(this[backing], arguments) : null;
            };
        })(prop, "_" + prop);
    }
    Phaser.Component.FixedToCamera = function() {};
    Phaser.Component.FixedToCamera.postUpdate = function() {
        if (this.fixedToCamera) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.Component.FixedToCamera.prototype = {
        _fixedToCamera: false,
        fixedToCamera: {
            get: function() {
                return this._fixedToCamera;
            },
            set: function(value) {
                if (value) {
                    this._fixedToCamera = true;
                    this.cameraOffset.set(this.x, this.y);
                } else {
                    this._fixedToCamera = false;
                }
            }
        },
        cameraOffset: new Phaser.Point()
    };
    Phaser.Component.Health = function() {};
    Phaser.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function(amount) {
            if (this.alive) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.kill();
                }
            }
            return this;
        },
        heal: function(amount) {
            if (this.alive) {
                this.health += amount;
                if (this.health > this.maxHealth) {
                    this.health = this.maxHealth;
                }
            }
            return this;
        }
    };
    Phaser.Component.InCamera = function() {};
    Phaser.Component.InCamera.prototype = {
        inCamera: {
            get: function() {
                return this.game.world.camera.view.intersects(this._bounds);
            }
        }
    };
    Phaser.Component.InputEnabled = function() {};
    Phaser.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
            get: function() {
                return this.input && this.input.enabled;
            },
            set: function(value) {
                if (value) {
                    if (this.input === null) {
                        this.input = new Phaser.InputHandler(this);
                        this.input.start();
                    } else if (this.input && !this.input.enabled) {
                        this.input.start();
                    }
                } else {
                    if (this.input && this.input.enabled) {
                        this.input.stop();
                    }
                }
            }
        }
    };
    Phaser.Component.InWorld = function() {};
    Phaser.Component.InWorld.preUpdate = function() {
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
            this._bounds.x += this.game.camera.view.x;
            this._bounds.y += this.game.camera.view.y;
            if (this.autoCull) {
                if (this.game.world.camera.view.intersects(this._bounds)) {
                    this.renderable = true;
                    this.game.world.camera.totalInView++;
                } else {
                    this.renderable = false;
                }
            }
            if (this.checkWorldBounds) {
                if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) {
                    this._outOfBoundsFired = false;
                    this.events.onEnterBounds$dispatch(this);
                } else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds)) {
                    this._outOfBoundsFired = true;
                    this.events.onOutOfBounds$dispatch(this);
                    if (this.outOfBoundsKill) {
                        this.kill();
                        return false;
                    }
                }
            }
        }
        return true;
    };
    Phaser.Component.InWorld.prototype = {
        checkWorldBounds: false,
        outOfBoundsKill: false,
        _outOfBoundsFired: false,
        inWorld: {
            get: function() {
                return this.game.world.bounds.intersects(this.getBounds());
            }
        }
    };
    Phaser.Component.LifeSpan = function() {};
    Phaser.Component.LifeSpan.preUpdate = function() {
        if (this.lifespan > 0) {
            this.lifespan -= this.game.time.physicsElapsedMS;
            if (this.lifespan <= 0) {
                this.kill();
                return false;
            }
        }
        return true;
    };
    Phaser.Component.LifeSpan.prototype = {
        alive: true,
        lifespan: 0,
        revive: function(health) {
            if (health === undefined) {
                health = 1;
            }
            this.alive = true;
            this.exists = true;
            this.visible = true;
            if (typeof this.health === "number") {
                this.health = health;
            }
            if (this.events) {
                this.events.onRevived$dispatch(this);
            }
            return this;
        },
        kill: function() {
            this.alive = false;
            this.exists = false;
            this.visible = false;
            if (this.events) {
                this.events.onKilled$dispatch(this);
            }
            return this;
        }
    };
    Phaser.Component.LoadTexture = function() {};
    Phaser.Component.LoadTexture.prototype = {
        customRender: false,
        _frame: null,
        loadTexture: function(key, frame, stopAnimation) {
            frame = frame || 0;
            if ((stopAnimation || stopAnimation === undefined) && this.animations) {
                this.animations.stop();
            }
            this.key = key;
            this.customRender = false;
            var cache = this.game.cache;
            var setFrame = true;
            var smoothed = !this.texture.baseTexture.scaleMode;
            if (Phaser.RenderTexture && key instanceof Phaser.RenderTexture) {
                this.key = key.key;
                this.setTexture(key);
            } else if (Phaser.BitmapData && key instanceof Phaser.BitmapData) {
                this.customRender = true;
                this.setTexture(key.texture);
                if (cache.hasFrameData(key.key, Phaser.Cache.BITMAPDATA)) {
                    setFrame = !this.animations.loadFrameData(cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA), frame);
                }
            } else if (Phaser.Video && key instanceof Phaser.Video) {
                this.customRender = true;
                var valid = key.texture.valid;
                this.setTexture(key.texture);
                this.setFrame(key.texture.frame.clone());
                key.onChangeSource.add(this.resizeFrame, this);
                this.texture.valid = valid;
            } else if (key instanceof PIXI.Texture) {
                this.setTexture(key);
            } else {
                var img = cache.getImage(key, true);
                this.key = img.key;
                this.setTexture(new PIXI.Texture(img.base));
                setFrame = !this.animations.loadFrameData(img.frameData, frame);
            }
            if (setFrame) {
                this._frame = Phaser.Rectangle.clone(this.texture.frame);
            }
            if (!smoothed) {
                this.texture.baseTexture.scaleMode = 1;
            }
        },
        setFrame: function(frame) {
            this._frame = frame;
            this.texture.frame.x = frame.x;
            this.texture.frame.y = frame.y;
            this.texture.frame.width = frame.width;
            this.texture.frame.height = frame.height;
            this.texture.crop.x = frame.x;
            this.texture.crop.y = frame.y;
            this.texture.crop.width = frame.width;
            this.texture.crop.height = frame.height;
            if (frame.trimmed) {
                if (this.texture.trim) {
                    this.texture.trim.x = frame.spriteSourceSizeX;
                    this.texture.trim.y = frame.spriteSourceSizeY;
                    this.texture.trim.width = frame.sourceSizeW;
                    this.texture.trim.height = frame.sourceSizeH;
                } else {
                    this.texture.trim = {
                        x: frame.spriteSourceSizeX,
                        y: frame.spriteSourceSizeY,
                        width: frame.sourceSizeW,
                        height: frame.sourceSizeH
                    };
                }
                this.texture.width = frame.sourceSizeW;
                this.texture.height = frame.sourceSizeH;
                this.texture.frame.width = frame.sourceSizeW;
                this.texture.frame.height = frame.sourceSizeH;
            } else if (!frame.trimmed && this.texture.trim) {
                this.texture.trim = null;
            }
            if (this.cropRect) {
                this.updateCrop();
            }
            this.texture.requiresReTint = true;
            this.texture._updateUvs();
            if (this.tilingTexture) {
                this.refreshTexture = true;
            }
        },
        resizeFrame: function(parent, width, height) {
            this.texture.frame.resize(width, height);
            this.texture.setFrame(this.texture.frame);
        },
        resetFrame: function() {
            if (this._frame) {
                this.setFrame(this._frame);
            }
        },
        frame: {
            get: function() {
                return this.animations.frame;
            },
            set: function(value) {
                this.animations.frame = value;
            }
        },
        frameName: {
            get: function() {
                return this.animations.frameName;
            },
            set: function(value) {
                this.animations.frameName = value;
            }
        }
    };
    Phaser.Component.Overlap = function() {};
    Phaser.Component.Overlap.prototype = {
        overlap: function(displayObject) {
            return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());
        }
    };
    Phaser.Component.PhysicsBody = function() {};
    Phaser.Component.PhysicsBody.preUpdate = function() {
        if (this.fresh && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this.previousPosition.set(this.world.x, this.world.y);
            this.previousRotation = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this.fresh = false;
            return false;
        }
        this.previousPosition.set(this.world.x, this.world.y);
        this.previousRotation = this.rotation;
        if (!this._exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        return true;
    };
    Phaser.Component.PhysicsBody.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
    };
    Phaser.Component.PhysicsBody.prototype = {
        body: null,
        x: {
            get: function() {
                return this.position.x;
            },
            set: function(value) {
                this.position.x = value;
                if (this.body && !this.body.dirty) {
                    this.body._reset = true;
                }
            }
        },
        y: {
            get: function() {
                return this.position.y;
            },
            set: function(value) {
                this.position.y = value;
                if (this.body && !this.body.dirty) {
                    this.body._reset = true;
                }
            }
        }
    };
    Phaser.Component.Reset = function() {};
    Phaser.Component.Reset.prototype.reset = function(x, y, health) {
        if (health === undefined) {
            health = 1;
        }
        this.world.set(x, y);
        this.position.set(x, y);
        this.fresh = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        if (this.components.InWorld) {
            this._outOfBoundsFired = false;
        }
        if (this.components.LifeSpan) {
            this.alive = true;
            this.health = health;
        }
        if (this.components.PhysicsBody) {
            if (this.body) {
                this.body.reset(x, y, false, false);
            }
        }
        return this;
    };
    Phaser.Component.ScaleMinMax = function() {};
    Phaser.Component.ScaleMinMax.prototype = {
        transformCallback: this.checkTransform,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function(wt) {
            if (this.scaleMin) {
                if (wt.a < this.scaleMin.x) {
                    wt.a = this.scaleMin.x;
                }
                if (wt.d < this.scaleMin.y) {
                    wt.d = this.scaleMin.y;
                }
            }
            if (this.scaleMax) {
                if (wt.a > this.scaleMax.x) {
                    wt.a = this.scaleMax.x;
                }
                if (wt.d > this.scaleMax.y) {
                    wt.d = this.scaleMax.y;
                }
            }
        },
        setScaleMinMax: function(minX, minY, maxX, maxY) {
            if (minY === undefined) {
                minY = maxX = maxY = minX;
            } else if (maxX === undefined) {
                maxX = maxY = minY;
                minY = minX;
            }
            if (minX === null) {
                this.scaleMin = null;
            } else {
                if (this.scaleMin) {
                    this.scaleMin.set(minX, minY);
                } else {
                    this.scaleMin = new Phaser.Point(minX, minY);
                }
            }
            if (maxX === null) {
                this.scaleMax = null;
            } else {
                if (this.scaleMax) {
                    this.scaleMax.set(maxX, maxY);
                } else {
                    this.scaleMax = new Phaser.Point(maxX, maxY);
                }
            }
        }
    };
    Phaser.Component.Smoothed = function() {};
    Phaser.Component.Smoothed.prototype = {
        smoothed: {
            get: function() {
                return !this.texture.baseTexture.scaleMode;
            },
            set: function(value) {
                if (value) {
                    if (this.texture) {
                        this.texture.baseTexture.scaleMode = 0;
                    }
                } else {
                    if (this.texture) {
                        this.texture.baseTexture.scaleMode = 1;
                    }
                }
            }
        }
    };
    Phaser.GameObjectFactory = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectFactory.prototype = {
        existing: function(object) {
            return this.world.add(object);
        },
        image: function(x, y, key, frame, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.Image(this.game, x, y, key, frame));
        },
        sprite: function(x, y, key, frame, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.create(x, y, key, frame);
        },
        creature: function(x, y, key, mesh, group) {
            if (group === undefined) {
                group = this.world;
            }
            var obj = new Phaser.Creature(this.game, x, y, key, mesh);
            group.add(obj);
            return obj;
        },
        tween: function(object) {
            return this.game.tweens.create(object);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);
        },
        physicsGroup: function(physicsBodyType, parent, name, addToStage) {
            return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (parent === undefined) {
                parent = null;
            }
            if (name === undefined) {
                name = "group";
            }
            if (addToStage === undefined) {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        audioSprite: function(key) {
            return this.game.sound.addSprite(key);
        },
        tileSprite: function(x, y, width, height, key, frame, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));
        },
        rope: function(x, y, key, frame, points, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.Rope(this.game, x, y, key, frame, points));
        },
        text: function(x, y, text, style, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.Text(this.game, x, y, text, style));
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));
        },
        graphics: function(x, y, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.Graphics(this.game, x, y));
        },
        emitter: function(x, y, maxParticles) {
            return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size, group) {
            if (group === undefined) {
                group = this.world;
            }
            return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (key === undefined || key === "") {
                key = this.game.rnd.uuid();
            }
            if (addToCache === undefined) {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        video: function(key, url) {
            return new Phaser.Video(this.game, key, url);
        },
        bitmapData: function(width, height, key, addToCache) {
            if (addToCache === undefined) {
                addToCache = false;
            }
            if (key === undefined || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        },
        plugin: function(plugin) {
            return this.game.plugins.add(plugin);
        }
    };
    Phaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory;
    Phaser.GameObjectCreator = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectCreator.prototype = {
        image: function(x, y, key, frame) {
            return new Phaser.Image(this.game, x, y, key, frame);
        },
        sprite: function(x, y, key, frame) {
            return new Phaser.Sprite(this.game, x, y, key, frame);
        },
        tween: function(obj) {
            return new Phaser.Tween(obj, this.game, this.game.tweens);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (name === undefined) {
                name = "group";
            }
            if (addToStage === undefined) {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        audioSprite: function(key) {
            return this.game.sound.addSprite(key);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        tileSprite: function(x, y, width, height, key, frame) {
            return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);
        },
        rope: function(x, y, key, frame, points) {
            return new Phaser.Rope(this.game, x, y, key, frame, points);
        },
        text: function(x, y, text, style) {
            return new Phaser.Text(this.game, x, y, text, style);
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
            return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);
        },
        graphics: function(x, y) {
            return new Phaser.Graphics(this.game, x, y);
        },
        emitter: function(x, y, maxParticles) {
            return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size, align) {
            return new Phaser.BitmapText(this.game, x, y, font, text, size, align);
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (key === undefined || key === "") {
                key = this.game.rnd.uuid();
            }
            if (addToCache === undefined) {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        bitmapData: function(width, height, key, addToCache) {
            if (addToCache === undefined) {
                addToCache = false;
            }
            if (key === undefined || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        }
    };
    Phaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator;
    Phaser.Sprite = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.SPRITE;
        this.physicsType = Phaser.SPRITE;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Sprite.prototype.constructor = Phaser.Sprite;
    Phaser.Component.Core.install.call(Phaser.Sprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]);
    Phaser.Sprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.Sprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.Sprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.Sprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.Sprite.prototype.preUpdate = function() {
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.Image = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.IMAGE;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.Image.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Image.prototype.constructor = Phaser.Image;
    Phaser.Component.Core.install.call(Phaser.Image.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "Smoothed" ]);
    Phaser.Image.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.Image.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.Image.prototype.preUpdate = function() {
        if (!this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.TileSprite = function(game, x, y, width, height, key, frame) {
        x = x || 0;
        y = y || 0;
        width = width || 256;
        height = height || 256;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.TILESPRITE;
        this.physicsType = Phaser.SPRITE;
        this._scroll = new Phaser.Point();
        var def = game.cache.getImage("__default", true);
        PIXI.TilingSprite.call(this, new PIXI.Texture(def.base), width, height);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    Phaser.TileSprite.prototype.constructor = Phaser.TileSprite;
    Phaser.Component.Core.install.call(Phaser.TileSprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed" ]);
    Phaser.TileSprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.TileSprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.TileSprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.TileSprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.TileSprite.prototype.preUpdate = function() {
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.TileSprite.prototype.autoScroll = function(x, y) {
        this._scroll.set(x, y);
    };
    Phaser.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    };
    Phaser.TileSprite.prototype.destroy = function(destroyChildren) {
        Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);
        PIXI.TilingSprite.prototype.destroy.call(this);
    };
    Phaser.TileSprite.prototype.reset = function(x, y) {
        Phaser.Component.Reset.prototype.reset.call(this, x, y);
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        return this;
    };
    Phaser.Rope = function(game, x, y, key, frame, points) {
        this.points = [];
        this.points = points;
        this._hasUpdateAnimation = false;
        this._updateAnimationCallback = null;
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.ROPE;
        this._scroll = new Phaser.Point();
        PIXI.Rope.call(this, PIXI.TextureCache["__default"], this.points);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype);
    Phaser.Rope.prototype.constructor = Phaser.Rope;
    Phaser.Component.Core.install.call(Phaser.Rope.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]);
    Phaser.Rope.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.Rope.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.Rope.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.Rope.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.Rope.prototype.preUpdate = function() {
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.Rope.prototype.update = function() {
        if (this._hasUpdateAnimation) {
            this.updateAnimation.call(this);
        }
    };
    Phaser.Rope.prototype.reset = function(x, y) {
        Phaser.Component.Reset.prototype.reset.call(this, x, y);
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        return this;
    };
    Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(value) {
            if (value && typeof value === "function") {
                this._hasUpdateAnimation = true;
                this._updateAnimation = value;
            } else {
                this._hasUpdateAnimation = false;
                this._updateAnimation = null;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "segments", {
        get: function() {
            var segments = [];
            var index, x1, y1, x2, y2, width, height, rect;
            for (var i = 0; i < this.points.length; i++) {
                index = i * 4;
                x1 = this.vertices[index] * this.scale.x;
                y1 = this.vertices[index + 1] * this.scale.y;
                x2 = this.vertices[index + 4] * this.scale.x;
                y2 = this.vertices[index + 3] * this.scale.y;
                width = Phaser.Math.difference(x1, x2);
                height = Phaser.Math.difference(y1, y2);
                x1 += this.world.x;
                y1 += this.world.y;
                rect = new Phaser.Rectangle(x1, y1, width, height);
                segments.push(rect);
            }
            return segments;
        }
    });
    Phaser.Button = function(game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        callback = callback || null;
        callbackContext = callbackContext || this;
        Phaser.Image.call(this, game, x, y, key, outFrame);
        this.type = Phaser.BUTTON;
        this.physicsType = Phaser.SPRITE;
        this._onOverFrame = null;
        this._onOutFrame = null;
        this._onDownFrame = null;
        this._onUpFrame = null;
        this.onOverSound = null;
        this.onOutSound = null;
        this.onDownSound = null;
        this.onUpSound = null;
        this.onOverSoundMarker = "";
        this.onOutSoundMarker = "";
        this.onDownSoundMarker = "";
        this.onUpSoundMarker = "";
        this.onInputOver = new Phaser.Signal();
        this.onInputOut = new Phaser.Signal();
        this.onInputDown = new Phaser.Signal();
        this.onInputUp = new Phaser.Signal();
        this.onOverMouseOnly = false;
        this.freezeFrames = false;
        this.forceOut = false;
        this.inputEnabled = true;
        this.input.start(0, true);
        this.input.useHandCursor = true;
        this.setFrames(overFrame, outFrame, downFrame, upFrame);
        if (callback !== null) {
            this.onInputUp.add(callback, callbackContext);
        }
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this);
        this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
    };
    Phaser.Button.prototype = Object.create(Phaser.Image.prototype);
    Phaser.Button.prototype.constructor = Phaser.Button;
    var STATE_OVER = "Over";
    var STATE_OUT = "Out";
    var STATE_DOWN = "Down";
    var STATE_UP = "Up";
    Phaser.Button.prototype.clearFrames = function() {
        this.setFrames(null, null, null, null);
    };
    Phaser.Button.prototype.removedFromWorld = function() {
        this.inputEnabled = false;
    };
    Phaser.Button.prototype.setStateFrame = function(state, frame, switchImmediately) {
        var frameKey = "_on" + state + "Frame";
        if (frame !== null) {
            this[frameKey] = frame;
            if (switchImmediately) {
                this.changeStateFrame(state);
            }
        } else {
            this[frameKey] = null;
        }
    };
    Phaser.Button.prototype.changeStateFrame = function(state) {
        if (this.freezeFrames) {
            return false;
        }
        var frameKey = "_on" + state + "Frame";
        var frame = this[frameKey];
        if (typeof frame === "string") {
            this.frameName = frame;
            return true;
        } else if (typeof frame === "number") {
            this.frame = frame;
            return true;
        } else {
            return false;
        }
    };
    Phaser.Button.prototype.setFrames = function(overFrame, outFrame, downFrame, upFrame) {
        this.setStateFrame(STATE_OVER, overFrame, this.input.pointerOver());
        this.setStateFrame(STATE_OUT, outFrame, !this.input.pointerOver());
        this.setStateFrame(STATE_DOWN, downFrame, this.input.pointerDown());
        this.setStateFrame(STATE_UP, upFrame, this.input.pointerUp());
    };
    Phaser.Button.prototype.setStateSound = function(state, sound, marker) {
        var soundKey = "on" + state + "Sound";
        var markerKey = "on" + state + "SoundMarker";
        if (sound instanceof Phaser.Sound || sound instanceof Phaser.AudioSprite) {
            this[soundKey] = sound;
            this[markerKey] = typeof marker === "string" ? marker : "";
        } else {
            this[soundKey] = null;
            this[markerKey] = "";
        }
    };
    Phaser.Button.prototype.playStateSound = function(state) {
        var soundKey = "on" + state + "Sound";
        var sound = this[soundKey];
        if (sound) {
            var markerKey = "on" + state + "SoundMarker";
            var marker = this[markerKey];
            sound.play(marker);
            return true;
        } else {
            return false;
        }
    };
    Phaser.Button.prototype.setSounds = function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
        this.setStateSound(STATE_OVER, overSound, overMarker);
        this.setStateSound(STATE_OUT, outSound, outMarker);
        this.setStateSound(STATE_DOWN, downSound, downMarker);
        this.setStateSound(STATE_UP, upSound, upMarker);
    };
    Phaser.Button.prototype.setOverSound = function(sound, marker) {
        this.setStateSound(STATE_OVER, sound, marker);
    };
    Phaser.Button.prototype.setOutSound = function(sound, marker) {
        this.setStateSound(STATE_OUT, sound, marker);
    };
    Phaser.Button.prototype.setDownSound = function(sound, marker) {
        this.setStateSound(STATE_DOWN, sound, marker);
    };
    Phaser.Button.prototype.setUpSound = function(sound, marker) {
        this.setStateSound(STATE_UP, sound, marker);
    };
    Phaser.Button.prototype.onInputOverHandler = function(sprite, pointer) {
        if (pointer.justReleased()) {
            return;
        }
        this.changeStateFrame(STATE_OVER);
        if (this.onOverMouseOnly && !pointer.isMouse) {
            return;
        }
        this.playStateSound(STATE_OVER);
        if (this.onInputOver) {
            this.onInputOver.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputOutHandler = function(sprite, pointer) {
        this.changeStateFrame(STATE_OUT);
        this.playStateSound(STATE_OUT);
        if (this.onInputOut) {
            this.onInputOut.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputDownHandler = function(sprite, pointer) {
        this.changeStateFrame(STATE_DOWN);
        this.playStateSound(STATE_DOWN);
        if (this.onInputDown) {
            this.onInputDown.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputUpHandler = function(sprite, pointer, isOver) {
        this.playStateSound(STATE_UP);
        if (this.onInputUp) {
            this.onInputUp.dispatch(this, pointer, isOver);
        }
        if (this.freezeFrames) {
            return;
        }
        if (this.forceOut) {
            this.changeStateFrame(STATE_OUT);
        } else {
            var changedUp = this.changeStateFrame(STATE_UP);
            if (!changedUp) {
                if (isOver) {
                    this.changeStateFrame(STATE_OVER);
                } else {
                    this.changeStateFrame(STATE_OUT);
                }
            }
        }
    };
    Phaser.SpriteBatch = function(game, parent, name, addToStage) {
        if (parent === undefined || parent === null) {
            parent = game.world;
        }
        PIXI.SpriteBatch.call(this);
        Phaser.Group.call(this, game, parent, name, addToStage);
        this.type = Phaser.SPRITEBATCH;
    };
    Phaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, Phaser.Group.prototype, PIXI.SpriteBatch.prototype);
    Phaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;
    Phaser.Particle = function(game, x, y, key, frame) {
        Phaser.Sprite.call(this, game, x, y, key, frame);
        this.autoScale = false;
        this.scaleData = null;
        this._s = 0;
        this.autoAlpha = false;
        this.alphaData = null;
        this._a = 0;
    };
    Phaser.Particle.prototype = Object.create(Phaser.Sprite.prototype);
    Phaser.Particle.prototype.constructor = Phaser.Particle;
    Phaser.Particle.prototype.update = function() {
        if (this.autoScale) {
            this._s--;
            if (this._s) {
                this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
            } else {
                this.autoScale = false;
            }
        }
        if (this.autoAlpha) {
            this._a--;
            if (this._a) {
                this.alpha = this.alphaData[this._a].v;
            } else {
                this.autoAlpha = false;
            }
        }
    };
    Phaser.Particle.prototype.onEmit = function() {};
    Phaser.Particle.prototype.setAlphaData = function(data) {
        this.alphaData = data;
        this._a = data.length - 1;
        this.alpha = this.alphaData[this._a].v;
        this.autoAlpha = true;
    };
    Phaser.Particle.prototype.setScaleData = function(data) {
        this.scaleData = data;
        this._s = data.length - 1;
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        this.autoScale = true;
    };
    Phaser.Particle.prototype.reset = function(x, y, health) {
        Phaser.Component.Reset.prototype.reset.call(this, x, y, health);
        this.alpha = 1;
        this.scale.set(1);
        this.autoScale = false;
        this.autoAlpha = false;
        return this;
    };
    Phaser.BitmapData = function(game, key, width, height) {
        if (width === undefined || width === 0) {
            width = 256;
        }
        if (height === undefined || height === 0) {
            height = 256;
        }
        this.game = game;
        this.key = key;
        this.width = width;
        this.height = height;
        this.canvas = PIXI.CanvasPool.create(this, width, height);
        this.context = this.canvas.getContext("2d", {
            alpha: true
        });
        this.ctx = this.context;
        this.imageData = this.context.getImageData(0, 0, width, height);
        this.data = null;
        if (this.imageData) {
            this.data = this.imageData.data;
        }
        this.pixels = null;
        if (this.data) {
            if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
            } else {
                if (window["ArrayBuffer"]) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer);
                } else {
                    this.pixels = this.imageData.data;
                }
            }
        }
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "bitmapData");
        this.texture.frame = this.textureFrame;
        this.type = Phaser.BITMAPDATA;
        this.disableTextureUpload = false;
        this.dirty = false;
        this.cls = this.clear;
        this._image = null;
        this._pos = new Phaser.Point();
        this._size = new Phaser.Point();
        this._scale = new Phaser.Point();
        this._rotate = 0;
        this._alpha = {
            prev: 1,
            current: 1
        };
        this._anchor = new Phaser.Point();
        this._tempR = 0;
        this._tempG = 0;
        this._tempB = 0;
        this._circle = new Phaser.Circle();
        this._swapCanvas = PIXI.CanvasPool.create(this, width, height);
    };
    Phaser.BitmapData.prototype = {
        move: function(x, y) {
            if (x !== 0) {
                this.moveH(x);
            }
            if (y !== 0) {
                this.moveV(y);
            }
            return this;
        },
        moveH: function(distance) {
            var c = this._swapCanvas;
            var ctx = c.getContext("2d");
            var h = this.height;
            var src = this.canvas;
            ctx.clearRect(0, 0, this.width, this.height);
            if (distance < 0) {
                distance = Math.abs(distance);
                var w = this.width - distance;
                ctx.drawImage(src, 0, 0, distance, h, w, 0, distance, h);
                ctx.drawImage(src, distance, 0, w, h, 0, 0, w, h);
            } else {
                var w = this.width - distance;
                ctx.drawImage(src, w, 0, distance, h, 0, 0, distance, h);
                ctx.drawImage(src, 0, 0, w, h, distance, 0, w, h);
            }
            this.clear();
            return this.copy(this._swapCanvas);
        },
        moveV: function(distance) {
            var c = this._swapCanvas;
            var ctx = c.getContext("2d");
            var w = this.width;
            var src = this.canvas;
            ctx.clearRect(0, 0, this.width, this.height);
            if (distance < 0) {
                distance = Math.abs(distance);
                var h = this.height - distance;
                ctx.drawImage(src, 0, 0, w, distance, 0, h, w, distance);
                ctx.drawImage(src, 0, distance, w, h, 0, 0, w, h);
            } else {
                var h = this.height - distance;
                ctx.drawImage(src, 0, h, w, distance, 0, 0, w, distance);
                ctx.drawImage(src, 0, 0, w, h, 0, distance, w, h);
            }
            this.clear();
            return this.copy(this._swapCanvas);
        },
        add: function(object) {
            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    if (object[i]["loadTexture"]) {
                        object[i].loadTexture(this);
                    }
                }
            } else {
                object.loadTexture(this);
            }
            return this;
        },
        load: function(source) {
            if (typeof source === "string") {
                source = this.game.cache.getImage(source);
            }
            if (source) {
                this.resize(source.width, source.height);
                this.cls();
            } else {
                return;
            }
            this.draw(source);
            this.update();
            return this;
        },
        clear: function(x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = this.width;
            }
            if (height === undefined) {
                height = this.height;
            }
            this.context.clearRect(x, y, width, height);
            this.dirty = true;
            return this;
        },
        fill: function(r, g, b, a) {
            if (a === undefined) {
                a = 1;
            }
            this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";
            this.context.fillRect(0, 0, this.width, this.height);
            this.dirty = true;
            return this;
        },
        generateTexture: function(key) {
            var image = new Image();
            image.src = this.canvas.toDataURL("image/png");
            var obj = this.game.cache.addImage(key, "", image);
            return new PIXI.Texture(obj.base);
        },
        resize: function(width, height) {
            if (width !== this.width || height !== this.height) {
                this.width = width;
                this.height = height;
                this.canvas.width = width;
                this.canvas.height = height;
                this._swapCanvas.width = width;
                this._swapCanvas.height = height;
                this.baseTexture.width = width;
                this.baseTexture.height = height;
                this.textureFrame.width = width;
                this.textureFrame.height = height;
                this.texture.width = width;
                this.texture.height = height;
                this.texture.crop.width = width;
                this.texture.crop.height = height;
                this.update();
                this.dirty = true;
            }
            return this;
        },
        update: function(x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = Math.max(1, this.width);
            }
            if (height === undefined) {
                height = Math.max(1, this.height);
            }
            this.imageData = this.context.getImageData(x, y, width, height);
            this.data = this.imageData.data;
            if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
            } else {
                if (window["ArrayBuffer"]) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer);
                } else {
                    this.pixels = this.imageData.data;
                }
            }
            return this;
        },
        processPixelRGB: function(callback, callbackContext, x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = this.width;
            }
            if (height === undefined) {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = Phaser.Color.createColor();
            var result = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== false && result !== null && result !== undefined) {
                        this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false);
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        processPixel: function(callback, callbackContext, x, y, width, height) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = this.width;
            }
            if (height === undefined) {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = 0;
            var result = 0;
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    pixel = this.getPixel32(tx, ty);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== pixel) {
                        this.pixels[ty * this.width + tx] = result;
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        replaceRGB: function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
            var sx = 0;
            var sy = 0;
            var w = this.width;
            var h = this.height;
            var source = Phaser.Color.packPixel(r1, g1, b1, a1);
            if (region !== undefined && region instanceof Phaser.Rectangle) {
                sx = region.x;
                sy = region.y;
                w = region.width;
                h = region.height;
            }
            for (var y = 0; y < h; y++) {
                for (var x = 0; x < w; x++) {
                    if (this.getPixel32(sx + x, sy + y) === source) {
                        this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false);
                    }
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setHSL: function(h, s, l, region) {
            if (h === undefined || h === null) {
                h = false;
            }
            if (s === undefined || s === null) {
                s = false;
            }
            if (l === undefined || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (region === undefined) {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = h;
                    }
                    if (s) {
                        pixel.s = s;
                    }
                    if (l) {
                        pixel.l = l;
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        shiftHSL: function(h, s, l, region) {
            if (h === undefined || h === null) {
                h = false;
            }
            if (s === undefined || s === null) {
                s = false;
            }
            if (l === undefined || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (region === undefined) {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = this.game.math.wrap(pixel.h + h, 0, 1);
                    }
                    if (s) {
                        pixel.s = this.game.math.limitValue(pixel.s + s, 0, 1);
                    }
                    if (l) {
                        pixel.l = this.game.math.limitValue(pixel.l + l, 0, 1);
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setPixel32: function(x, y, red, green, blue, alpha, immediate) {
            if (immediate === undefined) {
                immediate = true;
            }
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                if (Phaser.Device.LITTLE_ENDIAN) {
                    this.pixels[y * this.width + x] = alpha << 24 | blue << 16 | green << 8 | red;
                } else {
                    this.pixels[y * this.width + x] = red << 24 | green << 16 | blue << 8 | alpha;
                }
                if (immediate) {
                    this.context.putImageData(this.imageData, 0, 0);
                    this.dirty = true;
                }
            }
            return this;
        },
        setPixel: function(x, y, red, green, blue, immediate) {
            return this.setPixel32(x, y, red, green, blue, 255, immediate);
        },
        getPixel: function(x, y, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var index = ~~(x + y * this.width);
            index *= 4;
            out.r = this.data[index];
            out.g = this.data[++index];
            out.b = this.data[++index];
            out.a = this.data[++index];
            return out;
        },
        getPixel32: function(x, y) {
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                return this.pixels[y * this.width + x];
            }
        },
        getPixelRGB: function(x, y, out, hsl, hsv) {
            return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);
        },
        getPixels: function(rect) {
            return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);
        },
        getFirstPixel: function(direction) {
            if (direction === undefined) {
                direction = 0;
            }
            var pixel = Phaser.Color.createColor();
            var x = 0;
            var y = 0;
            var v = 1;
            var scan = false;
            if (direction === 1) {
                v = -1;
                y = this.height;
            } else if (direction === 3) {
                v = -1;
                x = this.width;
            }
            do {
                Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel);
                if (direction === 0 || direction === 1) {
                    x++;
                    if (x === this.width) {
                        x = 0;
                        y += v;
                        if (y >= this.height || y <= 0) {
                            scan = true;
                        }
                    }
                } else if (direction === 2 || direction === 3) {
                    y++;
                    if (y === this.height) {
                        y = 0;
                        x += v;
                        if (x >= this.width || x <= 0) {
                            scan = true;
                        }
                    }
                }
            } while (pixel.a === 0 && !scan);
            pixel.x = x;
            pixel.y = y;
            return pixel;
        },
        getBounds: function(rect) {
            if (rect === undefined) {
                rect = new Phaser.Rectangle();
            }
            rect.x = this.getFirstPixel(2).x;
            if (rect.x === this.width) {
                return rect.setTo(0, 0, 0, 0);
            }
            rect.y = this.getFirstPixel(0).y;
            rect.width = this.getFirstPixel(3).x - rect.x + 1;
            rect.height = this.getFirstPixel(1).y - rect.y + 1;
            return rect;
        },
        addToWorld: function(x, y, anchorX, anchorY, scaleX, scaleY) {
            scaleX = scaleX || 1;
            scaleY = scaleY || 1;
            var image = this.game.add.image(x, y, this);
            image.anchor.set(anchorX, anchorY);
            image.scale.set(scaleX, scaleY);
            return image;
        },
        copy: function(source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) {
            if (source === undefined || source === null) {
                source = this;
            }
            this._image = source;
            if (source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text || source instanceof PIXI.Sprite) {
                this._pos.set(source.texture.crop.x, source.texture.crop.y);
                this._size.set(source.texture.crop.width, source.texture.crop.height);
                this._scale.set(source.scale.x, source.scale.y);
                this._anchor.set(source.anchor.x, source.anchor.y);
                this._rotate = source.rotation;
                this._alpha.current = source.alpha;
                this._image = source.texture.baseTexture.source;
                if (tx === undefined || tx === null) {
                    tx = source.x;
                }
                if (ty === undefined || ty === null) {
                    ty = source.y;
                }
                if (source.texture.trim) {
                    tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width;
                    ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height;
                }
                if (source.tint !== 16777215) {
                    if (source.cachedTint !== source.tint) {
                        source.cachedTint = source.tint;
                        source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint);
                    }
                    this._image = source.tintedTexture;
                }
            } else {
                this._pos.set(0);
                this._scale.set(1);
                this._anchor.set(0);
                this._rotate = 0;
                this._alpha.current = 1;
                if (source instanceof Phaser.BitmapData) {
                    this._image = source.canvas;
                } else if (typeof source === "string") {
                    source = this.game.cache.getImage(source);
                    if (source === null) {
                        return;
                    } else {
                        this._image = source;
                    }
                }
                this._size.set(this._image.width, this._image.height);
            }
            if (x === undefined || x === null) {
                x = 0;
            }
            if (y === undefined || y === null) {
                y = 0;
            }
            if (width) {
                this._size.x = width;
            }
            if (height) {
                this._size.y = height;
            }
            if (tx === undefined || tx === null) {
                tx = x;
            }
            if (ty === undefined || ty === null) {
                ty = y;
            }
            if (newWidth === undefined || newWidth === null) {
                newWidth = this._size.x;
            }
            if (newHeight === undefined || newHeight === null) {
                newHeight = this._size.y;
            }
            if (typeof rotate === "number") {
                this._rotate = rotate;
            }
            if (typeof anchorX === "number") {
                this._anchor.x = anchorX;
            }
            if (typeof anchorY === "number") {
                this._anchor.y = anchorY;
            }
            if (typeof scaleX === "number") {
                this._scale.x = scaleX;
            }
            if (typeof scaleY === "number") {
                this._scale.y = scaleY;
            }
            if (typeof alpha === "number") {
                this._alpha.current = alpha;
            }
            if (blendMode === undefined) {
                blendMode = null;
            }
            if (roundPx === undefined) {
                roundPx = false;
            }
            if (this._alpha.current <= 0 || this._scale.x === 0 || this._scale.y === 0 || this._size.x === 0 || this._size.y === 0) {
                return;
            }
            var ctx = this.context;
            this._alpha.prev = ctx.globalAlpha;
            ctx.save();
            ctx.globalAlpha = this._alpha.current;
            if (blendMode) {
                this.op = blendMode;
            }
            if (roundPx) {
                tx |= 0;
                ty |= 0;
            }
            ctx.translate(tx, ty);
            ctx.scale(this._scale.x, this._scale.y);
            ctx.rotate(this._rotate);
            ctx.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight);
            ctx.restore();
            ctx.globalAlpha = this._alpha.prev;
            this.dirty = true;
            return this;
        },
        copyRect: function(source, area, x, y, alpha, blendMode, roundPx) {
            return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx);
        },
        draw: function(source, x, y, width, height, blendMode, roundPx) {
            return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx);
        },
        drawGroup: function(group, blendMode, roundPx) {
            if (group.total > 0) {
                group.forEachExists(this.copy, this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, blendMode, roundPx);
            }
            return this;
        },
        drawFull: function(parent, blendMode, roundPx) {
            if (parent.worldVisible === false || parent.worldAlpha === 0 || parent.hasOwnProperty("exists") && parent.exists === false) {
                return this;
            }
            if (parent.type !== Phaser.GROUP && parent.type !== Phaser.EMITTER && parent.type !== Phaser.BITMAPTEXT) {
                if (parent.type === Phaser.GRAPHICS) {
                    var bounds = parent.getBounds();
                    this.ctx.save();
                    this.ctx.translate(bounds.x, bounds.y);
                    PIXI.CanvasGraphics.renderGraphics(parent, this.ctx);
                    this.ctx.restore();
                } else {
                    this.copy(parent, null, null, null, null, parent.worldPosition.x, parent.worldPosition.y, null, null, parent.worldRotation, null, null, parent.worldScale.x, parent.worldScale.y, parent.worldAlpha, blendMode, roundPx);
                }
            }
            if (parent.children) {
                for (var i = 0; i < parent.children.length; i++) {
                    this.drawFull(parent.children[i], blendMode, roundPx);
                }
            }
            return this;
        },
        shadow: function(color, blur, x, y) {
            var ctx = this.context;
            if (color === undefined || color === null) {
                ctx.shadowColor = "rgba(0,0,0,0)";
            } else {
                ctx.shadowColor = color;
                ctx.shadowBlur = blur || 5;
                ctx.shadowOffsetX = x || 10;
                ctx.shadowOffsetY = y || 10;
            }
        },
        alphaMask: function(source, mask, sourceRect, maskRect) {
            if (maskRect === undefined || maskRect === null) {
                this.draw(mask).blendSourceAtop();
            } else {
                this.draw(mask, maskRect.x, maskRect.y, maskRect.width, maskRect.height).blendSourceAtop();
            }
            if (sourceRect === undefined || sourceRect === null) {
                this.draw(source).blendReset();
            } else {
                this.draw(source, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height).blendReset();
            }
            return this;
        },
        extract: function(destination, r, g, b, a, resize, r2, g2, b2) {
            if (a === undefined) {
                a = 255;
            }
            if (resize === undefined) {
                resize = false;
            }
            if (r2 === undefined) {
                r2 = r;
            }
            if (g2 === undefined) {
                g2 = g;
            }
            if (b2 === undefined) {
                b2 = b;
            }
            if (resize) {
                destination.resize(this.width, this.height);
            }
            this.processPixelRGB(function(pixel, x, y) {
                if (pixel.r === r && pixel.g === g && pixel.b === b) {
                    destination.setPixel32(x, y, r2, g2, b2, a, false);
                }
                return false;
            }, this);
            destination.context.putImageData(destination.imageData, 0, 0);
            destination.dirty = true;
            return destination;
        },
        rect: function(x, y, width, height, fillStyle) {
            if (typeof fillStyle !== "undefined") {
                this.context.fillStyle = fillStyle;
            }
            this.context.fillRect(x, y, width, height);
            return this;
        },
        text: function(text, x, y, font, color, shadow) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (font === undefined) {
                font = "14px Courier";
            }
            if (color === undefined) {
                color = "rgb(255,255,255)";
            }
            if (shadow === undefined) {
                shadow = true;
            }
            var ctx = this.context;
            var prevFont = ctx.font;
            ctx.font = font;
            if (shadow) {
                ctx.fillStyle = "rgb(0,0,0)";
                ctx.fillText(text, x + 1, y + 1);
            }
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
            ctx.font = prevFont;
        },
        circle: function(x, y, radius, fillStyle) {
            var ctx = this.context;
            if (fillStyle !== undefined) {
                ctx.fillStyle = fillStyle;
            }
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
            return this;
        },
        line: function(x1, y1, x2, y2, color, width) {
            if (color === undefined) {
                color = "#fff";
            }
            if (width === undefined) {
                width = 1;
            }
            var ctx = this.context;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.closePath();
            return this;
        },
        textureLine: function(line, image, repeat) {
            if (repeat === undefined) {
                repeat = "repeat-x";
            }
            if (typeof image === "string") {
                image = this.game.cache.getImage(image);
                if (!image) {
                    return;
                }
            }
            var width = line.length;
            if (repeat === "no-repeat" && width > image.width) {
                width = image.width;
            }
            var ctx = this.context;
            ctx.fillStyle = ctx.createPattern(image, repeat);
            this._circle = new Phaser.Circle(line.start.x, line.start.y, image.height);
            this._circle.circumferencePoint(line.angle - 1.5707963267948966, false, this._pos);
            ctx.save();
            ctx.translate(this._pos.x, this._pos.y);
            ctx.rotate(line.angle);
            ctx.fillRect(0, 0, width, image.height);
            ctx.restore();
            this.dirty = true;
            return this;
        },
        render: function() {
            if (!this.disableTextureUpload && this.dirty) {
                this.baseTexture.dirty();
                this.dirty = false;
            }
            return this;
        },
        destroy: function() {
            PIXI.CanvasPool.remove(this);
        },
        blendReset: function() {
            this.op = "source-over";
            return this;
        },
        blendSourceOver: function() {
            this.op = "source-over";
            return this;
        },
        blendSourceIn: function() {
            this.op = "source-in";
            return this;
        },
        blendSourceOut: function() {
            this.op = "source-out";
            return this;
        },
        blendSourceAtop: function() {
            this.op = "source-atop";
            return this;
        },
        blendDestinationOver: function() {
            this.op = "destination-over";
            return this;
        },
        blendDestinationIn: function() {
            this.op = "destination-in";
            return this;
        },
        blendDestinationOut: function() {
            this.op = "destination-out";
            return this;
        },
        blendDestinationAtop: function() {
            this.op = "destination-atop";
            return this;
        },
        blendXor: function() {
            this.op = "xor";
            return this;
        },
        blendAdd: function() {
            this.op = "lighter";
            return this;
        },
        blendMultiply: function() {
            this.op = "multiply";
            return this;
        },
        blendScreen: function() {
            this.op = "screen";
            return this;
        },
        blendOverlay: function() {
            this.op = "overlay";
            return this;
        },
        blendDarken: function() {
            this.op = "darken";
            return this;
        },
        blendLighten: function() {
            this.op = "lighten";
            return this;
        },
        blendColorDodge: function() {
            this.op = "color-dodge";
            return this;
        },
        blendColorBurn: function() {
            this.op = "color-burn";
            return this;
        },
        blendHardLight: function() {
            this.op = "hard-light";
            return this;
        },
        blendSoftLight: function() {
            this.op = "soft-light";
            return this;
        },
        blendDifference: function() {
            this.op = "difference";
            return this;
        },
        blendExclusion: function() {
            this.op = "exclusion";
            return this;
        },
        blendHue: function() {
            this.op = "hue";
            return this;
        },
        blendSaturation: function() {
            this.op = "saturation";
            return this;
        },
        blendColor: function() {
            this.op = "color";
            return this;
        },
        blendLuminosity: function() {
            this.op = "luminosity";
            return this;
        }
    };
    Object.defineProperty(Phaser.BitmapData.prototype, "smoothed", {
        get: function() {
            Phaser.Canvas.getSmoothingEnabled(this.context);
        },
        set: function(value) {
            Phaser.Canvas.setSmoothingEnabled(this.context, value);
        }
    });
    Object.defineProperty(Phaser.BitmapData.prototype, "op", {
        get: function() {
            return this.context.globalCompositeOperation;
        },
        set: function(value) {
            this.context.globalCompositeOperation = value;
        }
    });
    Phaser.BitmapData.getTransform = function(translateX, translateY, scaleX, scaleY, skewX, skewY) {
        if (typeof translateX !== "number") {
            translateX = 0;
        }
        if (typeof translateY !== "number") {
            translateY = 0;
        }
        if (typeof scaleX !== "number") {
            scaleX = 1;
        }
        if (typeof scaleY !== "number") {
            scaleY = 1;
        }
        if (typeof skewX !== "number") {
            skewX = 0;
        }
        if (typeof skewY !== "number") {
            skewY = 0;
        }
        return {
            sx: scaleX,
            sy: scaleY,
            scaleX: scaleX,
            scaleY: scaleY,
            skewX: skewX,
            skewY: skewY,
            translateX: translateX,
            translateY: translateY,
            tx: translateX,
            ty: translateY
        };
    };
    Phaser.BitmapData.prototype.constructor = Phaser.BitmapData;
    PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = 0;
        this.graphicsData = [];
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.currentPath = null;
        this._webGL = [];
        this.isMask = false;
        this.boundsPadding = 0;
        this._localBounds = new PIXI.Rectangle(0, 0, 1, 1);
        this.dirty = true;
        this.webGLDirty = false;
        this.cachedSpriteDirty = false;
    };
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Graphics.prototype.constructor = PIXI.Graphics;
    PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
        this.lineWidth = lineWidth || 0;
        this.lineColor = color || 0;
        this.lineAlpha = alpha === undefined ? 1 : alpha;
        if (this.currentPath) {
            if (this.currentPath.shape.points.length) {
                this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2)));
            } else {
                this.currentPath.lineWidth = this.lineWidth;
                this.currentPath.lineColor = this.lineColor;
                this.currentPath.lineAlpha = this.lineAlpha;
            }
        }
        return this;
    };
    PIXI.Graphics.prototype.moveTo = function(x, y) {
        this.drawShape(new PIXI.Polygon([ x, y ]));
        return this;
    };
    PIXI.Graphics.prototype.lineTo = function(x, y) {
        if (!this.currentPath) {
            this.moveTo(0, 0);
        }
        this.currentPath.shape.points.push(x, y);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [ 0, 0 ];
            }
        } else {
            this.moveTo(0, 0);
        }
        var xa, ya, n = 20, points = this.currentPath.shape.points;
        if (points.length === 0) {
            this.moveTo(0, 0);
        }
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; ++i) {
            j = i / n;
            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;
            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points = [ 0, 0 ];
            }
        } else {
            this.moveTo(0, 0);
        }
        var n = 20, dt, dt2, dt3, t2, t3, points = this.currentPath.shape.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; ++i) {
            j = i / n;
            dt = 1 - j;
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length === 0) {
                this.currentPath.shape.points.push(x1, y1);
            }
        } else {
            this.moveTo(x1, y1);
        }
        var points = this.currentPath.shape.points, fromX = points[points.length - 2], fromY = points[points.length - 1], a1 = fromY - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
        } else {
            var dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle = Math.atan2(qy - cy, qx - cx);
            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        if (startAngle === endAngle) {
            return this;
        }
        if (anticlockwise === undefined) {
            anticlockwise = false;
        }
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += Math.PI * 2;
        } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += Math.PI * 2;
        }
        var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle;
        var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;
        if (sweep === 0) {
            return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        if (anticlockwise && this.filling) {
            this.moveTo(cx, cy);
        } else {
            this.moveTo(startX, startY);
        }
        var points = this.currentPath.shape.points;
        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = segs - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i = 0; i <= segMinus; i++) {
            var real = i + remainder * i;
            var angle = theta + startAngle + theta2 * real;
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.beginFill = function(color, alpha) {
        this.filling = true;
        this.fillColor = color || 0;
        this.fillAlpha = alpha === undefined ? 1 : alpha;
        if (this.currentPath) {
            if (this.currentPath.shape.points.length <= 2) {
                this.currentPath.fill = this.filling;
                this.currentPath.fillColor = this.fillColor;
                this.currentPath.fillAlpha = this.fillAlpha;
            }
        }
        return this;
    };
    PIXI.Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this;
    };
    PIXI.Graphics.prototype.drawRect = function(x, y, width, height) {
        this.drawShape(new PIXI.Rectangle(x, y, width, height));
        return this;
    };
    PIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) {
        this.drawShape(new PIXI.RoundedRectangle(x, y, width, height, radius));
        return this;
    };
    PIXI.Graphics.prototype.drawCircle = function(x, y, diameter) {
        this.drawShape(new PIXI.Circle(x, y, diameter));
        return this;
    };
    PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height) {
        this.drawShape(new PIXI.Ellipse(x, y, width, height));
        return this;
    };
    PIXI.Graphics.prototype.drawPolygon = function(path) {
        if (path instanceof Phaser.Polygon || path instanceof PIXI.Polygon) {
            path = path.points;
        }
        var points = path;
        if (!Array.isArray(points)) {
            points = new Array(arguments.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments[i];
            }
        }
        this.drawShape(new Phaser.Polygon(points));
        return this;
    };
    PIXI.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
        return this;
    };
    PIXI.Graphics.prototype.generateTexture = function(resolution, scaleMode) {
        resolution = resolution || 1;
        var bounds = this.getBounds();
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width * resolution, bounds.height * resolution);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
        texture.baseTexture.resolution = resolution;
        canvasBuffer.context.scale(resolution, resolution);
        canvasBuffer.context.translate(-bounds.x, -bounds.y);
        PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);
        return texture;
    };
    PIXI.Graphics.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        if (this._cacheAsBitmap) {
            if (this.dirty || this.cachedSpriteDirty) {
                this._generateCachedSprite();
                this.updateCachedSpriteTexture();
                this.cachedSpriteDirty = false;
                this.dirty = false;
            }
            this._cachedSprite.worldAlpha = this.worldAlpha;
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
            return;
        } else {
            renderSession.spriteBatch.stop();
            renderSession.blendModeManager.setBlendMode(this.blendMode);
            if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock);
            if (this.blendMode !== renderSession.spriteBatch.currentBlendMode) {
                renderSession.spriteBatch.currentBlendMode = this.blendMode;
                var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
                renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
            }
            if (this.webGLDirty) {
                this.dirty = true;
                this.webGLDirty = false;
            }
            PIXI.WebGLGraphics.renderGraphics(this, renderSession);
            if (this.children.length) {
                renderSession.spriteBatch.start();
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i]._renderWebGL(renderSession);
                }
                renderSession.spriteBatch.stop();
            }
            if (this._filters) renderSession.filterManager.popFilter();
            if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession);
            renderSession.drawCount++;
            renderSession.spriteBatch.start();
        }
    };
    PIXI.Graphics.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        if (this._prevTint !== this.tint) {
            this.dirty = true;
            this._prevTint = this.tint;
        }
        if (this._cacheAsBitmap) {
            if (this.dirty || this.cachedSpriteDirty) {
                this._generateCachedSprite();
                this.updateCachedSpriteTexture();
                this.cachedSpriteDirty = false;
                this.dirty = false;
            }
            this._cachedSprite.alpha = this.alpha;
            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
            return;
        } else {
            var context = renderSession.context;
            var transform = this.worldTransform;
            if (this.blendMode !== renderSession.currentBlendMode) {
                renderSession.currentBlendMode = this.blendMode;
                context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
            }
            if (this._mask) {
                renderSession.maskManager.pushMask(this._mask, renderSession);
            }
            var resolution = renderSession.resolution;
            context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
            PIXI.CanvasGraphics.renderGraphics(this, context);
            for (var i = 0; i < this.children.length; i++) {
                this.children[i]._renderCanvas(renderSession);
            }
            if (this._mask) {
                renderSession.maskManager.popMask(renderSession);
            }
        }
    };
    PIXI.Graphics.prototype.getBounds = function(matrix) {
        if (!this._currentBounds) {
            if (!this.renderable) {
                return PIXI.EmptyRectangle;
            }
            if (this.dirty) {
                this.updateLocalBounds();
                this.webGLDirty = true;
                this.cachedSpriteDirty = true;
                this.dirty = false;
            }
            var bounds = this._localBounds;
            var w0 = bounds.x;
            var w1 = bounds.width + bounds.x;
            var h0 = bounds.y;
            var h1 = bounds.height + bounds.y;
            var worldTransform = matrix || this.worldTransform;
            var a = worldTransform.a;
            var b = worldTransform.b;
            var c = worldTransform.c;
            var d = worldTransform.d;
            var tx = worldTransform.tx;
            var ty = worldTransform.ty;
            var x1 = a * w1 + c * h1 + tx;
            var y1 = d * h1 + b * w1 + ty;
            var x2 = a * w0 + c * h1 + tx;
            var y2 = d * h1 + b * w0 + ty;
            var x3 = a * w0 + c * h0 + tx;
            var y3 = d * h0 + b * w0 + ty;
            var x4 = a * w1 + c * h0 + tx;
            var y4 = d * h0 + b * w1 + ty;
            var maxX = x1;
            var maxY = y1;
            var minX = x1;
            var minY = y1;
            minX = x2 < minX ? x2 : minX;
            minX = x3 < minX ? x3 : minX;
            minX = x4 < minX ? x4 : minX;
            minY = y2 < minY ? y2 : minY;
            minY = y3 < minY ? y3 : minY;
            minY = y4 < minY ? y4 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxX = x3 > maxX ? x3 : maxX;
            maxX = x4 > maxX ? x4 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
            maxY = y3 > maxY ? y3 : maxY;
            maxY = y4 > maxY ? y4 : maxY;
            this._bounds.x = minX;
            this._bounds.width = maxX - minX;
            this._bounds.y = minY;
            this._bounds.height = maxY - minY;
            this._currentBounds = this._bounds;
        }
        return this._currentBounds;
    };
    PIXI.Graphics.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; i++) {
            var data = graphicsData[i];
            if (!data.fill) {
                continue;
            }
            if (data.shape) {
                if (data.shape.contains(tempPoint.x, tempPoint.y)) {
                    return true;
                }
            }
        }
        return false;
    };
    PIXI.Graphics.prototype.updateLocalBounds = function() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
            var shape, points, x, y, w, h;
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineWidth;
                shape = data.shape;
                if (type === PIXI.Graphics.RECT || type === PIXI.Graphics.RREC) {
                    x = shape.x - lineWidth / 2;
                    y = shape.y - lineWidth / 2;
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;
                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === PIXI.Graphics.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + lineWidth / 2;
                    h = shape.radius + lineWidth / 2;
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else if (type === PIXI.Graphics.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + lineWidth / 2;
                    h = shape.height + lineWidth / 2;
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                } else {
                    points = shape.points;
                    for (var j = 0; j < points.length; j++) {
                        if (points[j] instanceof Phaser.Point) {
                            x = points[j].x;
                            y = points[j].y;
                        } else {
                            x = points[j];
                            y = points[j + 1];
                            if (j < points.length - 1) {
                                j++;
                            }
                        }
                        minX = x - lineWidth < minX ? x - lineWidth : minX;
                        maxX = x + lineWidth > maxX ? x + lineWidth : maxX;
                        minY = y - lineWidth < minY ? y - lineWidth : minY;
                        maxY = y + lineWidth > maxY ? y + lineWidth : maxY;
                    }
                }
            }
        } else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var padding = this.boundsPadding;
        this._localBounds.x = minX - padding;
        this._localBounds.width = maxX - minX + padding * 2;
        this._localBounds.y = minY - padding;
        this._localBounds.height = maxY - minY + padding * 2;
    };
    PIXI.Graphics.prototype._generateCachedSprite = function() {
        var bounds = this.getLocalBounds();
        if (!this._cachedSprite) {
            var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
            var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this._cachedSprite = new PIXI.Sprite(texture);
            this._cachedSprite.buffer = canvasBuffer;
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.buffer.resize(bounds.width, bounds.height);
        }
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y);
        this.worldAlpha = 1;
        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
        this._cachedSprite.alpha = this.alpha;
    };
    PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
        var cachedSprite = this._cachedSprite;
        var texture = cachedSprite.texture;
        var canvas = cachedSprite.buffer.canvas;
        texture.baseTexture.width = canvas.width;
        texture.baseTexture.height = canvas.height;
        texture.crop.width = texture.frame.width = canvas.width;
        texture.crop.height = texture.frame.height = canvas.height;
        cachedSprite._width = canvas.width;
        cachedSprite._height = canvas.height;
        texture.baseTexture.dirty();
    };
    PIXI.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.Graphics.prototype.drawShape = function(shape) {
        if (this.currentPath) {
            if (this.currentPath.shape.points.length <= 2) {
                this.graphicsData.pop();
            }
        }
        this.currentPath = null;
        if (shape instanceof Phaser.Polygon) {
            shape = shape.clone();
            shape.flatten();
        }
        var data = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);
        this.graphicsData.push(data);
        if (data.type === PIXI.Graphics.POLY) {
            data.shape.closed = this.filling;
            this.currentPath = data;
        }
        this.dirty = true;
        return data;
    };
    Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            this._cacheAsBitmap = value;
            if (this._cacheAsBitmap) {
                this._generateCachedSprite();
            } else {
                this.destroyCachedSprite();
                this.dirty = true;
            }
        }
    });
    PIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
        this.lineWidth = lineWidth;
        this.lineColor = lineColor;
        this.lineAlpha = lineAlpha;
        this._lineTint = lineColor;
        this.fillColor = fillColor;
        this.fillAlpha = fillAlpha;
        this._fillTint = fillColor;
        this.fill = fill;
        this.shape = shape;
        this.type = shape.type;
    };
    PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData;
    PIXI.GraphicsData.prototype.clone = function() {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
    };
    Phaser.Graphics = function(game, x, y) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        this.type = Phaser.GRAPHICS;
        this.physicsType = Phaser.SPRITE;
        PIXI.Graphics.call(this);
        Phaser.Component.Core.init.call(this, game, x, y, "", null);
    };
    Phaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    Phaser.Graphics.prototype.constructor = Phaser.Graphics;
    Phaser.Component.Core.install.call(Phaser.Graphics.prototype, [ "Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset" ]);
    Phaser.Graphics.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.Graphics.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.Graphics.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.Graphics.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.Graphics.prototype.preUpdate = function() {
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.Graphics.prototype.destroy = function(destroyChildren) {
        this.clear();
        Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);
    };
    Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
        if (cull === undefined) {
            cull = false;
        }
        var triangle = new Phaser.Polygon(points);
        if (cull) {
            var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);
            var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);
            var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);
            var faceNormal = cb.cross(ab);
            if (cameraToFace.dot(faceNormal) > 0) {
                this.drawPolygon(triangle);
            }
        } else {
            this.drawPolygon(triangle);
        }
    };
    Phaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) {
        if (cull === undefined) {
            cull = false;
        }
        var point1 = new Phaser.Point();
        var point2 = new Phaser.Point();
        var point3 = new Phaser.Point();
        var points = [];
        var i;
        if (!indices) {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < vertices.length / 3; i++) {
                    this.drawTriangle([ vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2] ], cull);
                }
            } else {
                for (i = 0; i < vertices.length / 6; i++) {
                    point1.x = vertices[i * 6 + 0];
                    point1.y = vertices[i * 6 + 1];
                    point2.x = vertices[i * 6 + 2];
                    point2.y = vertices[i * 6 + 3];
                    point3.x = vertices[i * 6 + 4];
                    point3.y = vertices[i * 6 + 5];
                    this.drawTriangle([ point1, point2, point3 ], cull);
                }
            }
        } else {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < indices.length / 3; i++) {
                    points.push(vertices[indices[i * 3]]);
                    points.push(vertices[indices[i * 3 + 1]]);
                    points.push(vertices[indices[i * 3 + 2]]);
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            } else {
                for (i = 0; i < indices.length; i++) {
                    point1.x = vertices[indices[i] * 2];
                    point1.y = vertices[indices[i] * 2 + 1];
                    points.push(point1.copyTo({}));
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            }
        }
    };
    Phaser.RenderTexture = function(game, width, height, key, scaleMode, resolution) {
        if (key === undefined) {
            key = "";
        }
        if (scaleMode === undefined) {
            scaleMode = Phaser.scaleModes.DEFAULT;
        }
        if (resolution === undefined) {
            resolution = 1;
        }
        this.game = game;
        this.key = key;
        this.type = Phaser.RENDERTEXTURE;
        this._tempMatrix = new PIXI.Matrix();
        PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode, resolution);
        this.render = Phaser.RenderTexture.prototype.render;
    };
    Phaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    Phaser.RenderTexture.prototype.constructor = Phaser.RenderTexture;
    Phaser.RenderTexture.prototype.renderXY = function(displayObject, x, y, clear) {
        displayObject.updateTransform();
        this._tempMatrix.copyFrom(displayObject.worldTransform);
        this._tempMatrix.tx = x;
        this._tempMatrix.ty = y;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderWebGL(displayObject, this._tempMatrix, clear);
        } else {
            this.renderCanvas(displayObject, this._tempMatrix, clear);
        }
    };
    Phaser.RenderTexture.prototype.renderRawXY = function(displayObject, x, y, clear) {
        this._tempMatrix.identity().translate(x, y);
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderWebGL(displayObject, this._tempMatrix, clear);
        } else {
            this.renderCanvas(displayObject, this._tempMatrix, clear);
        }
    };
    Phaser.RenderTexture.prototype.render = function(displayObject, matrix, clear) {
        if (matrix === undefined || matrix === null) {
            this._tempMatrix.copyFrom(displayObject.worldTransform);
        } else {
            this._tempMatrix.copyFrom(matrix);
        }
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderWebGL(displayObject, this._tempMatrix, clear);
        } else {
            this.renderCanvas(displayObject, this._tempMatrix, clear);
        }
    };
    Phaser.Text = function(game, x, y, text, style) {
        x = x || 0;
        y = y || 0;
        if (text === undefined || text === null) {
            text = "";
        } else {
            text = text.toString();
        }
        style = style || {};
        this.type = Phaser.TEXT;
        this.physicsType = Phaser.SPRITE;
        this.padding = new Phaser.Point();
        this.textBounds = null;
        this.canvas = PIXI.CanvasPool.create(this);
        this.context = this.canvas.getContext("2d");
        this.colors = [];
        this.strokeColors = [];
        this.fontStyles = [];
        this.fontWeights = [];
        this.autoRound = false;
        this._res = game.renderer.resolution;
        this._text = text;
        this._fontComponents = null;
        this._lineSpacing = 0;
        this._charCount = 0;
        this._width = 0;
        this._height = 0;
        Phaser.Sprite.call(this, game, x, y, PIXI.Texture.fromCanvas(this.canvas));
        this.setStyle(style);
        if (text !== "") {
            this.updateText();
        }
    };
    Phaser.Text.prototype = Object.create(Phaser.Sprite.prototype);
    Phaser.Text.prototype.constructor = Phaser.Text;
    Phaser.Text.prototype.preUpdate = function() {
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.Text.prototype.update = function() {};
    Phaser.Text.prototype.destroy = function(destroyChildren) {
        this.texture.destroy(true);
        PIXI.CanvasPool.remove(this);
        Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);
    };
    Phaser.Text.prototype.setShadow = function(x, y, color, blur, shadowStroke, shadowFill) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (color === undefined) {
            color = "rgba(0, 0, 0, 1)";
        }
        if (blur === undefined) {
            blur = 0;
        }
        if (shadowStroke === undefined) {
            shadowStroke = true;
        }
        if (shadowFill === undefined) {
            shadowFill = true;
        }
        this.style.shadowOffsetX = x;
        this.style.shadowOffsetY = y;
        this.style.shadowColor = color;
        this.style.shadowBlur = blur;
        this.style.shadowStroke = shadowStroke;
        this.style.shadowFill = shadowFill;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.backgroundColor = style.backgroundColor || null;
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.boundsAlignH = style.boundsAlignH || "left";
        style.boundsAlignV = style.boundsAlignV || "top";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        style.shadowOffsetX = style.shadowOffsetX || 0;
        style.shadowOffsetY = style.shadowOffsetY || 0;
        style.shadowColor = style.shadowColor || "rgba(0,0,0,0)";
        style.shadowBlur = style.shadowBlur || 0;
        style.tabs = style.tabs || 0;
        var components = this.fontToComponents(style.font);
        if (style.fontStyle) {
            components.fontStyle = style.fontStyle;
        }
        if (style.fontVariant) {
            components.fontVariant = style.fontVariant;
        }
        if (style.fontWeight) {
            components.fontWeight = style.fontWeight;
        }
        if (style.fontSize) {
            if (typeof style.fontSize === "number") {
                style.fontSize = style.fontSize + "px";
            }
            components.fontSize = style.fontSize;
        }
        this._fontComponents = components;
        style.font = this.componentsToFont(this._fontComponents);
        this.style = style;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this._res;
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) {
            outputText = this.runWordWrap(this.text);
        }
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var tabs = this.style.tabs;
        var lineWidths = [];
        var maxLineWidth = 0;
        var fontProperties = this.determineFontProperties(this.style.font);
        for (var i = 0; i < lines.length; i++) {
            if (tabs === 0) {
                var lineWidth = this.context.measureText(lines[i]).width + this.style.strokeThickness + this.padding.x;
            } else {
                var line = lines[i].split(/(?:\t)/);
                var lineWidth = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(tabs)) {
                    var tab = 0;
                    for (var c = 0; c < line.length; c++) {
                        var section = Math.ceil(this.context.measureText(line[c]).width);
                        if (c > 0) {
                            tab += tabs[c - 1];
                        }
                        lineWidth = tab + section;
                    }
                } else {
                    for (var c = 0; c < line.length; c++) {
                        lineWidth += Math.ceil(this.context.measureText(line[c]).width);
                        var diff = this.game.math.snapToCeil(lineWidth, tabs) - lineWidth;
                        lineWidth += diff;
                    }
                }
            }
            lineWidths[i] = Math.ceil(lineWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
        }
        var width = maxLineWidth + this.style.strokeThickness;
        this.canvas.width = width * this._res;
        var lineHeight = fontProperties.fontSize + this.style.strokeThickness + this.padding.y;
        var height = lineHeight * lines.length;
        var lineSpacing = this._lineSpacing;
        if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight) {
            lineSpacing = -lineHeight;
        }
        if (lineSpacing !== 0) {
            var diff = lineSpacing * (lines.length - 1);
            height += diff;
        }
        this.canvas.height = height * this._res;
        this.context.scale(this._res, this._res);
        if (navigator.isCocoonJS) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        if (this.style.backgroundColor) {
            this.context.fillStyle = this.style.backgroundColor;
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.textBaseline = "alphabetic";
        this.context.lineWidth = this.style.strokeThickness;
        this.context.lineCap = "round";
        this.context.lineJoin = "round";
        var linePositionX;
        var linePositionY;
        this._charCount = 0;
        for (i = 0; i < lines.length; i++) {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;
            if (i > 0) {
                linePositionY += lineSpacing * i;
            }
            if (this.style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (this.autoRound) {
                linePositionX = Math.round(linePositionX);
                linePositionY = Math.round(linePositionY);
            }
            if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                this.updateLine(lines[i], linePositionX, linePositionY);
            } else {
                if (this.style.stroke && this.style.strokeThickness) {
                    this.updateShadow(this.style.shadowStroke);
                    if (tabs === 0) {
                        this.context.strokeText(lines[i], linePositionX, linePositionY);
                    } else {
                        this.renderTabLine(lines[i], linePositionX, linePositionY, false);
                    }
                }
                if (this.style.fill) {
                    this.updateShadow(this.style.shadowFill);
                    if (tabs === 0) {
                        this.context.fillText(lines[i], linePositionX, linePositionY);
                    } else {
                        this.renderTabLine(lines[i], linePositionX, linePositionY, true);
                    }
                }
            }
        }
        this.updateTexture();
    };
    Phaser.Text.prototype.renderTabLine = function(line, x, y, fill) {
        var text = line.split(/(?:\t)/);
        var tabs = this.style.tabs;
        var snap = 0;
        if (Array.isArray(tabs)) {
            var tab = 0;
            for (var c = 0; c < text.length; c++) {
                if (c > 0) {
                    tab += tabs[c - 1];
                }
                snap = x + tab;
                if (fill) {
                    this.context.fillText(text[c], snap, y);
                } else {
                    this.context.strokeText(text[c], snap, y);
                }
            }
        } else {
            for (var c = 0; c < text.length; c++) {
                var section = Math.ceil(this.context.measureText(text[c]).width);
                snap = this.game.math.snapToCeil(x, tabs);
                if (fill) {
                    this.context.fillText(text[c], snap, y);
                } else {
                    this.context.strokeText(text[c], snap, y);
                }
                x = snap + section;
            }
        }
    };
    Phaser.Text.prototype.updateShadow = function(state) {
        if (state) {
            this.context.shadowOffsetX = this.style.shadowOffsetX;
            this.context.shadowOffsetY = this.style.shadowOffsetY;
            this.context.shadowColor = this.style.shadowColor;
            this.context.shadowBlur = this.style.shadowBlur;
        } else {
            this.context.shadowOffsetX = 0;
            this.context.shadowOffsetY = 0;
            this.context.shadowColor = 0;
            this.context.shadowBlur = 0;
        }
    };
    Phaser.Text.prototype.updateLine = function(line, x, y) {
        for (var i = 0; i < line.length; i++) {
            var letter = line[i];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var components = this.fontToComponents(this.context.font);
                if (this.fontStyles[this._charCount]) {
                    components.fontStyle = this.fontStyles[this._charCount];
                }
                if (this.fontWeights[this._charCount]) {
                    components.fontWeight = this.fontWeights[this._charCount];
                }
                this.context.font = this.componentsToFont(components);
            }
            if (this.style.stroke && this.style.strokeThickness) {
                if (this.strokeColors[this._charCount]) {
                    this.context.strokeStyle = this.strokeColors[this._charCount];
                }
                this.updateShadow(this.style.shadowStroke);
                this.context.strokeText(letter, x, y);
            }
            if (this.style.fill) {
                if (this.colors[this._charCount]) {
                    this.context.fillStyle = this.colors[this._charCount];
                }
                this.updateShadow(this.style.shadowFill);
                this.context.fillText(letter, x, y);
            }
            x += this.context.measureText(letter).width;
            this._charCount++;
        }
    };
    Phaser.Text.prototype.clearColors = function() {
        this.colors = [];
        this.strokeColors = [];
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.clearFontValues = function() {
        this.fontStyles = [];
        this.fontWeights = [];
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.addColor = function(color, position) {
        this.colors[position] = color;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.addStrokeColor = function(color, position) {
        this.strokeColors[position] = color;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.addFontStyle = function(style, position) {
        this.fontStyles[position] = style;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.addFontWeight = function(weight, position) {
        this.fontWeights[position] = weight;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.runWordWrap = function(text) {
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = this.style.wordWrapWidth;
            var words = lines[i].split(" ");
            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;
                var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                if (wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                        result += "\n";
                    }
                    result += words[j] + " ";
                    spaceLeft = this.style.wordWrapWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += words[j] + " ";
                }
            }
            if (i < lines.length - 1) {
                result += "\n";
            }
        }
        return result;
    };
    Phaser.Text.prototype.updateFont = function(components) {
        var font = this.componentsToFont(components);
        if (this.style.font !== font) {
            this.style.font = font;
            this.dirty = true;
            if (this.parent) {
                this.updateTransform();
            }
        }
    };
    Phaser.Text.prototype.fontToComponents = function(font) {
        var m = font.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        if (m) {
            return {
                font: font,
                fontStyle: m[1] || "normal",
                fontVariant: m[2] || "normal",
                fontWeight: m[3] || "normal",
                fontSize: m[4] || "medium",
                fontFamily: m[5]
            };
        } else {
            console.warn("Phaser.Text - unparsable CSS font: " + font);
            return {
                font: font
            };
        }
    };
    Phaser.Text.prototype.componentsToFont = function(components) {
        var parts = [];
        var v;
        v = components.fontStyle;
        if (v && v !== "normal") {
            parts.push(v);
        }
        v = components.fontVariant;
        if (v && v !== "normal") {
            parts.push(v);
        }
        v = components.fontWeight;
        if (v && v !== "normal") {
            parts.push(v);
        }
        v = components.fontSize;
        if (v && v !== "medium") {
            parts.push(v);
        }
        v = components.fontFamily;
        if (v) {
            parts.push(v);
        }
        if (!parts.length) {
            parts.push(components.font);
        }
        return parts.join(" ");
    };
    Phaser.Text.prototype.setText = function(text) {
        this.text = text.toString() || "";
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.parseList = function(list) {
        if (!Array.isArray(list)) {
            return this;
        } else {
            var s = "";
            for (var i = 0; i < list.length; i++) {
                if (Array.isArray(list[i])) {
                    s += list[i].join("	");
                    if (i < list.length - 1) {
                        s += "\n";
                    }
                } else {
                    s += list[i];
                    if (i < list.length - 1) {
                        s += "	";
                    }
                }
            }
        }
        this.text = s;
        this.dirty = true;
        return this;
    };
    Phaser.Text.prototype.setTextBounds = function(x, y, width, height) {
        if (x === undefined) {
            this.textBounds = null;
        } else {
            if (!this.textBounds) {
                this.textBounds = new Phaser.Rectangle(x, y, width, height);
            } else {
                this.textBounds.setTo(x, y, width, height);
            }
            if (this.style.wordWrapWidth > width) {
                this.style.wordWrapWidth = width;
            }
        }
        this.updateTexture();
        return this;
    };
    Phaser.Text.prototype.updateTexture = function() {
        var base = this.texture.baseTexture;
        var crop = this.texture.crop;
        var frame = this.texture.frame;
        var w = this.canvas.width;
        var h = this.canvas.height;
        base.width = w;
        base.height = h;
        crop.width = w;
        crop.height = h;
        frame.width = w;
        frame.height = h;
        this.texture.width = w;
        this.texture.height = h;
        this._width = w;
        this._height = h;
        if (this.textBounds) {
            var x = this.textBounds.x;
            var y = this.textBounds.y;
            if (this.style.boundsAlignH === "right") {
                x += this.textBounds.width - this.canvas.width;
            } else if (this.style.boundsAlignH === "center") {
                x += this.textBounds.halfWidth - this.canvas.width / 2;
            }
            if (this.style.boundsAlignV === "bottom") {
                y += this.textBounds.height - this.canvas.height;
            } else if (this.style.boundsAlignV === "middle") {
                y += this.textBounds.halfHeight - this.canvas.height / 2;
            }
            this.pivot.x = -x;
            this.pivot.y = -y;
        }
        this.renderable = w !== 0 && h !== 0;
        this.texture.requiresReTint = true;
        this.texture.baseTexture.dirty();
    };
    Phaser.Text.prototype._renderWebGL = function(renderSession) {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
    };
    Phaser.Text.prototype._renderCanvas = function(renderSession) {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.Sprite.prototype._renderCanvas.call(this, renderSession);
    };
    Phaser.Text.prototype.determineFontProperties = function(fontStyle) {
        var properties = Phaser.Text.fontPropertiesCache[fontStyle];
        if (!properties) {
            properties = {};
            var canvas = Phaser.Text.fontPropertiesCanvas;
            var context = Phaser.Text.fontPropertiesContext;
            context.font = fontStyle;
            var width = Math.ceil(context.measureText("|MÉq").width);
            var baseline = Math.ceil(context.measureText("|MÉq").width);
            var height = 2 * baseline;
            baseline = baseline * 1.4 | 0;
            canvas.width = width;
            canvas.height = height;
            context.fillStyle = "#f00";
            context.fillRect(0, 0, width, height);
            context.font = fontStyle;
            context.textBaseline = "alphabetic";
            context.fillStyle = "#000";
            context.fillText("|MÉq", 0, baseline);
            if (!context.getImageData(0, 0, width, height)) {
                properties.ascent = baseline;
                properties.descent = baseline + 6;
                properties.fontSize = properties.ascent + properties.descent;
                Phaser.Text.fontPropertiesCache[fontStyle] = properties;
                return properties;
            }
            var imagedata = context.getImageData(0, 0, width, height).data;
            var pixels = imagedata.length;
            var line = width * 4;
            var i, j;
            var idx = 0;
            var stop = false;
            for (i = 0; i < baseline; i++) {
                for (j = 0; j < line; j += 4) {
                    if (imagedata[idx + j] !== 255) {
                        stop = true;
                        break;
                    }
                }
                if (!stop) {
                    idx += line;
                } else {
                    break;
                }
            }
            properties.ascent = baseline - i;
            idx = pixels - line;
            stop = false;
            for (i = height; i > baseline; i--) {
                for (j = 0; j < line; j += 4) {
                    if (imagedata[idx + j] !== 255) {
                        stop = true;
                        break;
                    }
                }
                if (!stop) {
                    idx -= line;
                } else {
                    break;
                }
            }
            properties.descent = i - baseline;
            properties.descent += 6;
            properties.fontSize = properties.ascent + properties.descent;
            Phaser.Text.fontPropertiesCache[fontStyle] = properties;
        }
        return properties;
    };
    Phaser.Text.prototype.getBounds = function(matrix) {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        return PIXI.Sprite.prototype.getBounds.call(this, matrix);
    };
    Object.defineProperty(Phaser.Text.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || "";
                this.dirty = true;
                if (this.parent) {
                    this.updateTransform();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "cssFont", {
        get: function() {
            return this.componentsToFont(this._fontComponents);
        },
        set: function(value) {
            value = value || "bold 20pt Arial";
            this._fontComponents = this.fontToComponents(value);
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "font", {
        get: function() {
            return this._fontComponents.fontFamily;
        },
        set: function(value) {
            value = value || "Arial";
            value = value.trim();
            if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(value) && !/['",]/.exec(value)) {
                value = "'" + value + "'";
            }
            this._fontComponents.fontFamily = value;
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontSize", {
        get: function() {
            var size = this._fontComponents.fontSize;
            if (size && /(?:^0$|px$)/.exec(size)) {
                return parseInt(size, 10);
            } else {
                return size;
            }
        },
        set: function(value) {
            value = value || "0";
            if (typeof value === "number") {
                value = value + "px";
            }
            this._fontComponents.fontSize = value;
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontComponents.fontWeight || "normal";
        },
        set: function(value) {
            value = value || "normal";
            this._fontComponents.fontWeight = value;
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontStyle", {
        get: function() {
            return this._fontComponents.fontStyle || "normal";
        },
        set: function(value) {
            value = value || "normal";
            this._fontComponents.fontStyle = value;
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontVariant", {
        get: function() {
            return this._fontComponents.fontVariant || "normal";
        },
        set: function(value) {
            value = value || "normal";
            this._fontComponents.fontVariant = value;
            this.updateFont(this._fontComponents);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fill", {
        get: function() {
            return this.style.fill;
        },
        set: function(value) {
            if (value !== this.style.fill) {
                this.style.fill = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "align", {
        get: function() {
            return this.style.align;
        },
        set: function(value) {
            if (value !== this.style.align) {
                this.style.align = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "resolution", {
        get: function() {
            return this._res;
        },
        set: function(value) {
            if (value !== this._res) {
                this._res = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "tabs", {
        get: function() {
            return this.style.tabs;
        },
        set: function(value) {
            if (value !== this.style.tabs) {
                this.style.tabs = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "boundsAlignH", {
        get: function() {
            return this.style.boundsAlignH;
        },
        set: function(value) {
            if (value !== this.style.boundsAlignH) {
                this.style.boundsAlignH = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "boundsAlignV", {
        get: function() {
            return this.style.boundsAlignV;
        },
        set: function(value) {
            if (value !== this.style.boundsAlignV) {
                this.style.boundsAlignV = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke;
        },
        set: function(value) {
            if (value !== this.style.stroke) {
                this.style.stroke = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness;
        },
        set: function(value) {
            if (value !== this.style.strokeThickness) {
                this.style.strokeThickness = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap;
        },
        set: function(value) {
            if (value !== this.style.wordWrap) {
                this.style.wordWrap = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth;
        },
        set: function(value) {
            if (value !== this.style.wordWrapWidth) {
                this.style.wordWrapWidth = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing;
        },
        set: function(value) {
            if (value !== this._lineSpacing) {
                this._lineSpacing = parseFloat(value);
                this.dirty = true;
                if (this.parent) {
                    this.updateTransform();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetX) {
                this.style.shadowOffsetX = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetY) {
                this.style.shadowOffsetY = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor;
        },
        set: function(value) {
            if (value !== this.style.shadowColor) {
                this.style.shadowColor = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur;
        },
        set: function(value) {
            if (value !== this.style.shadowBlur) {
                this.style.shadowBlur = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowStroke", {
        get: function() {
            return this.style.shadowStroke;
        },
        set: function(value) {
            if (value !== this.style.shadowStroke) {
                this.style.shadowStroke = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowFill", {
        get: function() {
            return this.style.shadowFill;
        },
        set: function(value) {
            if (value !== this.style.shadowFill) {
                this.style.shadowFill = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "width", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "height", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    Phaser.Text.fontPropertiesCache = {};
    Phaser.Text.fontPropertiesCanvas = PIXI.CanvasPool.create(Phaser.Text.fontPropertiesCanvas);
    Phaser.Text.fontPropertiesContext = Phaser.Text.fontPropertiesCanvas.getContext("2d");
    Phaser.BitmapText = function(game, x, y, font, text, size, align) {
        x = x || 0;
        y = y || 0;
        font = font || "";
        text = text || "";
        size = size || 32;
        align = align || "left";
        PIXI.DisplayObjectContainer.call(this);
        this.type = Phaser.BITMAPTEXT;
        this.physicsType = Phaser.SPRITE;
        this.textWidth = 0;
        this.textHeight = 0;
        this.anchor = new Phaser.Point();
        this._prevAnchor = new Phaser.Point();
        this._glyphs = [];
        this._maxWidth = 0;
        this._text = text;
        this._data = game.cache.getBitmapFont(font);
        this._font = font;
        this._fontSize = size;
        this._align = align;
        this._tint = 16777215;
        this.updateText();
        this.dirty = false;
        Phaser.Component.Core.init.call(this, game, x, y, "", null);
    };
    Phaser.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    Phaser.BitmapText.prototype.constructor = Phaser.BitmapText;
    Phaser.Component.Core.install.call(Phaser.BitmapText.prototype, [ "Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset" ]);
    Phaser.BitmapText.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.BitmapText.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.BitmapText.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.BitmapText.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.BitmapText.prototype.preUpdate = function() {
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.BitmapText.prototype.postUpdate = function() {
        Phaser.Component.PhysicsBody.postUpdate.call(this);
        Phaser.Component.FixedToCamera.postUpdate.call(this);
        if (this.body && this.body.type === Phaser.Physics.ARCADE) {
            if (this.textWidth !== this.body.sourceWidth || this.textHeight !== this.body.sourceHeight) {
                this.body.setSize(this.textWidth, this.textHeight);
            }
        }
    };
    Phaser.BitmapText.prototype.setText = function(text) {
        this.text = text;
    };
    Phaser.BitmapText.prototype.scanLine = function(data, scale, text) {
        var x = 0;
        var w = 0;
        var lastSpace = -1;
        var prevCharCode = null;
        var maxWidth = this._maxWidth > 0 ? this._maxWidth : null;
        var chars = [];
        for (var i = 0; i < text.length; i++) {
            var end = i === text.length - 1 ? true : false;
            if (/(?:\r\n|\r|\n)/.test(text.charAt(i))) {
                return {
                    width: w,
                    text: text.substr(0, i),
                    end: end,
                    chars: chars
                };
            } else {
                var charCode = text.charCodeAt(i);
                var charData = data.chars[charCode];
                var c = 0;
                if (!charData) {
                    continue;
                }
                var kerning = prevCharCode && charData.kerning[prevCharCode] ? charData.kerning[prevCharCode] : 0;
                lastSpace = /(\s)/.test(text.charAt(i)) ? i : lastSpace;
                c = (kerning + charData.texture.width + charData.xOffset) * scale;
                if (maxWidth && w + c >= maxWidth && lastSpace > -1) {
                    return {
                        width: w,
                        text: text.substr(0, i - (i - lastSpace)),
                        end: end,
                        chars: chars
                    };
                } else {
                    w += charData.xAdvance * scale;
                    chars.push(x + charData.xOffset * scale);
                    x += charData.xAdvance * scale;
                    prevCharCode = charCode;
                }
            }
        }
        return {
            width: w,
            text: text,
            end: end,
            chars: chars
        };
    };
    Phaser.BitmapText.prototype.updateText = function() {
        var data = this._data.font;
        if (!data) {
            return;
        }
        var text = this.text;
        var scale = this._fontSize / data.size;
        var lines = [];
        var y = 0;
        this.textWidth = 0;
        do {
            var line = this.scanLine(data, scale, text);
            line.y = y;
            lines.push(line);
            if (line.width > this.textWidth) {
                this.textWidth = line.width;
            }
            y += data.lineHeight * scale;
            text = text.substr(line.text.length + 1);
        } while (line.end === false);
        this.textHeight = y;
        var t = 0;
        var align = 0;
        var ax = this.textWidth * this.anchor.x;
        var ay = this.textHeight * this.anchor.y;
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (this._align === "right") {
                align = this.textWidth - line.width;
            } else if (this._align === "center") {
                align = (this.textWidth - line.width) / 2;
            }
            for (var c = 0; c < line.text.length; c++) {
                var charCode = line.text.charCodeAt(c);
                var charData = data.chars[charCode];
                var g = this._glyphs[t];
                if (g) {
                    g.texture = charData.texture;
                } else {
                    g = new PIXI.Sprite(charData.texture);
                    g.name = line.text[c];
                    this._glyphs.push(g);
                }
                g.position.x = line.chars[c] + align - ax;
                g.position.y = line.y + charData.yOffset * scale - ay;
                g.scale.set(scale);
                g.tint = this.tint;
                g.texture.requiresReTint = true;
                if (!g.parent) {
                    this.addChild(g);
                }
                t++;
            }
        }
        for (i = t; i < this._glyphs.length; i++) {
            this.removeChild(this._glyphs[i]);
        }
    };
    Phaser.BitmapText.prototype.purgeGlyphs = function() {
        var len = this._glyphs.length;
        var kept = [];
        for (var i = 0; i < this._glyphs.length; i++) {
            if (this._glyphs[i].parent !== this) {
                this._glyphs[i].destroy();
            } else {
                kept.push(this._glyphs[i]);
            }
        }
        this._glyphs = [];
        this._glyphs = kept;
        this.updateText();
        return len - kept.length;
    };
    Phaser.BitmapText.prototype.updateTransform = function() {
        if (this.dirty || !this.anchor.equals(this._prevAnchor)) {
            this.updateText();
            this.dirty = false;
            this._prevAnchor.copyFrom(this.anchor);
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    Object.defineProperty(Phaser.BitmapText.prototype, "align", {
        get: function() {
            return this._align;
        },
        set: function(value) {
            if (value !== this._align && (value === "left" || value === "center" || value === "right")) {
                this._align = value;
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint;
        },
        set: function(value) {
            if (value !== this._tint) {
                this._tint = value;
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(value) {
            if (value !== this._font) {
                this._font = value.trim();
                this._data = this.game.cache.getBitmapFont(this._font);
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(value) {
            value = parseInt(value, 10);
            if (value !== this._fontSize && value > 0) {
                this._fontSize = value;
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || "";
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "maxWidth", {
        get: function() {
            return this._maxWidth;
        },
        set: function(value) {
            if (value !== this._maxWidth) {
                this._maxWidth = value;
                this.updateText();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "smoothed", {
        get: function() {
            return !this._data.base.scaleMode;
        },
        set: function(value) {
            if (value) {
                this._data.base.scaleMode = 0;
            } else {
                this._data.base.scaleMode = 1;
            }
        }
    });
    Phaser.RetroFont = function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
        if (!game.cache.checkImageKey(key)) {
            return false;
        }
        if (charsPerRow === undefined || charsPerRow === null) {
            charsPerRow = game.cache.getImage(key).width / characterWidth;
        }
        this.characterWidth = characterWidth;
        this.characterHeight = characterHeight;
        this.characterSpacingX = xSpacing || 0;
        this.characterSpacingY = ySpacing || 0;
        this.characterPerRow = charsPerRow;
        this.offsetX = xOffset || 0;
        this.offsetY = yOffset || 0;
        this.align = "left";
        this.multiLine = false;
        this.autoUpperCase = true;
        this.customSpacingX = 0;
        this.customSpacingY = 0;
        this.fixedWidth = 0;
        this.fontSet = game.cache.getImage(key);
        this._text = "";
        this.grabData = [];
        this.frameData = new Phaser.FrameData();
        var currentX = this.offsetX;
        var currentY = this.offsetY;
        var r = 0;
        for (var c = 0; c < chars.length; c++) {
            var frame = this.frameData.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight));
            this.grabData[chars.charCodeAt(c)] = frame.index;
            r++;
            if (r === this.characterPerRow) {
                r = 0;
                currentX = this.offsetX;
                currentY += this.characterHeight + this.characterSpacingY;
            } else {
                currentX += this.characterWidth + this.characterSpacingX;
            }
        }
        game.cache.updateFrameData(key, this.frameData);
        this.stamp = new Phaser.Image(game, 0, 0, key, 0);
        Phaser.RenderTexture.call(this, game, 100, 100, "", Phaser.scaleModes.NEAREST);
        this.type = Phaser.RETROFONT;
    };
    Phaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype);
    Phaser.RetroFont.prototype.constructor = Phaser.RetroFont;
    Phaser.RetroFont.ALIGN_LEFT = "left";
    Phaser.RetroFont.ALIGN_RIGHT = "right";
    Phaser.RetroFont.ALIGN_CENTER = "center";
    Phaser.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    Phaser.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    Phaser.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    Phaser.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    Phaser.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    Phaser.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    Phaser.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    Phaser.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    Phaser.RetroFont.prototype.setFixedWidth = function(width, lineAlignment) {
        if (lineAlignment === undefined) {
            lineAlignment = "left";
        }
        this.fixedWidth = width;
        this.align = lineAlignment;
    };
    Phaser.RetroFont.prototype.setText = function(content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
        this.multiLine = multiLine || false;
        this.customSpacingX = characterSpacing || 0;
        this.customSpacingY = lineSpacing || 0;
        this.align = lineAlignment || "left";
        if (allowLowerCase) {
            this.autoUpperCase = false;
        } else {
            this.autoUpperCase = true;
        }
        if (content.length > 0) {
            this.text = content;
        }
    };
    Phaser.RetroFont.prototype.buildRetroFontText = function() {
        var cx = 0;
        var cy = 0;
        this.clear();
        if (this.multiLine) {
            var lines = this._text.split("\n");
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            } else {
                this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            }
            for (var i = 0; i < lines.length; i++) {
                cx = 0;
                if (this.align === Phaser.RetroFont.ALIGN_RIGHT) {
                    cx = this.width - lines[i].length * (this.characterWidth + this.customSpacingX);
                } else if (this.align === Phaser.RetroFont.ALIGN_CENTER) {
                    cx = this.width / 2 - lines[i].length * (this.characterWidth + this.customSpacingX) / 2;
                    cx += this.customSpacingX / 2;
                }
                if (cx < 0) {
                    cx = 0;
                }
                this.pasteLine(lines[i], cx, cy, this.customSpacingX);
                cy += this.characterHeight + this.customSpacingY;
            }
        } else {
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, this.characterHeight, true);
            } else {
                this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true);
            }
            cx = 0;
            if (this.align === Phaser.RetroFont.ALIGN_RIGHT) {
                cx = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
            } else if (this.align === Phaser.RetroFont.ALIGN_CENTER) {
                cx = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
                cx += this.customSpacingX / 2;
            }
            if (cx < 0) {
                cx = 0;
            }
            this.pasteLine(this._text, cx, 0, this.customSpacingX);
        }
        this.requiresReTint = true;
    };
    Phaser.RetroFont.prototype.pasteLine = function(line, x, y, customSpacingX) {
        for (var c = 0; c < line.length; c++) {
            if (line.charAt(c) === " ") {
                x += this.characterWidth + customSpacingX;
            } else {
                if (this.grabData[line.charCodeAt(c)] >= 0) {
                    this.stamp.frame = this.grabData[line.charCodeAt(c)];
                    this.renderXY(this.stamp, x, y, false);
                    x += this.characterWidth + customSpacingX;
                    if (x > this.width) {
                        break;
                    }
                }
            }
        }
    };
    Phaser.RetroFont.prototype.getLongestLine = function() {
        var longestLine = 0;
        if (this._text.length > 0) {
            var lines = this._text.split("\n");
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].length > longestLine) {
                    longestLine = lines[i].length;
                }
            }
        }
        return longestLine;
    };
    Phaser.RetroFont.prototype.removeUnsupportedCharacters = function(stripCR) {
        var newString = "";
        for (var c = 0; c < this._text.length; c++) {
            var aChar = this._text[c];
            var code = aChar.charCodeAt(0);
            if (this.grabData[code] >= 0 || !stripCR && aChar === "\n") {
                newString = newString.concat(aChar);
            }
        }
        return newString;
    };
    Phaser.RetroFont.prototype.updateOffset = function(x, y) {
        if (this.offsetX === x && this.offsetY === y) {
            return;
        }
        var diffX = x - this.offsetX;
        var diffY = y - this.offsetY;
        var frames = this.game.cache.getFrameData(this.stamp.key).getFrames();
        var i = frames.length;
        while (i--) {
            frames[i].x += diffX;
            frames[i].y += diffY;
        }
        this.buildRetroFontText();
    };
    Object.defineProperty(Phaser.RetroFont.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            var newText;
            if (this.autoUpperCase) {
                newText = value.toUpperCase();
            } else {
                newText = value;
            }
            if (newText !== this._text) {
                this._text = newText;
                this.removeUnsupportedCharacters(this.multiLine);
                this.buildRetroFontText();
            }
        }
    });
    Object.defineProperty(Phaser.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed;
        },
        set: function(value) {
            this.stamp.smoothed = value;
            this.buildRetroFontText();
        }
    });
    Phaser.Rope = function(game, x, y, key, frame, points) {
        this.points = [];
        this.points = points;
        this._hasUpdateAnimation = false;
        this._updateAnimationCallback = null;
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.ROPE;
        this._scroll = new Phaser.Point();
        PIXI.Rope.call(this, PIXI.TextureCache["__default"], this.points);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype);
    Phaser.Rope.prototype.constructor = Phaser.Rope;
    Phaser.Component.Core.install.call(Phaser.Rope.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]);
    Phaser.Rope.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.Rope.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.Rope.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.Rope.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.Rope.prototype.preUpdate = function() {
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.Rope.prototype.update = function() {
        if (this._hasUpdateAnimation) {
            this.updateAnimation.call(this);
        }
    };
    Phaser.Rope.prototype.reset = function(x, y) {
        Phaser.Component.Reset.prototype.reset.call(this, x, y);
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        return this;
    };
    Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(value) {
            if (value && typeof value === "function") {
                this._hasUpdateAnimation = true;
                this._updateAnimation = value;
            } else {
                this._hasUpdateAnimation = false;
                this._updateAnimation = null;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "segments", {
        get: function() {
            var segments = [];
            var index, x1, y1, x2, y2, width, height, rect;
            for (var i = 0; i < this.points.length; i++) {
                index = i * 4;
                x1 = this.vertices[index] * this.scale.x;
                y1 = this.vertices[index + 1] * this.scale.y;
                x2 = this.vertices[index + 4] * this.scale.x;
                y2 = this.vertices[index + 3] * this.scale.y;
                width = Phaser.Math.difference(x1, x2);
                height = Phaser.Math.difference(y1, y2);
                x1 += this.world.x;
                y1 += this.world.y;
                rect = new Phaser.Rectangle(x1, y1, width, height);
                segments.push(rect);
            }
            return segments;
        }
    });
    Phaser.TileSprite = function(game, x, y, width, height, key, frame) {
        x = x || 0;
        y = y || 0;
        width = width || 256;
        height = height || 256;
        key = key || null;
        frame = frame || null;
        this.type = Phaser.TILESPRITE;
        this.physicsType = Phaser.SPRITE;
        this._scroll = new Phaser.Point();
        var def = game.cache.getImage("__default", true);
        PIXI.TilingSprite.call(this, new PIXI.Texture(def.base), width, height);
        Phaser.Component.Core.init.call(this, game, x, y, key, frame);
    };
    Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    Phaser.TileSprite.prototype.constructor = Phaser.TileSprite;
    Phaser.Component.Core.install.call(Phaser.TileSprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed" ]);
    Phaser.TileSprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate;
    Phaser.TileSprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate;
    Phaser.TileSprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate;
    Phaser.TileSprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.TileSprite.prototype.preUpdate = function() {
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) {
            return false;
        }
        return this.preUpdateCore();
    };
    Phaser.TileSprite.prototype.autoScroll = function(x, y) {
        this._scroll.set(x, y);
    };
    Phaser.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    };
    Phaser.TileSprite.prototype.destroy = function(destroyChildren) {
        Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren);
        PIXI.TilingSprite.prototype.destroy.call(this);
    };
    Phaser.TileSprite.prototype.reset = function(x, y) {
        Phaser.Component.Reset.prototype.reset.call(this, x, y);
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        return this;
    };
    Phaser.Device = function() {
        this.deviceReadyAt = 0;
        this.initialized = false;
        this.desktop = false;
        this.iOS = false;
        this.cocoonJS = false;
        this.cocoonJSApp = false;
        this.cordova = false;
        this.node = false;
        this.nodeWebkit = false;
        this.electron = false;
        this.ejecta = false;
        this.crosswalk = false;
        this.android = false;
        this.chromeOS = false;
        this.linux = false;
        this.macOS = false;
        this.windows = false;
        this.windowsPhone = false;
        this.canvas = false;
        this.canvasBitBltShift = null;
        this.webGL = false;
        this.file = false;
        this.fileSystem = false;
        this.localStorage = false;
        this.worker = false;
        this.css3D = false;
        this.pointerLock = false;
        this.typedArray = false;
        this.vibration = false;
        this.getUserMedia = true;
        this.quirksMode = false;
        this.touch = false;
        this.mspointer = false;
        this.wheelEvent = null;
        this.arora = false;
        this.chrome = false;
        this.chromeVersion = 0;
        this.epiphany = false;
        this.firefox = false;
        this.firefoxVersion = 0;
        this.ie = false;
        this.ieVersion = 0;
        this.trident = false;
        this.tridentVersion = 0;
        this.mobileSafari = false;
        this.midori = false;
        this.opera = false;
        this.safari = false;
        this.webApp = false;
        this.silk = false;
        this.audioData = false;
        this.webAudio = false;
        this.ogg = false;
        this.opus = false;
        this.mp3 = false;
        this.wav = false;
        this.m4a = false;
        this.webm = false;
        this.oggVideo = false;
        this.h264Video = false;
        this.mp4Video = false;
        this.webmVideo = false;
        this.vp9Video = false;
        this.hlsVideo = false;
        this.iPhone = false;
        this.iPhone4 = false;
        this.iPad = false;
        this.pixelRatio = 0;
        this.littleEndian = false;
        this.LITTLE_ENDIAN = false;
        this.support32bit = false;
        this.fullscreen = false;
        this.requestFullscreen = "";
        this.cancelFullscreen = "";
        this.fullscreenKeyboard = false;
    };
    Phaser.Device = new Phaser.Device();
    Phaser.Device.onInitialized = new Phaser.Signal();
    Phaser.Device.whenReady = function(callback, context, nonPrimer) {
        var readyCheck = this._readyCheck;
        if (this.deviceReadyAt || !readyCheck) {
            callback.call(context, this);
        } else if (readyCheck._monitor || nonPrimer) {
            readyCheck._queue = readyCheck._queue || [];
            readyCheck._queue.push([ callback, context ]);
        } else {
            readyCheck._monitor = readyCheck.bind(this);
            readyCheck._queue = readyCheck._queue || [];
            readyCheck._queue.push([ callback, context ]);
            var cordova = typeof window.cordova !== "undefined";
            var cocoonJS = navigator["isCocoonJS"];
            if (document.readyState === "complete" || document.readyState === "interactive") {
                window.setTimeout(readyCheck._monitor, 0);
            } else if (cordova && !cocoonJS) {
                document.addEventListener("deviceready", readyCheck._monitor, false);
            } else {
                document.addEventListener("DOMContentLoaded", readyCheck._monitor, false);
                window.addEventListener("load", readyCheck._monitor, false);
            }
        }
    };
    Phaser.Device._readyCheck = function() {
        var readyCheck = this._readyCheck;
        if (!document.body) {
            window.setTimeout(readyCheck._monitor, 20);
        } else if (!this.deviceReadyAt) {
            this.deviceReadyAt = Date.now();
            document.removeEventListener("deviceready", readyCheck._monitor);
            document.removeEventListener("DOMContentLoaded", readyCheck._monitor);
            window.removeEventListener("load", readyCheck._monitor);
            this._initialize();
            this.initialized = true;
            this.onInitialized.dispatch(this);
            var item;
            while (item = readyCheck._queue.shift()) {
                var callback = item[0];
                var context = item[1];
                callback.call(context, this);
            }
            this._readyCheck = null;
            this._initialize = null;
            this.onInitialized = null;
        }
    };
    Phaser.Device._initialize = function() {
        var device = this;
        function _checkOS() {
            var ua = navigator.userAgent;
            if (/Playstation Vita/.test(ua)) {
                device.vita = true;
            } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                device.kindle = true;
            } else if (/Android/.test(ua)) {
                device.android = true;
            } else if (/CrOS/.test(ua)) {
                device.chromeOS = true;
            } else if (/iP[ao]d|iPhone/i.test(ua)) {
                device.iOS = true;
            } else if (/Linux/.test(ua)) {
                device.linux = true;
            } else if (/Mac OS/.test(ua)) {
                device.macOS = true;
            } else if (/Windows/.test(ua)) {
                device.windows = true;
            }
            if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) {
                device.android = false;
                device.iOS = false;
                device.macOS = false;
                device.windows = true;
                device.windowsPhone = true;
            }
            var silk = /Silk/.test(ua);
            if (device.windows || device.macOS || device.linux && !silk || device.chromeOS) {
                device.desktop = true;
            }
            if (device.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
                device.desktop = false;
            }
        }
        function _checkFeatures() {
            device.canvas = !!window["CanvasRenderingContext2D"] || device.cocoonJS;
            try {
                device.localStorage = !!localStorage.getItem;
            } catch (error) {
                device.localStorage = false;
            }
            device.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
            device.fileSystem = !!window["requestFileSystem"];
            device.webGL = function() {
                try {
                    var canvas = document.createElement("canvas");
                    canvas.screencanvas = false;
                    return !!window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
                } catch (e) {
                    return false;
                }
            }();
            device.webGL = !!device.webGL;
            device.worker = !!window["Worker"];
            device.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            device.quirksMode = document.compatMode === "CSS1Compat" ? false : true;
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
            device.getUserMedia = device.getUserMedia && !!navigator.getUserMedia && !!window.URL;
            if (device.firefox && device.firefoxVersion < 21) {
                device.getUserMedia = false;
            }
            if (!device.iOS && (device.ie || device.firefox || device.chrome)) {
                device.canvasBitBltShift = true;
            }
            if (device.safari || device.mobileSafari) {
                device.canvasBitBltShift = false;
            }
        }
        function _checkInput() {
            if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) {
                device.touch = true;
            }
            if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) {
                device.mspointer = true;
            }
            if (!device.cocoonJS) {
                if ("onwheel" in window || device.ie && "WheelEvent" in window) {
                    device.wheelEvent = "wheel";
                } else if ("onmousewheel" in window) {
                    device.wheelEvent = "mousewheel";
                } else if (device.firefox && "MouseScrollEvent" in window) {
                    device.wheelEvent = "DOMMouseScroll";
                }
            }
        }
        function _checkFullScreenSupport() {
            var fs = [ "requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen" ];
            var element = document.createElement("div");
            for (var i = 0; i < fs.length; i++) {
                if (element[fs[i]]) {
                    device.fullscreen = true;
                    device.requestFullscreen = fs[i];
                    break;
                }
            }
            var cfs = [ "cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen" ];
            if (device.fullscreen) {
                for (var i = 0; i < cfs.length; i++) {
                    if (document[cfs[i]]) {
                        device.cancelFullscreen = cfs[i];
                        break;
                    }
                }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"]) {
                device.fullscreenKeyboard = true;
            }
        }
        function _checkBrowser() {
            var ua = navigator.userAgent;
            if (/Arora/.test(ua)) {
                device.arora = true;
            } else if (/Chrome\/(\d+)/.test(ua) && !device.windowsPhone) {
                device.chrome = true;
                device.chromeVersion = parseInt(RegExp.$1, 10);
            } else if (/Epiphany/.test(ua)) {
                device.epiphany = true;
            } else if (/Firefox\D+(\d+)/.test(ua)) {
                device.firefox = true;
                device.firefoxVersion = parseInt(RegExp.$1, 10);
            } else if (/AppleWebKit/.test(ua) && device.iOS) {
                device.mobileSafari = true;
            } else if (/MSIE (\d+\.\d+);/.test(ua)) {
                device.ie = true;
                device.ieVersion = parseInt(RegExp.$1, 10);
            } else if (/Midori/.test(ua)) {
                device.midori = true;
            } else if (/Opera/.test(ua)) {
                device.opera = true;
            } else if (/Safari/.test(ua) && !device.windowsPhone) {
                device.safari = true;
            } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
                device.ie = true;
                device.trident = true;
                device.tridentVersion = parseInt(RegExp.$1, 10);
                device.ieVersion = parseInt(RegExp.$3, 10);
            }
            if (/Silk/.test(ua)) {
                device.silk = true;
            }
            if (navigator["standalone"]) {
                device.webApp = true;
            }
            if (typeof window.cordova !== "undefined") {
                device.cordova = true;
            }
            if (typeof process !== "undefined" && typeof require !== "undefined") {
                device.node = true;
            }
            if (device.node && typeof process.versions === "object") {
                device.nodeWebkit = !!process.versions["node-webkit"];
                device.electron = !!process.versions.electron;
            }
            if (navigator["isCocoonJS"]) {
                device.cocoonJS = true;
            }
            if (device.cocoonJS) {
                try {
                    device.cocoonJSApp = typeof CocoonJS !== "undefined";
                } catch (error) {
                    device.cocoonJSApp = false;
                }
            }
            if (typeof window.ejecta !== "undefined") {
                device.ejecta = true;
            }
            if (/Crosswalk/.test(ua)) {
                device.crosswalk = true;
            }
        }
        function _checkVideo() {
            var videoElement = document.createElement("video");
            var result = false;
            try {
                if (result = !!videoElement.canPlayType) {
                    if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {
                        device.oggVideo = true;
                    }
                    if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                        device.h264Video = true;
                        device.mp4Video = true;
                    }
                    if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {
                        device.webmVideo = true;
                    }
                    if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {
                        device.vp9Video = true;
                    }
                    if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                        device.hlsVideo = true;
                    }
                }
            } catch (e) {}
        }
        function _checkAudio() {
            device.audioData = !!window["Audio"];
            device.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
            var audioElement = document.createElement("audio");
            var result = false;
            try {
                if (result = !!audioElement.canPlayType) {
                    if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                        device.ogg = true;
                    }
                    if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) {
                        device.opus = true;
                    }
                    if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                        device.mp3 = true;
                    }
                    if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")) {
                        device.wav = true;
                    }
                    if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                        device.m4a = true;
                    }
                    if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                        device.webm = true;
                    }
                }
            } catch (e) {}
        }
        function _checkDevice() {
            device.pixelRatio = window["devicePixelRatio"] || 1;
            device.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") != -1;
            device.iPhone4 = device.pixelRatio == 2 && device.iPhone;
            device.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") != -1;
            if (typeof Int8Array !== "undefined") {
                device.typedArray = true;
            } else {
                device.typedArray = false;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
                device.littleEndian = _checkIsLittleEndian();
                device.LITTLE_ENDIAN = device.littleEndian;
            }
            device.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && device.littleEndian !== null && _checkIsUint8ClampedImageData();
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
                device.vibration = true;
            }
        }
        function _checkIsLittleEndian() {
            var a = new ArrayBuffer(4);
            var b = new Uint8Array(a);
            var c = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            if (c[0] == 3569595041) {
                return true;
            }
            if (c[0] == 2712847316) {
                return false;
            } else {
                return null;
            }
        }
        function _checkIsUint8ClampedImageData() {
            if (Uint8ClampedArray === undefined) {
                return false;
            }
            var elem = PIXI.CanvasPool.create(this, 1, 1);
            var ctx = elem.getContext("2d");
            if (!ctx) {
                return false;
            }
            var image = ctx.createImageData(1, 1);
            PIXI.CanvasPool.remove(this);
            return image.data instanceof Uint8ClampedArray;
        }
        function _checkCSS3D() {
            var el = document.createElement("p");
            var has3d;
            var transforms = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(el, null);
            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }
            document.body.removeChild(el);
            device.css3D = has3d !== undefined && has3d.length > 0 && has3d !== "none";
        }
        _checkOS();
        _checkAudio();
        _checkVideo();
        _checkBrowser();
        _checkCSS3D();
        _checkDevice();
        _checkFeatures();
        _checkFullScreenSupport();
        _checkInput();
    };
    Phaser.Device.canPlayAudio = function(type) {
        if (type === "mp3" && this.mp3) {
            return true;
        } else if (type === "ogg" && (this.ogg || this.opus)) {
            return true;
        } else if (type === "m4a" && this.m4a) {
            return true;
        } else if (type === "opus" && this.opus) {
            return true;
        } else if (type === "wav" && this.wav) {
            return true;
        } else if (type === "webm" && this.webm) {
            return true;
        }
        return false;
    };
    Phaser.Device.canPlayVideo = function(type) {
        if (type === "webm" && (this.webmVideo || this.vp9Video)) {
            return true;
        } else if (type === "mp4" && (this.mp4Video || this.h264Video)) {
            return true;
        } else if ((type === "ogg" || type === "ogv") && this.oggVideo) {
            return true;
        } else if (type === "mpeg" && this.hlsVideo) {
            return true;
        }
        return false;
    };
    Phaser.Device.isConsoleOpen = function() {
        if (window.console && window.console["firebug"]) {
            return true;
        }
        if (window.console) {
            console.profile();
            console.profileEnd();
            if (console.clear) {
                console.clear();
            }
            if (console["profiles"]) {
                return console["profiles"].length > 0;
            }
        }
        return false;
    };
    Phaser.Device.isAndroidStockBrowser = function() {
        var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return matches && matches[1] < 537;
    };
    Phaser.DOM = {
        getOffset: function(element, point) {
            point = point || new Phaser.Point();
            var box = element.getBoundingClientRect();
            var scrollTop = Phaser.DOM.scrollY;
            var scrollLeft = Phaser.DOM.scrollX;
            var clientTop = document.documentElement.clientTop;
            var clientLeft = document.documentElement.clientLeft;
            point.x = box.left + scrollLeft - clientLeft;
            point.y = box.top + scrollTop - clientTop;
            return point;
        },
        getBounds: function(element, cushion) {
            if (cushion === undefined) {
                cushion = 0;
            }
            element = element && !element.nodeType ? element[0] : element;
            if (!element || element.nodeType !== 1) {
                return false;
            } else {
                return this.calibrate(element.getBoundingClientRect(), cushion);
            }
        },
        calibrate: function(coords, cushion) {
            cushion = +cushion || 0;
            var output = {
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            output.width = (output.right = coords.right + cushion) - (output.left = coords.left - cushion);
            output.height = (output.bottom = coords.bottom + cushion) - (output.top = coords.top - cushion);
            return output;
        },
        getAspectRatio: function(object) {
            object = null == object ? this.visualBounds : 1 === object.nodeType ? this.getBounds(object) : object;
            var w = object["width"];
            var h = object["height"];
            if (typeof w === "function") {
                w = w.call(object);
            }
            if (typeof h === "function") {
                h = h.call(object);
            }
            return w / h;
        },
        inLayoutViewport: function(element, cushion) {
            var r = this.getBounds(element, cushion);
            return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= this.layoutBounds.width && r.left <= this.layoutBounds.height;
        },
        getScreenOrientation: function(primaryFallback) {
            var screen = window.screen;
            var orientation = screen.orientation || screen.mozOrientation || screen.msOrientation;
            if (orientation && typeof orientation.type === "string") {
                return orientation.type;
            } else if (typeof orientation === "string") {
                return orientation;
            }
            var PORTRAIT = "portrait-primary";
            var LANDSCAPE = "landscape-primary";
            if (primaryFallback === "screen") {
                return screen.height > screen.width ? PORTRAIT : LANDSCAPE;
            } else if (primaryFallback === "viewport") {
                return this.visualBounds.height > this.visualBounds.width ? PORTRAIT : LANDSCAPE;
            } else if (primaryFallback === "window.orientation" && typeof window.orientation === "number") {
                return window.orientation === 0 || window.orientation === 180 ? PORTRAIT : LANDSCAPE;
            } else if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) {
                    return PORTRAIT;
                } else if (window.matchMedia("(orientation: landscape)").matches) {
                    return LANDSCAPE;
                }
            }
            return this.visualBounds.height > this.visualBounds.width ? PORTRAIT : LANDSCAPE;
        },
        visualBounds: new Phaser.Rectangle(),
        layoutBounds: new Phaser.Rectangle(),
        documentBounds: new Phaser.Rectangle()
    };
    Phaser.Device.whenReady(function(device) {
        var scrollX = window && "pageXOffset" in window ? function() {
            return window.pageXOffset;
        } : function() {
            return document.documentElement.scrollLeft;
        };
        var scrollY = window && "pageYOffset" in window ? function() {
            return window.pageYOffset;
        } : function() {
            return document.documentElement.scrollTop;
        };
        Object.defineProperty(Phaser.DOM, "scrollX", {
            get: scrollX
        });
        Object.defineProperty(Phaser.DOM, "scrollY", {
            get: scrollY
        });
        Object.defineProperty(Phaser.DOM.visualBounds, "x", {
            get: scrollX
        });
        Object.defineProperty(Phaser.DOM.visualBounds, "y", {
            get: scrollY
        });
        Object.defineProperty(Phaser.DOM.layoutBounds, "x", {
            value: 0
        });
        Object.defineProperty(Phaser.DOM.layoutBounds, "y", {
            value: 0
        });
        var treatAsDesktop = device.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
        if (treatAsDesktop) {
            var clientWidth = function() {
                return Math.max(window.innerWidth, document.documentElement.clientWidth);
            };
            var clientHeight = function() {
                return Math.max(window.innerHeight, document.documentElement.clientHeight);
            };
            Object.defineProperty(Phaser.DOM.visualBounds, "width", {
                get: clientWidth
            });
            Object.defineProperty(Phaser.DOM.visualBounds, "height", {
                get: clientHeight
            });
            Object.defineProperty(Phaser.DOM.layoutBounds, "width", {
                get: clientWidth
            });
            Object.defineProperty(Phaser.DOM.layoutBounds, "height", {
                get: clientHeight
            });
        } else {
            Object.defineProperty(Phaser.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth;
                }
            });
            Object.defineProperty(Phaser.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight;
                }
            });
            Object.defineProperty(Phaser.DOM.layoutBounds, "width", {
                get: function() {
                    var a = document.documentElement.clientWidth;
                    var b = window.innerWidth;
                    return a < b ? b : a;
                }
            });
            Object.defineProperty(Phaser.DOM.layoutBounds, "height", {
                get: function() {
                    var a = document.documentElement.clientHeight;
                    var b = window.innerHeight;
                    return a < b ? b : a;
                }
            });
        }
        Object.defineProperty(Phaser.DOM.documentBounds, "x", {
            value: 0
        });
        Object.defineProperty(Phaser.DOM.documentBounds, "y", {
            value: 0
        });
        Object.defineProperty(Phaser.DOM.documentBounds, "width", {
            get: function() {
                var d = document.documentElement;
                return Math.max(d.clientWidth, d.offsetWidth, d.scrollWidth);
            }
        });
        Object.defineProperty(Phaser.DOM.documentBounds, "height", {
            get: function() {
                var d = document.documentElement;
                return Math.max(d.clientHeight, d.offsetHeight, d.scrollHeight);
            }
        });
    }, null, true);
    Phaser.Canvas = {
        create: function(parent, width, height, id, skipPool) {
            width = width || 256;
            height = height || 256;
            if (skipPool === undefined) {
                var canvas = PIXI.CanvasPool.create(parent, width, height);
            } else {
                var canvas = document.createElement("canvas");
            }
            if (typeof id === "string" && id !== "") {
                canvas.id = id;
            }
            canvas.width = width;
            canvas.height = height;
            canvas.style.display = "block";
            return canvas;
        },
        setBackgroundColor: function(canvas, color) {
            color = color || "rgb(0,0,0)";
            canvas.style.backgroundColor = color;
            return canvas;
        },
        setTouchAction: function(canvas, value) {
            value = value || "none";
            canvas.style.msTouchAction = value;
            canvas.style["ms-touch-action"] = value;
            canvas.style["touch-action"] = value;
            return canvas;
        },
        setUserSelect: function(canvas, value) {
            value = value || "none";
            canvas.style["-webkit-touch-callout"] = value;
            canvas.style["-webkit-user-select"] = value;
            canvas.style["-khtml-user-select"] = value;
            canvas.style["-moz-user-select"] = value;
            canvas.style["-ms-user-select"] = value;
            canvas.style["user-select"] = value;
            canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return canvas;
        },
        addToDOM: function(canvas, parent, overflowHidden) {
            var target;
            if (overflowHidden === undefined) {
                overflowHidden = true;
            }
            if (parent) {
                if (typeof parent === "string") {
                    target = document.getElementById(parent);
                } else if (typeof parent === "object" && parent.nodeType === 1) {
                    target = parent;
                }
            }
            if (!target) {
                target = document.body;
            }
            if (overflowHidden && target.style) {
                target.style.overflow = "hidden";
            }
            target.appendChild(canvas);
            return canvas;
        },
        removeFromDOM: function(canvas) {
            if (canvas.parentNode) {
                canvas.parentNode.removeChild(canvas);
            }
        },
        setTransform: function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
            context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY);
            return context;
        },
        setSmoothingEnabled: function(context, value) {
            var vendor = [ "i", "mozI", "oI", "webkitI", "msI" ];
            for (var prefix in vendor) {
                var s = vendor[prefix] + "mageSmoothingEnabled";
                if (s in context) {
                    context[s] = value;
                    return context;
                }
            }
            return context;
        },
        getSmoothingEnabled: function(context) {
            return context["imageSmoothingEnabled"] || context["mozImageSmoothingEnabled"] || context["oImageSmoothingEnabled"] || context["webkitImageSmoothingEnabled"] || context["msImageSmoothingEnabled"];
        },
        setImageRenderingCrisp: function(canvas) {
            canvas.style["image-rendering"] = "optimizeSpeed";
            canvas.style["image-rendering"] = "crisp-edges";
            canvas.style["image-rendering"] = "-moz-crisp-edges";
            canvas.style["image-rendering"] = "-webkit-optimize-contrast";
            canvas.style["image-rendering"] = "optimize-contrast";
            canvas.style["image-rendering"] = "pixelated";
            canvas.style.msInterpolationMode = "nearest-neighbor";
            return canvas;
        },
        setImageRenderingBicubic: function(canvas) {
            canvas.style["image-rendering"] = "auto";
            canvas.style.msInterpolationMode = "bicubic";
            return canvas;
        }
    };
    Phaser.RequestAnimationFrame = function(game, forceSetTimeOut) {
        if (forceSetTimeOut === undefined) {
            forceSetTimeOut = false;
        }
        this.game = game;
        this.isRunning = false;
        this.forceSetTimeOut = forceSetTimeOut;
        var vendors = [ "ms", "moz", "webkit", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
        }
        this._isSetTimeOut = false;
        this._onLoop = null;
        this._timeOutID = null;
    };
    Phaser.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = true;
            var _this = this;
            if (!window.requestAnimationFrame || this.forceSetTimeOut) {
                this._isSetTimeOut = true;
                this._onLoop = function() {
                    return _this.updateSetTimeout();
                };
                this._timeOutID = window.setTimeout(this._onLoop, 0);
            } else {
                this._isSetTimeOut = false;
                this._onLoop = function(time) {
                    return _this.updateRAF(time);
                };
                this._timeOutID = window.requestAnimationFrame(this._onLoop);
            }
        },
        updateRAF: function(rafTime) {
            this.game.update(Math.floor(rafTime));
            this._timeOutID = window.requestAnimationFrame(this._onLoop);
        },
        updateSetTimeout: function() {
            this.game.update(Date.now());
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
        },
        stop: function() {
            if (this._isSetTimeOut) {
                clearTimeout(this._timeOutID);
            } else {
                window.cancelAnimationFrame(this._timeOutID);
            }
            this.isRunning = false;
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut;
        },
        isRAF: function() {
            return this._isSetTimeOut === false;
        }
    };
    Phaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame;
    Phaser.Math = {
        PI2: Math.PI * 2,
        fuzzyEqual: function(a, b, epsilon) {
            if (epsilon === undefined) {
                epsilon = 1e-4;
            }
            return Math.abs(a - b) < epsilon;
        },
        fuzzyLessThan: function(a, b, epsilon) {
            if (epsilon === undefined) {
                epsilon = 1e-4;
            }
            return a < b + epsilon;
        },
        fuzzyGreaterThan: function(a, b, epsilon) {
            if (epsilon === undefined) {
                epsilon = 1e-4;
            }
            return a > b - epsilon;
        },
        fuzzyCeil: function(val, epsilon) {
            if (epsilon === undefined) {
                epsilon = 1e-4;
            }
            return Math.ceil(val - epsilon);
        },
        fuzzyFloor: function(val, epsilon) {
            if (epsilon === undefined) {
                epsilon = 1e-4;
            }
            return Math.floor(val + epsilon);
        },
        average: function() {
            var sum = 0;
            for (var i = 0; i < arguments.length; i++) {
                sum += +arguments[i];
            }
            return sum / arguments.length;
        },
        shear: function(n) {
            return n % 1;
        },
        snapTo: function(input, gap, start) {
            if (start === undefined) {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.round(input / gap);
            return start + input;
        },
        snapToFloor: function(input, gap, start) {
            if (start === undefined) {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.floor(input / gap);
            return start + input;
        },
        snapToCeil: function(input, gap, start) {
            if (start === undefined) {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.ceil(input / gap);
            return start + input;
        },
        roundTo: function(value, place, base) {
            if (place === undefined) {
                place = 0;
            }
            if (base === undefined) {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.round(value * p) / p;
        },
        floorTo: function(value, place, base) {
            if (place === undefined) {
                place = 0;
            }
            if (base === undefined) {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.floor(value * p) / p;
        },
        ceilTo: function(value, place, base) {
            if (place === undefined) {
                place = 0;
            }
            if (base === undefined) {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.ceil(value * p) / p;
        },
        angleBetween: function(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        },
        angleBetweenY: function(x1, y1, x2, y2) {
            return Math.atan2(x2 - x1, y2 - y1);
        },
        angleBetweenPoints: function(point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
        },
        angleBetweenPointsY: function(point1, point2) {
            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
        },
        reverseAngle: function(angleRad) {
            return this.normalizeAngle(angleRad + Math.PI, true);
        },
        normalizeAngle: function(angleRad) {
            angleRad = angleRad % (2 * Math.PI);
            return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;
        },
        maxAdd: function(value, amount, max) {
            return Math.min(value + amount, max);
        },
        minSub: function(value, amount, min) {
            return Math.max(value - amount, min);
        },
        wrap: function(value, min, max) {
            var range = max - min;
            if (range <= 0) {
                return 0;
            }
            var result = (value - min) % range;
            if (result < 0) {
                result += range;
            }
            return result + min;
        },
        wrapValue: function(value, amount, max) {
            var diff;
            value = Math.abs(value);
            amount = Math.abs(amount);
            max = Math.abs(max);
            diff = (value + amount) % max;
            return diff;
        },
        isOdd: function(n) {
            return !!(n & 1);
        },
        isEven: function(n) {
            return !(n & 1);
        },
        min: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i] < data[min]) {
                    min = i;
                }
            }
            return data[min];
        },
        max: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i] > data[max]) {
                    max = i;
                }
            }
            return data[max];
        },
        minProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i][property] < data[min][property]) {
                    min = i;
                }
            }
            return data[min][property];
        },
        maxProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i][property] > data[max][property]) {
                    max = i;
                }
            }
            return data[max][property];
        },
        wrapAngle: function(angle, radians) {
            return radians ? this.wrap(angle, -Math.PI, Math.PI) : this.wrap(angle, -180, 180);
        },
        linearInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (k < 0) {
                return this.linear(v[0], v[1], f);
            }
            if (k > 1) {
                return this.linear(v[m], v[m - 1], m - f);
            }
            return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        bezierInterpolation: function(v, k) {
            var b = 0;
            var n = v.length - 1;
            for (var i = 0; i <= n; i++) {
                b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);
            }
            return b;
        },
        catmullRomInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor(f = m * (1 + k));
                }
                return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            } else {
                if (k < 0) {
                    return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        linear: function(p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        bernstein: function(n, i) {
            return this.factorial(n) / this.factorial(i) / this.factorial(n - i);
        },
        factorial: function(value) {
            if (value === 0) {
                return 1;
            }
            var res = value;
            while (--value) {
                res *= value;
            }
            return res;
        },
        catmullRom: function(p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * .5, v1 = (p3 - p1) * .5, t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
        difference: function(a, b) {
            return Math.abs(a - b);
        },
        roundAwayFromZero: function(value) {
            return value > 0 ? Math.ceil(value) : Math.floor(value);
        },
        sinCosGenerator: function(length, sinAmplitude, cosAmplitude, frequency) {
            if (sinAmplitude === undefined) {
                sinAmplitude = 1;
            }
            if (cosAmplitude === undefined) {
                cosAmplitude = 1;
            }
            if (frequency === undefined) {
                frequency = 1;
            }
            var sin = sinAmplitude;
            var cos = cosAmplitude;
            var frq = frequency * Math.PI / length;
            var cosTable = [];
            var sinTable = [];
            for (var c = 0; c < length; c++) {
                cos -= sin * frq;
                sin += cos * frq;
                cosTable[c] = cos;
                sinTable[c] = sin;
            }
            return {
                sin: sinTable,
                cos: cosTable,
                length: length
            };
        },
        distance: function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        },
        distanceSq: function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return dx * dx + dy * dy;
        },
        distancePow: function(x1, y1, x2, y2, pow) {
            if (pow === undefined) {
                pow = 2;
            }
            return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
        },
        clamp: function(x, a, b) {
            return x < a ? a : x > b ? b : x;
        },
        clampBottom: function(x, a) {
            return x < a ? a : x;
        },
        within: function(a, b, tolerance) {
            return Math.abs(a - b) <= tolerance;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        smoothstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        sign: function(x) {
            return x < 0 ? -1 : x > 0 ? 1 : 0;
        },
        percent: function(a, b, base) {
            if (base === undefined) {
                base = 0;
            }
            if (a > b || base > b) {
                return 1;
            } else if (a < base || base > a) {
                return 0;
            } else {
                return (a - base) / b;
            }
        }
    };
    var degreeToRadiansFactor = Math.PI / 180;
    var radianToDegreesFactor = 180 / Math.PI;
    Phaser.Math.degToRad = function degToRad(degrees) {
        return degrees * degreeToRadiansFactor;
    };
    Phaser.Math.radToDeg = function radToDeg(radians) {
        return radians * radianToDegreesFactor;
    };
    Phaser.RandomDataGenerator = function(seeds) {
        if (seeds === undefined) {
            seeds = [];
        }
        this.c = 1;
        this.s0 = 0;
        this.s1 = 0;
        this.s2 = 0;
        this.sow(seeds);
    };
    Phaser.RandomDataGenerator.prototype = {
        rnd: function() {
            var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;
            this.c = t | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = t - this.c;
            return this.s2;
        },
        sow: function(seeds) {
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            if (!seeds) {
                return;
            }
            for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
                var seed = seeds[i];
                this.s0 -= this.hash(seed);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(seed);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(seed);
                this.s2 += ~~(this.s2 < 0);
            }
        },
        hash: function(data) {
            var h, i, n;
            n = 4022871197;
            data = data.toString();
            for (i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                h = .02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 4294967296;
            }
            return (n >>> 0) * 2.3283064365386963e-10;
        },
        integer: function() {
            return this.rnd.apply(this) * 4294967296;
        },
        frac: function() {
            return this.rnd.apply(this) + (this.rnd.apply(this) * 2097152 | 0) * 1.1102230246251565e-16;
        },
        real: function() {
            return this.integer() + this.frac();
        },
        integerInRange: function(min, max) {
            return Math.floor(this.realInRange(0, max - min + 1) + min);
        },
        between: function(min, max) {
            return this.integerInRange(min, max);
        },
        realInRange: function(min, max) {
            return this.frac() * (max - min) + min;
        },
        normal: function() {
            return 1 - 2 * this.frac();
        },
        uuid: function() {
            var a = "";
            var b = "";
            for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}
            return b;
        },
        pick: function(ary) {
            return ary[this.integerInRange(0, ary.length - 1)];
        },
        weightedPick: function(ary) {
            return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1) + .5)];
        },
        timestamp: function(min, max) {
            return this.realInRange(min || 9466848e5, max || 1577862e6);
        },
        angle: function() {
            return this.integerInRange(-180, 180);
        }
    };
    Phaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator;
    Phaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.level = 0;
        this.bounds = {};
        this.objects = [];
        this.nodes = [];
        this._empty = [];
        this.reset(x, y, width, height, maxObjects, maxLevels, level);
    };
    Phaser.QuadTree.prototype = {
        reset: function(x, y, width, height, maxObjects, maxLevels, level) {
            this.maxObjects = maxObjects || 10;
            this.maxLevels = maxLevels || 4;
            this.level = level || 0;
            this.bounds = {
                x: Math.round(x),
                y: Math.round(y),
                width: width,
                height: height,
                subWidth: Math.floor(width / 2),
                subHeight: Math.floor(height / 2),
                right: Math.round(x) + Math.floor(width / 2),
                bottom: Math.round(y) + Math.floor(height / 2)
            };
            this.objects.length = 0;
            this.nodes.length = 0;
        },
        populate: function(group) {
            group.forEach(this.populateHandler, this, true);
        },
        populateHandler: function(sprite) {
            if (sprite.body && sprite.exists) {
                this.insert(sprite.body);
            }
        },
        split: function() {
            this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        },
        insert: function(body) {
            var i = 0;
            var index;
            if (this.nodes[0] != null) {
                index = this.getIndex(body);
                if (index !== -1) {
                    this.nodes[index].insert(body);
                    return;
                }
            }
            this.objects.push(body);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                if (this.nodes[0] == null) {
                    this.split();
                }
                while (i < this.objects.length) {
                    index = this.getIndex(this.objects[i]);
                    if (index !== -1) {
                        this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                    } else {
                        i++;
                    }
                }
            }
        },
        getIndex: function(rect) {
            var index = -1;
            if (rect.x < this.bounds.right && rect.right < this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 1;
                } else if (rect.y > this.bounds.bottom) {
                    index = 2;
                }
            } else if (rect.x > this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 0;
                } else if (rect.y > this.bounds.bottom) {
                    index = 3;
                }
            }
            return index;
        },
        retrieve: function(source) {
            if (source instanceof Phaser.Rectangle) {
                var returnObjects = this.objects;
                var index = this.getIndex(source);
            } else {
                if (!source.body) {
                    return this._empty;
                }
                var returnObjects = this.objects;
                var index = this.getIndex(source.body);
            }
            if (this.nodes[0]) {
                if (index !== -1) {
                    returnObjects = returnObjects.concat(this.nodes[index].retrieve(source));
                } else {
                    returnObjects = returnObjects.concat(this.nodes[0].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[1].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[2].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[3].retrieve(source));
                }
            }
            return returnObjects;
        },
        clear: function() {
            this.objects.length = 0;
            var i = this.nodes.length;
            while (i--) {
                this.nodes[i].clear();
                this.nodes.splice(i, 1);
            }
            this.nodes.length = 0;
        }
    };
    Phaser.QuadTree.prototype.constructor = Phaser.QuadTree;
    Phaser.Net = function(game) {
        this.game = game;
    };
    Phaser.Net.prototype = {
        getHostName: function() {
            if (window.location && window.location.hostname) {
                return window.location.hostname;
            }
            return null;
        },
        checkDomainName: function(domain) {
            return window.location.hostname.indexOf(domain) !== -1;
        },
        updateQueryString: function(key, value, redirect, url) {
            if (redirect === undefined) {
                redirect = false;
            }
            if (url === undefined || url === "") {
                url = window.location.href;
            }
            var output = "";
            var re = new RegExp("([?|&])" + key + "=.*?(&|#|$)(.*)", "gi");
            if (re.test(url)) {
                if (typeof value !== "undefined" && value !== null) {
                    output = url.replace(re, "$1" + key + "=" + value + "$2$3");
                } else {
                    output = url.replace(re, "$1$3").replace(/(&|\?)$/, "");
                }
            } else {
                if (typeof value !== "undefined" && value !== null) {
                    var separator = url.indexOf("?") !== -1 ? "&" : "?";
                    var hash = url.split("#");
                    url = hash[0] + separator + key + "=" + value;
                    if (hash[1]) {
                        url += "#" + hash[1];
                    }
                    output = url;
                } else {
                    output = url;
                }
            }
            if (redirect) {
                window.location.href = output;
            } else {
                return output;
            }
        },
        getQueryString: function(parameter) {
            if (parameter === undefined) {
                parameter = "";
            }
            var output = {};
            var keyValues = location.search.substring(1).split("&");
            for (var i in keyValues) {
                var key = keyValues[i].split("=");
                if (key.length > 1) {
                    if (parameter && parameter == this.decodeURI(key[0])) {
                        return this.decodeURI(key[1]);
                    } else {
                        output[this.decodeURI(key[0])] = this.decodeURI(key[1]);
                    }
                }
            }
            return output;
        },
        decodeURI: function(value) {
            return decodeURIComponent(value.replace(/\+/g, " "));
        }
    };
    Phaser.Net.prototype.constructor = Phaser.Net;
    Phaser.TweenManager = function(game) {
        this.game = game;
        this.frameBased = false;
        this._tweens = [];
        this._add = [];
        this.easeMap = {
            Power0: Phaser.Easing.Power0,
            Power1: Phaser.Easing.Power1,
            Power2: Phaser.Easing.Power2,
            Power3: Phaser.Easing.Power3,
            Power4: Phaser.Easing.Power4,
            Linear: Phaser.Easing.Linear.None,
            Quad: Phaser.Easing.Quadratic.Out,
            Cubic: Phaser.Easing.Cubic.Out,
            Quart: Phaser.Easing.Quartic.Out,
            Quint: Phaser.Easing.Quintic.Out,
            Sine: Phaser.Easing.Sinusoidal.Out,
            Expo: Phaser.Easing.Exponential.Out,
            Circ: Phaser.Easing.Circular.Out,
            Elastic: Phaser.Easing.Elastic.Out,
            Back: Phaser.Easing.Back.Out,
            Bounce: Phaser.Easing.Bounce.Out,
            "Quad.easeIn": Phaser.Easing.Quadratic.In,
            "Cubic.easeIn": Phaser.Easing.Cubic.In,
            "Quart.easeIn": Phaser.Easing.Quartic.In,
            "Quint.easeIn": Phaser.Easing.Quintic.In,
            "Sine.easeIn": Phaser.Easing.Sinusoidal.In,
            "Expo.easeIn": Phaser.Easing.Exponential.In,
            "Circ.easeIn": Phaser.Easing.Circular.In,
            "Elastic.easeIn": Phaser.Easing.Elastic.In,
            "Back.easeIn": Phaser.Easing.Back.In,
            "Bounce.easeIn": Phaser.Easing.Bounce.In,
            "Quad.easeOut": Phaser.Easing.Quadratic.Out,
            "Cubic.easeOut": Phaser.Easing.Cubic.Out,
            "Quart.easeOut": Phaser.Easing.Quartic.Out,
            "Quint.easeOut": Phaser.Easing.Quintic.Out,
            "Sine.easeOut": Phaser.Easing.Sinusoidal.Out,
            "Expo.easeOut": Phaser.Easing.Exponential.Out,
            "Circ.easeOut": Phaser.Easing.Circular.Out,
            "Elastic.easeOut": Phaser.Easing.Elastic.Out,
            "Back.easeOut": Phaser.Easing.Back.Out,
            "Bounce.easeOut": Phaser.Easing.Bounce.Out,
            "Quad.easeInOut": Phaser.Easing.Quadratic.InOut,
            "Cubic.easeInOut": Phaser.Easing.Cubic.InOut,
            "Quart.easeInOut": Phaser.Easing.Quartic.InOut,
            "Quint.easeInOut": Phaser.Easing.Quintic.InOut,
            "Sine.easeInOut": Phaser.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": Phaser.Easing.Exponential.InOut,
            "Circ.easeInOut": Phaser.Easing.Circular.InOut,
            "Elastic.easeInOut": Phaser.Easing.Elastic.InOut,
            "Back.easeInOut": Phaser.Easing.Back.InOut,
            "Bounce.easeInOut": Phaser.Easing.Bounce.InOut
        };
        this.game.onPause.add(this._pauseAll, this);
        this.game.onResume.add(this._resumeAll, this);
    };
    Phaser.TweenManager.prototype = {
        getAll: function() {
            return this._tweens;
        },
        removeAll: function() {
            for (var i = 0; i < this._tweens.length; i++) {
                this._tweens[i].pendingDelete = true;
            }
            this._add = [];
        },
        removeFrom: function(obj, children) {
            if (children === undefined) {
                children = true;
            }
            var i;
            var len;
            if (Array.isArray(obj)) {
                for (i = 0, len = obj.length; i < len; i++) {
                    this.removeFrom(obj[i]);
                }
            } else if (obj.type === Phaser.GROUP && children) {
                for (var i = 0, len = obj.children.length; i < len; i++) {
                    this.removeFrom(obj.children[i]);
                }
            } else {
                for (i = 0, len = this._tweens.length; i < len; i++) {
                    if (obj === this._tweens[i].target) {
                        this.remove(this._tweens[i]);
                    }
                }
                for (i = 0, len = this._add.length; i < len; i++) {
                    if (obj === this._add[i].target) {
                        this.remove(this._add[i]);
                    }
                }
            }
        },
        add: function(tween) {
            tween._manager = this;
            this._add.push(tween);
        },
        create: function(object) {
            return new Phaser.Tween(object, this.game, this);
        },
        remove: function(tween) {
            var i = this._tweens.indexOf(tween);
            if (i !== -1) {
                this._tweens[i].pendingDelete = true;
            } else {
                i = this._add.indexOf(tween);
                if (i !== -1) {
                    this._add[i].pendingDelete = true;
                }
            }
        },
        update: function() {
            var addTweens = this._add.length;
            var numTweens = this._tweens.length;
            if (numTweens === 0 && addTweens === 0) {
                return false;
            }
            var i = 0;
            while (i < numTweens) {
                if (this._tweens[i].update(this.game.time.time)) {
                    i++;
                } else {
                    this._tweens.splice(i, 1);
                    numTweens--;
                }
            }
            if (addTweens > 0) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0;
            }
            return true;
        },
        isTweening: function(object) {
            return this._tweens.some(function(tween) {
                return tween.target === object;
            });
        },
        _pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._pause();
            }
        },
        _resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._resume();
            }
        },
        pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].pause();
            }
        },
        resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].resume(true);
            }
        }
    };
    Phaser.TweenManager.prototype.constructor = Phaser.TweenManager;
    Phaser.Tween = function(target, game, manager) {
        this.game = game;
        this.target = target;
        this.manager = manager;
        this.timeline = [];
        this.reverse = false;
        this.timeScale = 1;
        this.repeatCounter = 0;
        this.pendingDelete = false;
        this.onStart = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onRepeat = new Phaser.Signal();
        this.onChildComplete = new Phaser.Signal();
        this.onComplete = new Phaser.Signal();
        this.isRunning = false;
        this.current = 0;
        this.properties = {};
        this.chainedTween = null;
        this.isPaused = false;
        this.frameBased = manager.frameBased;
        this._onUpdateCallback = null;
        this._onUpdateCallbackContext = null;
        this._pausedTime = 0;
        this._codePaused = false;
        this._hasStarted = false;
    };
    Phaser.Tween.prototype = {
        to: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            if (duration === undefined || duration <= 0) {
                duration = 1e3;
            }
            if (ease === undefined || ease === null) {
                ease = Phaser.Easing.Default;
            }
            if (autoStart === undefined) {
                autoStart = false;
            }
            if (delay === undefined) {
                delay = 0;
            }
            if (repeat === undefined) {
                repeat = 0;
            }
            if (yoyo === undefined) {
                yoyo = false;
            }
            if (typeof ease === "string" && this.manager.easeMap[ease]) {
                ease = this.manager.easeMap[ease];
            }
            if (this.isRunning) {
                console.warn("Phaser.Tween.to cannot be called after Tween.start");
                return this;
            }
            this.timeline.push(new Phaser.TweenData(this).to(properties, duration, ease, delay, repeat, yoyo));
            if (autoStart) {
                this.start();
            }
            return this;
        },
        from: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            if (duration === undefined) {
                duration = 1e3;
            }
            if (ease === undefined || ease === null) {
                ease = Phaser.Easing.Default;
            }
            if (autoStart === undefined) {
                autoStart = false;
            }
            if (delay === undefined) {
                delay = 0;
            }
            if (repeat === undefined) {
                repeat = 0;
            }
            if (yoyo === undefined) {
                yoyo = false;
            }
            if (typeof ease === "string" && this.manager.easeMap[ease]) {
                ease = this.manager.easeMap[ease];
            }
            if (this.isRunning) {
                console.warn("Phaser.Tween.from cannot be called after Tween.start");
                return this;
            }
            this.timeline.push(new Phaser.TweenData(this).from(properties, duration, ease, delay, repeat, yoyo));
            if (autoStart) {
                this.start();
            }
            return this;
        },
        start: function(index) {
            if (index === undefined) {
                index = 0;
            }
            if (this.game === null || this.target === null || this.timeline.length === 0 || this.isRunning) {
                return this;
            }
            for (var i = 0; i < this.timeline.length; i++) {
                for (var property in this.timeline[i].vEnd) {
                    this.properties[property] = this.target[property] || 0;
                    if (!Array.isArray(this.properties[property])) {
                        this.properties[property] *= 1;
                    }
                }
            }
            for (var i = 0; i < this.timeline.length; i++) {
                this.timeline[i].loadValues();
            }
            this.manager.add(this);
            this.isRunning = true;
            if (index < 0 || index > this.timeline.length - 1) {
                index = 0;
            }
            this.current = index;
            this.timeline[this.current].start();
            return this;
        },
        stop: function(complete) {
            if (complete === undefined) {
                complete = false;
            }
            this.isRunning = false;
            this._onUpdateCallback = null;
            this._onUpdateCallbackContext = null;
            if (complete) {
                this.onComplete.dispatch(this.target, this);
                if (this.chainedTween) {
                    this.chainedTween.start();
                }
            }
            this.manager.remove(this);
            return this;
        },
        updateTweenData: function(property, value, index) {
            if (this.timeline.length === 0) {
                return this;
            }
            if (index === undefined) {
                index = 0;
            }
            if (index === -1) {
                for (var i = 0; i < this.timeline.length; i++) {
                    this.timeline[i][property] = value;
                }
            } else {
                this.timeline[index][property] = value;
            }
            return this;
        },
        delay: function(duration, index) {
            return this.updateTweenData("delay", duration, index);
        },
        repeat: function(total, repeatDelay, index) {
            if (repeatDelay === undefined) {
                repeatDelay = 0;
            }
            this.updateTweenData("repeatCounter", total, index);
            return this.updateTweenData("repeatDelay", repeatDelay, index);
        },
        repeatDelay: function(duration, index) {
            return this.updateTweenData("repeatDelay", duration, index);
        },
        yoyo: function(enable, yoyoDelay, index) {
            if (yoyoDelay === undefined) {
                yoyoDelay = 0;
            }
            this.updateTweenData("yoyo", enable, index);
            return this.updateTweenData("yoyoDelay", yoyoDelay, index);
        },
        yoyoDelay: function(duration, index) {
            return this.updateTweenData("yoyoDelay", duration, index);
        },
        easing: function(ease, index) {
            if (typeof ease === "string" && this.manager.easeMap[ease]) {
                ease = this.manager.easeMap[ease];
            }
            return this.updateTweenData("easingFunction", ease, index);
        },
        interpolation: function(interpolation, context, index) {
            if (context === undefined) {
                context = Phaser.Math;
            }
            this.updateTweenData("interpolationFunction", interpolation, index);
            return this.updateTweenData("interpolationContext", context, index);
        },
        repeatAll: function(total) {
            if (total === undefined) {
                total = 0;
            }
            this.repeatCounter = total;
            return this;
        },
        chain: function() {
            var i = arguments.length;
            while (i--) {
                if (i > 0) {
                    arguments[i - 1].chainedTween = arguments[i];
                } else {
                    this.chainedTween = arguments[i];
                }
            }
            return this;
        },
        loop: function(value) {
            if (value === undefined) {
                value = true;
            }
            if (value) {
                this.repeatAll(-1);
            } else {
                this.repeatCounter = 0;
            }
            return this;
        },
        onUpdateCallback: function(callback, callbackContext) {
            this._onUpdateCallback = callback;
            this._onUpdateCallbackContext = callbackContext;
            return this;
        },
        pause: function() {
            this.isPaused = true;
            this._codePaused = true;
            this._pausedTime = this.game.time.time;
        },
        _pause: function() {
            if (!this._codePaused) {
                this.isPaused = true;
                this._pausedTime = this.game.time.time;
            }
        },
        resume: function() {
            if (this.isPaused) {
                this.isPaused = false;
                this._codePaused = false;
                for (var i = 0; i < this.timeline.length; i++) {
                    if (!this.timeline[i].isRunning) {
                        this.timeline[i].startTime += this.game.time.time - this._pausedTime;
                    }
                }
            }
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this.resume();
            }
        },
        update: function(time) {
            if (this.pendingDelete) {
                return false;
            }
            if (this.isPaused) {
                return true;
            }
            var status = this.timeline[this.current].update(time);
            if (status === Phaser.TweenData.PENDING) {
                return true;
            } else if (status === Phaser.TweenData.RUNNING) {
                if (!this._hasStarted) {
                    this.onStart.dispatch(this.target, this);
                    this._hasStarted = true;
                }
                if (this._onUpdateCallback !== null) {
                    this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]);
                }
                return this.isRunning;
            } else if (status === Phaser.TweenData.LOOPED) {
                this.onLoop.dispatch(this.target, this);
                return true;
            } else if (status === Phaser.TweenData.COMPLETE) {
                var complete = false;
                if (this.reverse) {
                    this.current--;
                    if (this.current < 0) {
                        this.current = this.timeline.length - 1;
                        complete = true;
                    }
                } else {
                    this.current++;
                    if (this.current === this.timeline.length) {
                        this.current = 0;
                        complete = true;
                    }
                }
                if (complete) {
                    if (this.repeatCounter === -1) {
                        this.timeline[this.current].start();
                        this.onRepeat.dispatch(this.target, this);
                        return true;
                    } else if (this.repeatCounter > 0) {
                        this.repeatCounter--;
                        this.timeline[this.current].start();
                        this.onRepeat.dispatch(this.target, this);
                        return true;
                    } else {
                        this.isRunning = false;
                        this.onComplete.dispatch(this.target, this);
                        if (this.chainedTween) {
                            this.chainedTween.start();
                        }
                        return false;
                    }
                } else {
                    this.onChildComplete.dispatch(this.target, this);
                    this.timeline[this.current].start();
                    return true;
                }
            }
        },
        generateData: function(frameRate, data) {
            if (this.game === null || this.target === null) {
                return null;
            }
            if (frameRate === undefined) {
                frameRate = 60;
            }
            if (data === undefined) {
                data = [];
            }
            for (var i = 0; i < this.timeline.length; i++) {
                for (var property in this.timeline[i].vEnd) {
                    this.properties[property] = this.target[property] || 0;
                    if (!Array.isArray(this.properties[property])) {
                        this.properties[property] *= 1;
                    }
                }
            }
            for (var i = 0; i < this.timeline.length; i++) {
                this.timeline[i].loadValues();
            }
            for (var i = 0; i < this.timeline.length; i++) {
                data = data.concat(this.timeline[i].generateData(frameRate));
            }
            return data;
        }
    };
    Object.defineProperty(Phaser.Tween.prototype, "totalDuration", {
        get: function() {
            var total = 0;
            for (var i = 0; i < this.timeline.length; i++) {
                total += this.timeline[i].duration;
            }
            return total;
        }
    });
    Phaser.Tween.prototype.constructor = Phaser.Tween;
    Phaser.TweenData = function(parent) {
        this.parent = parent;
        this.game = parent.game;
        this.vStart = {};
        this.vStartCache = {};
        this.vEnd = {};
        this.vEndCache = {};
        this.duration = 1e3;
        this.percent = 0;
        this.value = 0;
        this.repeatCounter = 0;
        this.repeatDelay = 0;
        this.interpolate = false;
        this.yoyo = false;
        this.yoyoDelay = 0;
        this.inReverse = false;
        this.delay = 0;
        this.dt = 0;
        this.startTime = null;
        this.easingFunction = Phaser.Easing.Default;
        this.interpolationFunction = Phaser.Math.linearInterpolation;
        this.interpolationContext = Phaser.Math;
        this.isRunning = false;
        this.isFrom = false;
    };
    Phaser.TweenData.PENDING = 0;
    Phaser.TweenData.RUNNING = 1;
    Phaser.TweenData.LOOPED = 2;
    Phaser.TweenData.COMPLETE = 3;
    Phaser.TweenData.prototype = {
        to: function(properties, duration, ease, delay, repeat, yoyo) {
            this.vEnd = properties;
            this.duration = duration;
            this.easingFunction = ease;
            this.delay = delay;
            this.repeatCounter = repeat;
            this.yoyo = yoyo;
            this.isFrom = false;
            return this;
        },
        from: function(properties, duration, ease, delay, repeat, yoyo) {
            this.vEnd = properties;
            this.duration = duration;
            this.easingFunction = ease;
            this.delay = delay;
            this.repeatCounter = repeat;
            this.yoyo = yoyo;
            this.isFrom = true;
            return this;
        },
        start: function() {
            this.startTime = this.game.time.time + this.delay;
            if (this.parent.reverse) {
                this.dt = this.duration;
            } else {
                this.dt = 0;
            }
            if (this.delay > 0) {
                this.isRunning = false;
            } else {
                this.isRunning = true;
            }
            if (this.isFrom) {
                for (var property in this.vStartCache) {
                    this.vStart[property] = this.vEndCache[property];
                    this.vEnd[property] = this.vStartCache[property];
                    this.parent.target[property] = this.vStart[property];
                }
            }
            this.value = 0;
            this.yoyoCounter = 0;
            return this;
        },
        loadValues: function() {
            for (var property in this.parent.properties) {
                this.vStart[property] = this.parent.properties[property];
                if (Array.isArray(this.vEnd[property])) {
                    if (this.vEnd[property].length === 0) {
                        continue;
                    }
                    if (this.percent === 0) {
                        this.vEnd[property] = [ this.vStart[property] ].concat(this.vEnd[property]);
                    }
                }
                if (typeof this.vEnd[property] !== "undefined") {
                    if (typeof this.vEnd[property] === "string") {
                        this.vEnd[property] = this.vStart[property] + parseFloat(this.vEnd[property], 10);
                    }
                    this.parent.properties[property] = this.vEnd[property];
                } else {
                    this.vEnd[property] = this.vStart[property];
                }
                this.vStartCache[property] = this.vStart[property];
                this.vEndCache[property] = this.vEnd[property];
            }
            return this;
        },
        update: function(time) {
            if (!this.isRunning) {
                if (time >= this.startTime) {
                    this.isRunning = true;
                } else {
                    return Phaser.TweenData.PENDING;
                }
            } else {
                if (time < this.startTime) {
                    return Phaser.TweenData.RUNNING;
                }
            }
            var ms = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
            if (this.parent.reverse) {
                this.dt -= ms * this.parent.timeScale;
                this.dt = Math.max(this.dt, 0);
            } else {
                this.dt += ms * this.parent.timeScale;
                this.dt = Math.min(this.dt, this.duration);
            }
            this.percent = this.dt / this.duration;
            this.value = this.easingFunction(this.percent);
            for (var property in this.vEnd) {
                var start = this.vStart[property];
                var end = this.vEnd[property];
                if (Array.isArray(end)) {
                    this.parent.target[property] = this.interpolationFunction.call(this.interpolationContext, end, this.value);
                } else {
                    this.parent.target[property] = start + (end - start) * this.value;
                }
            }
            if (!this.parent.reverse && this.percent === 1 || this.parent.reverse && this.percent === 0) {
                return this.repeat();
            }
            return Phaser.TweenData.RUNNING;
        },
        generateData: function(frameRate) {
            if (this.parent.reverse) {
                this.dt = this.duration;
            } else {
                this.dt = 0;
            }
            var data = [];
            var complete = false;
            var fps = 1 / frameRate * 1e3;
            do {
                if (this.parent.reverse) {
                    this.dt -= fps;
                    this.dt = Math.max(this.dt, 0);
                } else {
                    this.dt += fps;
                    this.dt = Math.min(this.dt, this.duration);
                }
                this.percent = this.dt / this.duration;
                this.value = this.easingFunction(this.percent);
                var blob = {};
                for (var property in this.vEnd) {
                    var start = this.vStart[property];
                    var end = this.vEnd[property];
                    if (Array.isArray(end)) {
                        blob[property] = this.interpolationFunction(end, this.value);
                    } else {
                        blob[property] = start + (end - start) * this.value;
                    }
                }
                data.push(blob);
                if (!this.parent.reverse && this.percent === 1 || this.parent.reverse && this.percent === 0) {
                    complete = true;
                }
            } while (!complete);
            if (this.yoyo) {
                var reversed = data.slice();
                reversed.reverse();
                data = data.concat(reversed);
            }
            return data;
        },
        repeat: function() {
            if (this.yoyo) {
                if (this.inReverse && this.repeatCounter === 0) {
                    return Phaser.TweenData.COMPLETE;
                }
                this.inReverse = !this.inReverse;
            } else {
                if (this.repeatCounter === 0) {
                    return Phaser.TweenData.COMPLETE;
                }
            }
            if (this.inReverse) {
                for (var property in this.vStartCache) {
                    this.vStart[property] = this.vEndCache[property];
                    this.vEnd[property] = this.vStartCache[property];
                }
            } else {
                for (var property in this.vStartCache) {
                    this.vStart[property] = this.vStartCache[property];
                    this.vEnd[property] = this.vEndCache[property];
                }
                if (this.repeatCounter > 0) {
                    this.repeatCounter--;
                }
            }
            this.startTime = this.game.time.time;
            if (this.yoyo && this.inReverse) {
                this.startTime += this.yoyoDelay;
            } else if (!this.inReverse) {
                this.startTime += this.repeatDelay;
            }
            if (this.parent.reverse) {
                this.dt = this.duration;
            } else {
                this.dt = 0;
            }
            return Phaser.TweenData.LOOPED;
        }
    };
    Phaser.TweenData.prototype.constructor = Phaser.TweenData;
    Phaser.Easing = {
        Linear: {
            None: function(k) {
                return k;
            }
        },
        Quadratic: {
            In: function(k) {
                return k * k;
            },
            Out: function(k) {
                return k * (2 - k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k;
                return -.5 * (--k * (k - 2) - 1);
            }
        },
        Cubic: {
            In: function(k) {
                return k * k * k;
            },
            Out: function(k) {
                return --k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k;
                return .5 * ((k -= 2) * k * k + 2);
            }
        },
        Quartic: {
            In: function(k) {
                return k * k * k * k;
            },
            Out: function(k) {
                return 1 - --k * k * k * k;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k;
                return -.5 * ((k -= 2) * k * k * k - 2);
            }
        },
        Quintic: {
            In: function(k) {
                return k * k * k * k * k;
            },
            Out: function(k) {
                return --k * k * k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k * k;
                return .5 * ((k -= 2) * k * k * k * k + 2);
            }
        },
        Sinusoidal: {
            In: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                return 1 - Math.cos(k * Math.PI / 2);
            },
            Out: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                return Math.sin(k * Math.PI / 2);
            },
            InOut: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                return .5 * (1 - Math.cos(Math.PI * k));
            }
        },
        Exponential: {
            In: function(k) {
                return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            Out: function(k) {
                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            InOut: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
                return .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
        },
        Circular: {
            In: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            Out: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
                return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
        },
        Elastic: {
            In: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            },
            Out: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            },
            InOut: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                if ((k *= 2) < 1) return -.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
            }
        },
        Back: {
            In: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            Out: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            InOut: function(k) {
                var s = 1.70158 * 1.525;
                if ((k *= 2) < 1) return .5 * (k * k * ((s + 1) * k - s));
                return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
        },
        Bounce: {
            In: function(k) {
                return 1 - Phaser.Easing.Bounce.Out(1 - k);
            },
            Out: function(k) {
                if (k < 1 / 2.75) {
                    return 7.5625 * k * k;
                } else if (k < 2 / 2.75) {
                    return 7.5625 * (k -= 1.5 / 2.75) * k + .75;
                } else if (k < 2.5 / 2.75) {
                    return 7.5625 * (k -= 2.25 / 2.75) * k + .9375;
                } else {
                    return 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
                }
            },
            InOut: function(k) {
                if (k < .5) return Phaser.Easing.Bounce.In(k * 2) * .5;
                return Phaser.Easing.Bounce.Out(k * 2 - 1) * .5 + .5;
            }
        }
    };
    Phaser.Easing.Default = Phaser.Easing.Linear.None;
    Phaser.Easing.Power0 = Phaser.Easing.Linear.None;
    Phaser.Easing.Power1 = Phaser.Easing.Quadratic.Out;
    Phaser.Easing.Power2 = Phaser.Easing.Cubic.Out;
    Phaser.Easing.Power3 = Phaser.Easing.Quartic.Out;
    Phaser.Easing.Power4 = Phaser.Easing.Quintic.Out;
    Phaser.Time = function(game) {
        this.game = game;
        this.time = 0;
        this.prevTime = 0;
        this.now = 0;
        this.elapsed = 0;
        this.elapsedMS = 0;
        this.physicsElapsed = 0;
        this.physicsElapsedMS = 0;
        this.desiredFps = 60;
        this.suggestedFps = null;
        this.slowMotion = 1;
        this.advancedTiming = false;
        this.frames = 0;
        this.fps = 0;
        this.fpsMin = 1e3;
        this.fpsMax = 0;
        this.msMin = 1e3;
        this.msMax = 0;
        this.pauseDuration = 0;
        this.timeToCall = 0;
        this.timeExpected = 0;
        this.events = new Phaser.Timer(this.game, false);
        this._frameCount = 0;
        this._elapsedAccumulator = 0;
        this._started = 0;
        this._timeLastSecond = 0;
        this._pauseStarted = 0;
        this._justResumed = false;
        this._timers = [];
    };
    Phaser.Time.prototype = {
        boot: function() {
            this._started = Date.now();
            this.time = Date.now();
            this.events.start();
        },
        add: function(timer) {
            this._timers.push(timer);
            return timer;
        },
        create: function(autoDestroy) {
            if (autoDestroy === undefined) {
                autoDestroy = true;
            }
            var timer = new Phaser.Timer(this.game, autoDestroy);
            this._timers.push(timer);
            return timer;
        },
        removeAll: function() {
            for (var i = 0; i < this._timers.length; i++) {
                this._timers[i].destroy();
            }
            this._timers = [];
            this.events.removeAll();
        },
        update: function(time) {
            if (this.game.raf._isSetTimeOut) {
                this.updateSetTimeout(time);
            } else {
                this.updateRAF(time);
            }
            if (this.advancedTiming) {
                this.updateAdvancedTiming();
            }
            if (!this.game.paused) {
                this.events.update(this.time);
                if (this._timers.length) {
                    this.updateTimers();
                }
            }
        },
        updateSetTimeout: function(time) {
            var previousDateNow = this.time;
            this.time = time;
            this.elapsedMS = this.time - previousDateNow;
            this.prevTime = this.now;
            this.now = time;
            this.elapsed = this.now - this.prevTime;
            this.timeToCall = Math.floor(Math.max(0, 1e3 / this.desiredFps - (this.timeCallExpected - time)));
            this.timeCallExpected = time + this.timeToCall;
            this.physicsElapsed = 1 / this.desiredFps;
            this.physicsElapsedMS = this.physicsElapsed * 1e3;
        },
        updateRAF: function(time) {
            var previousDateNow = this.time;
            this.time = Date.now();
            this.elapsedMS = this.time - previousDateNow;
            this.prevTime = this.now;
            this.now = time;
            this.elapsed = this.now - this.prevTime;
            this.physicsElapsed = 1 / this.desiredFps;
            this.physicsElapsedMS = this.physicsElapsed * 1e3;
        },
        updateTimers: function() {
            var i = 0;
            var len = this._timers.length;
            while (i < len) {
                if (this._timers[i].update(this.time)) {
                    i++;
                } else {
                    this._timers.splice(i, 1);
                    len--;
                }
            }
        },
        updateAdvancedTiming: function() {
            this._frameCount++;
            this._elapsedAccumulator += this.elapsed;
            if (this._frameCount >= this.desiredFps * 2) {
                this.suggestedFps = Math.floor(200 / (this._elapsedAccumulator / this._frameCount)) * 5;
                this._frameCount = 0;
                this._elapsedAccumulator = 0;
            }
            this.msMin = Math.min(this.msMin, this.elapsed);
            this.msMax = Math.max(this.msMax, this.elapsed);
            this.frames++;
            if (this.now > this._timeLastSecond + 1e3) {
                this.fps = Math.round(this.frames * 1e3 / (this.now - this._timeLastSecond));
                this.fpsMin = Math.min(this.fpsMin, this.fps);
                this.fpsMax = Math.max(this.fpsMax, this.fps);
                this._timeLastSecond = this.now;
                this.frames = 0;
            }
        },
        gamePaused: function() {
            this._pauseStarted = Date.now();
            this.events.pause();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._pause();
            }
        },
        gameResumed: function() {
            this.time = Date.now();
            this.pauseDuration = this.time - this._pauseStarted;
            this.events.resume();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._resume();
            }
        },
        totalElapsedSeconds: function() {
            return (this.time - this._started) * .001;
        },
        elapsedSince: function(since) {
            return this.time - since;
        },
        elapsedSecondsSince: function(since) {
            return (this.time - since) * .001;
        },
        reset: function() {
            this._started = this.time;
            this.removeAll();
        }
    };
    Phaser.Time.prototype.constructor = Phaser.Time;
    Phaser.Timer = function(game, autoDestroy) {
        if (autoDestroy === undefined) {
            autoDestroy = true;
        }
        this.game = game;
        this.running = false;
        this.autoDestroy = autoDestroy;
        this.expired = false;
        this.elapsed = 0;
        this.events = [];
        this.onComplete = new Phaser.Signal();
        this.nextTick = 0;
        this.timeCap = 1e3;
        this.paused = false;
        this._codePaused = false;
        this._started = 0;
        this._pauseStarted = 0;
        this._pauseTotal = 0;
        this._now = Date.now();
        this._len = 0;
        this._marked = 0;
        this._i = 0;
        this._diff = 0;
        this._newTick = 0;
    };
    Phaser.Timer.MINUTE = 6e4;
    Phaser.Timer.SECOND = 1e3;
    Phaser.Timer.HALF = 500;
    Phaser.Timer.QUARTER = 250;
    Phaser.Timer.prototype = {
        create: function(delay, loop, repeatCount, callback, callbackContext, args) {
            delay = Math.round(delay);
            var tick = delay;
            if (this._now === 0) {
                tick += this.game.time.time;
            } else {
                tick += this._now;
            }
            var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);
            this.events.push(event);
            this.order();
            this.expired = false;
            return event;
        },
        add: function(delay, callback, callbackContext) {
            return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        repeat: function(delay, repeatCount, callback, callbackContext) {
            return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
        },
        loop: function(delay, callback, callbackContext) {
            return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        start: function(delay) {
            if (this.running) {
                return;
            }
            this._started = this.game.time.time + (delay || 0);
            this.running = true;
            for (var i = 0; i < this.events.length; i++) {
                this.events[i].tick = this.events[i].delay + this._started;
            }
        },
        stop: function(clearEvents) {
            this.running = false;
            if (clearEvents === undefined) {
                clearEvents = true;
            }
            if (clearEvents) {
                this.events.length = 0;
            }
        },
        remove: function(event) {
            for (var i = 0; i < this.events.length; i++) {
                if (this.events[i] === event) {
                    this.events[i].pendingDelete = true;
                    return true;
                }
            }
            return false;
        },
        order: function() {
            if (this.events.length > 0) {
                this.events.sort(this.sortHandler);
                this.nextTick = this.events[0].tick;
            }
        },
        sortHandler: function(a, b) {
            if (a.tick < b.tick) {
                return -1;
            } else if (a.tick > b.tick) {
                return 1;
            }
            return 0;
        },
        clearPendingEvents: function() {
            this._i = this.events.length;
            while (this._i--) {
                if (this.events[this._i].pendingDelete) {
                    this.events.splice(this._i, 1);
                }
            }
            this._len = this.events.length;
            this._i = 0;
        },
        update: function(time) {
            if (this.paused) {
                return true;
            }
            this.elapsed = time - this._now;
            this._now = time;
            if (this.elapsed > this.timeCap) {
                this.adjustEvents(time - this.elapsed);
            }
            this._marked = 0;
            this.clearPendingEvents();
            if (this.running && this._now >= this.nextTick && this._len > 0) {
                while (this._i < this._len && this.running) {
                    if (this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete) {
                        this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick);
                        if (this._newTick < 0) {
                            this._newTick = this._now + this.events[this._i].delay;
                        }
                        if (this.events[this._i].loop === true) {
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else if (this.events[this._i].repeatCount > 0) {
                            this.events[this._i].repeatCount--;
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else {
                            this._marked++;
                            this.events[this._i].pendingDelete = true;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        }
                        this._i++;
                    } else {
                        break;
                    }
                }
                if (this.events.length > this._marked) {
                    this.order();
                } else {
                    this.expired = true;
                    this.onComplete.dispatch(this);
                }
            }
            if (this.expired && this.autoDestroy) {
                return false;
            } else {
                return true;
            }
        },
        pause: function() {
            if (!this.running) {
                return;
            }
            this._codePaused = true;
            if (this.paused) {
                return;
            }
            this._pauseStarted = this.game.time.time;
            this.paused = true;
        },
        _pause: function() {
            if (this.paused || !this.running) {
                return;
            }
            this._pauseStarted = this.game.time.time;
            this.paused = true;
        },
        adjustEvents: function(baseTime) {
            for (var i = 0; i < this.events.length; i++) {
                if (!this.events[i].pendingDelete) {
                    var t = this.events[i].tick - baseTime;
                    if (t < 0) {
                        t = 0;
                    }
                    this.events[i].tick = this._now + t;
                }
            }
            var d = this.nextTick - baseTime;
            if (d < 0) {
                this.nextTick = this._now;
            } else {
                this.nextTick = this._now + d;
            }
        },
        resume: function() {
            if (!this.paused) {
                return;
            }
            var now = this.game.time.time;
            this._pauseTotal += now - this._now;
            this._now = now;
            this.adjustEvents(this._pauseStarted);
            this.paused = false;
            this._codePaused = false;
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this.resume();
            }
        },
        removeAll: function() {
            this.onComplete.removeAll();
            this.events.length = 0;
            this._len = 0;
            this._i = 0;
        },
        destroy: function() {
            this.onComplete.removeAll();
            this.running = false;
            this.events = [];
            this._len = 0;
            this._i = 0;
        }
    };
    Object.defineProperty(Phaser.Timer.prototype, "next", {
        get: function() {
            return this.nextTick;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "duration", {
        get: function() {
            if (this.running && this.nextTick > this._now) {
                return this.nextTick - this._now;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "length", {
        get: function() {
            return this.events.length;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "ms", {
        get: function() {
            if (this.running) {
                return this._now - this._started - this._pauseTotal;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "seconds", {
        get: function() {
            if (this.running) {
                return this.ms * .001;
            } else {
                return 0;
            }
        }
    });
    Phaser.Timer.prototype.constructor = Phaser.Timer;
    Phaser.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {
        this.timer = timer;
        this.delay = delay;
        this.tick = tick;
        this.repeatCount = repeatCount - 1;
        this.loop = loop;
        this.callback = callback;
        this.callbackContext = callbackContext;
        this.args = args;
        this.pendingDelete = false;
    };
    Phaser.TimerEvent.prototype.constructor = Phaser.TimerEvent;
    Phaser.AnimationManager = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.currentFrame = null;
        this.currentAnim = null;
        this.updateIfVisible = true;
        this.isLoaded = false;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = [];
    };
    Phaser.AnimationManager.prototype = {
        loadFrameData: function(frameData, frame) {
            if (frameData === undefined) {
                return false;
            }
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(frameData);
                }
            }
            this._frameData = frameData;
            if (frame === undefined || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        copyFrameData: function(frameData, frame) {
            this._frameData = frameData.clone();
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(this._frameData);
                }
            }
            if (frame === undefined || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        add: function(name, frames, frameRate, loop, useNumericIndex) {
            frames = frames || [];
            frameRate = frameRate || 60;
            if (loop === undefined) {
                loop = false;
            }
            if (useNumericIndex === undefined) {
                if (frames && typeof frames[0] === "number") {
                    useNumericIndex = true;
                } else {
                    useNumericIndex = false;
                }
            }
            this._outputFrames = [];
            this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames);
            this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop);
            this.currentAnim = this._anims[name];
            if (this.sprite.tilingTexture) {
                this.sprite.refreshTexture = true;
            }
            return this._anims[name];
        },
        validateFrames: function(frames, useNumericIndex) {
            if (useNumericIndex === undefined) {
                useNumericIndex = true;
            }
            for (var i = 0; i < frames.length; i++) {
                if (useNumericIndex === true) {
                    if (frames[i] > this._frameData.total) {
                        return false;
                    }
                } else {
                    if (this._frameData.checkFrameName(frames[i]) === false) {
                        return false;
                    }
                }
            }
            return true;
        },
        play: function(name, frameRate, loop, killOnComplete) {
            if (this._anims[name]) {
                if (this.currentAnim === this._anims[name]) {
                    if (this.currentAnim.isPlaying === false) {
                        this.currentAnim.paused = false;
                        return this.currentAnim.play(frameRate, loop, killOnComplete);
                    }
                    return this.currentAnim;
                } else {
                    if (this.currentAnim && this.currentAnim.isPlaying) {
                        this.currentAnim.stop();
                    }
                    this.currentAnim = this._anims[name];
                    this.currentAnim.paused = false;
                    this.currentFrame = this.currentAnim.currentFrame;
                    return this.currentAnim.play(frameRate, loop, killOnComplete);
                }
            }
        },
        stop: function(name, resetFrame) {
            if (resetFrame === undefined) {
                resetFrame = false;
            }
            if (typeof name === "string") {
                if (this._anims[name]) {
                    this.currentAnim = this._anims[name];
                    this.currentAnim.stop(resetFrame);
                }
            } else {
                if (this.currentAnim) {
                    this.currentAnim.stop(resetFrame);
                }
            }
        },
        update: function() {
            if (this.updateIfVisible && !this.sprite.visible) {
                return false;
            }
            if (this.currentAnim && this.currentAnim.update()) {
                this.currentFrame = this.currentAnim.currentFrame;
                return true;
            }
            return false;
        },
        next: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.next(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        previous: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.previous(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        getAnimation: function(name) {
            if (typeof name === "string") {
                if (this._anims[name]) {
                    return this._anims[name];
                }
            }
            return null;
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
        },
        destroy: function() {
            var anim = null;
            for (var anim in this._anims) {
                if (this._anims.hasOwnProperty(anim)) {
                    this._anims[anim].destroy();
                }
            }
            this._anims = {};
            this._outputFrames = [];
            this._frameData = null;
            this.currentAnim = null;
            this.currentFrame = null;
            this.sprite = null;
            this.game = null;
        }
    };
    Phaser.AnimationManager.prototype.constructor = Phaser.AnimationManager;
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused;
        },
        set: function(value) {
            this.currentAnim.paused = value;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "name", {
        get: function() {
            if (this.currentAnim) {
                return this.currentAnim.name;
            }
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) {
                return this.currentFrame.index;
            }
        },
        set: function(value) {
            if (typeof value === "number" && this._frameData && this._frameData.getFrame(value) !== null) {
                this.currentFrame = this._frameData.getFrame(value);
                if (this.currentFrame) {
                    this.sprite.setFrame(this.currentFrame);
                }
            }
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) {
                return this.currentFrame.name;
            }
        },
        set: function(value) {
            if (typeof value === "string" && this._frameData && this._frameData.getFrameByName(value) !== null) {
                this.currentFrame = this._frameData.getFrameByName(value);
                if (this.currentFrame) {
                    this._frameIndex = this.currentFrame.index;
                    this.sprite.setFrame(this.currentFrame);
                }
            } else {
                console.warn("Cannot set frameName: " + value);
            }
        }
    });
    Phaser.Animation = function(game, parent, name, frameData, frames, frameRate, loop) {
        if (loop === undefined) {
            loop = false;
        }
        this.game = game;
        this._parent = parent;
        this._frameData = frameData;
        this.name = name;
        this._frames = [];
        this._frames = this._frames.concat(frames);
        this.delay = 1e3 / frameRate;
        this.loop = loop;
        this.loopCount = 0;
        this.killOnComplete = false;
        this.isFinished = false;
        this.isPlaying = false;
        this.isPaused = false;
        this._pauseStartTime = 0;
        this._frameIndex = 0;
        this._frameDiff = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.onStart = new Phaser.Signal();
        this.onUpdate = null;
        this.onComplete = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.game.onPause.add(this.onPause, this);
        this.game.onResume.add(this.onResume, this);
    };
    Phaser.Animation.prototype = {
        play: function(frameRate, loop, killOnComplete) {
            if (typeof frameRate === "number") {
                this.delay = 1e3 / frameRate;
            }
            if (typeof loop === "boolean") {
                this.loop = loop;
            }
            if (typeof killOnComplete !== "undefined") {
                this.killOnComplete = killOnComplete;
            }
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.time;
            this._timeNextFrame = this.game.time.time + this.delay;
            this._frameIndex = 0;
            this.updateCurrentFrame(false, true);
            this._parent.events.onAnimationStart$dispatch(this._parent, this);
            this.onStart.dispatch(this._parent, this);
            this._parent.animations.currentAnim = this;
            this._parent.animations.currentFrame = this.currentFrame;
            return this;
        },
        restart: function() {
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.time;
            this._timeNextFrame = this.game.time.time + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setFrame(this.currentFrame);
            this._parent.animations.currentAnim = this;
            this._parent.animations.currentFrame = this.currentFrame;
            this.onStart.dispatch(this._parent, this);
        },
        setFrame: function(frameId, useLocalFrameIndex) {
            var frameIndex;
            if (useLocalFrameIndex === undefined) {
                useLocalFrameIndex = false;
            }
            if (typeof frameId === "string") {
                for (var i = 0; i < this._frames.length; i++) {
                    if (this._frameData.getFrame(this._frames[i]).name === frameId) {
                        frameIndex = i;
                    }
                }
            } else if (typeof frameId === "number") {
                if (useLocalFrameIndex) {
                    frameIndex = frameId;
                } else {
                    for (var i = 0; i < this._frames.length; i++) {
                        if (this._frames[i] === frameIndex) {
                            frameIndex = i;
                        }
                    }
                }
            }
            if (frameIndex) {
                this._frameIndex = frameIndex - 1;
                this._timeNextFrame = this.game.time.time;
                this.update();
            }
        },
        stop: function(resetFrame, dispatchComplete) {
            if (resetFrame === undefined) {
                resetFrame = false;
            }
            if (dispatchComplete === undefined) {
                dispatchComplete = false;
            }
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (resetFrame) {
                this.currentFrame = this._frameData.getFrame(this._frames[0]);
                this._parent.setFrame(this.currentFrame);
            }
            if (dispatchComplete) {
                this._parent.events.onAnimationComplete$dispatch(this._parent, this);
                this.onComplete.dispatch(this._parent, this);
            }
        },
        onPause: function() {
            if (this.isPlaying) {
                this._frameDiff = this._timeNextFrame - this.game.time.time;
            }
        },
        onResume: function() {
            if (this.isPlaying) {
                this._timeNextFrame = this.game.time.time + this._frameDiff;
            }
        },
        update: function() {
            if (this.isPaused) {
                return false;
            }
            if (this.isPlaying && this.game.time.time >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.time - this._timeNextFrame;
                this._timeLastFrame = this.game.time.time;
                if (this._frameDiff > this.delay) {
                    this._frameSkip = Math.floor(this._frameDiff / this.delay);
                    this._frameDiff -= this._frameSkip * this.delay;
                }
                this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length) {
                    if (this.loop) {
                        this._frameIndex %= this._frames.length;
                        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                        if (this.currentFrame) {
                            this._parent.setFrame(this.currentFrame);
                        }
                        this.loopCount++;
                        this._parent.events.onAnimationLoop$dispatch(this._parent, this);
                        this.onLoop.dispatch(this._parent, this);
                        if (this.onUpdate) {
                            this.onUpdate.dispatch(this, this.currentFrame);
                            return !!this._frameData;
                        } else {
                            return true;
                        }
                    } else {
                        this.complete();
                        return false;
                    }
                } else {
                    return this.updateCurrentFrame(true);
                }
            }
            return false;
        },
        updateCurrentFrame: function(signalUpdate, fromPlay) {
            if (fromPlay === undefined) {
                fromPlay = false;
            }
            if (!this._frameData) {
                return false;
            }
            var idx = this.currentFrame.index;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            if (this.currentFrame && (fromPlay || !fromPlay && idx !== this.currentFrame.index)) {
                this._parent.setFrame(this.currentFrame);
            }
            if (this.onUpdate && signalUpdate) {
                this.onUpdate.dispatch(this, this.currentFrame);
                return !!this._frameData;
            } else {
                return true;
            }
        },
        next: function(quantity) {
            if (quantity === undefined) {
                quantity = 1;
            }
            var frame = this._frameIndex + quantity;
            if (frame >= this._frames.length) {
                if (this.loop) {
                    frame %= this._frames.length;
                } else {
                    frame = this._frames.length - 1;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.updateCurrentFrame(true);
            }
        },
        previous: function(quantity) {
            if (quantity === undefined) {
                quantity = 1;
            }
            var frame = this._frameIndex - quantity;
            if (frame < 0) {
                if (this.loop) {
                    frame = this._frames.length + frame;
                } else {
                    frame++;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.updateCurrentFrame(true);
            }
        },
        updateFrameData: function(frameData) {
            this._frameData = frameData;
            this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
        },
        destroy: function() {
            if (!this._frameData) {
                return;
            }
            this.game.onPause.remove(this.onPause, this);
            this.game.onResume.remove(this.onResume, this);
            this.game = null;
            this._parent = null;
            this._frames = null;
            this._frameData = null;
            this.currentFrame = null;
            this.isPlaying = false;
            this.onStart.dispose();
            this.onLoop.dispose();
            this.onComplete.dispose();
            if (this.onUpdate) {
                this.onUpdate.dispose();
            }
        },
        complete: function() {
            this._frameIndex = this._frames.length - 1;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            this._parent.events.onAnimationComplete$dispatch(this._parent, this);
            this.onComplete.dispatch(this._parent, this);
            if (this.killOnComplete) {
                this._parent.kill();
            }
        }
    };
    Phaser.Animation.prototype.constructor = Phaser.Animation;
    Object.defineProperty(Phaser.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused;
        },
        set: function(value) {
            this.isPaused = value;
            if (value) {
                this._pauseStartTime = this.game.time.time;
            } else {
                if (this.isPlaying) {
                    this._timeNextFrame = this.game.time.time + this.delay;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length;
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frame", {
        get: function() {
            if (this.currentFrame !== null) {
                return this.currentFrame.index;
            } else {
                return this._frameIndex;
            }
        },
        set: function(value) {
            this.currentFrame = this._frameData.getFrame(this._frames[value]);
            if (this.currentFrame !== null) {
                this._frameIndex = value;
                this._parent.setFrame(this.currentFrame);
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1e3 / this.delay);
        },
        set: function(value) {
            if (value >= 1) {
                this.delay = 1e3 / value;
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "enableUpdate", {
        get: function() {
            return this.onUpdate !== null;
        },
        set: function(value) {
            if (value && this.onUpdate === null) {
                this.onUpdate = new Phaser.Signal();
            } else if (!value && this.onUpdate !== null) {
                this.onUpdate.dispose();
                this.onUpdate = null;
            }
        }
    });
    Phaser.Animation.generateFrameNames = function(prefix, start, stop, suffix, zeroPad) {
        if (suffix === undefined) {
            suffix = "";
        }
        var output = [];
        var frame = "";
        if (start < stop) {
            for (var i = start; i <= stop; i++) {
                if (typeof zeroPad === "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        } else {
            for (var i = start; i >= stop; i--) {
                if (typeof zeroPad === "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        }
        return output;
    };
    Phaser.Frame = function(index, x, y, width, height, name) {
        this.index = index;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.name = name;
        this.centerX = Math.floor(width / 2);
        this.centerY = Math.floor(height / 2);
        this.distance = Phaser.Math.distance(0, 0, width, height);
        this.rotated = false;
        this.rotationDirection = "cw";
        this.trimmed = false;
        this.sourceSizeW = width;
        this.sourceSizeH = height;
        this.spriteSourceSizeX = 0;
        this.spriteSourceSizeY = 0;
        this.spriteSourceSizeW = 0;
        this.spriteSourceSizeH = 0;
        this.right = this.x + this.width;
        this.bottom = this.y + this.height;
    };
    Phaser.Frame.prototype = {
        resize: function(width, height) {
            this.width = width;
            this.height = height;
            this.centerX = Math.floor(width / 2);
            this.centerY = Math.floor(height / 2);
            this.distance = Phaser.Math.distance(0, 0, width, height);
            this.sourceSizeW = width;
            this.sourceSizeH = height;
            this.right = this.x + width;
            this.bottom = this.y + height;
        },
        setTrim: function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
            this.trimmed = trimmed;
            if (trimmed) {
                this.sourceSizeW = actualWidth;
                this.sourceSizeH = actualHeight;
                this.centerX = Math.floor(actualWidth / 2);
                this.centerY = Math.floor(actualHeight / 2);
                this.spriteSourceSizeX = destX;
                this.spriteSourceSizeY = destY;
                this.spriteSourceSizeW = destWidth;
                this.spriteSourceSizeH = destHeight;
            }
        },
        clone: function() {
            var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
            for (var prop in this) {
                if (this.hasOwnProperty(prop)) {
                    output[prop] = this[prop];
                }
            }
            return output;
        },
        getRect: function(out) {
            if (out === undefined) {
                out = new Phaser.Rectangle(this.x, this.y, this.width, this.height);
            } else {
                out.setTo(this.x, this.y, this.width, this.height);
            }
            return out;
        }
    };
    Phaser.Frame.prototype.constructor = Phaser.Frame;
    Phaser.FrameData = function() {
        this._frames = [];
        this._frameNames = [];
    };
    Phaser.FrameData.prototype = {
        addFrame: function(frame) {
            frame.index = this._frames.length;
            this._frames.push(frame);
            if (frame.name !== "") {
                this._frameNames[frame.name] = frame.index;
            }
            return frame;
        },
        getFrame: function(index) {
            if (index >= this._frames.length) {
                index = 0;
            }
            return this._frames[index];
        },
        getFrameByName: function(name) {
            if (typeof this._frameNames[name] === "number") {
                return this._frames[this._frameNames[name]];
            }
            return null;
        },
        checkFrameName: function(name) {
            if (this._frameNames[name] == null) {
                return false;
            }
            return true;
        },
        clone: function() {
            var output = new Phaser.FrameData();
            for (var i = 0; i < this._frames.length; i++) {
                output._frames.push(this._frames[i].clone());
            }
            for (var p in this._frameNames) {
                if (this._frameNames.hasOwnProperty(p)) {
                    output._frameNames.push(this._frameNames[p]);
                }
            }
            return output;
        },
        getFrameRange: function(start, end, output) {
            if (output === undefined) {
                output = [];
            }
            for (var i = start; i <= end; i++) {
                output.push(this._frames[i]);
            }
            return output;
        },
        getFrames: function(frames, useNumericIndex, output) {
            if (useNumericIndex === undefined) {
                useNumericIndex = true;
            }
            if (output === undefined) {
                output = [];
            }
            if (frames === undefined || frames.length === 0) {
                for (var i = 0; i < this._frames.length; i++) {
                    output.push(this._frames[i]);
                }
            } else {
                for (var i = 0; i < frames.length; i++) {
                    if (useNumericIndex) {
                        output.push(this.getFrame(frames[i]));
                    } else {
                        output.push(this.getFrameByName(frames[i]));
                    }
                }
            }
            return output;
        },
        getFrameIndexes: function(frames, useNumericIndex, output) {
            if (useNumericIndex === undefined) {
                useNumericIndex = true;
            }
            if (output === undefined) {
                output = [];
            }
            if (frames === undefined || frames.length === 0) {
                for (var i = 0; i < this._frames.length; i++) {
                    output.push(this._frames[i].index);
                }
            } else {
                for (var i = 0; i < frames.length; i++) {
                    if (useNumericIndex) {
                        output.push(this._frames[frames[i]].index);
                    } else {
                        if (this.getFrameByName(frames[i])) {
                            output.push(this.getFrameByName(frames[i]).index);
                        }
                    }
                }
            }
            return output;
        }
    };
    Phaser.FrameData.prototype.constructor = Phaser.FrameData;
    Object.defineProperty(Phaser.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length;
        }
    });
    Phaser.AnimationParser = {
        spriteSheet: function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
            var img = key;
            if (typeof key === "string") {
                img = game.cache.getImage(key);
            }
            if (img === null) {
                return null;
            }
            var width = img.width;
            var height = img.height;
            if (frameWidth <= 0) {
                frameWidth = Math.floor(-width / Math.min(-1, frameWidth));
            }
            if (frameHeight <= 0) {
                frameHeight = Math.floor(-height / Math.min(-1, frameHeight));
            }
            var row = Math.floor((width - margin) / (frameWidth + spacing));
            var column = Math.floor((height - margin) / (frameHeight + spacing));
            var total = row * column;
            if (frameMax !== -1) {
                total = frameMax;
            }
            if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0) {
                console.warn("Phaser.AnimationParser.spriteSheet: '" + key + "'s width/height zero or width/height < given frameWidth/frameHeight");
                return null;
            }
            var data = new Phaser.FrameData();
            var x = margin;
            var y = margin;
            for (var i = 0; i < total; i++) {
                data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, ""));
                x += frameWidth + spacing;
                if (x + frameWidth > width) {
                    x = margin;
                    y += frameHeight + spacing;
                }
            }
            return data;
        },
        JSONData: function(game, json) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
                newFrame = data.addFrame(new Phaser.Frame(i, frames[i].frame.x, frames[i].frame.y, frames[i].frame.w, frames[i].frame.h, frames[i].filename));
                if (frames[i].trimmed) {
                    newFrame.setTrim(frames[i].trimmed, frames[i].sourceSize.w, frames[i].sourceSize.h, frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].spriteSourceSize.w, frames[i].spriteSourceSize.h);
                }
            }
            return data;
        },
        JSONDataHash: function(game, json) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            var i = 0;
            for (var key in frames) {
                newFrame = data.addFrame(new Phaser.Frame(i, frames[key].frame.x, frames[key].frame.y, frames[key].frame.w, frames[key].frame.h, key));
                if (frames[key].trimmed) {
                    newFrame.setTrim(frames[key].trimmed, frames[key].sourceSize.w, frames[key].sourceSize.h, frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].spriteSourceSize.w, frames[key].spriteSourceSize.h);
                }
                i++;
            }
            return data;
        },
        XMLData: function(game, xml) {
            if (!xml.getElementsByTagName("TextureAtlas")) {
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                return;
            }
            var data = new Phaser.FrameData();
            var frames = xml.getElementsByTagName("SubTexture");
            var newFrame;
            var name;
            var frame;
            var x;
            var y;
            var width;
            var height;
            var frameX;
            var frameY;
            var frameWidth;
            var frameHeight;
            for (var i = 0; i < frames.length; i++) {
                frame = frames[i].attributes;
                name = frame.name.value;
                x = parseInt(frame.x.value, 10);
                y = parseInt(frame.y.value, 10);
                width = parseInt(frame.width.value, 10);
                height = parseInt(frame.height.value, 10);
                frameX = null;
                frameY = null;
                if (frame.frameX) {
                    frameX = Math.abs(parseInt(frame.frameX.value, 10));
                    frameY = Math.abs(parseInt(frame.frameY.value, 10));
                    frameWidth = parseInt(frame.frameWidth.value, 10);
                    frameHeight = parseInt(frame.frameHeight.value, 10);
                }
                newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));
                if (frameX !== null || frameY !== null) {
                    newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
                }
            }
            return data;
        }
    };
    Phaser.Cache = function(game) {
        this.game = game;
        this.autoResolveURL = false;
        this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {}
        };
        this._urlMap = {};
        this._urlResolver = new Image();
        this._urlTemp = null;
        this.onSoundUnlock = new Phaser.Signal();
        this._cacheMap = [];
        this._cacheMap[Phaser.Cache.CANVAS] = this._cache.canvas;
        this._cacheMap[Phaser.Cache.IMAGE] = this._cache.image;
        this._cacheMap[Phaser.Cache.TEXTURE] = this._cache.texture;
        this._cacheMap[Phaser.Cache.SOUND] = this._cache.sound;
        this._cacheMap[Phaser.Cache.TEXT] = this._cache.text;
        this._cacheMap[Phaser.Cache.PHYSICS] = this._cache.physics;
        this._cacheMap[Phaser.Cache.TILEMAP] = this._cache.tilemap;
        this._cacheMap[Phaser.Cache.BINARY] = this._cache.binary;
        this._cacheMap[Phaser.Cache.BITMAPDATA] = this._cache.bitmapData;
        this._cacheMap[Phaser.Cache.BITMAPFONT] = this._cache.bitmapFont;
        this._cacheMap[Phaser.Cache.JSON] = this._cache.json;
        this._cacheMap[Phaser.Cache.XML] = this._cache.xml;
        this._cacheMap[Phaser.Cache.VIDEO] = this._cache.video;
        this._cacheMap[Phaser.Cache.SHADER] = this._cache.shader;
        this._cacheMap[Phaser.Cache.RENDER_TEXTURE] = this._cache.renderTexture;
        this.addDefaultImage();
        this.addMissingImage();
    };
    Phaser.Cache.CANVAS = 1;
    Phaser.Cache.IMAGE = 2;
    Phaser.Cache.TEXTURE = 3;
    Phaser.Cache.SOUND = 4;
    Phaser.Cache.TEXT = 5;
    Phaser.Cache.PHYSICS = 6;
    Phaser.Cache.TILEMAP = 7;
    Phaser.Cache.BINARY = 8;
    Phaser.Cache.BITMAPDATA = 9;
    Phaser.Cache.BITMAPFONT = 10;
    Phaser.Cache.JSON = 11;
    Phaser.Cache.XML = 12;
    Phaser.Cache.VIDEO = 13;
    Phaser.Cache.SHADER = 14;
    Phaser.Cache.RENDER_TEXTURE = 15;
    Phaser.Cache.prototype = {
        addCanvas: function(key, canvas, context) {
            if (context === undefined) {
                context = canvas.getContext("2d");
            }
            this._cache.canvas[key] = {
                canvas: canvas,
                context: context
            };
        },
        addImage: function(key, url, data) {
            if (this.checkImageKey(key)) {
                this.removeImage(key);
            }
            var img = {
                key: key,
                url: url,
                data: data,
                base: new PIXI.BaseTexture(data),
                frame: new Phaser.Frame(0, 0, 0, data.width, data.height, key),
                frameData: new Phaser.FrameData()
            };
            img.frameData.addFrame(new Phaser.Frame(0, 0, 0, data.width, data.height, url));
            this._cache.image[key] = img;
            this._resolveURL(url, img);
            return img;
        },
        addDefaultImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            var obj = this.addImage("__default", null, img);
            PIXI.TextureCache["__default"] = new PIXI.Texture(obj.base);
        },
        addMissingImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            var obj = this.addImage("__missing", null, img);
            PIXI.TextureCache["__missing"] = new PIXI.Texture(obj.base);
        },
        addSound: function(key, url, data, webAudio, audioTag) {
            if (webAudio === undefined) {
                webAudio = true;
                audioTag = false;
            }
            if (audioTag === undefined) {
                webAudio = false;
                audioTag = true;
            }
            var decoded = false;
            if (audioTag) {
                decoded = true;
            }
            this._cache.sound[key] = {
                url: url,
                data: data,
                isDecoding: false,
                decoded: decoded,
                webAudio: webAudio,
                audioTag: audioTag,
                locked: this.game.sound.touchLocked
            };
            this._resolveURL(url, this._cache.sound[key]);
        },
        addText: function(key, url, data) {
            this._cache.text[key] = {
                url: url,
                data: data
            };
            this._resolveURL(url, this._cache.text[key]);
        },
        addPhysicsData: function(key, url, JSONData, format) {
            this._cache.physics[key] = {
                url: url,
                data: JSONData,
                format: format
            };
            this._resolveURL(url, this._cache.physics[key]);
        },
        addTilemap: function(key, url, mapData, format) {
            this._cache.tilemap[key] = {
                url: url,
                data: mapData,
                format: format
            };
            this._resolveURL(url, this._cache.tilemap[key]);
        },
        addBinary: function(key, binaryData) {
            this._cache.binary[key] = binaryData;
        },
        addBitmapData: function(key, bitmapData, frameData) {
            bitmapData.key = key;
            if (frameData === undefined) {
                frameData = new Phaser.FrameData();
                frameData.addFrame(bitmapData.textureFrame);
            }
            this._cache.bitmapData[key] = {
                data: bitmapData,
                frameData: frameData
            };
            return bitmapData;
        },
        addBitmapFont: function(key, url, data, atlasData, atlasType, xSpacing, ySpacing) {
            var obj = {
                url: url,
                data: data,
                font: null,
                base: new PIXI.BaseTexture(data)
            };
            if (atlasType === "json") {
                obj.font = Phaser.LoaderParser.jsonBitmapFont(atlasData, obj.base, xSpacing, ySpacing);
            } else {
                obj.font = Phaser.LoaderParser.xmlBitmapFont(atlasData, obj.base, xSpacing, ySpacing);
            }
            this._cache.bitmapFont[key] = obj;
            this._resolveURL(url, obj);
        },
        addJSON: function(key, url, data) {
            this._cache.json[key] = {
                url: url,
                data: data
            };
            this._resolveURL(url, this._cache.json[key]);
        },
        addXML: function(key, url, data) {
            this._cache.xml[key] = {
                url: url,
                data: data
            };
            this._resolveURL(url, this._cache.xml[key]);
        },
        addVideo: function(key, url, data, isBlob) {
            this._cache.video[key] = {
                url: url,
                data: data,
                isBlob: isBlob,
                locked: true
            };
            this._resolveURL(url, this._cache.video[key]);
        },
        addShader: function(key, url, data) {
            this._cache.shader[key] = {
                url: url,
                data: data
            };
            this._resolveURL(url, this._cache.shader[key]);
        },
        addRenderTexture: function(key, texture) {
            this._cache.renderTexture[key] = {
                texture: texture,
                frame: new Phaser.Frame(0, 0, 0, texture.width, texture.height, "", "")
            };
        },
        addSpriteSheet: function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
            if (frameMax === undefined) {
                frameMax = -1;
            }
            if (margin === undefined) {
                margin = 0;
            }
            if (spacing === undefined) {
                spacing = 0;
            }
            var obj = {
                key: key,
                url: url,
                data: data,
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                margin: margin,
                spacing: spacing,
                base: new PIXI.BaseTexture(data),
                frameData: Phaser.AnimationParser.spriteSheet(this.game, data, frameWidth, frameHeight, frameMax, margin, spacing)
            };
            this._cache.image[key] = obj;
            this._resolveURL(url, obj);
        },
        addTextureAtlas: function(key, url, data, atlasData, format) {
            var obj = {
                key: key,
                url: url,
                data: data,
                base: new PIXI.BaseTexture(data)
            };
            if (format === Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                obj.frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key);
            } else {
                if (Array.isArray(atlasData.frames)) {
                    obj.frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key);
                } else {
                    obj.frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key);
                }
            }
            this._cache.image[key] = obj;
            this._resolveURL(url, obj);
        },
        reloadSound: function(key) {
            var _this = this;
            var sound = this.getSound(key);
            if (sound) {
                sound.data.src = sound.url;
                sound.data.addEventListener("canplaythrough", function() {
                    return _this.reloadSoundComplete(key);
                }, false);
                sound.data.load();
            }
        },
        reloadSoundComplete: function(key) {
            var sound = this.getSound(key);
            if (sound) {
                sound.locked = false;
                this.onSoundUnlock.dispatch(key);
            }
        },
        updateSound: function(key, property, value) {
            var sound = this.getSound(key);
            if (sound) {
                sound[property] = value;
            }
        },
        decodedSound: function(key, data) {
            var sound = this.getSound(key);
            sound.data = data;
            sound.decoded = true;
            sound.isDecoding = false;
        },
        isSoundDecoded: function(key) {
            var sound = this.getItem(key, Phaser.Cache.SOUND, "isSoundDecoded");
            if (sound) {
                return sound.decoded;
            }
        },
        isSoundReady: function(key) {
            var sound = this.getItem(key, Phaser.Cache.SOUND, "isSoundDecoded");
            if (sound) {
                return sound.decoded && !this.game.sound.touchLocked;
            }
        },
        checkKey: function(cache, key) {
            if (this._cacheMap[cache][key]) {
                return true;
            }
            return false;
        },
        checkURL: function(url) {
            if (this._urlMap[this._resolveURL(url)]) {
                return true;
            }
            return false;
        },
        checkCanvasKey: function(key) {
            return this.checkKey(Phaser.Cache.CANVAS, key);
        },
        checkImageKey: function(key) {
            return this.checkKey(Phaser.Cache.IMAGE, key);
        },
        checkTextureKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXTURE, key);
        },
        checkSoundKey: function(key) {
            return this.checkKey(Phaser.Cache.SOUND, key);
        },
        checkTextKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXT, key);
        },
        checkPhysicsKey: function(key) {
            return this.checkKey(Phaser.Cache.PHYSICS, key);
        },
        checkTilemapKey: function(key) {
            return this.checkKey(Phaser.Cache.TILEMAP, key);
        },
        checkBinaryKey: function(key) {
            return this.checkKey(Phaser.Cache.BINARY, key);
        },
        checkBitmapDataKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPDATA, key);
        },
        checkBitmapFontKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPFONT, key);
        },
        checkJSONKey: function(key) {
            return this.checkKey(Phaser.Cache.JSON, key);
        },
        checkXMLKey: function(key) {
            return this.checkKey(Phaser.Cache.XML, key);
        },
        checkVideoKey: function(key) {
            return this.checkKey(Phaser.Cache.VIDEO, key);
        },
        checkShaderKey: function(key) {
            return this.checkKey(Phaser.Cache.SHADER, key);
        },
        checkRenderTextureKey: function(key) {
            return this.checkKey(Phaser.Cache.RENDER_TEXTURE, key);
        },
        getItem: function(key, cache, method, property) {
            if (!this.checkKey(cache, key)) {
                if (method) {
                    console.warn("Phaser.Cache." + method + ': Key "' + key + '" not found in Cache.');
                }
            } else {
                if (property === undefined) {
                    return this._cacheMap[cache][key];
                } else {
                    return this._cacheMap[cache][key][property];
                }
            }
            return null;
        },
        getCanvas: function(key) {
            return this.getItem(key, Phaser.Cache.CANVAS, "getCanvas", "canvas");
        },
        getImage: function(key, full) {
            if (key === undefined || key === null) {
                key = "__default";
            }
            if (full === undefined) {
                full = false;
            }
            var img = this.getItem(key, Phaser.Cache.IMAGE, "getImage");
            if (img === null) {
                img = this.getItem("__missing", Phaser.Cache.IMAGE, "getImage");
            }
            if (full) {
                return img;
            } else {
                return img.data;
            }
        },
        getTextureFrame: function(key) {
            return this.getItem(key, Phaser.Cache.TEXTURE, "getTextureFrame", "frame");
        },
        getSound: function(key) {
            return this.getItem(key, Phaser.Cache.SOUND, "getSound");
        },
        getSoundData: function(key) {
            return this.getItem(key, Phaser.Cache.SOUND, "getSoundData", "data");
        },
        getText: function(key) {
            return this.getItem(key, Phaser.Cache.TEXT, "getText", "data");
        },
        getPhysicsData: function(key, object, fixtureKey) {
            var data = this.getItem(key, Phaser.Cache.PHYSICS, "getPhysicsData", "data");
            if (data === null || object === undefined || object === null) {
                return data;
            } else {
                if (data[object]) {
                    var fixtures = data[object];
                    if (fixtures && fixtureKey) {
                        for (var fixture in fixtures) {
                            fixture = fixtures[fixture];
                            if (fixture.fixtureKey === fixtureKey) {
                                return fixture;
                            }
                        }
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + fixtureKey + " in " + key + '"');
                    } else {
                        return fixtures;
                    }
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + key + " / " + object + '"');
                }
            }
            return null;
        },
        getTilemapData: function(key) {
            return this.getItem(key, Phaser.Cache.TILEMAP, "getTilemapData");
        },
        getBinary: function(key) {
            return this.getItem(key, Phaser.Cache.BINARY, "getBinary");
        },
        getBitmapData: function(key) {
            return this.getItem(key, Phaser.Cache.BITMAPDATA, "getBitmapData", "data");
        },
        getBitmapFont: function(key) {
            return this.getItem(key, Phaser.Cache.BITMAPFONT, "getBitmapFont");
        },
        getJSON: function(key, clone) {
            var data = this.getItem(key, Phaser.Cache.JSON, "getJSON", "data");
            if (data) {
                if (clone) {
                    return Phaser.Utils.extend(true, data);
                } else {
                    return data;
                }
            } else {
                return null;
            }
        },
        getXML: function(key) {
            return this.getItem(key, Phaser.Cache.XML, "getXML", "data");
        },
        getVideo: function(key) {
            return this.getItem(key, Phaser.Cache.VIDEO, "getVideo");
        },
        getShader: function(key) {
            return this.getItem(key, Phaser.Cache.SHADER, "getShader", "data");
        },
        getRenderTexture: function(key) {
            return this.getItem(key, Phaser.Cache.RENDER_TEXTURE, "getRenderTexture");
        },
        getBaseTexture: function(key, cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            return this.getItem(key, cache, "getBaseTexture", "base");
        },
        getFrame: function(key, cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            return this.getItem(key, cache, "getFrame", "frame");
        },
        getFrameCount: function(key, cache) {
            var data = this.getFrameData(key, cache);
            if (data) {
                return data.total;
            } else {
                return 0;
            }
        },
        getFrameData: function(key, cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            return this.getItem(key, cache, "getFrameData", "frameData");
        },
        hasFrameData: function(key, cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            return this.getItem(key, cache, "", "frameData") !== null;
        },
        updateFrameData: function(key, frameData, cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            if (this._cacheMap[cache][key]) {
                this._cacheMap[cache][key].frameData = frameData;
            }
        },
        getFrameByIndex: function(key, index, cache) {
            var data = this.getFrameData(key, cache);
            if (data) {
                return data.getFrame(index);
            } else {
                return null;
            }
        },
        getFrameByName: function(key, name, cache) {
            var data = this.getFrameData(key, cache);
            if (data) {
                return data.getFrameByName(name);
            } else {
                return null;
            }
        },
        getPixiTexture: function(key) {
            if (PIXI.TextureCache[key]) {
                return PIXI.TextureCache[key];
            } else {
                var base = this.getPixiBaseTexture(key);
                if (base) {
                    return new PIXI.Texture(base);
                } else {
                    return null;
                }
            }
        },
        getPixiBaseTexture: function(key) {
            if (PIXI.BaseTextureCache[key]) {
                return PIXI.BaseTextureCache[key];
            } else {
                var img = this.getItem(key, Phaser.Cache.IMAGE, "getPixiBaseTexture");
                if (img !== null) {
                    return img.base;
                } else {
                    return null;
                }
            }
        },
        getURL: function(url) {
            var url = this._resolveURL(url);
            if (url) {
                return this._urlMap[url];
            } else {
                console.warn('Phaser.Cache.getUrl: Invalid url: "' + url + '" or Cache.autoResolveURL was false');
                return null;
            }
        },
        getKeys: function(cache) {
            if (cache === undefined) {
                cache = Phaser.Cache.IMAGE;
            }
            var out = [];
            if (this._cacheMap[cache]) {
                for (var key in this._cacheMap[cache]) {
                    if (key !== "__default" && key !== "__missing") {
                        out.push(key);
                    }
                }
            }
            return out;
        },
        removeCanvas: function(key) {
            delete this._cache.canvas[key];
        },
        removeImage: function(key, removeFromPixi) {
            if (removeFromPixi === undefined) {
                removeFromPixi = true;
            }
            var img = this.getImage(key, true);
            if (removeFromPixi && img.base) {
                img.base.destroy();
            }
            delete this._cache.image[key];
        },
        removeSound: function(key) {
            delete this._cache.sound[key];
        },
        removeText: function(key) {
            delete this._cache.text[key];
        },
        removePhysics: function(key) {
            delete this._cache.physics[key];
        },
        removeTilemap: function(key) {
            delete this._cache.tilemap[key];
        },
        removeBinary: function(key) {
            delete this._cache.binary[key];
        },
        removeBitmapData: function(key) {
            delete this._cache.bitmapData[key];
        },
        removeBitmapFont: function(key) {
            delete this._cache.bitmapFont[key];
        },
        removeJSON: function(key) {
            delete this._cache.json[key];
        },
        removeXML: function(key) {
            delete this._cache.xml[key];
        },
        removeVideo: function(key) {
            delete this._cache.video[key];
        },
        removeShader: function(key) {
            delete this._cache.shader[key];
        },
        removeRenderTexture: function(key) {
            delete this._cache.renderTexture[key];
        },
        removeSpriteSheet: function(key) {
            delete this._cache.spriteSheet[key];
        },
        removeTextureAtlas: function(key) {
            delete this._cache.atlas[key];
        },
        clearGLTextures: function() {
            for (var key in this.cache.image) {
                this.cache.image[key].base._glTextures = [];
            }
        },
        _resolveURL: function(url, data) {
            if (!this.autoResolveURL) {
                return null;
            }
            this._urlResolver.src = this.game.load.baseURL + url;
            this._urlTemp = this._urlResolver.src;
            this._urlResolver.src = "";
            if (data) {
                this._urlMap[this._urlTemp] = data;
            }
            return this._urlTemp;
        },
        destroy: function() {
            for (var i = 0; i < this._cacheMap.length; i++) {
                var cache = this._cacheMap[i];
                for (var key in cache) {
                    if (key !== "__default" && key !== "__missing") {
                        if (cache[key]["destroy"]) {
                            cache[key].destroy();
                        }
                        delete cache[key];
                    }
                }
            }
            this._urlMap = null;
            this._urlResolver = null;
            this._urlTemp = null;
        }
    };
    Phaser.Cache.prototype.constructor = Phaser.Cache;
    Phaser.Loader = function(game) {
        this.game = game;
        this.cache = game.cache;
        this.resetLocked = false;
        this.isLoading = false;
        this.hasLoaded = false;
        this.preloadSprite = null;
        this.crossOrigin = false;
        this.baseURL = "";
        this.path = "";
        this.onLoadStart = new Phaser.Signal();
        this.onLoadComplete = new Phaser.Signal();
        this.onPackComplete = new Phaser.Signal();
        this.onFileStart = new Phaser.Signal();
        this.onFileComplete = new Phaser.Signal();
        this.onFileError = new Phaser.Signal();
        this.useXDomainRequest = false;
        this._warnedAboutXDomainRequest = false;
        this.enableParallel = true;
        this.maxParallelDownloads = 4;
        this._withSyncPointDepth = 0;
        this._fileList = [];
        this._flightQueue = [];
        this._processingHead = 0;
        this._fileLoadStarted = false;
        this._totalPackCount = 0;
        this._totalFileCount = 0;
        this._loadedPackCount = 0;
        this._loadedFileCount = 0;
    };
    Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    Phaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    Phaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    Phaser.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    Phaser.Loader.PHYSICS_PHASER_JSON = 4;
    Phaser.Loader.prototype = {
        setPreloadSprite: function(sprite, direction) {
            direction = direction || 0;
            this.preloadSprite = {
                sprite: sprite,
                direction: direction,
                width: sprite.width,
                height: sprite.height,
                rect: null
            };
            if (direction === 0) {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, 1, sprite.height);
            } else {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, sprite.width, 1);
            }
            sprite.crop(this.preloadSprite.rect);
            sprite.visible = true;
        },
        resize: function() {
            if (this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height) {
                this.preloadSprite.rect.height = this.preloadSprite.sprite.height;
            }
        },
        checkKeyExists: function(type, key) {
            return this.getAssetIndex(type, key) > -1;
        },
        getAssetIndex: function(type, key) {
            var bestFound = -1;
            for (var i = 0; i < this._fileList.length; i++) {
                var file = this._fileList[i];
                if (file.type === type && file.key === key) {
                    bestFound = i;
                    if (!file.loaded && !file.loading) {
                        break;
                    }
                }
            }
            return bestFound;
        },
        getAsset: function(type, key) {
            var fileIndex = this.getAssetIndex(type, key);
            if (fileIndex > -1) {
                return {
                    index: fileIndex,
                    file: this._fileList[fileIndex]
                };
            }
            return false;
        },
        reset: function(hard, clearEvents) {
            if (clearEvents === undefined) {
                clearEvents = false;
            }
            if (this.resetLocked) {
                return;
            }
            if (hard) {
                this.preloadSprite = null;
            }
            this.isLoading = false;
            this._processingHead = 0;
            this._fileList.length = 0;
            this._flightQueue.length = 0;
            this._fileLoadStarted = false;
            this._totalFileCount = 0;
            this._totalPackCount = 0;
            this._loadedPackCount = 0;
            this._loadedFileCount = 0;
            if (clearEvents) {
                this.onLoadStart.removeAll();
                this.onLoadComplete.removeAll();
                this.onPackComplete.removeAll();
                this.onFileStart.removeAll();
                this.onFileComplete.removeAll();
                this.onFileError.removeAll();
            }
        },
        addToFileList: function(type, key, url, properties, overwrite, extension) {
            if (overwrite === undefined) {
                overwrite = false;
            }
            if (key === undefined || key === "") {
                console.warn("Phaser.Loader: Invalid or no key given of type " + type);
                return this;
            }
            if (url === undefined || url === null) {
                if (extension) {
                    url = key + extension;
                } else {
                    console.warn("Phaser.Loader: No URL given for file type: " + type + " key: " + key);
                    return this;
                }
            }
            var file = {
                type: type,
                key: key,
                path: this.path,
                url: url,
                syncPoint: this._withSyncPointDepth > 0,
                data: null,
                loading: false,
                loaded: false,
                error: false
            };
            if (properties) {
                for (var prop in properties) {
                    file[prop] = properties[prop];
                }
            }
            var fileIndex = this.getAssetIndex(type, key);
            if (overwrite && fileIndex > -1) {
                var currentFile = this._fileList[fileIndex];
                if (!currentFile.loading && !currentFile.loaded) {
                    this._fileList[fileIndex] = file;
                } else {
                    this._fileList.push(file);
                    this._totalFileCount++;
                }
            } else if (fileIndex === -1) {
                this._fileList.push(file);
                this._totalFileCount++;
            }
            return this;
        },
        replaceInFileList: function(type, key, url, properties) {
            return this.addToFileList(type, key, url, properties, true);
        },
        pack: function(key, url, data, callbackContext) {
            if (url === undefined) {
                url = null;
            }
            if (data === undefined) {
                data = null;
            }
            if (callbackContext === undefined) {
                callbackContext = null;
            }
            if (!url && !data) {
                console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
                return this;
            }
            var pack = {
                type: "packfile",
                key: key,
                url: url,
                path: this.path,
                syncPoint: true,
                data: null,
                loading: false,
                loaded: false,
                error: false,
                callbackContext: callbackContext
            };
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
                pack.data = data || {};
                pack.loaded = true;
            }
            for (var i = 0; i < this._fileList.length + 1; i++) {
                var file = this._fileList[i];
                if (!file || !file.loaded && !file.loading && file.type !== "packfile") {
                    this._fileList.splice(i, 1, pack);
                    this._totalPackCount++;
                    break;
                }
            }
            return this;
        },
        image: function(key, url, overwrite) {
            return this.addToFileList("image", key, url, undefined, overwrite, ".png");
        },
        images: function(keys, urls) {
            if (Array.isArray(urls)) {
                for (var i = 0; i < keys.length; i++) {
                    this.image(keys[i], urls[i]);
                }
            } else {
                for (var i = 0; i < keys.length; i++) {
                    this.image(keys[i]);
                }
            }
            return this;
        },
        text: function(key, url, overwrite) {
            return this.addToFileList("text", key, url, undefined, overwrite, ".txt");
        },
        json: function(key, url, overwrite) {
            return this.addToFileList("json", key, url, undefined, overwrite, ".json");
        },
        shader: function(key, url, overwrite) {
            return this.addToFileList("shader", key, url, undefined, overwrite, ".frag");
        },
        xml: function(key, url, overwrite) {
            return this.addToFileList("xml", key, url, undefined, overwrite, ".xml");
        },
        script: function(key, url, callback, callbackContext) {
            if (callback === undefined) {
                callback = false;
            }
            if (callback !== false && callbackContext === undefined) {
                callbackContext = this;
            }
            return this.addToFileList("script", key, url, {
                syncPoint: true,
                callback: callback,
                callbackContext: callbackContext
            }, false, ".js");
        },
        binary: function(key, url, callback, callbackContext) {
            if (callback === undefined) {
                callback = false;
            }
            if (callback !== false && callbackContext === undefined) {
                callbackContext = callback;
            }
            return this.addToFileList("binary", key, url, {
                callback: callback,
                callbackContext: callbackContext
            }, false, ".bin");
        },
        spritesheet: function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
            if (frameMax === undefined) {
                frameMax = -1;
            }
            if (margin === undefined) {
                margin = 0;
            }
            if (spacing === undefined) {
                spacing = 0;
            }
            return this.addToFileList("spritesheet", key, url, {
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                frameMax: frameMax,
                margin: margin,
                spacing: spacing
            }, false, ".png");
        },
        audio: function(key, urls, autoDecode) {
            if (this.game.sound.noAudio) {
                return this;
            }
            if (autoDecode === undefined) {
                autoDecode = true;
            }
            if (typeof urls === "string") {
                urls = [ urls ];
            }
            return this.addToFileList("audio", key, urls, {
                buffer: null,
                autoDecode: autoDecode
            });
        },
        audiosprite: function(key, urls, jsonURL, jsonData, autoDecode) {
            if (this.game.sound.noAudio) {
                return this;
            }
            if (jsonURL === undefined) {
                jsonURL = null;
            }
            if (jsonData === undefined) {
                jsonData = null;
            }
            if (autoDecode === undefined) {
                autoDecode = true;
            }
            this.audio(key, urls, autoDecode);
            if (jsonURL) {
                this.json(key + "-audioatlas", jsonURL);
            } else if (jsonData) {
                if (typeof jsonData === "string") {
                    jsonData = JSON.parse(jsonData);
                }
                this.cache.addJSON(key + "-audioatlas", "", jsonData);
            } else {
                console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object");
            }
            return this;
        },
        video: function(key, urls, loadEvent, asBlob) {
            if (loadEvent === undefined) {
                if (this.game.device.firefox) {
                    loadEvent = "loadeddata";
                } else {
                    loadEvent = "canplaythrough";
                }
            }
            if (asBlob === undefined) {
                asBlob = false;
            }
            if (typeof urls === "string") {
                urls = [ urls ];
            }
            return this.addToFileList("video", key, urls, {
                buffer: null,
                asBlob: asBlob,
                loadEvent: loadEvent
            });
        },
        tilemap: function(key, url, data, format) {
            if (url === undefined) {
                url = null;
            }
            if (data === undefined) {
                data = null;
            }
            if (format === undefined) {
                format = Phaser.Tilemap.CSV;
            }
            if (!url && !data) {
                if (format === Phaser.Tilemap.CSV) {
                    url = key + ".csv";
                } else {
                    url = key + ".json";
                }
            }
            if (data) {
                switch (format) {
                  case Phaser.Tilemap.CSV:
                    break;

                  case Phaser.Tilemap.TILED_JSON:
                    if (typeof data === "string") {
                        data = JSON.parse(data);
                    }
                    break;
                }
                this.cache.addTilemap(key, null, data, format);
            } else {
                this.addToFileList("tilemap", key, url, {
                    format: format
                });
            }
            return this;
        },
        physics: function(key, url, data, format) {
            if (url === undefined) {
                url = null;
            }
            if (data === undefined) {
                data = null;
            }
            if (format === undefined) {
                format = Phaser.Physics.LIME_CORONA_JSON;
            }
            if (!url && !data) {
                url = key + ".json";
            }
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
                this.cache.addPhysicsData(key, null, data, format);
            } else {
                this.addToFileList("physics", key, url, {
                    format: format
                });
            }
            return this;
        },
        bitmapFont: function(key, textureURL, atlasURL, atlasData, xSpacing, ySpacing) {
            if (textureURL === undefined || textureURL === null) {
                textureURL = key + ".png";
            }
            if (atlasURL === undefined) {
                atlasURL = null;
            }
            if (atlasData === undefined) {
                atlasData = null;
            }
            if (xSpacing === undefined) {
                xSpacing = 0;
            }
            if (ySpacing === undefined) {
                ySpacing = 0;
            }
            if (atlasURL) {
                this.addToFileList("bitmapfont", key, textureURL, {
                    atlasURL: atlasURL,
                    xSpacing: xSpacing,
                    ySpacing: ySpacing
                });
            } else {
                if (typeof atlasData === "string") {
                    var json, xml;
                    try {
                        json = JSON.parse(atlasData);
                    } catch (e) {
                        xml = this.parseXml(atlasData);
                    }
                    if (!xml && !json) {
                        throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    }
                    this.addToFileList("bitmapfont", key, textureURL, {
                        atlasURL: null,
                        atlasData: json || xml,
                        atlasType: !!json ? "json" : "xml",
                        xSpacing: xSpacing,
                        ySpacing: ySpacing
                    });
                }
            }
            return this;
        },
        atlasJSONArray: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function(key, textureURL, atlasURL, atlasData) {
            if (atlasURL === undefined) {
                atlasURL = null;
            }
            if (atlasData === undefined) {
                atlasData = null;
            }
            if (!atlasURL && !atlasData) {
                atlasURL = key + ".xml";
            }
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function(key, textureURL, atlasURL, atlasData, format) {
            if (textureURL === undefined || textureURL === null) {
                textureURL = key + ".png";
            }
            if (atlasURL === undefined) {
                atlasURL = null;
            }
            if (atlasData === undefined) {
                atlasData = null;
            }
            if (format === undefined) {
                format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY;
            }
            if (!atlasURL && !atlasData) {
                if (format === Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                    atlasURL = key + ".xml";
                } else {
                    atlasURL = key + ".json";
                }
            }
            if (atlasURL) {
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: atlasURL,
                    format: format
                });
            } else {
                switch (format) {
                  case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    if (typeof atlasData === "string") {
                        atlasData = JSON.parse(atlasData);
                    }
                    break;

                  case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if (typeof atlasData === "string") {
                        var xml = this.parseXml(atlasData);
                        if (!xml) {
                            throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        }
                        atlasData = xml;
                    }
                    break;
                }
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: null,
                    atlasData: atlasData,
                    format: format
                });
            }
            return this;
        },
        withSyncPoint: function(callback, callbackContext) {
            this._withSyncPointDepth++;
            try {
                callback.call(callbackContext || this, this);
            } finally {
                this._withSyncPointDepth--;
            }
            return this;
        },
        addSyncPoint: function(type, key) {
            var asset = this.getAsset(type, key);
            if (asset) {
                asset.file.syncPoint = true;
            }
            return this;
        },
        removeFile: function(type, key) {
            var asset = this.getAsset(type, key);
            if (asset) {
                if (!asset.loaded && !asset.loading) {
                    this._fileList.splice(asset.index, 1);
                }
            }
        },
        removeAll: function() {
            this._fileList.length = 0;
            this._flightQueue.length = 0;
        },
        start: function() {
            if (this.isLoading) {
                return;
            }
            this.hasLoaded = false;
            this.isLoading = true;
            this.updateProgress();
            this.processLoadQueue();
        },
        processLoadQueue: function() {
            if (!this.isLoading) {
                console.warn("Phaser.Loader - active loading canceled / reset");
                this.finishedLoading(true);
                return;
            }
            for (var i = 0; i < this._flightQueue.length; i++) {
                var file = this._flightQueue[i];
                if (file.loaded || file.error) {
                    this._flightQueue.splice(i, 1);
                    i--;
                    file.loading = false;
                    file.requestUrl = null;
                    file.requestObject = null;
                    if (file.error) {
                        this.onFileError.dispatch(file.key, file);
                    }
                    if (file.type !== "packfile") {
                        this._loadedFileCount++;
                        this.onFileComplete.dispatch(this.progress, file.key, !file.error, this._loadedFileCount, this._totalFileCount);
                    } else if (file.type === "packfile" && file.error) {
                        this._loadedPackCount++;
                        this.onPackComplete.dispatch(file.key, !file.error, this._loadedPackCount, this._totalPackCount);
                    }
                }
            }
            var syncblock = false;
            var inflightLimit = this.enableParallel ? Phaser.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
            for (var i = this._processingHead; i < this._fileList.length; i++) {
                var file = this._fileList[i];
                if (file.type === "packfile" && !file.error && file.loaded && i === this._processingHead) {
                    this.processPack(file);
                    this._loadedPackCount++;
                    this.onPackComplete.dispatch(file.key, !file.error, this._loadedPackCount, this._totalPackCount);
                }
                if (file.loaded || file.error) {
                    if (i === this._processingHead) {
                        this._processingHead = i + 1;
                    }
                } else if (!file.loading && this._flightQueue.length < inflightLimit) {
                    if (file.type === "packfile" && !file.data) {
                        this._flightQueue.push(file);
                        file.loading = true;
                        this.loadFile(file);
                    } else if (!syncblock) {
                        if (!this._fileLoadStarted) {
                            this._fileLoadStarted = true;
                            this.onLoadStart.dispatch();
                        }
                        this._flightQueue.push(file);
                        file.loading = true;
                        this.onFileStart.dispatch(this.progress, file.key, file.url);
                        this.loadFile(file);
                    }
                }
                if (!file.loaded && file.syncPoint) {
                    syncblock = true;
                }
                if (this._flightQueue.length >= inflightLimit || syncblock && this._loadedPackCount === this._totalPackCount) {
                    break;
                }
            }
            this.updateProgress();
            if (this._processingHead >= this._fileList.length) {
                this.finishedLoading();
            } else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var _this = this;
                setTimeout(function() {
                    _this.finishedLoading(true);
                }, 2e3);
            }
        },
        finishedLoading: function(abnormal) {
            if (this.hasLoaded) {
                return;
            }
            this.hasLoaded = true;
            this.isLoading = false;
            if (!abnormal && !this._fileLoadStarted) {
                this._fileLoadStarted = true;
                this.onLoadStart.dispatch();
            }
            this.onLoadComplete.dispatch();
            this.reset();
            this.game.state.loadComplete();
        },
        asyncComplete: function(file, errorMessage) {
            if (errorMessage === undefined) {
                errorMessage = "";
            }
            file.loaded = true;
            file.error = !!errorMessage;
            if (errorMessage) {
                file.errorMessage = errorMessage;
                console.warn("Phaser.Loader - " + file.type + "[" + file.key + "]" + ": " + errorMessage);
            }
            this.processLoadQueue();
        },
        processPack: function(pack) {
            var packData = pack.data[pack.key];
            if (!packData) {
                console.warn("Phaser.Loader - " + pack.key + ": pack has data, but not for pack key");
                return;
            }
            for (var i = 0; i < packData.length; i++) {
                var file = packData[i];
                switch (file.type) {
                  case "image":
                    this.image(file.key, file.url, file.overwrite);
                    break;

                  case "text":
                    this.text(file.key, file.url, file.overwrite);
                    break;

                  case "json":
                    this.json(file.key, file.url, file.overwrite);
                    break;

                  case "xml":
                    this.xml(file.key, file.url, file.overwrite);
                    break;

                  case "script":
                    this.script(file.key, file.url, file.callback, pack.callbackContext || this);
                    break;

                  case "binary":
                    this.binary(file.key, file.url, file.callback, pack.callbackContext || this);
                    break;

                  case "spritesheet":
                    this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                    break;

                  case "video":
                    this.video(file.key, file.urls);
                    break;

                  case "audio":
                    this.audio(file.key, file.urls, file.autoDecode);
                    break;

                  case "audiosprite":
                    this.audiosprite(file.key, file.urls, file.jsonURL, file.jsonData, file.autoDecode);
                    break;

                  case "tilemap":
                    this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);
                    break;

                  case "physics":
                    this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);
                    break;

                  case "bitmapFont":
                    this.bitmapFont(file.key, file.textureURL, file.atlasURL, file.atlasData, file.xSpacing, file.ySpacing);
                    break;

                  case "atlasJSONArray":
                    this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);
                    break;

                  case "atlasJSONHash":
                    this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);
                    break;

                  case "atlasXML":
                    this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);
                    break;

                  case "atlas":
                    this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);
                    break;

                  case "shader":
                    this.shader(file.key, file.url, file.overwrite);
                    break;
                }
            }
        },
        transformUrl: function(url, file) {
            if (!url) {
                return false;
            }
            if (url.substr(0, 4) === "http" || url.substr(0, 2) === "//") {
                return url;
            } else {
                return this.baseURL + file.path + url;
            }
        },
        loadFile: function(file) {
            switch (file.type) {
              case "packfile":
                this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.fileComplete);
                break;

              case "image":
              case "spritesheet":
              case "textureatlas":
              case "bitmapfont":
                this.loadImageTag(file);
                break;

              case "audio":
                file.url = this.getAudioURL(file.url);
                if (file.url) {
                    if (this.game.sound.usingWebAudio) {
                        this.xhrLoad(file, this.transformUrl(file.url, file), "arraybuffer", this.fileComplete);
                    } else if (this.game.sound.usingAudioTag) {
                        this.loadAudioTag(file);
                    }
                } else {
                    this.fileError(file, null, "No supported audio URL specified or device does not have audio playback support");
                }
                break;

              case "video":
                file.url = this.getVideoURL(file.url);
                if (file.url) {
                    if (file.asBlob) {
                        this.xhrLoad(file, this.transformUrl(file.url, file), "arraybuffer", this.fileComplete);
                    } else {
                        this.loadVideoTag(file);
                    }
                } else {
                    this.fileError(file, null, "No supported video URL specified or device does not have video playback support");
                }
                break;

              case "json":
                this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.jsonLoadComplete);
                break;

              case "xml":
                this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.xmlLoadComplete);
                break;

              case "tilemap":
                if (file.format === Phaser.Tilemap.TILED_JSON) {
                    this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.jsonLoadComplete);
                } else if (file.format === Phaser.Tilemap.CSV) {
                    this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.csvLoadComplete);
                } else {
                    this.asyncComplete(file, "invalid Tilemap format: " + file.format);
                }
                break;

              case "text":
              case "script":
              case "shader":
              case "physics":
                this.xhrLoad(file, this.transformUrl(file.url, file), "text", this.fileComplete);
                break;

              case "binary":
                this.xhrLoad(file, this.transformUrl(file.url, file), "arraybuffer", this.fileComplete);
                break;
            }
        },
        loadImageTag: function(file) {
            var _this = this;
            file.data = new Image();
            file.data.name = file.key;
            if (this.crossOrigin) {
                file.data.crossOrigin = this.crossOrigin;
            }
            file.data.onload = function() {
                if (file.data.onload) {
                    file.data.onload = null;
                    file.data.onerror = null;
                    _this.fileComplete(file);
                }
            };
            file.data.onerror = function() {
                if (file.data.onload) {
                    file.data.onload = null;
                    file.data.onerror = null;
                    _this.fileError(file);
                }
            };
            file.data.src = this.transformUrl(file.url, file);
            if (file.data.complete && file.data.width && file.data.height) {
                file.data.onload = null;
                file.data.onerror = null;
                this.fileComplete(file);
            }
        },
        loadVideoTag: function(file) {
            var _this = this;
            file.data = document.createElement("video");
            file.data.name = file.key;
            file.data.controls = false;
            file.data.autoplay = false;
            var videoLoadEvent = function() {
                file.data.removeEventListener(file.loadEvent, videoLoadEvent, false);
                file.data.onerror = null;
                file.data.canplay = true;
                Phaser.GAMES[_this.game.id].load.fileComplete(file);
            };
            file.data.onerror = function() {
                file.data.removeEventListener(file.loadEvent, videoLoadEvent, false);
                file.data.onerror = null;
                file.data.canplay = false;
                _this.fileError(file);
            };
            file.data.addEventListener(file.loadEvent, videoLoadEvent, false);
            file.data.src = this.transformUrl(file.url, file);
            file.data.load();
        },
        loadAudioTag: function(file) {
            var _this = this;
            if (this.game.sound.touchLocked) {
                file.data = new Audio();
                file.data.name = file.key;
                file.data.preload = "auto";
                file.data.src = this.transformUrl(file.url, file);
                this.fileComplete(file);
            } else {
                file.data = new Audio();
                file.data.name = file.key;
                var playThroughEvent = function() {
                    file.data.removeEventListener("canplaythrough", playThroughEvent, false);
                    file.data.onerror = null;
                    Phaser.GAMES[_this.game.id].load.fileComplete(file);
                };
                file.data.onerror = function() {
                    file.data.removeEventListener("canplaythrough", playThroughEvent, false);
                    file.data.onerror = null;
                    _this.fileError(file);
                };
                file.data.preload = "auto";
                file.data.src = this.transformUrl(file.url, file);
                file.data.addEventListener("canplaythrough", playThroughEvent, false);
                file.data.load();
            }
        },
        xhrLoad: function(file, url, type, onload, onerror) {
            if (this.useXDomainRequest && window.XDomainRequest) {
                this.xhrLoadWithXDR(file, url, type, onload, onerror);
                return;
            }
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = type;
            onerror = onerror || this.fileError;
            var _this = this;
            xhr.onload = function() {
                try {
                    return onload.call(_this, file, xhr);
                } catch (e) {
                    if (!_this.hasLoaded) {
                        _this.asyncComplete(file, e.message || "Exception");
                    } else {
                        if (window["console"]) {
                            console.error(e);
                        }
                    }
                }
            };
            xhr.onerror = function() {
                try {
                    return onerror.call(_this, file, xhr);
                } catch (e) {
                    if (!_this.hasLoaded) {
                        _this.asyncComplete(file, e.message || "Exception");
                    } else {
                        if (window["console"]) {
                            console.error(e);
                        }
                    }
                }
            };
            file.requestObject = xhr;
            file.requestUrl = url;
            xhr.send();
        },
        xhrLoadWithXDR: function(file, url, type, onload, onerror) {
            if (!this._warnedAboutXDomainRequest && (!this.game.device.ie || this.game.device.ieVersion >= 10)) {
                this._warnedAboutXDomainRequest = true;
                console.warn("Phaser.Loader - using XDomainRequest outside of IE 9");
            }
            var xhr = new window.XDomainRequest();
            xhr.open("GET", url, true);
            xhr.responseType = type;
            xhr.timeout = 3e3;
            onerror = onerror || this.fileError;
            var _this = this;
            xhr.onerror = function() {
                try {
                    return onerror.call(_this, file, xhr);
                } catch (e) {
                    _this.asyncComplete(file, e.message || "Exception");
                }
            };
            xhr.ontimeout = function() {
                try {
                    return onerror.call(_this, file, xhr);
                } catch (e) {
                    _this.asyncComplete(file, e.message || "Exception");
                }
            };
            xhr.onprogress = function() {};
            xhr.onload = function() {
                try {
                    return onload.call(_this, file, xhr);
                } catch (e) {
                    _this.asyncComplete(file, e.message || "Exception");
                }
            };
            file.requestObject = xhr;
            file.requestUrl = url;
            setTimeout(function() {
                xhr.send();
            }, 0);
        },
        getVideoURL: function(urls) {
            for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                var videoType;
                if (url.uri) {
                    url = url.uri;
                    videoType = url.type;
                } else {
                    if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
                        return url;
                    }
                    if (url.indexOf("?") >= 0) {
                        url = url.substr(0, url.indexOf("?"));
                    }
                    var extension = url.substr((Math.max(0, url.lastIndexOf(".")) || Infinity) + 1);
                    videoType = extension.toLowerCase();
                }
                if (this.game.device.canPlayVideo(videoType)) {
                    return urls[i];
                }
            }
            return null;
        },
        getAudioURL: function(urls) {
            if (this.game.sound.noAudio) {
                return null;
            }
            for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                var audioType;
                if (url.uri) {
                    url = url.uri;
                    audioType = url.type;
                } else {
                    if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
                        return url;
                    }
                    if (url.indexOf("?") >= 0) {
                        url = url.substr(0, url.indexOf("?"));
                    }
                    var extension = url.substr((Math.max(0, url.lastIndexOf(".")) || Infinity) + 1);
                    audioType = extension.toLowerCase();
                }
                if (this.game.device.canPlayAudio(audioType)) {
                    return urls[i];
                }
            }
            return null;
        },
        fileError: function(file, xhr, reason) {
            var url = file.requestUrl || this.transformUrl(file.url, file);
            var message = "error loading asset from URL " + url;
            if (!reason && xhr) {
                reason = xhr.status;
            }
            if (reason) {
                message = message + " (" + reason + ")";
            }
            this.asyncComplete(file, message);
        },
        fileComplete: function(file, xhr) {
            var loadNext = true;
            switch (file.type) {
              case "packfile":
                var data = JSON.parse(xhr.responseText);
                file.data = data || {};
                break;

              case "image":
                this.cache.addImage(file.key, file.url, file.data);
                break;

              case "spritesheet":
                this.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                break;

              case "textureatlas":
                if (file.atlasURL == null) {
                    this.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format);
                } else {
                    loadNext = false;
                    if (file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) {
                        this.xhrLoad(file, this.transformUrl(file.atlasURL, file), "text", this.jsonLoadComplete);
                    } else if (file.format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                        this.xhrLoad(file, this.transformUrl(file.atlasURL, file), "text", this.xmlLoadComplete);
                    } else {
                        throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + file.format);
                    }
                }
                break;

              case "bitmapfont":
                if (!file.atlasURL) {
                    this.cache.addBitmapFont(file.key, file.url, file.data, file.atlasData, file.atlasType, file.xSpacing, file.ySpacing);
                } else {
                    loadNext = false;
                    this.xhrLoad(file, this.transformUrl(file.atlasURL, file), "text", function(file, xhr) {
                        var json;
                        try {
                            json = JSON.parse(xhr.responseText);
                        } catch (e) {}
                        if (!!json) {
                            file.atlasType = "json";
                            this.jsonLoadComplete(file, xhr);
                        } else {
                            file.atlasType = "xml";
                            this.xmlLoadComplete(file, xhr);
                        }
                    });
                }
                break;

              case "video":
                if (file.asBlob) {
                    try {
                        file.data = new Blob([ new Uint8Array(xhr.response) ]);
                    } catch (e) {
                        throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + file.key);
                    }
                }
                this.cache.addVideo(file.key, file.url, file.data, file.asBlob);
                break;

              case "audio":
                if (this.game.sound.usingWebAudio) {
                    file.data = xhr.response;
                    this.cache.addSound(file.key, file.url, file.data, true, false);
                    if (file.autoDecode) {
                        this.game.sound.decode(file.key);
                    }
                } else {
                    this.cache.addSound(file.key, file.url, file.data, false, true);
                }
                break;

              case "text":
                file.data = xhr.responseText;
                this.cache.addText(file.key, file.url, file.data);
                break;

              case "shader":
                file.data = xhr.responseText;
                this.cache.addShader(file.key, file.url, file.data);
                break;

              case "physics":
                var data = JSON.parse(xhr.responseText);
                this.cache.addPhysicsData(file.key, file.url, data, file.format);
                break;

              case "script":
                file.data = document.createElement("script");
                file.data.language = "javascript";
                file.data.type = "text/javascript";
                file.data.defer = false;
                file.data.text = xhr.responseText;
                document.head.appendChild(file.data);
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, xhr.responseText);
                }
                break;

              case "binary":
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, xhr.response);
                } else {
                    file.data = xhr.response;
                }
                this.cache.addBinary(file.key, file.data);
                break;
            }
            if (loadNext) {
                this.asyncComplete(file);
            }
        },
        jsonLoadComplete: function(file, xhr) {
            var data = JSON.parse(xhr.responseText);
            if (file.type === "tilemap") {
                this.cache.addTilemap(file.key, file.url, data, file.format);
            } else if (file.type === "bitmapfont") {
                this.cache.addBitmapFont(file.key, file.url, file.data, data, file.atlasType, file.xSpacing, file.ySpacing);
            } else if (file.type === "json") {
                this.cache.addJSON(file.key, file.url, data);
            } else {
                this.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);
            }
            this.asyncComplete(file);
        },
        csvLoadComplete: function(file, xhr) {
            var data = xhr.responseText;
            this.cache.addTilemap(file.key, file.url, data, file.format);
            this.asyncComplete(file);
        },
        xmlLoadComplete: function(file, xhr) {
            var data = xhr.responseText;
            var xml = this.parseXml(data);
            if (!xml) {
                var responseType = xhr.responseType || xhr.contentType;
                console.warn("Phaser.Loader - " + file.key + ": invalid XML (" + responseType + ")");
                this.asyncComplete(file, "invalid XML");
                return;
            }
            if (file.type === "bitmapfont") {
                this.cache.addBitmapFont(file.key, file.url, file.data, xml, file.atlasType, file.xSpacing, file.ySpacing);
            } else if (file.type === "textureatlas") {
                this.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);
            } else if (file.type === "xml") {
                this.cache.addXML(file.key, file.url, xml);
            }
            this.asyncComplete(file);
        },
        parseXml: function(data) {
            var xml;
            try {
                if (window["DOMParser"]) {
                    var domparser = new DOMParser();
                    xml = domparser.parseFromString(data, "text/xml");
                } else {
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = null;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                return null;
            } else {
                return xml;
            }
        },
        updateProgress: function() {
            if (this.preloadSprite) {
                if (this.preloadSprite.direction === 0) {
                    this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
                } else {
                    this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
                }
                if (this.preloadSprite.sprite) {
                    this.preloadSprite.sprite.updateCrop();
                } else {
                    this.preloadSprite = null;
                }
            }
        },
        totalLoadedFiles: function() {
            return this._loadedFileCount;
        },
        totalQueuedFiles: function() {
            return this._totalFileCount - this._loadedFileCount;
        },
        totalLoadedPacks: function() {
            return this._totalPackCount;
        },
        totalQueuedPacks: function() {
            return this._totalPackCount - this._loadedPackCount;
        }
    };
    Object.defineProperty(Phaser.Loader.prototype, "progressFloat", {
        get: function() {
            var progress = this._loadedFileCount / this._totalFileCount * 100;
            return Phaser.Math.clamp(progress || 0, 0, 100);
        }
    });
    Object.defineProperty(Phaser.Loader.prototype, "progress", {
        get: function() {
            return Math.round(this.progressFloat);
        }
    });
    Phaser.Loader.prototype.constructor = Phaser.Loader;
    Phaser.LoaderParser = {
        bitmapFont: function(xml, baseTexture, xSpacing, ySpacing) {
            return this.xmlBitmapFont(xml, baseTexture, xSpacing, ySpacing);
        },
        xmlBitmapFont: function(xml, baseTexture, xSpacing, ySpacing) {
            var data = {};
            var info = xml.getElementsByTagName("info")[0];
            var common = xml.getElementsByTagName("common")[0];
            data.font = info.getAttribute("face");
            data.size = parseInt(info.getAttribute("size"), 10);
            data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10) + ySpacing;
            data.chars = {};
            var letters = xml.getElementsByTagName("char");
            for (var i = 0; i < letters.length; i++) {
                var charCode = parseInt(letters[i].getAttribute("id"), 10);
                data.chars[charCode] = {
                    x: parseInt(letters[i].getAttribute("x"), 10),
                    y: parseInt(letters[i].getAttribute("y"), 10),
                    width: parseInt(letters[i].getAttribute("width"), 10),
                    height: parseInt(letters[i].getAttribute("height"), 10),
                    xOffset: parseInt(letters[i].getAttribute("xoffset"), 10),
                    yOffset: parseInt(letters[i].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10) + xSpacing,
                    kerning: {}
                };
            }
            var kernings = xml.getElementsByTagName("kerning");
            for (i = 0; i < kernings.length; i++) {
                var first = parseInt(kernings[i].getAttribute("first"), 10);
                var second = parseInt(kernings[i].getAttribute("second"), 10);
                var amount = parseInt(kernings[i].getAttribute("amount"), 10);
                data.chars[second].kerning[first] = amount;
            }
            return this.finalizeBitmapFont(baseTexture, data);
        },
        jsonBitmapFont: function(json, baseTexture, xSpacing, ySpacing) {
            var data = {
                font: json.font.info._face,
                size: parseInt(json.font.info._size, 10),
                lineHeight: parseInt(json.font.common._lineHeight, 10) + ySpacing,
                chars: {}
            };
            json.font.chars["char"].forEach(function parseChar(letter) {
                var charCode = parseInt(letter._id, 10);
                data.chars[charCode] = {
                    x: parseInt(letter._x, 10),
                    y: parseInt(letter._y, 10),
                    width: parseInt(letter._width, 10),
                    height: parseInt(letter._height, 10),
                    xOffset: parseInt(letter._xoffset, 10),
                    yOffset: parseInt(letter._yoffset, 10),
                    xAdvance: parseInt(letter._xadvance, 10) + xSpacing,
                    kerning: {}
                };
            });
            if (json.font.kernings && json.font.kernings.kerning) {
                json.font.kernings.kerning.forEach(function parseKerning(kerning) {
                    data.chars[kerning._second].kerning[kerning._first] = parseInt(kerning._amount, 10);
                });
            }
            return this.finalizeBitmapFont(baseTexture, data);
        },
        finalizeBitmapFont: function(baseTexture, bitmapFontData) {
            Object.keys(bitmapFontData.chars).forEach(function addTexture(charCode) {
                var letter = bitmapFontData.chars[charCode];
                letter.texture = new PIXI.Texture(baseTexture, new Phaser.Rectangle(letter.x, letter.y, letter.width, letter.height));
            });
            return bitmapFontData;
        }
    };
    Phaser.AudioSprite = function(game, key) {
        this.game = game;
        this.key = key;
        this.config = this.game.cache.getJSON(key + "-audioatlas");
        this.autoplayKey = null;
        this.autoplay = false;
        this.sounds = {};
        for (var k in this.config.spritemap) {
            var marker = this.config.spritemap[k];
            var sound = this.game.add.sound(this.key);
            sound.addMarker(k, marker.start, marker.end - marker.start, null, marker.loop);
            this.sounds[k] = sound;
        }
        if (this.config.autoplay) {
            this.autoplayKey = this.config.autoplay;
            this.play(this.autoplayKey);
            this.autoplay = this.sounds[this.autoplayKey];
        }
    };
    Phaser.AudioSprite.prototype = {
        play: function(marker, volume) {
            if (volume === undefined) {
                volume = 1;
            }
            return this.sounds[marker].play(marker, null, volume);
        },
        stop: function(marker) {
            if (!marker) {
                for (var key in this.sounds) {
                    this.sounds[key].stop();
                }
            } else {
                this.sounds[marker].stop();
            }
        },
        get: function(marker) {
            return this.sounds[marker];
        }
    };
    Phaser.AudioSprite.prototype.constructor = Phaser.AudioSprite;
    Phaser.Sound = function(game, key, volume, loop, connect) {
        if (volume === undefined) {
            volume = 1;
        }
        if (loop === undefined) {
            loop = false;
        }
        if (connect === undefined) {
            connect = game.sound.connectToMaster;
        }
        this.game = game;
        this.name = key;
        this.key = key;
        this.loop = loop;
        this.volume = volume;
        this.markers = {};
        this.context = null;
        this.autoplay = false;
        this.totalDuration = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.duration = 0;
        this.durationMS = 0;
        this.position = 0;
        this.stopTime = 0;
        this.paused = false;
        this.pausedPosition = 0;
        this.pausedTime = 0;
        this.isPlaying = false;
        this.currentMarker = "";
        this.fadeTween = null;
        this.pendingPlayback = false;
        this.override = false;
        this.allowMultiple = false;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        this.externalNode = null;
        this.masterGainNode = null;
        this.gainNode = null;
        this._sound = null;
        if (this.usingWebAudio) {
            this.context = this.game.sound.context;
            this.masterGainNode = this.game.sound.masterGain;
            if (this.context.createGain === undefined) {
                this.gainNode = this.context.createGainNode();
            } else {
                this.gainNode = this.context.createGain();
            }
            this.gainNode.gain.value = volume * this.game.sound.volume;
            if (connect) {
                this.gainNode.connect(this.masterGainNode);
            }
        } else if (this.usingAudioTag) {
            if (this.game.cache.getSound(key) && this.game.cache.isSoundReady(key)) {
                this._sound = this.game.cache.getSoundData(key);
                this.totalDuration = 0;
                if (this._sound.duration) {
                    this.totalDuration = this._sound.duration;
                }
            } else {
                this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
            }
        }
        this.onDecoded = new Phaser.Signal();
        this.onPlay = new Phaser.Signal();
        this.onPause = new Phaser.Signal();
        this.onResume = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onStop = new Phaser.Signal();
        this.onMute = new Phaser.Signal();
        this.onMarkerComplete = new Phaser.Signal();
        this.onFadeComplete = new Phaser.Signal();
        this._volume = volume;
        this._buffer = null;
        this._muted = false;
        this._tempMarker = 0;
        this._tempPosition = 0;
        this._tempVolume = 0;
        this._muteVolume = 0;
        this._tempLoop = 0;
        this._paused = false;
        this._onDecodedEventDispatched = false;
    };
    Phaser.Sound.prototype = {
        soundHasUnlocked: function(key) {
            if (key === this.key) {
                this._sound = this.game.cache.getSoundData(this.key);
                this.totalDuration = this._sound.duration;
            }
        },
        addMarker: function(name, start, duration, volume, loop) {
            if (volume === undefined || volume === null) {
                volume = 1;
            }
            if (loop === undefined) {
                loop = false;
            }
            this.markers[name] = {
                name: name,
                start: start,
                stop: start + duration,
                volume: volume,
                duration: duration,
                durationMS: duration * 1e3,
                loop: loop
            };
        },
        removeMarker: function(name) {
            delete this.markers[name];
        },
        onEndedHandler: function() {
            this.isPlaying = false;
            this.stop();
        },
        update: function() {
            if (!this.game.cache.checkSoundKey(this.key)) {
                this.destroy();
                return;
            }
            if (this.isDecoded && !this._onDecodedEventDispatched) {
                this.onDecoded.dispatch(this);
                this._onDecodedEventDispatched = true;
            }
            if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
                this.pendingPlayback = false;
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
            }
            if (this.isPlaying) {
                this.currentTime = this.game.time.time - this.startTime;
                if (this.currentTime >= this.durationMS) {
                    if (this.usingWebAudio) {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            if (this.currentMarker === "") {
                                this.currentTime = 0;
                                this.startTime = this.game.time.time;
                            } else {
                                this.onMarkerComplete.dispatch(this.currentMarker, this);
                                this.play(this.currentMarker, 0, this.volume, true, true);
                            }
                        } else {
                            if (this.currentMarker !== "") {
                                this.stop();
                            }
                        }
                    } else {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            this.play(this.currentMarker, 0, this.volume, true, true);
                        } else {
                            this.stop();
                        }
                    }
                }
            }
        },
        loopFull: function(volume) {
            this.play(null, 0, volume, true);
        },
        play: function(marker, position, volume, loop, forceRestart) {
            if (marker === undefined || marker === false || marker === null) {
                marker = "";
            }
            if (forceRestart === undefined) {
                forceRestart = true;
            }
            if (this.isPlaying && !this.allowMultiple && !forceRestart && !this.override) {
                return this;
            }
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || forceRestart)) {
                if (this.usingWebAudio) {
                    if (this.externalNode) {
                        this._sound.disconnect(this.externalNode);
                    } else {
                        this._sound.disconnect(this.gainNode);
                    }
                    if (this._sound.stop === undefined) {
                        this._sound.noteOff(0);
                    } else {
                        try {
                            this._sound.stop(0);
                        } catch (e) {}
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            if (marker === "" && Object.keys(this.markers).length > 0) {
                return this;
            }
            if (marker !== "") {
                this.currentMarker = marker;
                if (this.markers[marker]) {
                    this.position = this.markers[marker].start;
                    this.volume = this.markers[marker].volume;
                    this.loop = this.markers[marker].loop;
                    this.duration = this.markers[marker].duration;
                    this.durationMS = this.markers[marker].durationMS;
                    if (typeof volume !== "undefined") {
                        this.volume = volume;
                    }
                    if (typeof loop !== "undefined") {
                        this.loop = loop;
                    }
                    this._tempMarker = marker;
                    this._tempPosition = this.position;
                    this._tempVolume = this.volume;
                    this._tempLoop = this.loop;
                } else {
                    return this;
                }
            } else {
                position = position || 0;
                if (volume === undefined) {
                    volume = this._volume;
                }
                if (loop === undefined) {
                    loop = this.loop;
                }
                this.position = position;
                this.volume = volume;
                this.loop = loop;
                this.duration = 0;
                this.durationMS = 0;
                this._tempMarker = marker;
                this._tempPosition = position;
                this._tempVolume = volume;
                this._tempLoop = loop;
            }
            if (this.usingWebAudio) {
                if (this.game.cache.isSoundDecoded(this.key)) {
                    this._sound = this.context.createBufferSource();
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    this._buffer = this.game.cache.getSoundData(this.key);
                    this._sound.buffer = this._buffer;
                    if (this.loop && marker === "") {
                        this._sound.loop = true;
                    }
                    if (!this.loop && marker === "") {
                        this._sound.onended = this.onEndedHandler.bind(this);
                    }
                    this.totalDuration = this._sound.buffer.duration;
                    if (this.duration === 0) {
                        this.duration = this.totalDuration;
                        this.durationMS = Math.ceil(this.totalDuration * 1e3);
                    }
                    if (this._sound.start === undefined) {
                        this._sound.noteGrainOn(0, this.position, this.duration);
                    } else {
                        if (this.loop && marker === "") {
                            this._sound.start(0, 0);
                        } else {
                            this._sound.start(0, this.position, this.duration);
                        }
                    }
                    this.isPlaying = true;
                    this.startTime = this.game.time.time;
                    this.currentTime = 0;
                    this.stopTime = this.startTime + this.durationMS;
                    this.onPlay.dispatch(this);
                } else {
                    this.pendingPlayback = true;
                    if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false) {
                        this.game.sound.decode(this.key, this);
                    }
                }
            } else {
                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
                    this.game.cache.reloadSound(this.key);
                    this.pendingPlayback = true;
                } else {
                    if (this._sound && (this.game.device.cocoonJS || this._sound.readyState === 4)) {
                        this._sound.play();
                        this.totalDuration = this._sound.duration;
                        if (this.duration === 0) {
                            this.duration = this.totalDuration;
                            this.durationMS = this.totalDuration * 1e3;
                        }
                        this._sound.currentTime = this.position;
                        this._sound.muted = this._muted;
                        if (this._muted) {
                            this._sound.volume = 0;
                        } else {
                            this._sound.volume = this._volume;
                        }
                        this.isPlaying = true;
                        this.startTime = this.game.time.time;
                        this.currentTime = 0;
                        this.stopTime = this.startTime + this.durationMS;
                        this.onPlay.dispatch(this);
                    } else {
                        this.pendingPlayback = true;
                    }
                }
            }
            return this;
        },
        restart: function(marker, position, volume, loop) {
            marker = marker || "";
            position = position || 0;
            volume = volume || 1;
            if (loop === undefined) {
                loop = false;
            }
            this.play(marker, position, volume, loop, true);
        },
        pause: function() {
            if (this.isPlaying && this._sound) {
                this.paused = true;
                this.pausedPosition = this.currentTime;
                this.pausedTime = this.game.time.time;
                this.onPause.dispatch(this);
                this.stop();
            }
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var p = this.position + this.pausedPosition / 1e3;
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    if (this.loop) {
                        this._sound.loop = true;
                    }
                    if (!this.loop && this.currentMarker === "") {
                        this._sound.onended = this.onEndedHandler.bind(this);
                    }
                    var duration = this.duration - this.pausedPosition / 1e3;
                    if (this._sound.start === undefined) {
                        this._sound.noteGrainOn(0, p, duration);
                    } else {
                        if (this.loop && this.game.device.chrome) {
                            if (this.game.device.chromeVersion === 42) {
                                this._sound.start(0);
                            } else {
                                this._sound.start(0, p);
                            }
                        } else {
                            this._sound.start(0, p, duration);
                        }
                    }
                } else {
                    this._sound.play();
                }
                this.isPlaying = true;
                this.paused = false;
                this.startTime += this.game.time.time - this.pausedTime;
                this.onResume.dispatch(this);
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (this.externalNode) {
                        this._sound.disconnect(this.externalNode);
                    } else {
                        this._sound.disconnect(this.gainNode);
                    }
                    if (this._sound.stop === undefined) {
                        this._sound.noteOff(0);
                    } else {
                        try {
                            this._sound.stop(0);
                        } catch (e) {}
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            this.pendingPlayback = false;
            this.isPlaying = false;
            var prevMarker = this.currentMarker;
            if (this.currentMarker !== "") {
                this.onMarkerComplete.dispatch(this.currentMarker, this);
            }
            this.currentMarker = "";
            if (this.fadeTween !== null) {
                this.fadeTween.stop();
            }
            if (!this.paused) {
                this.onStop.dispatch(this, prevMarker);
            }
        },
        fadeIn: function(duration, loop, marker) {
            if (loop === undefined) {
                loop = false;
            }
            if (marker === undefined) {
                marker = this.currentMarker;
            }
            if (this.paused) {
                return;
            }
            this.play(marker, 0, 0, loop);
            this.fadeTo(duration, 1);
        },
        fadeOut: function(duration) {
            this.fadeTo(duration, 0);
        },
        fadeTo: function(duration, volume) {
            if (!this.isPlaying || this.paused || volume === this.volume) {
                return;
            }
            if (duration === undefined) {
                duration = 1e3;
            }
            if (volume === undefined) {
                console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                return;
            }
            this.fadeTween = this.game.add.tween(this).to({
                volume: volume
            }, duration, Phaser.Easing.Linear.None, true);
            this.fadeTween.onComplete.add(this.fadeComplete, this);
        },
        fadeComplete: function() {
            this.onFadeComplete.dispatch(this, this.volume);
            if (this.volume === 0) {
                this.stop();
            }
        },
        destroy: function(remove) {
            if (remove === undefined) {
                remove = true;
            }
            this.stop();
            if (remove) {
                this.game.sound.remove(this);
            } else {
                this.markers = {};
                this.context = null;
                this._buffer = null;
                this.externalNode = null;
                this.onDecoded.dispose();
                this.onPlay.dispose();
                this.onPause.dispose();
                this.onResume.dispose();
                this.onLoop.dispose();
                this.onStop.dispose();
                this.onMute.dispose();
                this.onMarkerComplete.dispose();
            }
        }
    };
    Phaser.Sound.prototype.constructor = Phaser.Sound;
    Object.defineProperty(Phaser.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding;
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute;
        },
        set: function(value) {
            value = value || false;
            if (value === this._muted) {
                return;
            }
            if (value) {
                this._muted = true;
                this._muteVolume = this._tempVolume;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = 0;
                } else if (this.usingAudioTag && this._sound) {
                    this._sound.volume = 0;
                }
            } else {
                this._muted = false;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = this._muteVolume;
                } else if (this.usingAudioTag && this._sound) {
                    this._sound.volume = this._muteVolume;
                }
            }
            this.onMute.dispatch(this);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(value) {
            if (this.game.device.firefox && this.usingAudioTag) {
                value = this.game.math.clamp(value, 0, 1);
            }
            if (this._muted) {
                this._muteVolume = value;
                return;
            }
            this._tempVolume = value;
            this._volume = value;
            if (this.usingWebAudio) {
                this.gainNode.gain.value = value;
            } else if (this.usingAudioTag && this._sound) {
                this._sound.volume = value;
            }
        }
    });
    Phaser.SoundManager = function(game) {
        this.game = game;
        this.onSoundDecode = new Phaser.Signal();
        this.onVolumeChange = new Phaser.Signal();
        this.onMute = new Phaser.Signal();
        this.onUnMute = new Phaser.Signal();
        this.context = null;
        this.usingWebAudio = false;
        this.usingAudioTag = false;
        this.noAudio = false;
        this.connectToMaster = true;
        this.touchLocked = false;
        this.channels = 32;
        this._codeMuted = false;
        this._muted = false;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this._watchList = new Phaser.ArraySet();
        this._watching = false;
        this._watchCallback = null;
        this._watchContext = null;
    };
    Phaser.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && this.game.device.webAudio === false) {
                this.channels = 1;
            }
            if (window["PhaserGlobal"]) {
                if (window["PhaserGlobal"].disableAudio === true) {
                    this.noAudio = true;
                    this.touchLocked = false;
                    return;
                }
                if (window["PhaserGlobal"].disableWebAudio === true) {
                    this.usingAudioTag = true;
                    this.touchLocked = false;
                    return;
                }
            }
            if (window["PhaserGlobal"] && window["PhaserGlobal"].audioContext) {
                this.context = window["PhaserGlobal"].audioContext;
            } else {
                if (!!window["AudioContext"]) {
                    try {
                        this.context = new window["AudioContext"]();
                    } catch (error) {
                        this.context = null;
                        this.usingWebAudio = false;
                        this.touchLocked = false;
                    }
                } else if (!!window["webkitAudioContext"]) {
                    try {
                        this.context = new window["webkitAudioContext"]();
                    } catch (error) {
                        this.context = null;
                        this.usingWebAudio = false;
                        this.touchLocked = false;
                    }
                }
            }
            if (this.context === null) {
                if (window["Audio"] === undefined) {
                    this.noAudio = true;
                    return;
                } else {
                    this.usingAudioTag = true;
                }
            } else {
                this.usingWebAudio = true;
                if (this.context.createGain === undefined) {
                    this.masterGain = this.context.createGainNode();
                } else {
                    this.masterGain = this.context.createGain();
                }
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this.context.destination);
            }
            if (!this.noAudio) {
                if (!this.game.device.cocoonJS && this.game.device.iOS || window["PhaserGlobal"] && window["PhaserGlobal"].fakeiOSTouchLock) {
                    this.setTouchLock();
                }
            }
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this);
            this.touchLocked = true;
        },
        unlock: function() {
            if (this.noAudio || !this.touchLocked || this._unlockSource !== null) {
                return true;
            }
            if (this.usingAudioTag) {
                this.touchLocked = false;
                this._unlockSource = null;
            } else if (this.usingWebAudio) {
                var buffer = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource();
                this._unlockSource.buffer = buffer;
                this._unlockSource.connect(this.context.destination);
                if (this._unlockSource.start === undefined) {
                    this._unlockSource.noteOn(0);
                } else {
                    this._unlockSource.start(0);
                }
            }
            return true;
        },
        stopAll: function() {
            if (this.noAudio) {
                return;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].stop();
                }
            }
        },
        pauseAll: function() {
            if (this.noAudio) {
                return;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].pause();
                }
            }
        },
        resumeAll: function() {
            if (this.noAudio) {
                return;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].resume();
                }
            }
        },
        decode: function(key, sound) {
            sound = sound || null;
            var soundData = this.game.cache.getSoundData(key);
            if (soundData) {
                if (this.game.cache.isSoundDecoded(key) === false) {
                    this.game.cache.updateSound(key, "isDecoding", true);
                    var _this = this;
                    try {
                        this.context.decodeAudioData(soundData, function(buffer) {
                            if (buffer) {
                                _this.game.cache.decodedSound(key, buffer);
                                _this.onSoundDecode.dispatch(key, sound);
                            }
                        });
                    } catch (e) {}
                }
            }
        },
        setDecodedCallback: function(files, callback, callbackContext) {
            if (typeof files === "string") {
                files = [ files ];
            }
            this._watchList.reset();
            for (var i = 0; i < files.length; i++) {
                if (files[i] instanceof Phaser.Sound) {
                    if (!this.game.cache.isSoundDecoded(files[i].key)) {
                        this._watchList.add(files[i].key);
                    }
                } else if (!this.game.cache.isSoundDecoded(files[i])) {
                    this._watchList.add(files[i]);
                }
            }
            if (this._watchList.total === 0) {
                this._watching = false;
                callback.call(callbackContext);
            } else {
                this._watching = true;
                this._watchCallback = callback;
                this._watchContext = callbackContext;
            }
        },
        update: function() {
            if (this.noAudio) {
                return;
            }
            if (this.touchLocked && this._unlockSource !== null && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE)) {
                this.touchLocked = false;
                this._unlockSource = null;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                this._sounds[i].update();
            }
            if (this._watching) {
                var key = this._watchList.first;
                while (key) {
                    if (this.game.cache.isSoundDecoded(key)) {
                        this._watchList.remove(key);
                    }
                    key = this._watchList.next;
                }
                if (this._watchList.total === 0) {
                    this._watching = false;
                    this._watchCallback.call(this._watchContext);
                }
            }
        },
        add: function(key, volume, loop, connect) {
            if (volume === undefined) {
                volume = 1;
            }
            if (loop === undefined) {
                loop = false;
            }
            if (connect === undefined) {
                connect = this.connectToMaster;
            }
            var sound = new Phaser.Sound(this.game, key, volume, loop, connect);
            this._sounds.push(sound);
            return sound;
        },
        addSprite: function(key) {
            var audioSprite = new Phaser.AudioSprite(this.game, key);
            return audioSprite;
        },
        remove: function(sound) {
            var i = this._sounds.length;
            while (i--) {
                if (this._sounds[i] === sound) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    return true;
                }
            }
            return false;
        },
        removeByKey: function(key) {
            var i = this._sounds.length;
            var removed = 0;
            while (i--) {
                if (this._sounds[i].key === key) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    removed++;
                }
            }
            return removed;
        },
        play: function(key, volume, loop) {
            if (this.noAudio) {
                return;
            }
            var sound = this.add(key, volume, loop);
            sound.play();
            return sound;
        },
        setMute: function() {
            if (this._muted) {
                return;
            }
            this._muted = true;
            if (this.usingWebAudio) {
                this._muteVolume = this.masterGain.gain.value;
                this.masterGain.gain.value = 0;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = true;
                }
            }
            this.onMute.dispatch();
        },
        unsetMute: function() {
            if (!this._muted || this._codeMuted) {
                return;
            }
            this._muted = false;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = this._muteVolume;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = false;
                }
            }
            this.onUnMute.dispatch();
        },
        destroy: function() {
            this.stopAll();
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].destroy();
                }
            }
            this._sounds = [];
            this.onSoundDecode.dispose();
            if (this.context && window["PhaserGlobal"]) {
                window["PhaserGlobal"].audioContext = this.context;
            }
        }
    };
    Phaser.SoundManager.prototype.constructor = Phaser.SoundManager;
    Object.defineProperty(Phaser.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(value) {
            value = value || false;
            if (value) {
                if (this._muted) {
                    return;
                }
                this._codeMuted = true;
                this.setMute();
            } else {
                if (!this._muted) {
                    return;
                }
                this._codeMuted = false;
                this.unsetMute();
            }
        }
    });
    Object.defineProperty(Phaser.SoundManager.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(value) {
            if (value < 0) {
                value = 0;
            } else if (value > 1) {
                value = 1;
            }
            if (this._volume !== value) {
                this._volume = value;
                if (this.usingWebAudio) {
                    this.masterGain.gain.value = value;
                } else {
                    for (var i = 0; i < this._sounds.length; i++) {
                        if (this._sounds[i].usingAudioTag) {
                            this._sounds[i].volume = this._sounds[i].volume * value;
                        }
                    }
                }
                this.onVolumeChange.dispatch(value);
            }
        }
    });
    Phaser.Utils.Debug = function(game) {
        this.game = game;
        this.sprite = null;
        this.bmd = null;
        this.canvas = null;
        this.context = null;
        this.font = "14px Courier";
        this.columnWidth = 100;
        this.lineHeight = 16;
        this.renderShadow = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentAlpha = 1;
        this.dirty = false;
    };
    Phaser.Utils.Debug.prototype = {
        boot: function() {
            if (this.game.renderType === Phaser.CANVAS) {
                this.context = this.game.context;
            } else {
                this.bmd = this.game.make.bitmapData(this.game.width, this.game.height);
                this.sprite = this.game.make.image(0, 0, this.bmd);
                this.game.stage.addChild(this.sprite);
                this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height);
                this.context = this.canvas.getContext("2d");
            }
        },
        preUpdate: function() {
            if (this.dirty && this.sprite) {
                this.bmd.clear();
                this.bmd.draw(this.canvas, 0, 0);
                this.context.clearRect(0, 0, this.game.width, this.game.height);
                this.dirty = false;
            }
        },
        reset: function() {
            if (this.context) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
            }
            if (this.sprite) {
                this.bmd.clear();
            }
        },
        start: function(x, y, color, columnWidth) {
            if (typeof x !== "number") {
                x = 0;
            }
            if (typeof y !== "number") {
                y = 0;
            }
            color = color || "rgb(255,255,255)";
            if (columnWidth === undefined) {
                columnWidth = 0;
            }
            this.currentX = x;
            this.currentY = y;
            this.currentColor = color;
            this.columnWidth = columnWidth;
            this.dirty = true;
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.strokeStyle = color;
            this.context.fillStyle = color;
            this.context.font = this.font;
            this.context.globalAlpha = this.currentAlpha;
        },
        stop: function() {
            this.context.restore();
        },
        line: function() {
            var x = this.currentX;
            for (var i = 0; i < arguments.length; i++) {
                if (this.renderShadow) {
                    this.context.fillStyle = "rgb(0,0,0)";
                    this.context.fillText(arguments[i], x + 1, this.currentY + 1);
                    this.context.fillStyle = this.currentColor;
                }
                this.context.fillText(arguments[i], x, this.currentY);
                x += this.columnWidth;
            }
            this.currentY += this.lineHeight;
        },
        soundInfo: function(sound, x, y, color) {
            this.start(x, y, color);
            this.line("Sound: " + sound.key + " Locked: " + sound.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(sound.key) + " Pending Playback: " + sound.pendingPlayback);
            this.line("Decoded: " + sound.isDecoded + " Decoding: " + sound.isDecoding);
            this.line("Total Duration: " + sound.totalDuration + " Playing: " + sound.isPlaying);
            this.line("Time: " + sound.currentTime);
            this.line("Volume: " + sound.volume + " Muted: " + sound.mute);
            this.line("WebAudio: " + sound.usingWebAudio + " Audio: " + sound.usingAudioTag);
            if (sound.currentMarker !== "") {
                this.line("Marker: " + sound.currentMarker + " Duration: " + sound.duration + " (ms: " + sound.durationMS + ")");
                this.line("Start: " + sound.markers[sound.currentMarker].start + " Stop: " + sound.markers[sound.currentMarker].stop);
                this.line("Position: " + sound.position);
            }
            this.stop();
        },
        cameraInfo: function(camera, x, y, color) {
            this.start(x, y, color);
            this.line("Camera (" + camera.width + " x " + camera.height + ")");
            this.line("X: " + camera.x + " Y: " + camera.y);
            if (camera.bounds) {
                this.line("Bounds x: " + camera.bounds.x + " Y: " + camera.bounds.y + " w: " + camera.bounds.width + " h: " + camera.bounds.height);
            }
            this.line("View x: " + camera.view.x + " Y: " + camera.view.y + " w: " + camera.view.width + " h: " + camera.view.height);
            this.line("Total in view: " + camera.totalInView);
            this.stop();
        },
        timer: function(timer, x, y, color) {
            this.start(x, y, color);
            this.line("Timer (running: " + timer.running + " expired: " + timer.expired + ")");
            this.line("Next Tick: " + timer.next + " Duration: " + timer.duration);
            this.line("Paused: " + timer.paused + " Length: " + timer.length);
            this.stop();
        },
        pointer: function(pointer, hideIfUp, downColor, upColor, color) {
            if (pointer == null) {
                return;
            }
            if (hideIfUp === undefined) {
                hideIfUp = false;
            }
            downColor = downColor || "rgba(0,255,0,0.5)";
            upColor = upColor || "rgba(255,0,0,0.5)";
            if (hideIfUp === true && pointer.isUp === true) {
                return;
            }
            this.start(pointer.x, pointer.y - 100, color);
            this.context.beginPath();
            this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2);
            if (pointer.active) {
                this.context.fillStyle = downColor;
            } else {
                this.context.fillStyle = upColor;
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y);
            this.context.lineTo(pointer.position.x, pointer.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + pointer.id + " Active: " + pointer.active);
            this.line("World X: " + pointer.worldX + " World Y: " + pointer.worldY);
            this.line("Screen X: " + pointer.x + " Screen Y: " + pointer.y + " In: " + pointer.withinGame);
            this.line("Duration: " + pointer.duration + " ms");
            this.line("is Down: " + pointer.isDown + " is Up: " + pointer.isUp);
            this.stop();
        },
        spriteInputInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite Input: (" + sprite.width + " x " + sprite.height + ")");
            this.line("x: " + sprite.input.pointerX().toFixed(1) + " y: " + sprite.input.pointerY().toFixed(1));
            this.line("over: " + sprite.input.pointerOver() + " duration: " + sprite.input.overDuration().toFixed(0));
            this.line("down: " + sprite.input.pointerDown() + " duration: " + sprite.input.downDuration().toFixed(0));
            this.line("just over: " + sprite.input.justOver() + " just out: " + sprite.input.justOut());
            this.stop();
        },
        key: function(key, x, y, color) {
            this.start(x, y, color, 150);
            this.line("Key:", key.keyCode, "isDown:", key.isDown);
            this.line("justDown:", key.justDown, "justUp:", key.justUp);
            this.line("Time Down:", key.timeDown.toFixed(0), "duration:", key.duration.toFixed(0));
            this.stop();
        },
        inputInfo: function(x, y, color) {
            this.start(x, y, color);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop();
        },
        spriteBounds: function(sprite, color, filled) {
            var bounds = sprite.getBounds();
            bounds.x += this.game.camera.x;
            bounds.y += this.game.camera.y;
            this.rectangle(bounds, color, filled);
        },
        ropeSegments: function(rope, color, filled) {
            var segments = rope.segments;
            var self = this;
            segments.forEach(function(segment) {
                self.rectangle(segment, color, filled);
            }, this);
        },
        spriteInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite: " + " (" + sprite.width + " x " + sprite.height + ") anchor: " + sprite.anchor.x + " x " + sprite.anchor.y);
            this.line("x: " + sprite.x.toFixed(1) + " y: " + sprite.y.toFixed(1));
            this.line("angle: " + sprite.angle.toFixed(1) + " rotation: " + sprite.rotation.toFixed(1));
            this.line("visible: " + sprite.visible + " in camera: " + sprite.inCamera);
            this.line("bounds x: " + sprite._bounds.x.toFixed(1) + " y: " + sprite._bounds.y.toFixed(1) + " w: " + sprite._bounds.width.toFixed(1) + " h: " + sprite._bounds.height.toFixed(1));
            this.stop();
        },
        spriteCoords: function(sprite, x, y, color) {
            this.start(x, y, color, 100);
            if (sprite.name) {
                this.line(sprite.name);
            }
            this.line("x:", sprite.x.toFixed(2), "y:", sprite.y.toFixed(2));
            this.line("pos x:", sprite.position.x.toFixed(2), "pos y:", sprite.position.y.toFixed(2));
            this.line("world x:", sprite.world.x.toFixed(2), "world y:", sprite.world.y.toFixed(2));
            this.stop();
        },
        lineInfo: function(line, x, y, color) {
            this.start(x, y, color, 80);
            this.line("start.x:", line.start.x.toFixed(2), "start.y:", line.start.y.toFixed(2));
            this.line("end.x:", line.end.x.toFixed(2), "end.y:", line.end.y.toFixed(2));
            this.line("length:", line.length.toFixed(2), "angle:", line.angle);
            this.stop();
        },
        pixel: function(x, y, color, size) {
            size = size || 2;
            this.start();
            this.context.fillStyle = color;
            this.context.fillRect(x, y, size, size);
            this.stop();
        },
        geom: function(object, color, filled, forceType) {
            if (filled === undefined) {
                filled = true;
            }
            if (forceType === undefined) {
                forceType = 0;
            }
            color = color || "rgba(0,255,0,0.4)";
            this.start();
            this.context.fillStyle = color;
            this.context.strokeStyle = color;
            if (object instanceof Phaser.Rectangle || forceType === 1) {
                if (filled) {
                    this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                } else {
                    this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                }
            } else if (object instanceof Phaser.Circle || forceType === 2) {
                this.context.beginPath();
                this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false);
                this.context.closePath();
                if (filled) {
                    this.context.fill();
                } else {
                    this.context.stroke();
                }
            } else if (object instanceof Phaser.Point || forceType === 3) {
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4);
            } else if (object instanceof Phaser.Line || forceType === 4) {
                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(object.start.x + .5 - this.game.camera.x, object.start.y + .5 - this.game.camera.y);
                this.context.lineTo(object.end.x + .5 - this.game.camera.x, object.end.y + .5 - this.game.camera.y);
                this.context.closePath();
                this.context.stroke();
            }
            this.stop();
        },
        rectangle: function(object, color, filled) {
            if (filled === undefined) {
                filled = true;
            }
            color = color || "rgba(0, 255, 0, 0.4)";
            this.start();
            if (filled) {
                this.context.fillStyle = color;
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            } else {
                this.context.strokeStyle = color;
                this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            }
            this.stop();
        },
        text: function(text, x, y, color, font) {
            color = color || "rgb(255,255,255)";
            font = font || "16px Courier";
            this.start();
            this.context.font = font;
            if (this.renderShadow) {
                this.context.fillStyle = "rgb(0,0,0)";
                this.context.fillText(text, x + 1, y + 1);
            }
            this.context.fillStyle = color;
            this.context.fillText(text, x, y);
            this.stop();
        },
        quadTree: function(quadtree, color) {
            color = color || "rgba(255,0,0,0.3)";
            this.start();
            var bounds = quadtree.bounds;
            if (quadtree.nodes.length === 0) {
                this.context.strokeStyle = color;
                this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                this.text("size: " + quadtree.objects.length, bounds.x + 4, bounds.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var i = 0; i < quadtree.objects.length; i++) {
                    this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);
                }
            } else {
                for (var i = 0; i < quadtree.nodes.length; i++) {
                    this.quadTree(quadtree.nodes[i]);
                }
            }
            this.stop();
        },
        body: function(sprite, color, filled) {
            if (sprite.body) {
                this.start();
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled);
                } else if (sprite.body.type === Phaser.Physics.NINJA) {
                    Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled);
                } else if (sprite.body.type === Phaser.Physics.BOX2D) {
                    Phaser.Physics.Box2D.renderBody(this.context, sprite.body, color);
                }
                this.stop();
            }
        },
        bodyInfo: function(sprite, x, y, color) {
            if (sprite.body) {
                this.start(x, y, color, 210);
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body);
                } else if (sprite.body.type === Phaser.Physics.BOX2D) {
                    this.game.physics.box2d.renderBodyInfo(this, sprite.body);
                }
                this.stop();
            }
        },
        box2dWorld: function() {
            this.start();
            this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);
            this.game.physics.box2d.renderDebugDraw(this.context);
            this.stop();
        },
        box2dBody: function(body, color) {
            this.start();
            Phaser.Physics.Box2D.renderBody(this.context, body, color);
            this.stop();
        },
        destroy: function() {
            PIXI.CanvasPool.remove(this);
        }
    };
    Phaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug;
    Phaser.ArraySet = function(list) {
        this.position = 0;
        this.list = list || [];
    };
    Phaser.ArraySet.prototype = {
        add: function(item) {
            if (!this.exists(item)) {
                this.list.push(item);
            }
            return item;
        },
        getIndex: function(item) {
            return this.list.indexOf(item);
        },
        getByKey: function(property, value) {
            var i = this.list.length;
            while (i--) {
                if (this.list[i][property] === value) {
                    return this.list[i];
                }
            }
            return null;
        },
        exists: function(item) {
            return this.list.indexOf(item) > -1;
        },
        reset: function() {
            this.list.length = 0;
        },
        remove: function(item) {
            var idx = this.list.indexOf(item);
            if (idx > -1) {
                this.list.splice(idx, 1);
                return item;
            }
        },
        setAll: function(key, value) {
            var i = this.list.length;
            while (i--) {
                if (this.list[i]) {
                    this.list[i][key] = value;
                }
            }
        },
        callAll: function(key) {
            var args = Array.prototype.splice.call(arguments, 1);
            var i = this.list.length;
            while (i--) {
                if (this.list[i] && this.list[i][key]) {
                    this.list[i][key].apply(this.list[i], args);
                }
            }
        },
        removeAll: function(destroy) {
            if (destroy === undefined) {
                destroy = false;
            }
            var i = this.list.length;
            while (i--) {
                if (this.list[i]) {
                    var item = this.remove(this.list[i]);
                    if (destroy) {
                        item.destroy();
                    }
                }
            }
            this.position = 0;
            this.list = [];
        }
    };
    Object.defineProperty(Phaser.ArraySet.prototype, "total", {
        get: function() {
            return this.list.length;
        }
    });
    Object.defineProperty(Phaser.ArraySet.prototype, "first", {
        get: function() {
            this.position = 0;
            if (this.list.length > 0) {
                return this.list[0];
            } else {
                return null;
            }
        }
    });
    Object.defineProperty(Phaser.ArraySet.prototype, "next", {
        get: function() {
            if (this.position < this.list.length) {
                this.position++;
                return this.list[this.position];
            } else {
                return null;
            }
        }
    });
    Phaser.ArraySet.prototype.constructor = Phaser.ArraySet;
    Phaser.ArrayUtils = {
        getRandomItem: function(objects, startIndex, length) {
            if (objects === null) {
                return null;
            }
            if (startIndex === undefined) {
                startIndex = 0;
            }
            if (length === undefined) {
                length = objects.length;
            }
            var randomIndex = startIndex + Math.floor(Math.random() * length);
            return objects[randomIndex] === undefined ? null : objects[randomIndex];
        },
        removeRandomItem: function(objects, startIndex, length) {
            if (objects == null) {
                return null;
            }
            if (startIndex === undefined) {
                startIndex = 0;
            }
            if (length === undefined) {
                length = objects.length;
            }
            var randomIndex = startIndex + Math.floor(Math.random() * length);
            if (randomIndex < objects.length) {
                var removed = objects.splice(randomIndex, 1);
                return removed[0] === undefined ? null : removed[0];
            } else {
                return null;
            }
        },
        shuffle: function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        },
        transposeMatrix: function(array) {
            var sourceRowCount = array.length;
            var sourceColCount = array[0].length;
            var result = new Array(sourceColCount);
            for (var i = 0; i < sourceColCount; i++) {
                result[i] = new Array(sourceRowCount);
                for (var j = sourceRowCount - 1; j > -1; j--) {
                    result[i][j] = array[j][i];
                }
            }
            return result;
        },
        rotateMatrix: function(matrix, direction) {
            if (typeof direction !== "string") {
                direction = (direction % 360 + 360) % 360;
            }
            if (direction === 90 || direction === -270 || direction === "rotateLeft") {
                matrix = Phaser.ArrayUtils.transposeMatrix(matrix);
                matrix = matrix.reverse();
            } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
                matrix = matrix.reverse();
                matrix = Phaser.ArrayUtils.transposeMatrix(matrix);
            } else if (Math.abs(direction) === 180 || direction === "rotate180") {
                for (var i = 0; i < matrix.length; i++) {
                    matrix[i].reverse();
                }
                matrix = matrix.reverse();
            }
            return matrix;
        },
        findClosest: function(value, arr) {
            if (!arr.length) {
                return NaN;
            } else if (arr.length === 1 || value < arr[0]) {
                return arr[0];
            }
            var i = 1;
            while (arr[i] < value) {
                i++;
            }
            var low = arr[i - 1];
            var high = i < arr.length ? arr[i] : Number.POSITIVE_INFINITY;
            return high - value <= value - low ? high : low;
        },
        rotate: function(array) {
            var s = array.shift();
            array.push(s);
            return s;
        },
        numberArray: function(start, end) {
            var result = [];
            for (var i = start; i <= end; i++) {
                result.push(i);
            }
            return result;
        },
        numberArrayStep: function(start, end, step) {
            if (start === undefined || start === null) {
                start = 0;
            }
            if (end === undefined || end === null) {
                end = start;
                start = 0;
            }
            if (step === undefined) {
                step = 1;
            }
            var result = [];
            var total = Math.max(Phaser.Math.roundAwayFromZero((end - start) / (step || 1)), 0);
            for (var i = 0; i < total; i++) {
                result.push(start);
                start += step;
            }
            return result;
        }
    };
    Phaser.Color = {
        packPixel: function(r, g, b, a) {
            if (Phaser.Device.LITTLE_ENDIAN) {
                return (a << 24 | b << 16 | g << 8 | r) >>> 0;
            } else {
                return (r << 24 | g << 16 | b << 8 | a) >>> 0;
            }
        },
        unpackPixel: function(rgba, out, hsl, hsv) {
            if (out === undefined || out === null) {
                out = Phaser.Color.createColor();
            }
            if (hsl === undefined || hsl === null) {
                hsl = false;
            }
            if (hsv === undefined || hsv === null) {
                hsv = false;
            }
            if (Phaser.Device.LITTLE_ENDIAN) {
                out.a = (rgba & 4278190080) >>> 24;
                out.b = (rgba & 16711680) >>> 16;
                out.g = (rgba & 65280) >>> 8;
                out.r = rgba & 255;
            } else {
                out.r = (rgba & 4278190080) >>> 24;
                out.g = (rgba & 16711680) >>> 16;
                out.b = (rgba & 65280) >>> 8;
                out.a = rgba & 255;
            }
            out.color = rgba;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a / 255 + ")";
            if (hsl) {
                Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out);
            }
            if (hsv) {
                Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out);
            }
            return out;
        },
        fromRGBA: function(rgba, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            out.r = (rgba & 4278190080) >>> 24;
            out.g = (rgba & 16711680) >>> 16;
            out.b = (rgba & 65280) >>> 8;
            out.a = rgba & 255;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        toRGBA: function(r, g, b, a) {
            return r << 24 | g << 16 | b << 8 | a;
        },
        RGBtoHSL: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 1);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            out.h = 0;
            out.s = 0;
            out.l = (max + min) / 2;
            if (max !== min) {
                var d = max - min;
                out.s = out.l > .5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSLtoRGB: function(h, s, l, out) {
            if (!out) {
                out = Phaser.Color.createColor(l, l, l);
            } else {
                out.r = l;
                out.g = l;
                out.b = l;
            }
            if (s !== 0) {
                var q = l < .5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3);
                out.g = Phaser.Color.hueToColor(p, q, h);
                out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);
            }
            out.r = Math.floor(out.r * 255 | 0);
            out.g = Math.floor(out.g * 255 | 0);
            out.b = Math.floor(out.b * 255 | 0);
            Phaser.Color.updateColor(out);
            return out;
        },
        RGBtoHSV: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 255);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var d = max - min;
            out.h = 0;
            out.s = max === 0 ? 0 : d / max;
            out.v = max;
            if (max !== min) {
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSVtoRGB: function(h, s, v, out) {
            if (out === undefined) {
                out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v);
            }
            var r, g, b;
            var i = Math.floor(h * 6);
            var f = h * 6 - i;
            var p = v * (1 - s);
            var q = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);
            switch (i % 6) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
            out.r = Math.floor(r * 255);
            out.g = Math.floor(g * 255);
            out.b = Math.floor(b * 255);
            Phaser.Color.updateColor(out);
            return out;
        },
        hueToColor: function(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        },
        createColor: function(r, g, b, a, h, s, l, v) {
            var out = {
                r: r || 0,
                g: g || 0,
                b: b || 0,
                a: a || 1,
                h: h || 0,
                s: s || 0,
                l: l || 0,
                v: v || 0,
                color: 0,
                color32: 0,
                rgba: ""
            };
            return Phaser.Color.updateColor(out);
        },
        updateColor: function(out) {
            out.rgba = "rgba(" + out.r.toString() + "," + out.g.toString() + "," + out.b.toString() + "," + out.a.toString() + ")";
            out.color = Phaser.Color.getColor(out.r, out.g, out.b);
            out.color32 = Phaser.Color.getColor32(out.a, out.r, out.g, out.b);
            return out;
        },
        getColor32: function(a, r, g, b) {
            return a << 24 | r << 16 | g << 8 | b;
        },
        getColor: function(r, g, b) {
            return r << 16 | g << 8 | b;
        },
        RGBtoString: function(r, g, b, a, prefix) {
            if (a === undefined) {
                a = 255;
            }
            if (prefix === undefined) {
                prefix = "#";
            }
            if (prefix === "#") {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            } else {
                return "0x" + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);
            }
        },
        hexToRGB: function(hex) {
            var rgb = Phaser.Color.hexToColor(hex);
            if (rgb) {
                return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b);
            }
        },
        hexToColor: function(hex, out) {
            hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                var r = parseInt(result[1], 16);
                var g = parseInt(result[2], 16);
                var b = parseInt(result[3], 16);
                if (!out) {
                    out = Phaser.Color.createColor(r, g, b);
                } else {
                    out.r = r;
                    out.g = g;
                    out.b = b;
                }
            }
            return out;
        },
        webToColor: function(web, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(web);
            if (result) {
                out.r = parseInt(result[1], 10);
                out.g = parseInt(result[2], 10);
                out.b = parseInt(result[3], 10);
                out.a = result[4] !== undefined ? parseFloat(result[4]) : 1;
                Phaser.Color.updateColor(out);
            }
            return out;
        },
        valueToColor: function(value, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            if (typeof value === "string") {
                if (value.indexOf("rgb") === 0) {
                    return Phaser.Color.webToColor(value, out);
                } else {
                    out.a = 1;
                    return Phaser.Color.hexToColor(value, out);
                }
            } else if (typeof value === "number") {
                var tempColor = Phaser.Color.getRGB(value);
                out.r = tempColor.r;
                out.g = tempColor.g;
                out.b = tempColor.b;
                out.a = tempColor.a / 255;
                return out;
            } else {
                return out;
            }
        },
        componentToHex: function(color) {
            var hex = color.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        },
        HSVColorWheel: function(s, v) {
            if (s === undefined) {
                s = 1;
            }
            if (v === undefined) {
                v = 1;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));
            }
            return colors;
        },
        HSLColorWheel: function(s, l) {
            if (s === undefined) {
                s = .5;
            }
            if (l === undefined) {
                l = .5;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));
            }
            return colors;
        },
        interpolateColor: function(color1, color2, steps, currentStep, alpha) {
            if (alpha === undefined) {
                alpha = 255;
            }
            var src1 = Phaser.Color.getRGB(color1);
            var src2 = Phaser.Color.getRGB(color2);
            var r = (src2.red - src1.red) * currentStep / steps + src1.red;
            var g = (src2.green - src1.green) * currentStep / steps + src1.green;
            var b = (src2.blue - src1.blue) * currentStep / steps + src1.blue;
            return Phaser.Color.getColor32(alpha, r, g, b);
        },
        interpolateColorWithRGB: function(color, r, g, b, steps, currentStep) {
            var src = Phaser.Color.getRGB(color);
            var or = (r - src.red) * currentStep / steps + src.red;
            var og = (g - src.green) * currentStep / steps + src.green;
            var ob = (b - src.blue) * currentStep / steps + src.blue;
            return Phaser.Color.getColor(or, og, ob);
        },
        interpolateRGB: function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
            var r = (r2 - r1) * currentStep / steps + r1;
            var g = (g2 - g1) * currentStep / steps + g1;
            var b = (b2 - b1) * currentStep / steps + b1;
            return Phaser.Color.getColor(r, g, b);
        },
        getRandomColor: function(min, max, alpha) {
            if (min === undefined) {
                min = 0;
            }
            if (max === undefined) {
                max = 255;
            }
            if (alpha === undefined) {
                alpha = 255;
            }
            if (max > 255 || min > max) {
                return Phaser.Color.getColor(255, 255, 255);
            }
            var red = min + Math.round(Math.random() * (max - min));
            var green = min + Math.round(Math.random() * (max - min));
            var blue = min + Math.round(Math.random() * (max - min));
            return Phaser.Color.getColor32(alpha, red, green, blue);
        },
        getRGB: function(color) {
            if (color > 16777215) {
                return {
                    alpha: color >>> 24,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: color >>> 24,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            } else {
                return {
                    alpha: 255,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: 255,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            }
        },
        getWebRGB: function(color) {
            if (typeof color === "object") {
                return "rgba(" + color.r.toString() + "," + color.g.toString() + "," + color.b.toString() + "," + (color.a / 255).toString() + ")";
            } else {
                var rgb = Phaser.Color.getRGB(color);
                return "rgba(" + rgb.r.toString() + "," + rgb.g.toString() + "," + rgb.b.toString() + "," + (rgb.a / 255).toString() + ")";
            }
        },
        getAlpha: function(color) {
            return color >>> 24;
        },
        getAlphaFloat: function(color) {
            return (color >>> 24) / 255;
        },
        getRed: function(color) {
            return color >> 16 & 255;
        },
        getGreen: function(color) {
            return color >> 8 & 255;
        },
        getBlue: function(color) {
            return color & 255;
        },
        blendNormal: function(a) {
            return a;
        },
        blendLighten: function(a, b) {
            return b > a ? b : a;
        },
        blendDarken: function(a, b) {
            return b > a ? a : b;
        },
        blendMultiply: function(a, b) {
            return a * b / 255;
        },
        blendAverage: function(a, b) {
            return (a + b) / 2;
        },
        blendAdd: function(a, b) {
            return Math.min(255, a + b);
        },
        blendSubtract: function(a, b) {
            return Math.max(0, a + b - 255);
        },
        blendDifference: function(a, b) {
            return Math.abs(a - b);
        },
        blendNegation: function(a, b) {
            return 255 - Math.abs(255 - a - b);
        },
        blendScreen: function(a, b) {
            return 255 - ((255 - a) * (255 - b) >> 8);
        },
        blendExclusion: function(a, b) {
            return a + b - 2 * a * b / 255;
        },
        blendOverlay: function(a, b) {
            return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255;
        },
        blendSoftLight: function(a, b) {
            return b < 128 ? 2 * ((a >> 1) + 64) * (b / 255) : 255 - 2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255;
        },
        blendHardLight: function(a, b) {
            return Phaser.Color.blendOverlay(b, a);
        },
        blendColorDodge: function(a, b) {
            return b === 255 ? b : Math.min(255, (a << 8) / (255 - b));
        },
        blendColorBurn: function(a, b) {
            return b === 0 ? b : Math.max(0, 255 - (255 - a << 8) / b);
        },
        blendLinearDodge: function(a, b) {
            return Phaser.Color.blendAdd(a, b);
        },
        blendLinearBurn: function(a, b) {
            return Phaser.Color.blendSubtract(a, b);
        },
        blendLinearLight: function(a, b) {
            return b < 128 ? Phaser.Color.blendLinearBurn(a, 2 * b) : Phaser.Color.blendLinearDodge(a, 2 * (b - 128));
        },
        blendVividLight: function(a, b) {
            return b < 128 ? Phaser.Color.blendColorBurn(a, 2 * b) : Phaser.Color.blendColorDodge(a, 2 * (b - 128));
        },
        blendPinLight: function(a, b) {
            return b < 128 ? Phaser.Color.blendDarken(a, 2 * b) : Phaser.Color.blendLighten(a, 2 * (b - 128));
        },
        blendHardMix: function(a, b) {
            return Phaser.Color.blendVividLight(a, b) < 128 ? 0 : 255;
        },
        blendReflect: function(a, b) {
            return b === 255 ? b : Math.min(255, a * a / (255 - b));
        },
        blendGlow: function(a, b) {
            return Phaser.Color.blendReflect(b, a);
        },
        blendPhoenix: function(a, b) {
            return Math.min(a, b) - Math.max(a, b) + 255;
        }
    };
    Phaser.LinkedList = function() {
        this.next = null;
        this.prev = null;
        this.first = null;
        this.last = null;
        this.total = 0;
    };
    Phaser.LinkedList.prototype = {
        add: function(item) {
            if (this.total === 0 && this.first === null && this.last === null) {
                this.first = item;
                this.last = item;
                this.next = item;
                item.prev = this;
                this.total++;
                return item;
            }
            this.last.next = item;
            item.prev = this.last;
            this.last = item;
            this.total++;
            return item;
        },
        reset: function() {
            this.first = null;
            this.last = null;
            this.next = null;
            this.prev = null;
            this.total = 0;
        },
        remove: function(item) {
            if (this.total === 1) {
                this.reset();
                item.next = item.prev = null;
                return;
            }
            if (item === this.first) {
                this.first = this.first.next;
            } else if (item === this.last) {
                this.last = this.last.prev;
            }
            if (item.prev) {
                item.prev.next = item.next;
            }
            if (item.next) {
                item.next.prev = item.prev;
            }
            item.next = item.prev = null;
            if (this.first === null) {
                this.last = null;
            }
            this.total--;
        },
        callAll: function(callback) {
            if (!this.first || !this.last) {
                return;
            }
            var entity = this.first;
            do {
                if (entity && entity[callback]) {
                    entity[callback].call(entity);
                }
                entity = entity.next;
            } while (entity != this.last.next);
        }
    };
    Phaser.LinkedList.prototype.constructor = Phaser.LinkedList;
    Phaser.Physics = function(game, config) {
        config = config || {};
        this.game = game;
        this.config = config;
        this.arcade = null;
        this.p2 = null;
        this.ninja = null;
        this.box2d = null;
        this.chipmunk = null;
        this.matter = null;
        this.parseConfig();
    };
    Phaser.Physics.ARCADE = 0;
    Phaser.Physics.P2JS = 1;
    Phaser.Physics.NINJA = 2;
    Phaser.Physics.BOX2D = 3;
    Phaser.Physics.CHIPMUNK = 4;
    Phaser.Physics.MATTERJS = 5;
    Phaser.Physics.prototype = {
        parseConfig: function() {
            if ((!this.config.hasOwnProperty("arcade") || this.config["arcade"] === true) && Phaser.Physics.hasOwnProperty("Arcade")) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
            }
            if (this.config.hasOwnProperty("ninja") && this.config["ninja"] === true && Phaser.Physics.hasOwnProperty("Ninja")) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            }
            if (this.config.hasOwnProperty("p2") && this.config["p2"] === true && Phaser.Physics.hasOwnProperty("P2")) {
                this.p2 = new Phaser.Physics.P2(this.game, this.config);
            }
            if (this.config.hasOwnProperty("box2d") && this.config["box2d"] === true && Phaser.Physics.hasOwnProperty("BOX2D")) {
                this.box2d = new Phaser.Physics.BOX2D(this.game, this.config);
            }
            if (this.config.hasOwnProperty("matter") && this.config["matter"] === true && Phaser.Physics.hasOwnProperty("Matter")) {
                this.matter = new Phaser.Physics.Matter(this.game, this.config);
            }
        },
        startSystem: function(system) {
            if (system === Phaser.Physics.ARCADE) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
            } else if (system === Phaser.Physics.P2JS) {
                if (this.p2 === null) {
                    this.p2 = new Phaser.Physics.P2(this.game, this.config);
                } else {
                    this.p2.reset();
                }
            } else if (system === Phaser.Physics.NINJA) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            } else if (system === Phaser.Physics.BOX2D) {
                if (this.box2d === null) {
                    this.box2d = new Phaser.Physics.Box2D(this.game, this.config);
                } else {
                    this.box2d.reset();
                }
            } else if (system === Phaser.Physics.MATTERJS) {
                if (this.matter === null) {
                    this.matter = new Phaser.Physics.Matter(this.game, this.config);
                } else {
                    this.matter.reset();
                }
            }
        },
        enable: function(object, system, debug) {
            if (system === undefined) {
                system = Phaser.Physics.ARCADE;
            }
            if (debug === undefined) {
                debug = false;
            }
            if (system === Phaser.Physics.ARCADE) {
                this.arcade.enable(object);
            } else if (system === Phaser.Physics.P2JS && this.p2) {
                this.p2.enable(object, debug);
            } else if (system === Phaser.Physics.NINJA && this.ninja) {
                this.ninja.enableAABB(object);
            } else if (system === Phaser.Physics.BOX2D && this.box2d) {
                this.box2d.enable(object);
            } else if (system === Phaser.Physics.MATTERJS && this.matter) {
                this.matter.enable(object);
            }
        },
        preUpdate: function() {
            if (this.p2) {
                this.p2.preUpdate();
            }
            if (this.box2d) {
                this.box2d.preUpdate();
            }
            if (this.matter) {
                this.matter.preUpdate();
            }
        },
        update: function() {
            if (this.p2) {
                this.p2.update();
            }
            if (this.box2d) {
                this.box2d.update();
            }
            if (this.matter) {
                this.matter.update();
            }
        },
        setBoundsToWorld: function() {
            if (this.arcade) {
                this.arcade.setBoundsToWorld();
            }
            if (this.ninja) {
                this.ninja.setBoundsToWorld();
            }
            if (this.p2) {
                this.p2.setBoundsToWorld();
            }
            if (this.box2d) {
                this.box2d.setBoundsToWorld();
            }
            if (this.matter) {
                this.matter.setBoundsToWorld();
            }
        },
        clear: function() {
            if (this.p2) {
                this.p2.clear();
            }
            if (this.box2d) {
                this.box2d.clear();
            }
            if (this.matter) {
                this.matter.clear();
            }
        },
        reset: function() {
            if (this.p2) {
                this.p2.reset();
            }
            if (this.box2d) {
                this.box2d.reset();
            }
            if (this.matter) {
                this.matter.reset();
            }
        },
        destroy: function() {
            if (this.p2) {
                this.p2.destroy();
            }
            if (this.box2d) {
                this.box2d.destroy();
            }
            if (this.matter) {
                this.matter.destroy();
            }
            this.arcade = null;
            this.ninja = null;
            this.p2 = null;
            this.box2d = null;
            this.matter = null;
        }
    };
    Phaser.Physics.prototype.constructor = Phaser.Physics;
    Phaser.Physics.Arcade = function(game) {
        this.game = game;
        this.gravity = new Phaser.Point();
        this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height);
        this.checkCollision = {
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.OVERLAP_BIAS = 4;
        this.forceX = false;
        this.sortDirection = Phaser.Physics.Arcade.LEFT_RIGHT;
        this.skipQuadTree = true;
        this.isPaused = false;
        this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this._total = 0;
        this.setBoundsToWorld();
    };
    Phaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade;
    Phaser.Physics.Arcade.SORT_NONE = 0;
    Phaser.Physics.Arcade.LEFT_RIGHT = 1;
    Phaser.Physics.Arcade.RIGHT_LEFT = 2;
    Phaser.Physics.Arcade.TOP_BOTTOM = 3;
    Phaser.Physics.Arcade.BOTTOM_TOP = 4;
    Phaser.Physics.Arcade.prototype = {
        setBounds: function(x, y, width, height) {
            this.bounds.setTo(x, y, width, height);
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds);
        },
        enable: function(object, children) {
            if (children === undefined) {
                children = true;
            }
            var i = 1;
            if (Array.isArray(object)) {
                i = object.length;
                while (i--) {
                    if (object[i] instanceof Phaser.Group) {
                        this.enable(object[i].children, children);
                    } else {
                        this.enableBody(object[i]);
                        if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                            this.enable(object[i], true);
                        }
                    }
                }
            } else {
                if (object instanceof Phaser.Group) {
                    this.enable(object.children, children);
                } else {
                    this.enableBody(object);
                    if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                        this.enable(object.children, true);
                    }
                }
            }
        },
        enableBody: function(object) {
            if (object.hasOwnProperty("body") && object.body === null) {
                object.body = new Phaser.Physics.Arcade.Body(object);
                if (object.parent && object.parent instanceof Phaser.Group) {
                    object.parent.addToHash(object);
                }
            }
        },
        updateMotion: function(body) {
            var velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity;
            body.angularVelocity += velocityDelta;
            body.rotation += body.angularVelocity * this.game.time.physicsElapsed;
            body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x);
            body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y);
        },
        computeVelocity: function(axis, body, velocity, acceleration, drag, max) {
            if (max === undefined) {
                max = 1e4;
            }
            if (axis === 1 && body.allowGravity) {
                velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed;
            } else if (axis === 2 && body.allowGravity) {
                velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed;
            }
            if (acceleration) {
                velocity += acceleration * this.game.time.physicsElapsed;
            } else if (drag) {
                drag *= this.game.time.physicsElapsed;
                if (velocity - drag > 0) {
                    velocity -= drag;
                } else if (velocity + drag < 0) {
                    velocity += drag;
                } else {
                    velocity = 0;
                }
            }
            if (velocity > max) {
                velocity = max;
            } else if (velocity < -max) {
                velocity = -max;
            }
            return velocity;
        },
        overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
            overlapCallback = overlapCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || overlapCallback;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0; i < object2.length; i++) {
                    this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0; i < object1.length; i++) {
                    this.collideHandler(object1[i], object2, overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0; i < object1.length; i++) {
                    for (var j = 0; j < object2.length; j++) {
                        this.collideHandler(object1[i], object2[j], overlapCallback, processCallback, callbackContext, true);
                    }
                }
            } else {
                this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);
            }
            return this._total > 0;
        },
        collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
            collideCallback = collideCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || collideCallback;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0; i < object2.length; i++) {
                    this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0; i < object1.length; i++) {
                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0; i < object1.length; i++) {
                    for (var j = 0; j < object2.length; j++) {
                        this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, false);
                    }
                }
            } else {
                this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);
            }
            return this._total > 0;
        },
        sortLeftRight: function(a, b) {
            if (!a.body || !b.body) {
                return 0;
            }
            return a.body.x - b.body.x;
        },
        sortRightLeft: function(a, b) {
            if (!a.body || !b.body) {
                return 0;
            }
            return b.body.x - a.body.x;
        },
        sortTopBottom: function(a, b) {
            if (!a.body || !b.body) {
                return 0;
            }
            return a.body.y - b.body.y;
        },
        sortBottomTop: function(a, b) {
            if (!a.body || !b.body) {
                return 0;
            }
            return b.body.y - a.body.y;
        },
        sort: function(group, sortDirection) {
            if (group.physicsSortDirection !== null) {
                sortDirection = group.physicsSortDirection;
            } else {
                if (sortDirection === undefined) {
                    sortDirection = this.sortDirection;
                }
            }
            if (sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) {
                group.hash.sort(this.sortLeftRight);
            } else if (sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) {
                group.hash.sort(this.sortRightLeft);
            } else if (sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) {
                group.hash.sort(this.sortTopBottom);
            } else if (sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) {
                group.hash.sort(this.sortBottomTop);
            }
        },
        collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (object2 === undefined && object1.physicsType === Phaser.GROUP) {
                this.sort(object1);
                this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);
                return;
            }
            if (!object1 || !object2 || !object1.exists || !object2.exists) {
                return;
            }
            if (this.sortDirection !== Phaser.Physics.Arcade.SORT_NONE) {
                if (object1.physicsType === Phaser.GROUP) {
                    this.sort(object1);
                }
                if (object2.physicsType === Phaser.GROUP) {
                    this.sort(object2);
                }
            }
            if (object1.physicsType === Phaser.SPRITE) {
                if (object2.physicsType === Phaser.SPRITE) {
                    this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.physicsType === Phaser.GROUP) {
                    this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.physicsType === Phaser.TILEMAPLAYER) {
                    this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
            } else if (object1.physicsType === Phaser.GROUP) {
                if (object2.physicsType === Phaser.SPRITE) {
                    this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.physicsType === Phaser.GROUP) {
                    this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.physicsType === Phaser.TILEMAPLAYER) {
                    this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
            } else if (object1.physicsType === Phaser.TILEMAPLAYER) {
                if (object2.physicsType === Phaser.SPRITE) {
                    this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.physicsType === Phaser.GROUP) {
                    this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                }
            }
        },
        collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (!sprite1.body || !sprite2.body) {
                return false;
            }
            if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
                if (collideCallback) {
                    collideCallback.call(callbackContext, sprite1, sprite2);
                }
                this._total++;
            }
            return true;
        },
        collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0 || !sprite.body) {
                return;
            }
            var body;
            if (this.skipQuadTree || sprite.body.skipQuadTree) {
                for (var i = 0; i < group.hash.length; i++) {
                    if (!group.hash[i] || !group.hash[i].exists || !group.hash[i].body) {
                        continue;
                    }
                    body = group.hash[i].body;
                    if (this.sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) {
                        if (sprite.body.right < body.x) {
                            break;
                        } else if (body.right < sprite.body.x) {
                            continue;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) {
                        if (sprite.body.x > body.right) {
                            break;
                        } else if (body.x > sprite.body.right) {
                            continue;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) {
                        if (sprite.body.bottom < body.y) {
                            break;
                        } else if (body.bottom < sprite.body.y) {
                            continue;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) {
                        if (sprite.body.y > body.bottom) {
                            break;
                        } else if (body.y > sprite.body.bottom) {
                            continue;
                        }
                    }
                    this.collideSpriteVsSprite(sprite, group.hash[i], collideCallback, processCallback, callbackContext, overlapOnly);
                }
            } else {
                this.quadTree.clear();
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
                this.quadTree.populate(group);
                var items = this.quadTree.retrieve(sprite);
                for (var i = 0; i < items.length; i++) {
                    if (this.separate(sprite.body, items[i], processCallback, callbackContext, overlapOnly)) {
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, items[i].sprite);
                        }
                        this._total++;
                    }
                }
            }
        },
        collideGroupVsSelf: function(group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0) {
                return;
            }
            for (var i = 0; i < group.hash.length; i++) {
                if (!group.hash[i] || !group.hash[i].exists || !group.hash[i].body) {
                    continue;
                }
                var object1 = group.hash[i];
                for (var j = i + 1; j < group.hash.length; j++) {
                    if (!group.hash[j] || !group.hash[j].exists || !group.hash[j].body) {
                        continue;
                    }
                    var object2 = group.hash[j];
                    if (this.sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) {
                        if (object1.body.right < object2.body.x) {
                            break;
                        } else if (object2.body.right < object1.body.x) {
                            continue;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) {
                        if (object1.body.x > object2.body.right) {
                            continue;
                        } else if (object2.body.x > object1.body.right) {
                            break;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) {
                        if (object1.body.bottom < object2.body.y) {
                            continue;
                        } else if (object2.body.bottom < object1.body.y) {
                            break;
                        }
                    } else if (this.sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) {
                        if (object1.body.y > object2.body.bottom) {
                            continue;
                        } else if (object2.body.y > object1.body.bottom) {
                            break;
                        }
                    }
                    this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
            }
        },
        collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group1.length === 0 || group2.length === 0) {
                return;
            }
            for (var i = 0; i < group1.children.length; i++) {
                if (group1.children[i].exists) {
                    if (group1.children[i].physicsType === Phaser.GROUP) {
                        this.collideGroupVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else {
                        this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            }
        },
        separate: function(body1, body2, processCallback, callbackContext, overlapOnly) {
            if (!body1.enable || !body2.enable || !this.intersects(body1, body2)) {
                return false;
            }
            if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) {
                return false;
            }
            var result = false;
            if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                result = this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly);
            } else {
                result = this.separateY(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly);
            }
            if (overlapOnly) {
                return true;
            } else {
                return result;
            }
        },
        intersects: function(body1, body2) {
            if (body1.right <= body2.position.x) {
                return false;
            }
            if (body1.bottom <= body2.position.y) {
                return false;
            }
            if (body1.position.x >= body2.right) {
                return false;
            }
            if (body1.position.y >= body2.bottom) {
                return false;
            }
            return true;
        },
        separateX: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            var overlap = 0;
            if (this.intersects(body1, body2)) {
                var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;
                if (body1.deltaX() === 0 && body2.deltaX() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaX() > body2.deltaX()) {
                    overlap = body1.right - body2.x;
                    if (overlap > maxOverlap || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                        overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.right = true;
                        body2.touching.none = false;
                        body2.touching.left = true;
                    }
                } else if (body1.deltaX() < body2.deltaX()) {
                    overlap = body1.x - body2.width - body2.x;
                    if (-overlap > maxOverlap || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                        overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.left = true;
                        body2.touching.none = false;
                        body2.touching.right = true;
                    }
                }
                body1.overlapX = overlap;
                body2.overlapX = overlap;
                if (overlap !== 0) {
                    if (overlapOnly || body1.customSeparateX || body2.customSeparateX) {
                        return true;
                    }
                    var v1 = body1.velocity.x;
                    var v2 = body2.velocity.x;
                    if (!body1.immovable && !body2.immovable) {
                        overlap *= .5;
                        body1.x = body1.x - overlap;
                        body2.x += overlap;
                        var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
                        var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
                        var avg = (nv1 + nv2) * .5;
                        nv1 -= avg;
                        nv2 -= avg;
                        body1.velocity.x = avg + nv1 * body1.bounce.x;
                        body2.velocity.x = avg + nv2 * body2.bounce.x;
                    } else if (!body1.immovable) {
                        body1.x = body1.x - overlap;
                        body1.velocity.x = v2 - v1 * body1.bounce.x;
                        if (body2.moves) {
                            body1.y += (body2.y - body2.prev.y) * body2.friction.y;
                        }
                    } else if (!body2.immovable) {
                        body2.x += overlap;
                        body2.velocity.x = v1 - v2 * body2.bounce.x;
                        if (body1.moves) {
                            body2.y += (body1.y - body1.prev.y) * body1.friction.y;
                        }
                    }
                    return true;
                }
            }
            return false;
        },
        separateY: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            var overlap = 0;
            if (this.intersects(body1, body2)) {
                var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;
                if (body1.deltaY() === 0 && body2.deltaY() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaY() > body2.deltaY()) {
                    overlap = body1.bottom - body2.y;
                    if (overlap > maxOverlap || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                        overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.down = true;
                        body2.touching.none = false;
                        body2.touching.up = true;
                    }
                } else if (body1.deltaY() < body2.deltaY()) {
                    overlap = body1.y - body2.bottom;
                    if (-overlap > maxOverlap || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                        overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.up = true;
                        body2.touching.none = false;
                        body2.touching.down = true;
                    }
                }
                body1.overlapY = overlap;
                body2.overlapY = overlap;
                if (overlap !== 0) {
                    if (overlapOnly || body1.customSeparateY || body2.customSeparateY) {
                        return true;
                    }
                    var v1 = body1.velocity.y;
                    var v2 = body2.velocity.y;
                    if (!body1.immovable && !body2.immovable) {
                        overlap *= .5;
                        body1.y = body1.y - overlap;
                        body2.y += overlap;
                        var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
                        var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
                        var avg = (nv1 + nv2) * .5;
                        nv1 -= avg;
                        nv2 -= avg;
                        body1.velocity.y = avg + nv1 * body1.bounce.y;
                        body2.velocity.y = avg + nv2 * body2.bounce.y;
                    } else if (!body1.immovable) {
                        body1.y = body1.y - overlap;
                        body1.velocity.y = v2 - v1 * body1.bounce.y;
                        if (body2.moves) {
                            body1.x += (body2.x - body2.prev.x) * body2.friction.x;
                        }
                    } else if (!body2.immovable) {
                        body2.y += overlap;
                        body2.velocity.y = v1 - v2 * body2.bounce.y;
                        if (body1.moves) {
                            body2.x += (body1.x - body1.prev.x) * body1.friction.x;
                        }
                    }
                    return true;
                }
            }
            return false;
        },
        getObjectsUnderPointer: function(pointer, group, callback, callbackContext) {
            if (group.length === 0 || !pointer.exists) {
                return;
            }
            return this.getObjectsAtLocation(pointer.x, pointer.y, group, callback, callbackContext, pointer);
        },
        getObjectsAtLocation: function(x, y, group, callback, callbackContext, callbackArg) {
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(group);
            var rect = new Phaser.Rectangle(x, y, 1, 1);
            var output = [];
            var items = this.quadTree.retrieve(rect);
            for (var i = 0; i < items.length; i++) {
                if (items[i].hitTest(x, y)) {
                    if (callback) {
                        callback.call(callbackContext, callbackArg, items[i].sprite);
                    }
                    output.push(items[i].sprite);
                }
            }
            return output;
        },
        moveToObject: function(displayObject, destination, speed, maxTime) {
            if (speed === undefined) {
                speed = 60;
            }
            if (maxTime === undefined) {
                maxTime = 0;
            }
            var angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceBetween(displayObject, destination) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(angle) * speed;
            displayObject.body.velocity.y = Math.sin(angle) * speed;
            return angle;
        },
        moveToPointer: function(displayObject, speed, pointer, maxTime) {
            if (speed === undefined) {
                speed = 60;
            }
            pointer = pointer || this.game.input.activePointer;
            if (maxTime === undefined) {
                maxTime = 0;
            }
            var angle = this.angleToPointer(displayObject, pointer);
            if (maxTime > 0) {
                speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(angle) * speed;
            displayObject.body.velocity.y = Math.sin(angle) * speed;
            return angle;
        },
        moveToXY: function(displayObject, x, y, speed, maxTime) {
            if (speed === undefined) {
                speed = 60;
            }
            if (maxTime === undefined) {
                maxTime = 0;
            }
            var angle = Math.atan2(y - displayObject.y, x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(angle) * speed;
            displayObject.body.velocity.y = Math.sin(angle) * speed;
            return angle;
        },
        velocityFromAngle: function(angle, speed, point) {
            if (speed === undefined) {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(this.game.math.degToRad(angle)) * speed, Math.sin(this.game.math.degToRad(angle)) * speed);
        },
        velocityFromRotation: function(rotation, speed, point) {
            if (speed === undefined) {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerationFromRotation: function(rotation, speed, point) {
            if (speed === undefined) {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerateToObject: function(displayObject, destination, speed, xSpeedMax, ySpeedMax) {
            if (speed === undefined) {
                speed = 60;
            }
            if (xSpeedMax === undefined) {
                xSpeedMax = 1e3;
            }
            if (ySpeedMax === undefined) {
                ySpeedMax = 1e3;
            }
            var angle = this.angleBetween(displayObject, destination);
            displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return angle;
        },
        accelerateToPointer: function(displayObject, pointer, speed, xSpeedMax, ySpeedMax) {
            if (speed === undefined) {
                speed = 60;
            }
            if (pointer === undefined) {
                pointer = this.game.input.activePointer;
            }
            if (xSpeedMax === undefined) {
                xSpeedMax = 1e3;
            }
            if (ySpeedMax === undefined) {
                ySpeedMax = 1e3;
            }
            var angle = this.angleToPointer(displayObject, pointer);
            displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return angle;
        },
        accelerateToXY: function(displayObject, x, y, speed, xSpeedMax, ySpeedMax) {
            if (speed === undefined) {
                speed = 60;
            }
            if (xSpeedMax === undefined) {
                xSpeedMax = 1e3;
            }
            if (ySpeedMax === undefined) {
                ySpeedMax = 1e3;
            }
            var angle = this.angleToXY(displayObject, x, y);
            displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return angle;
        },
        distanceBetween: function(source, target) {
            var dx = source.x - target.x;
            var dy = source.y - target.y;
            return Math.sqrt(dx * dx + dy * dy);
        },
        distanceToXY: function(displayObject, x, y) {
            var dx = displayObject.x - x;
            var dy = displayObject.y - y;
            return Math.sqrt(dx * dx + dy * dy);
        },
        distanceToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            var dx = displayObject.x - pointer.worldX;
            var dy = displayObject.y - pointer.worldY;
            return Math.sqrt(dx * dx + dy * dy);
        },
        angleBetween: function(source, target) {
            var dx = target.x - source.x;
            var dy = target.y - source.y;
            return Math.atan2(dy, dx);
        },
        angleToXY: function(displayObject, x, y) {
            var dx = x - displayObject.x;
            var dy = y - displayObject.y;
            return Math.atan2(dy, dx);
        },
        angleToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            var dx = pointer.worldX - displayObject.x;
            var dy = pointer.worldY - displayObject.y;
            return Math.atan2(dy, dx);
        }
    };
    Phaser.Physics.Arcade.Body = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.type = Phaser.Physics.ARCADE;
        this.enable = true;
        this.offset = new Phaser.Point();
        this.position = new Phaser.Point(sprite.x, sprite.y);
        this.prev = new Phaser.Point(this.position.x, this.position.y);
        this.allowRotation = true;
        this.rotation = sprite.rotation;
        this.preRotation = sprite.rotation;
        this.width = sprite.width;
        this.height = sprite.height;
        this.sourceWidth = sprite.width;
        this.sourceHeight = sprite.height;
        if (sprite.texture) {
            this.sourceWidth = sprite.texture.frame.width;
            this.sourceHeight = sprite.texture.frame.height;
        }
        this.halfWidth = Math.abs(sprite.width / 2);
        this.halfHeight = Math.abs(sprite.height / 2);
        this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight);
        this.velocity = new Phaser.Point();
        this.newVelocity = new Phaser.Point(0, 0);
        this.deltaMax = new Phaser.Point(0, 0);
        this.acceleration = new Phaser.Point();
        this.drag = new Phaser.Point();
        this.allowGravity = true;
        this.gravity = new Phaser.Point(0, 0);
        this.bounce = new Phaser.Point();
        this.maxVelocity = new Phaser.Point(1e4, 1e4);
        this.friction = new Phaser.Point(1, 0);
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.angularDrag = 0;
        this.maxAngular = 1e3;
        this.mass = 1;
        this.angle = 0;
        this.speed = 0;
        this.facing = Phaser.NONE;
        this.immovable = false;
        this.moves = true;
        this.customSeparateX = false;
        this.customSeparateY = false;
        this.overlapX = 0;
        this.overlapY = 0;
        this.embedded = false;
        this.collideWorldBounds = false;
        this.checkCollision = {
            none: false,
            any: true,
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.touching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.wasTouching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.blocked = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.tilePadding = new Phaser.Point();
        this.dirty = false;
        this.skipQuadTree = false;
        this.syncBounds = false;
        this._reset = true;
        this._sx = sprite.scale.x;
        this._sy = sprite.scale.y;
        this._dx = 0;
        this._dy = 0;
    };
    Phaser.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            if (this.syncBounds) {
                var b = this.sprite.getBounds();
                b.ceilAll();
                if (b.width !== this.width || b.height !== this.height) {
                    this.width = b.width;
                    this.height = b.height;
                    this._reset = true;
                }
            } else {
                var asx = Math.abs(this.sprite.scale.x);
                var asy = Math.abs(this.sprite.scale.y);
                if (asx !== this._sx || asy !== this._sy) {
                    this.width = this.sourceWidth * asx;
                    this.height = this.sourceHeight * asy;
                    this._sx = asx;
                    this._sy = asy;
                    this._reset = true;
                }
            }
            if (this._reset) {
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            }
        },
        preUpdate: function() {
            if (!this.enable || this.game.physics.arcade.isPaused) {
                return;
            }
            this.dirty = true;
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = true;
            this.touching.up = false;
            this.touching.down = false;
            this.touching.left = false;
            this.touching.right = false;
            this.blocked.up = false;
            this.blocked.down = false;
            this.blocked.left = false;
            this.blocked.right = false;
            this.embedded = false;
            this.updateBounds();
            this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            if (this._reset || this.sprite.fresh) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y;
            }
            if (this.moves) {
                this.game.physics.arcade.updateMotion(this);
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
                this.position.x += this.newVelocity.x;
                this.position.y += this.newVelocity.y;
                if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) {
                    this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
                if (this.collideWorldBounds) {
                    this.checkWorldBounds();
                }
            }
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            this._reset = false;
        },
        postUpdate: function() {
            if (!this.enable || !this.dirty) {
                return;
            }
            this.dirty = false;
            if (this.deltaX() < 0) {
                this.facing = Phaser.LEFT;
            } else if (this.deltaX() > 0) {
                this.facing = Phaser.RIGHT;
            }
            if (this.deltaY() < 0) {
                this.facing = Phaser.UP;
            } else if (this.deltaY() > 0) {
                this.facing = Phaser.DOWN;
            }
            if (this.moves) {
                this._dx = this.deltaX();
                this._dy = this.deltaY();
                if (this.deltaMax.x !== 0 && this._dx !== 0) {
                    if (this._dx < 0 && this._dx < -this.deltaMax.x) {
                        this._dx = -this.deltaMax.x;
                    } else if (this._dx > 0 && this._dx > this.deltaMax.x) {
                        this._dx = this.deltaMax.x;
                    }
                }
                if (this.deltaMax.y !== 0 && this._dy !== 0) {
                    if (this._dy < 0 && this._dy < -this.deltaMax.y) {
                        this._dy = -this.deltaMax.y;
                    } else if (this._dy > 0 && this._dy > this.deltaMax.y) {
                        this._dy = this.deltaMax.y;
                    }
                }
                this.sprite.position.x += this._dx;
                this.sprite.position.y += this._dy;
                this._reset = true;
            }
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            if (this.allowRotation) {
                this.sprite.angle += this.deltaZ();
            }
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
        },
        destroy: function() {
            if (this.sprite.parent && this.sprite.parent instanceof Phaser.Group) {
                this.sprite.parent.removeFromHash(this.sprite);
            }
            this.sprite.body = null;
            this.sprite = null;
        },
        checkWorldBounds: function() {
            var pos = this.position;
            var bounds = this.game.physics.arcade.bounds;
            var check = this.game.physics.arcade.checkCollision;
            if (pos.x < bounds.x && check.left) {
                pos.x = bounds.x;
                this.velocity.x *= -this.bounce.x;
                this.blocked.left = true;
            } else if (this.right > bounds.right && check.right) {
                pos.x = bounds.right - this.width;
                this.velocity.x *= -this.bounce.x;
                this.blocked.right = true;
            }
            if (pos.y < bounds.y && check.up) {
                pos.y = bounds.y;
                this.velocity.y *= -this.bounce.y;
                this.blocked.up = true;
            } else if (this.bottom > bounds.bottom && check.down) {
                pos.y = bounds.bottom - this.height;
                this.velocity.y *= -this.bounce.y;
                this.blocked.down = true;
            }
        },
        setSize: function(width, height, offsetX, offsetY) {
            if (offsetX === undefined) {
                offsetX = this.offset.x;
            }
            if (offsetY === undefined) {
                offsetY = this.offset.y;
            }
            this.sourceWidth = width;
            this.sourceHeight = height;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(offsetX, offsetY);
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        reset: function(x, y) {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.speed = 0;
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.position.x = x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = y - this.sprite.anchor.y * this.height + this.offset.y;
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            this._sx = this.sprite.scale.x;
            this._sy = this.sprite.scale.y;
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        hitTest: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        onFloor: function() {
            return this.blocked.down;
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function() {
            return this.position.x - this.prev.x;
        },
        deltaY: function() {
            return this.position.y - this.prev.y;
        },
        deltaZ: function() {
            return this.rotation - this.preRotation;
        }
    };
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    Phaser.Physics.Arcade.Body.render = function(context, body, color, filled) {
        if (filled === undefined) {
            filled = true;
        }
        color = color || "rgba(0,255,0,0.4)";
        if (filled) {
            context.fillStyle = color;
            context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        } else {
            context.strokeStyle = color;
            context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        }
    };
    Phaser.Physics.Arcade.Body.renderBodyInfo = function(debug, body) {
        debug.line("x: " + body.x.toFixed(2), "y: " + body.y.toFixed(2), "width: " + body.width, "height: " + body.height);
        debug.line("velocity x: " + body.velocity.x.toFixed(2), "y: " + body.velocity.y.toFixed(2), "deltaX: " + body._dx.toFixed(2), "deltaY: " + body._dy.toFixed(2));
        debug.line("acceleration x: " + body.acceleration.x.toFixed(2), "y: " + body.acceleration.y.toFixed(2), "speed: " + body.speed.toFixed(2), "angle: " + body.angle.toFixed(2));
        debug.line("gravity x: " + body.gravity.x, "y: " + body.gravity.y, "bounce x: " + body.bounce.x.toFixed(2), "y: " + body.bounce.y.toFixed(2));
        debug.line("touching left: " + body.touching.left, "right: " + body.touching.right, "up: " + body.touching.up, "down: " + body.touching.down);
        debug.line("blocked left: " + body.blocked.left, "right: " + body.blocked.right, "up: " + body.blocked.up, "down: " + body.blocked.down);
    };
    Phaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body;
    Phaser.Physics.Arcade.TilemapCollision = function() {};
    Phaser.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (!sprite.body) {
                return;
            }
            var mapData = tilemapLayer.getTiles(sprite.body.position.x - sprite.body.tilePadding.x, sprite.body.position.y - sprite.body.tilePadding.y, sprite.body.width + sprite.body.tilePadding.x, sprite.body.height + sprite.body.tilePadding.y, false, false);
            if (mapData.length === 0) {
                return;
            }
            for (var i = 0; i < mapData.length; i++) {
                if (processCallback) {
                    if (processCallback.call(callbackContext, sprite, mapData[i])) {
                        if (this.separateTile(i, sprite.body, mapData[i], overlapOnly)) {
                            this._total++;
                            if (collideCallback) {
                                collideCallback.call(callbackContext, sprite, mapData[i]);
                            }
                        }
                    }
                } else {
                    if (this.separateTile(i, sprite.body, mapData[i], overlapOnly)) {
                        this._total++;
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, mapData[i]);
                        }
                    }
                }
            }
        },
        collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0) {
                return;
            }
            for (var i = 0; i < group.children.length; i++) {
                if (group.children[i].exists) {
                    this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly);
                }
            }
        },
        separateTile: function(i, body, tile, overlapOnly) {
            if (!body.enable) {
                return false;
            }
            if (!tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                return false;
            } else if (overlapOnly) {
                return true;
            }
            if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile)) {
                return false;
            } else if (tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile)) {
                return false;
            }
            if (!tile.faceLeft && !tile.faceRight && !tile.faceTop && !tile.faceBottom) {
                return false;
            }
            var ox = 0;
            var oy = 0;
            var minX = 0;
            var minY = 1;
            if (body.deltaAbsX() > body.deltaAbsY()) {
                minX = -1;
            } else if (body.deltaAbsX() < body.deltaAbsY()) {
                minY = -1;
            }
            if (body.deltaX() !== 0 && body.deltaY() !== 0 && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom)) {
                minX = Math.min(Math.abs(body.position.x - tile.right), Math.abs(body.right - tile.left));
                minY = Math.min(Math.abs(body.position.y - tile.bottom), Math.abs(body.bottom - tile.top));
            }
            if (minX < minY) {
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                    if (ox !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                }
            } else {
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                    if (oy !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                }
            }
            return ox !== 0 || oy !== 0;
        },
        tileCheckX: function(body, tile) {
            var ox = 0;
            if (body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left) {
                if (tile.faceRight && body.x < tile.right) {
                    ox = body.x - tile.right;
                    if (ox < -this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            } else if (body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right) {
                if (tile.faceLeft && body.right > tile.left) {
                    ox = body.right - tile.left;
                    if (ox > this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            }
            if (ox !== 0) {
                if (body.customSeparateX) {
                    body.overlapX = ox;
                } else {
                    this.processTileSeparationX(body, ox);
                }
            }
            return ox;
        },
        tileCheckY: function(body, tile) {
            var oy = 0;
            if (body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up) {
                if (tile.faceBottom && body.y < tile.bottom) {
                    oy = body.y - tile.bottom;
                    if (oy < -this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            } else if (body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down) {
                if (tile.faceTop && body.bottom > tile.top) {
                    oy = body.bottom - tile.top;
                    if (oy > this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            }
            if (oy !== 0) {
                if (body.customSeparateY) {
                    body.overlapY = oy;
                } else {
                    this.processTileSeparationY(body, oy);
                }
            }
            return oy;
        },
        processTileSeparationX: function(body, x) {
            if (x < 0) {
                body.blocked.left = true;
            } else if (x > 0) {
                body.blocked.right = true;
            }
            body.position.x -= x;
            if (body.bounce.x === 0) {
                body.velocity.x = 0;
            } else {
                body.velocity.x = -body.velocity.x * body.bounce.x;
            }
        },
        processTileSeparationY: function(body, y) {
            if (y < 0) {
                body.blocked.up = true;
            } else if (y > 0) {
                body.blocked.down = true;
            }
            body.position.y -= y;
            if (body.bounce.y === 0) {
                body.velocity.y = 0;
            } else {
                body.velocity.y = -body.velocity.y * body.bounce.y;
            }
        }
    };
    Phaser.Utils.mixinPrototype(Phaser.Physics.Arcade.prototype, Phaser.Physics.Arcade.TilemapCollision.prototype);
    p2.Body.prototype.parent = null;
    p2.Spring.prototype.parent = null;
    Phaser.Physics.P2 = function(game, config) {
        this.game = game;
        if (config === undefined) {
            config = {
                gravity: [ 0, 0 ],
                broadphase: new p2.SAPBroadphase()
            };
        } else {
            if (!config.hasOwnProperty("gravity")) {
                config.gravity = [ 0, 0 ];
            }
            if (!config.hasOwnProperty("broadphase")) {
                config.broadphase = new p2.SAPBroadphase();
            }
        }
        this.config = config;
        this.world = new p2.World(this.config);
        this.frameRate = 1 / 60;
        this.useElapsedTime = false;
        this.paused = false;
        this.materials = [];
        this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);
        this.walls = {
            left: null,
            right: null,
            top: null,
            bottom: null
        };
        this.onBodyAdded = new Phaser.Signal();
        this.onBodyRemoved = new Phaser.Signal();
        this.onSpringAdded = new Phaser.Signal();
        this.onSpringRemoved = new Phaser.Signal();
        this.onConstraintAdded = new Phaser.Signal();
        this.onConstraintRemoved = new Phaser.Signal();
        this.onContactMaterialAdded = new Phaser.Signal();
        this.onContactMaterialRemoved = new Phaser.Signal();
        this.postBroadphaseCallback = null;
        this.callbackContext = null;
        this.onBeginContact = new Phaser.Signal();
        this.onEndContact = new Phaser.Signal();
        if (config.hasOwnProperty("mpx") && config.hasOwnProperty("pxm") && config.hasOwnProperty("mpxi") && config.hasOwnProperty("pxmi")) {
            this.mpx = config.mpx;
            this.mpxi = config.mpxi;
            this.pxm = config.pxm;
            this.pxmi = config.pxmi;
        }
        this.world.on("beginContact", this.beginContactHandler, this);
        this.world.on("endContact", this.endContactHandler, this);
        this.collisionGroups = [];
        this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
        this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
        this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
        this.boundsCollidesWith = [];
        this._toRemove = [];
        this._collisionGroupID = 2;
        this._boundsLeft = true;
        this._boundsRight = true;
        this._boundsTop = true;
        this._boundsBottom = true;
        this._boundsOwnGroup = false;
        this.setBoundsToWorld(true, true, true, true, false);
    };
    Phaser.Physics.P2.prototype = {
        removeBodyNextStep: function(body) {
            this._toRemove.push(body);
        },
        preUpdate: function() {
            var i = this._toRemove.length;
            while (i--) {
                this.removeBody(this._toRemove[i]);
            }
            this._toRemove.length = 0;
        },
        enable: function(object, debug, children) {
            if (debug === undefined) {
                debug = false;
            }
            if (children === undefined) {
                children = true;
            }
            var i = 1;
            if (Array.isArray(object)) {
                i = object.length;
                while (i--) {
                    if (object[i] instanceof Phaser.Group) {
                        this.enable(object[i].children, debug, children);
                    } else {
                        this.enableBody(object[i], debug);
                        if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                            this.enable(object[i], debug, true);
                        }
                    }
                }
            } else {
                if (object instanceof Phaser.Group) {
                    this.enable(object.children, debug, children);
                } else {
                    this.enableBody(object, debug);
                    if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                        this.enable(object.children, debug, true);
                    }
                }
            }
        },
        enableBody: function(object, debug) {
            if (object.hasOwnProperty("body") && object.body === null) {
                object.body = new Phaser.Physics.P2.Body(this.game, object, object.x, object.y, 1);
                object.body.debug = debug;
                if (typeof object.anchor !== "undefined") {
                    object.anchor.set(.5);
                }
            }
        },
        setImpactEvents: function(state) {
            if (state) {
                this.world.on("impact", this.impactHandler, this);
            } else {
                this.world.off("impact", this.impactHandler, this);
            }
        },
        setPostBroadphaseCallback: function(callback, context) {
            this.postBroadphaseCallback = callback;
            this.callbackContext = context;
            if (callback !== null) {
                this.world.on("postBroadphase", this.postBroadphaseHandler, this);
            } else {
                this.world.off("postBroadphase", this.postBroadphaseHandler, this);
            }
        },
        postBroadphaseHandler: function(event) {
            if (!this.postBroadphaseCallback || event.pairs.length === 0) {
                return;
            }
            for (var i = event.pairs.length - 2; i >= 0; i -= 2) {
                if (event.pairs[i].parent && event.pairs[i + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, event.pairs[i].parent, event.pairs[i + 1].parent)) {
                    event.pairs.splice(i, 2);
                }
            }
        },
        impactHandler: function(event) {
            if (event.bodyA.parent && event.bodyB.parent) {
                var a = event.bodyA.parent;
                var b = event.bodyB.parent;
                if (a._bodyCallbacks[event.bodyB.id]) {
                    a._bodyCallbacks[event.bodyB.id].call(a._bodyCallbackContext[event.bodyB.id], a, b, event.shapeA, event.shapeB);
                }
                if (b._bodyCallbacks[event.bodyA.id]) {
                    b._bodyCallbacks[event.bodyA.id].call(b._bodyCallbackContext[event.bodyA.id], b, a, event.shapeB, event.shapeA);
                }
                if (a._groupCallbacks[event.shapeB.collisionGroup]) {
                    a._groupCallbacks[event.shapeB.collisionGroup].call(a._groupCallbackContext[event.shapeB.collisionGroup], a, b, event.shapeA, event.shapeB);
                }
                if (b._groupCallbacks[event.shapeA.collisionGroup]) {
                    b._groupCallbacks[event.shapeA.collisionGroup].call(b._groupCallbackContext[event.shapeA.collisionGroup], b, a, event.shapeB, event.shapeA);
                }
            }
        },
        beginContactHandler: function(event) {
            if (event.bodyA && event.bodyB) {
                this.onBeginContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB, event.contactEquations);
                if (event.bodyA.parent) {
                    event.bodyA.parent.onBeginContact.dispatch(event.bodyB.parent, event.bodyB, event.shapeA, event.shapeB, event.contactEquations);
                }
                if (event.bodyB.parent) {
                    event.bodyB.parent.onBeginContact.dispatch(event.bodyA.parent, event.bodyA, event.shapeB, event.shapeA, event.contactEquations);
                }
            }
        },
        endContactHandler: function(event) {
            if (event.bodyA && event.bodyB) {
                this.onEndContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB);
                if (event.bodyA.parent) {
                    event.bodyA.parent.onEndContact.dispatch(event.bodyB.parent, event.bodyB, event.shapeA, event.shapeB);
                }
                if (event.bodyB.parent) {
                    event.bodyB.parent.onEndContact.dispatch(event.bodyA.parent, event.bodyA, event.shapeB, event.shapeA);
                }
            }
        },
        setBoundsToWorld: function(left, right, top, bottom, setCollisionGroup) {
            this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, setCollisionGroup);
        },
        setWorldMaterial: function(material, left, right, top, bottom) {
            if (left === undefined) {
                left = true;
            }
            if (right === undefined) {
                right = true;
            }
            if (top === undefined) {
                top = true;
            }
            if (bottom === undefined) {
                bottom = true;
            }
            if (left && this.walls.left) {
                this.walls.left.shapes[0].material = material;
            }
            if (right && this.walls.right) {
                this.walls.right.shapes[0].material = material;
            }
            if (top && this.walls.top) {
                this.walls.top.shapes[0].material = material;
            }
            if (bottom && this.walls.bottom) {
                this.walls.bottom.shapes[0].material = material;
            }
        },
        updateBoundsCollisionGroup: function(setCollisionGroup) {
            var mask = this.everythingCollisionGroup.mask;
            if (setCollisionGroup === undefined) {
                mask = this.boundsCollisionGroup.mask;
            }
            if (this.walls.left) {
                this.walls.left.shapes[0].collisionGroup = mask;
            }
            if (this.walls.right) {
                this.walls.right.shapes[0].collisionGroup = mask;
            }
            if (this.walls.top) {
                this.walls.top.shapes[0].collisionGroup = mask;
            }
            if (this.walls.bottom) {
                this.walls.bottom.shapes[0].collisionGroup = mask;
            }
        },
        setBounds: function(x, y, width, height, left, right, top, bottom, setCollisionGroup) {
            if (left === undefined) {
                left = this._boundsLeft;
            }
            if (right === undefined) {
                right = this._boundsRight;
            }
            if (top === undefined) {
                top = this._boundsTop;
            }
            if (bottom === undefined) {
                bottom = this._boundsBottom;
            }
            if (setCollisionGroup === undefined) {
                setCollisionGroup = this._boundsOwnGroup;
            }
            if (this.walls.left) {
                this.world.removeBody(this.walls.left);
            }
            if (this.walls.right) {
                this.world.removeBody(this.walls.right);
            }
            if (this.walls.top) {
                this.world.removeBody(this.walls.top);
            }
            if (this.walls.bottom) {
                this.world.removeBody(this.walls.bottom);
            }
            if (left) {
                this.walls.left = new p2.Body({
                    mass: 0,
                    position: [ this.pxmi(x), this.pxmi(y) ],
                    angle: 1.5707963267948966
                });
                this.walls.left.addShape(new p2.Plane());
                if (setCollisionGroup) {
                    this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
                }
                this.world.addBody(this.walls.left);
            }
            if (right) {
                this.walls.right = new p2.Body({
                    mass: 0,
                    position: [ this.pxmi(x + width), this.pxmi(y) ],
                    angle: -1.5707963267948966
                });
                this.walls.right.addShape(new p2.Plane());
                if (setCollisionGroup) {
                    this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
                }
                this.world.addBody(this.walls.right);
            }
            if (top) {
                this.walls.top = new p2.Body({
                    mass: 0,
                    position: [ this.pxmi(x), this.pxmi(y) ],
                    angle: -3.141592653589793
                });
                this.walls.top.addShape(new p2.Plane());
                if (setCollisionGroup) {
                    this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
                }
                this.world.addBody(this.walls.top);
            }
            if (bottom) {
                this.walls.bottom = new p2.Body({
                    mass: 0,
                    position: [ this.pxmi(x), this.pxmi(y + height) ]
                });
                this.walls.bottom.addShape(new p2.Plane());
                if (setCollisionGroup) {
                    this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
                }
                this.world.addBody(this.walls.bottom);
            }
            this._boundsLeft = left;
            this._boundsRight = right;
            this._boundsTop = top;
            this._boundsBottom = bottom;
            this._boundsOwnGroup = setCollisionGroup;
        },
        pause: function() {
            this.paused = true;
        },
        resume: function() {
            this.paused = false;
        },
        update: function() {
            if (this.paused) {
                return;
            }
            if (this.useElapsedTime) {
                this.world.step(this.game.time.physicsElapsed);
            } else {
                this.world.step(this.frameRate);
            }
        },
        reset: function() {
            this.world.on("beginContact", this.beginContactHandler, this);
            this.world.on("endContact", this.endContactHandler, this);
            this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
            this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
            this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
            this._collisionGroupID = 2;
            this.setBoundsToWorld(true, true, true, true, false);
        },
        clear: function() {
            this.world.time = 0;
            this.world.fixedStepTime = 0;
            if (this.world.solver && this.world.solver.equations.length) {
                this.world.solver.removeAllEquations();
            }
            var cs = this.world.constraints;
            for (var i = cs.length - 1; i >= 0; i--) {
                this.world.removeConstraint(cs[i]);
            }
            var bodies = this.world.bodies;
            for (var i = bodies.length - 1; i >= 0; i--) {
                this.world.removeBody(bodies[i]);
            }
            var springs = this.world.springs;
            for (var i = springs.length - 1; i >= 0; i--) {
                this.world.removeSpring(springs[i]);
            }
            var cms = this.world.contactMaterials;
            for (var i = cms.length - 1; i >= 0; i--) {
                this.world.removeContactMaterial(cms[i]);
            }
            this.world.off("beginContact", this.beginContactHandler, this);
            this.world.off("endContact", this.endContactHandler, this);
            this.postBroadphaseCallback = null;
            this.callbackContext = null;
            this.impactCallback = null;
            this.collisionGroups = [];
            this._toRemove = [];
            this.boundsCollidesWith = [];
        },
        destroy: function() {
            this.clear();
            this.game = null;
        },
        addBody: function(body) {
            if (body.data.world) {
                return false;
            } else {
                this.world.addBody(body.data);
                this.onBodyAdded.dispatch(body);
                return true;
            }
        },
        removeBody: function(body) {
            if (body.data.world == this.world) {
                this.world.removeBody(body.data);
                this.onBodyRemoved.dispatch(body);
            }
            return body;
        },
        addSpring: function(spring) {
            if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
                this.world.addSpring(spring.data);
            } else {
                this.world.addSpring(spring);
            }
            this.onSpringAdded.dispatch(spring);
            return spring;
        },
        removeSpring: function(spring) {
            if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
                this.world.removeSpring(spring.data);
            } else {
                this.world.removeSpring(spring);
            }
            this.onSpringRemoved.dispatch(spring);
            return spring;
        },
        createDistanceConstraint: function(bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Constraint, invalid body objects given");
            } else {
                return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce));
            }
        },
        createGearConstraint: function(bodyA, bodyB, angle, ratio) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Constraint, invalid body objects given");
            } else {
                return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, bodyA, bodyB, angle, ratio));
            }
        },
        createRevoluteConstraint: function(bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Constraint, invalid body objects given");
            } else {
                return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot));
            }
        },
        createLockConstraint: function(bodyA, bodyB, offset, angle, maxForce) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Constraint, invalid body objects given");
            } else {
                return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, bodyA, bodyB, offset, angle, maxForce));
            }
        },
        createPrismaticConstraint: function(bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Constraint, invalid body objects given");
            } else {
                return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce));
            }
        },
        addConstraint: function(constraint) {
            this.world.addConstraint(constraint);
            this.onConstraintAdded.dispatch(constraint);
            return constraint;
        },
        removeConstraint: function(constraint) {
            this.world.removeConstraint(constraint);
            this.onConstraintRemoved.dispatch(constraint);
            return constraint;
        },
        addContactMaterial: function(material) {
            this.world.addContactMaterial(material);
            this.onContactMaterialAdded.dispatch(material);
            return material;
        },
        removeContactMaterial: function(material) {
            this.world.removeContactMaterial(material);
            this.onContactMaterialRemoved.dispatch(material);
            return material;
        },
        getContactMaterial: function(materialA, materialB) {
            return this.world.getContactMaterial(materialA, materialB);
        },
        setMaterial: function(material, bodies) {
            var i = bodies.length;
            while (i--) {
                bodies[i].setMaterial(material);
            }
        },
        createMaterial: function(name, body) {
            name = name || "";
            var material = new Phaser.Physics.P2.Material(name);
            this.materials.push(material);
            if (typeof body !== "undefined") {
                body.setMaterial(material);
            }
            return material;
        },
        createContactMaterial: function(materialA, materialB, options) {
            if (materialA === undefined) {
                materialA = this.createMaterial();
            }
            if (materialB === undefined) {
                materialB = this.createMaterial();
            }
            var contact = new Phaser.Physics.P2.ContactMaterial(materialA, materialB, options);
            return this.addContactMaterial(contact);
        },
        getBodies: function() {
            var output = [];
            var i = this.world.bodies.length;
            while (i--) {
                output.push(this.world.bodies[i].parent);
            }
            return output;
        },
        getBody: function(object) {
            if (object instanceof p2.Body) {
                return object;
            } else if (object instanceof Phaser.Physics.P2.Body) {
                return object.data;
            } else if (object["body"] && object["body"].type === Phaser.Physics.P2JS) {
                return object.body.data;
            }
            return null;
        },
        getSprings: function() {
            var output = [];
            var i = this.world.springs.length;
            while (i--) {
                output.push(this.world.springs[i].parent);
            }
            return output;
        },
        getConstraints: function() {
            var output = [];
            var i = this.world.constraints.length;
            while (i--) {
                output.push(this.world.constraints[i]);
            }
            return output;
        },
        hitTest: function(worldPoint, bodies, precision, filterStatic) {
            if (bodies === undefined) {
                bodies = this.world.bodies;
            }
            if (precision === undefined) {
                precision = 5;
            }
            if (filterStatic === undefined) {
                filterStatic = false;
            }
            var physicsPosition = [ this.pxmi(worldPoint.x), this.pxmi(worldPoint.y) ];
            var query = [];
            var i = bodies.length;
            while (i--) {
                if (bodies[i] instanceof Phaser.Physics.P2.Body && !(filterStatic && bodies[i].data.type === p2.Body.STATIC)) {
                    query.push(bodies[i].data);
                } else if (bodies[i] instanceof p2.Body && bodies[i].parent && !(filterStatic && bodies[i].type === p2.Body.STATIC)) {
                    query.push(bodies[i]);
                } else if (bodies[i] instanceof Phaser.Sprite && bodies[i].hasOwnProperty("body") && !(filterStatic && bodies[i].body.data.type === p2.Body.STATIC)) {
                    query.push(bodies[i].body.data);
                }
            }
            return this.world.hitTest(physicsPosition, query, precision);
        },
        toJSON: function() {
            return this.world.toJSON();
        },
        createCollisionGroup: function(object) {
            var bitmask = Math.pow(2, this._collisionGroupID);
            if (this.walls.left) {
                this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | bitmask;
            }
            if (this.walls.right) {
                this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | bitmask;
            }
            if (this.walls.top) {
                this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | bitmask;
            }
            if (this.walls.bottom) {
                this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | bitmask;
            }
            this._collisionGroupID++;
            var group = new Phaser.Physics.P2.CollisionGroup(bitmask);
            this.collisionGroups.push(group);
            if (object) {
                this.setCollisionGroup(object, group);
            }
            return group;
        },
        setCollisionGroup: function(object, group) {
            if (object instanceof Phaser.Group) {
                for (var i = 0; i < object.total; i++) {
                    if (object.children[i]["body"] && object.children[i]["body"].type === Phaser.Physics.P2JS) {
                        object.children[i].body.setCollisionGroup(group);
                    }
                }
            } else {
                object.body.setCollisionGroup(group);
            }
        },
        createSpring: function(bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Spring, invalid body objects given");
            } else {
                return this.addSpring(new Phaser.Physics.P2.Spring(this, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB));
            }
        },
        createRotationalSpring: function(bodyA, bodyB, restAngle, stiffness, damping) {
            bodyA = this.getBody(bodyA);
            bodyB = this.getBody(bodyB);
            if (!bodyA || !bodyB) {
                console.warn("Cannot create Rotational Spring, invalid body objects given");
            } else {
                return this.addSpring(new Phaser.Physics.P2.RotationalSpring(this, bodyA, bodyB, restAngle, stiffness, damping));
            }
        },
        createBody: function(x, y, mass, addToWorld, options, data) {
            if (addToWorld === undefined) {
                addToWorld = false;
            }
            var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
            if (data) {
                var result = body.addPolygon(options, data);
                if (!result) {
                    return false;
                }
            }
            if (addToWorld) {
                this.world.addBody(body.data);
            }
            return body;
        },
        createParticle: function(x, y, mass, addToWorld, options, data) {
            if (addToWorld === undefined) {
                addToWorld = false;
            }
            var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
            if (data) {
                var result = body.addPolygon(options, data);
                if (!result) {
                    return false;
                }
            }
            if (addToWorld) {
                this.world.addBody(body.data);
            }
            return body;
        },
        convertCollisionObjects: function(map, layer, addToWorld) {
            if (addToWorld === undefined) {
                addToWorld = true;
            }
            var output = [];
            for (var i = 0, len = map.collision[layer].length; i < len; i++) {
                var object = map.collision[layer][i];
                var body = this.createBody(object.x, object.y, 0, addToWorld, {}, object.polyline);
                if (body) {
                    output.push(body);
                }
            }
            return output;
        },
        clearTilemapLayerBodies: function(map, layer) {
            layer = map.getLayer(layer);
            var i = map.layers[layer].bodies.length;
            while (i--) {
                map.layers[layer].bodies[i].destroy();
            }
            map.layers[layer].bodies.length = 0;
        },
        convertTilemap: function(map, layer, addToWorld, optimize) {
            layer = map.getLayer(layer);
            if (addToWorld === undefined) {
                addToWorld = true;
            }
            if (optimize === undefined) {
                optimize = true;
            }
            this.clearTilemapLayerBodies(map, layer);
            var width = 0;
            var sx = 0;
            var sy = 0;
            for (var y = 0, h = map.layers[layer].height; y < h; y++) {
                width = 0;
                for (var x = 0, w = map.layers[layer].width; x < w; x++) {
                    var tile = map.layers[layer].data[y][x];
                    if (tile && tile.index > -1 && tile.collides) {
                        if (optimize) {
                            var right = map.getTileRight(layer, x, y);
                            if (width === 0) {
                                sx = tile.x * tile.width;
                                sy = tile.y * tile.height;
                                width = tile.width;
                            }
                            if (right && right.collides) {
                                width += tile.width;
                            } else {
                                var body = this.createBody(sx, sy, 0, false);
                                body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);
                                if (addToWorld) {
                                    this.addBody(body);
                                }
                                map.layers[layer].bodies.push(body);
                                width = 0;
                            }
                        } else {
                            var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);
                            body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);
                            if (addToWorld) {
                                this.addBody(body);
                            }
                            map.layers[layer].bodies.push(body);
                        }
                    }
                }
            }
            return map.layers[layer].bodies;
        },
        mpx: function(v) {
            return v *= 20;
        },
        pxm: function(v) {
            return v * .05;
        },
        mpxi: function(v) {
            return v *= -20;
        },
        pxmi: function(v) {
            return v * -.05;
        }
    };
    Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
        get: function() {
            return this.world.defaultContactMaterial.friction;
        },
        set: function(value) {
            this.world.defaultContactMaterial.friction = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
        get: function() {
            return this.world.defaultContactMaterial.restitution;
        },
        set: function(value) {
            this.world.defaultContactMaterial.restitution = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
        get: function() {
            return this.world.defaultContactMaterial;
        },
        set: function(value) {
            this.world.defaultContactMaterial = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
        get: function() {
            return this.world.applySpringForces;
        },
        set: function(value) {
            this.world.applySpringForces = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
        get: function() {
            return this.world.applyDamping;
        },
        set: function(value) {
            this.world.applyDamping = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
        get: function() {
            return this.world.applyGravity;
        },
        set: function(value) {
            this.world.applyGravity = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
        get: function() {
            return this.world.solveConstraints;
        },
        set: function(value) {
            this.world.solveConstraints = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
        get: function() {
            return this.world.time;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
        get: function() {
            return this.world.emitImpactEvent;
        },
        set: function(value) {
            this.world.emitImpactEvent = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "sleepMode", {
        get: function() {
            return this.world.sleepMode;
        },
        set: function(value) {
            this.world.sleepMode = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
        get: function() {
            return this.world.bodies.length;
        }
    });
    Phaser.Physics.P2.FixtureList = function(list) {
        if (!Array.isArray(list)) {
            list = [ list ];
        }
        this.rawList = list;
        this.init();
        this.parse(this.rawList);
    };
    Phaser.Physics.P2.FixtureList.prototype = {
        init: function() {
            this.namedFixtures = {};
            this.groupedFixtures = [];
            this.allFixtures = [];
        },
        setCategory: function(bit, fixtureKey) {
            var setter = function(fixture) {
                fixture.collisionGroup = bit;
            };
            this.getFixtures(fixtureKey).forEach(setter);
        },
        setMask: function(bit, fixtureKey) {
            var setter = function(fixture) {
                fixture.collisionMask = bit;
            };
            this.getFixtures(fixtureKey).forEach(setter);
        },
        setSensor: function(value, fixtureKey) {
            var setter = function(fixture) {
                fixture.sensor = value;
            };
            this.getFixtures(fixtureKey).forEach(setter);
        },
        setMaterial: function(material, fixtureKey) {
            var setter = function(fixture) {
                fixture.material = material;
            };
            this.getFixtures(fixtureKey).forEach(setter);
        },
        getFixtures: function(keys) {
            var fixtures = [];
            if (keys) {
                if (!(keys instanceof Array)) {
                    keys = [ keys ];
                }
                var self = this;
                keys.forEach(function(key) {
                    if (self.namedFixtures[key]) {
                        fixtures.push(self.namedFixtures[key]);
                    }
                });
                return this.flatten(fixtures);
            } else {
                return this.allFixtures;
            }
        },
        getFixtureByKey: function(key) {
            return this.namedFixtures[key];
        },
        getGroup: function(groupID) {
            return this.groupedFixtures[groupID];
        },
        parse: function() {
            var key, value, _ref, _results;
            _ref = this.rawList;
            _results = [];
            for (key in _ref) {
                value = _ref[key];
                if (!isNaN(key - 0)) {
                    this.groupedFixtures[key] = this.groupedFixtures[key] || [];
                    this.groupedFixtures[key] = this.groupedFixtures[key].concat(value);
                } else {
                    this.namedFixtures[key] = this.flatten(value);
                }
                _results.push(this.allFixtures = this.flatten(this.groupedFixtures));
            }
        },
        flatten: function(array) {
            var result, self;
            result = [];
            self = arguments.callee;
            array.forEach(function(item) {
                return Array.prototype.push.apply(result, Array.isArray(item) ? self(item) : [ item ]);
            });
            return result;
        }
    };
    Phaser.Physics.P2.PointProxy = function(world, destination) {
        this.world = world;
        this.destination = destination;
    };
    Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;
    Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
        get: function() {
            return this.world.mpx(this.destination[0]);
        },
        set: function(value) {
            this.destination[0] = this.world.pxm(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
        get: function() {
            return this.world.mpx(this.destination[1]);
        },
        set: function(value) {
            this.destination[1] = this.world.pxm(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(value) {
            this.destination[0] = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(value) {
            this.destination[1] = value;
        }
    });
    Phaser.Physics.P2.InversePointProxy = function(world, destination) {
        this.world = world;
        this.destination = destination;
    };
    Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;
    Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.destination[0]);
        },
        set: function(value) {
            this.destination[0] = this.world.pxmi(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.destination[1]);
        },
        set: function(value) {
            this.destination[1] = this.world.pxmi(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(value) {
            this.destination[0] = -value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(value) {
            this.destination[1] = -value;
        }
    });
    Phaser.Physics.P2.Body = function(game, sprite, x, y, mass) {
        sprite = sprite || null;
        x = x || 0;
        y = y || 0;
        if (mass === undefined) {
            mass = 1;
        }
        this.game = game;
        this.world = game.physics.p2;
        this.sprite = sprite;
        this.type = Phaser.Physics.P2JS;
        this.offset = new Phaser.Point();
        this.data = new p2.Body({
            position: [ this.world.pxmi(x), this.world.pxmi(y) ],
            mass: mass
        });
        this.data.parent = this;
        this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);
        this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);
        this.gravity = new Phaser.Point();
        this.onBeginContact = new Phaser.Signal();
        this.onEndContact = new Phaser.Signal();
        this.collidesWith = [];
        this.removeNextStep = false;
        this.debugBody = null;
        this.dirty = false;
        this._collideWorldBounds = true;
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        this._reset = false;
        if (sprite) {
            this.setRectangleFromSprite(sprite);
            if (sprite.exists) {
                this.game.physics.p2.addBody(this);
            }
        }
    };
    Phaser.Physics.P2.Body.prototype = {
        createBodyCallback: function(object, callback, callbackContext) {
            var id = -1;
            if (object["id"]) {
                id = object.id;
            } else if (object["body"]) {
                id = object.body.id;
            }
            if (id > -1) {
                if (callback === null) {
                    delete this._bodyCallbacks[id];
                    delete this._bodyCallbackContext[id];
                } else {
                    this._bodyCallbacks[id] = callback;
                    this._bodyCallbackContext[id] = callbackContext;
                }
            }
        },
        createGroupCallback: function(group, callback, callbackContext) {
            if (callback === null) {
                delete this._groupCallbacks[group.mask];
                delete this._groupCallbackContext[group.mask];
            } else {
                this._groupCallbacks[group.mask] = callback;
                this._groupCallbackContext[group.mask] = callbackContext;
            }
        },
        getCollisionMask: function() {
            var mask = 0;
            if (this._collideWorldBounds) {
                mask = this.game.physics.p2.boundsCollisionGroup.mask;
            }
            for (var i = 0; i < this.collidesWith.length; i++) {
                mask = mask | this.collidesWith[i].mask;
            }
            return mask;
        },
        updateCollisionMask: function(shape) {
            var mask = this.getCollisionMask();
            if (shape === undefined) {
                for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                    this.data.shapes[i].collisionMask = mask;
                }
            } else {
                shape.collisionMask = mask;
            }
        },
        setCollisionGroup: function(group, shape) {
            var mask = this.getCollisionMask();
            if (shape === undefined) {
                for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                    this.data.shapes[i].collisionGroup = group.mask;
                    this.data.shapes[i].collisionMask = mask;
                }
            } else {
                shape.collisionGroup = group.mask;
                shape.collisionMask = mask;
            }
        },
        clearCollision: function(clearGroup, clearMask, shape) {
            if (clearGroup === undefined) {
                clearGroup = true;
            }
            if (clearMask === undefined) {
                clearMask = true;
            }
            if (shape === undefined) {
                for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                    if (clearGroup) {
                        this.data.shapes[i].collisionGroup = null;
                    }
                    if (clearMask) {
                        this.data.shapes[i].collisionMask = null;
                    }
                }
            } else {
                if (clearGroup) {
                    shape.collisionGroup = null;
                }
                if (clearMask) {
                    shape.collisionMask = null;
                }
            }
            if (clearGroup) {
                this.collidesWith.length = 0;
            }
        },
        collides: function(group, callback, callbackContext, shape) {
            if (Array.isArray(group)) {
                for (var i = 0; i < group.length; i++) {
                    if (this.collidesWith.indexOf(group[i]) === -1) {
                        this.collidesWith.push(group[i]);
                        if (callback) {
                            this.createGroupCallback(group[i], callback, callbackContext);
                        }
                    }
                }
            } else {
                if (this.collidesWith.indexOf(group) === -1) {
                    this.collidesWith.push(group);
                    if (callback) {
                        this.createGroupCallback(group, callback, callbackContext);
                    }
                }
            }
            var mask = this.getCollisionMask();
            if (shape === undefined) {
                for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                    this.data.shapes[i].collisionMask = mask;
                }
            } else {
                shape.collisionMask = mask;
            }
        },
        adjustCenterOfMass: function() {
            this.data.adjustCenterOfMass();
            this.shapeChanged();
        },
        getVelocityAtPoint: function(result, relativePoint) {
            return this.data.getVelocityAtPoint(result, relativePoint);
        },
        applyDamping: function(dt) {
            this.data.applyDamping(dt);
        },
        applyImpulse: function(impulse, worldX, worldY) {
            this.data.applyImpulse(impulse, [ this.world.pxmi(worldX), this.world.pxmi(worldY) ]);
        },
        applyImpulseLocal: function(impulse, localX, localY) {
            this.data.applyImpulseLocal(impulse, [ this.world.pxmi(localX), this.world.pxmi(localY) ]);
        },
        applyForce: function(force, worldX, worldY) {
            this.data.applyForce(force, [ this.world.pxmi(worldX), this.world.pxmi(worldY) ]);
        },
        setZeroForce: function() {
            this.data.setZeroForce();
        },
        setZeroRotation: function() {
            this.data.angularVelocity = 0;
        },
        setZeroVelocity: function() {
            this.data.velocity[0] = 0;
            this.data.velocity[1] = 0;
        },
        setZeroDamping: function() {
            this.data.damping = 0;
            this.data.angularDamping = 0;
        },
        toLocalFrame: function(out, worldPoint) {
            return this.data.toLocalFrame(out, worldPoint);
        },
        toWorldFrame: function(out, localPoint) {
            return this.data.toWorldFrame(out, localPoint);
        },
        rotateLeft: function(speed) {
            this.data.angularVelocity = this.world.pxm(-speed);
        },
        rotateRight: function(speed) {
            this.data.angularVelocity = this.world.pxm(speed);
        },
        moveForward: function(speed) {
            var magnitude = this.world.pxmi(-speed);
            var angle = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = magnitude * Math.cos(angle);
            this.data.velocity[1] = magnitude * Math.sin(angle);
        },
        moveBackward: function(speed) {
            var magnitude = this.world.pxmi(-speed);
            var angle = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = -(magnitude * Math.cos(angle));
            this.data.velocity[1] = -(magnitude * Math.sin(angle));
        },
        thrust: function(speed) {
            var magnitude = this.world.pxmi(-speed);
            var angle = this.data.angle + Math.PI / 2;
            this.data.force[0] += magnitude * Math.cos(angle);
            this.data.force[1] += magnitude * Math.sin(angle);
        },
        reverse: function(speed) {
            var magnitude = this.world.pxmi(-speed);
            var angle = this.data.angle + Math.PI / 2;
            this.data.force[0] -= magnitude * Math.cos(angle);
            this.data.force[1] -= magnitude * Math.sin(angle);
        },
        moveLeft: function(speed) {
            this.data.velocity[0] = this.world.pxmi(-speed);
        },
        moveRight: function(speed) {
            this.data.velocity[0] = this.world.pxmi(speed);
        },
        moveUp: function(speed) {
            this.data.velocity[1] = this.world.pxmi(-speed);
        },
        moveDown: function(speed) {
            this.data.velocity[1] = this.world.pxmi(speed);
        },
        preUpdate: function() {
            this.dirty = true;
            if (this.removeNextStep) {
                this.removeFromWorld();
                this.removeNextStep = false;
            }
        },
        postUpdate: function() {
            this.sprite.x = this.world.mpxi(this.data.position[0]);
            this.sprite.y = this.world.mpxi(this.data.position[1]);
            if (!this.fixedRotation) {
                this.sprite.rotation = this.data.angle;
            }
            if (this.debugBody) {
                this.debugBody.updateSpriteTransform();
            }
            this.dirty = false;
        },
        reset: function(x, y, resetDamping, resetMass) {
            if (resetDamping === undefined) {
                resetDamping = false;
            }
            if (resetMass === undefined) {
                resetMass = false;
            }
            this.setZeroForce();
            this.setZeroVelocity();
            this.setZeroRotation();
            if (resetDamping) {
                this.setZeroDamping();
            }
            if (resetMass) {
                this.mass = 1;
            }
            this.x = x;
            this.y = y;
        },
        addToWorld: function() {
            if (this.game.physics.p2._toRemove) {
                for (var i = 0; i < this.game.physics.p2._toRemove.length; i++) {
                    if (this.game.physics.p2._toRemove[i] === this) {
                        this.game.physics.p2._toRemove.splice(i, 1);
                    }
                }
            }
            if (this.data.world !== this.game.physics.p2.world) {
                this.game.physics.p2.addBody(this);
            }
        },
        removeFromWorld: function() {
            if (this.data.world === this.game.physics.p2.world) {
                this.game.physics.p2.removeBodyNextStep(this);
            }
        },
        destroy: function() {
            this.removeFromWorld();
            this.clearShapes();
            this._bodyCallbacks = {};
            this._bodyCallbackContext = {};
            this._groupCallbacks = {};
            this._groupCallbackContext = {};
            if (this.debugBody) {
                this.debugBody.destroy(true, true);
            }
            this.debugBody = null;
            if (this.sprite) {
                this.sprite.body = null;
                this.sprite = null;
            }
        },
        clearShapes: function() {
            var i = this.data.shapes.length;
            while (i--) {
                this.data.removeShape(this.data.shapes[i]);
            }
            this.shapeChanged();
        },
        addShape: function(shape, offsetX, offsetY, rotation) {
            if (offsetX === undefined) {
                offsetX = 0;
            }
            if (offsetY === undefined) {
                offsetY = 0;
            }
            if (rotation === undefined) {
                rotation = 0;
            }
            this.data.addShape(shape, [ this.world.pxmi(offsetX), this.world.pxmi(offsetY) ], rotation);
            this.shapeChanged();
            return shape;
        },
        addCircle: function(radius, offsetX, offsetY, rotation) {
            var shape = new p2.Circle({
                radius: this.world.pxm(radius)
            });
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addRectangle: function(width, height, offsetX, offsetY, rotation) {
            var shape = new p2.Box({
                width: this.world.pxm(width),
                height: this.world.pxm(height)
            });
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addPlane: function(offsetX, offsetY, rotation) {
            var shape = new p2.Plane();
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addParticle: function(offsetX, offsetY, rotation) {
            var shape = new p2.Particle();
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addLine: function(length, offsetX, offsetY, rotation) {
            var shape = new p2.Line({
                length: this.world.pxm(length)
            });
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addCapsule: function(length, radius, offsetX, offsetY, rotation) {
            var shape = new p2.Capsule({
                length: this.world.pxm(length),
                radius: this.world.pxm(radius)
            });
            return this.addShape(shape, offsetX, offsetY, rotation);
        },
        addPolygon: function(options, points) {
            options = options || {};
            if (!Array.isArray(points)) {
                points = Array.prototype.slice.call(arguments, 1);
            }
            var path = [];
            if (points.length === 1 && Array.isArray(points[0])) {
                path = points[0].slice(0);
            } else if (Array.isArray(points[0])) {
                path = points.slice();
            } else if (typeof points[0] === "number") {
                for (var i = 0, len = points.length; i < len; i += 2) {
                    path.push([ points[i], points[i + 1] ]);
                }
            }
            var idx = path.length - 1;
            if (path[idx][0] === path[0][0] && path[idx][1] === path[0][1]) {
                path.pop();
            }
            for (var p = 0; p < path.length; p++) {
                path[p][0] = this.world.pxmi(path[p][0]);
                path[p][1] = this.world.pxmi(path[p][1]);
            }
            var result = this.data.fromPolygon(path, options);
            this.shapeChanged();
            return result;
        },
        removeShape: function(shape) {
            var result = this.data.removeShape(shape);
            this.shapeChanged();
            return result;
        },
        setCircle: function(radius, offsetX, offsetY, rotation) {
            this.clearShapes();
            return this.addCircle(radius, offsetX, offsetY, rotation);
        },
        setRectangle: function(width, height, offsetX, offsetY, rotation) {
            if (width === undefined) {
                width = 16;
            }
            if (height === undefined) {
                height = 16;
            }
            this.clearShapes();
            return this.addRectangle(width, height, offsetX, offsetY, rotation);
        },
        setRectangleFromSprite: function(sprite) {
            if (sprite === undefined) {
                sprite = this.sprite;
            }
            this.clearShapes();
            return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);
        },
        setMaterial: function(material, shape) {
            if (shape === undefined) {
                for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                    this.data.shapes[i].material = material;
                }
            } else {
                shape.material = material;
            }
        },
        shapeChanged: function() {
            if (this.debugBody) {
                this.debugBody.draw();
            }
        },
        addPhaserPolygon: function(key, object) {
            var data = this.game.cache.getPhysicsData(key, object);
            var createdFixtures = [];
            for (var i = 0; i < data.length; i++) {
                var fixtureData = data[i];
                var shapesOfFixture = this.addFixture(fixtureData);
                createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group] || [];
                createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group].concat(shapesOfFixture);
                if (fixtureData.fixtureKey) {
                    createdFixtures[fixtureData.fixtureKey] = shapesOfFixture;
                }
            }
            this.data.aabbNeedsUpdate = true;
            this.shapeChanged();
            return createdFixtures;
        },
        addFixture: function(fixtureData) {
            var generatedShapes = [];
            if (fixtureData.circle) {
                var shape = new p2.Circle({
                    radius: this.world.pxm(fixtureData.circle.radius)
                });
                shape.collisionGroup = fixtureData.filter.categoryBits;
                shape.collisionMask = fixtureData.filter.maskBits;
                shape.sensor = fixtureData.isSensor;
                var offset = p2.vec2.create();
                offset[0] = this.world.pxmi(fixtureData.circle.position[0] - this.sprite.width / 2);
                offset[1] = this.world.pxmi(fixtureData.circle.position[1] - this.sprite.height / 2);
                this.data.addShape(shape, offset);
                generatedShapes.push(shape);
            } else {
                var polygons = fixtureData.polygons;
                var cm = p2.vec2.create();
                for (var i = 0; i < polygons.length; i++) {
                    var shapes = polygons[i];
                    var vertices = [];
                    for (var s = 0; s < shapes.length; s += 2) {
                        vertices.push([ this.world.pxmi(shapes[s]), this.world.pxmi(shapes[s + 1]) ]);
                    }
                    var shape = new p2.Convex({
                        vertices: vertices
                    });
                    for (var j = 0; j !== shape.vertices.length; j++) {
                        var v = shape.vertices[j];
                        p2.vec2.sub(v, v, shape.centerOfMass);
                    }
                    p2.vec2.scale(cm, shape.centerOfMass, 1);
                    cm[0] -= this.world.pxmi(this.sprite.width / 2);
                    cm[1] -= this.world.pxmi(this.sprite.height / 2);
                    shape.updateTriangles();
                    shape.updateCenterOfMass();
                    shape.updateBoundingRadius();
                    shape.collisionGroup = fixtureData.filter.categoryBits;
                    shape.collisionMask = fixtureData.filter.maskBits;
                    shape.sensor = fixtureData.isSensor;
                    this.data.addShape(shape, cm);
                    generatedShapes.push(shape);
                }
            }
            return generatedShapes;
        },
        loadPolygon: function(key, object) {
            if (key === null) {
                var data = object;
            } else {
                var data = this.game.cache.getPhysicsData(key, object);
            }
            var cm = p2.vec2.create();
            for (var i = 0; i < data.length; i++) {
                var vertices = [];
                for (var s = 0; s < data[i].shape.length; s += 2) {
                    vertices.push([ this.world.pxmi(data[i].shape[s]), this.world.pxmi(data[i].shape[s + 1]) ]);
                }
                var c = new p2.Convex({
                    vertices: vertices
                });
                for (var j = 0; j !== c.vertices.length; j++) {
                    var v = c.vertices[j];
                    p2.vec2.sub(v, v, c.centerOfMass);
                }
                p2.vec2.scale(cm, c.centerOfMass, 1);
                cm[0] -= this.world.pxmi(this.sprite.width / 2);
                cm[1] -= this.world.pxmi(this.sprite.height / 2);
                c.updateTriangles();
                c.updateCenterOfMass();
                c.updateBoundingRadius();
                this.data.addShape(c, cm);
            }
            this.data.aabbNeedsUpdate = true;
            this.shapeChanged();
            return true;
        }
    };
    Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;
    Phaser.Physics.P2.Body.DYNAMIC = 1;
    Phaser.Physics.P2.Body.STATIC = 2;
    Phaser.Physics.P2.Body.KINEMATIC = 4;
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
        get: function() {
            return this.data.type === Phaser.Physics.P2.Body.STATIC;
        },
        set: function(value) {
            if (value && this.data.type !== Phaser.Physics.P2.Body.STATIC) {
                this.data.type = Phaser.Physics.P2.Body.STATIC;
                this.mass = 0;
            } else if (!value && this.data.type === Phaser.Physics.P2.Body.STATIC) {
                this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
                this.mass = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
        get: function() {
            return this.data.type === Phaser.Physics.P2.Body.DYNAMIC;
        },
        set: function(value) {
            if (value && this.data.type !== Phaser.Physics.P2.Body.DYNAMIC) {
                this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
                this.mass = 1;
            } else if (!value && this.data.type === Phaser.Physics.P2.Body.DYNAMIC) {
                this.data.type = Phaser.Physics.P2.Body.STATIC;
                this.mass = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
        get: function() {
            return this.data.type === Phaser.Physics.P2.Body.KINEMATIC;
        },
        set: function(value) {
            if (value && this.data.type !== Phaser.Physics.P2.Body.KINEMATIC) {
                this.data.type = Phaser.Physics.P2.Body.KINEMATIC;
                this.mass = 4;
            } else if (!value && this.data.type === Phaser.Physics.P2.Body.KINEMATIC) {
                this.data.type = Phaser.Physics.P2.Body.STATIC;
                this.mass = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
        get: function() {
            return this.data.allowSleep;
        },
        set: function(value) {
            if (value !== this.data.allowSleep) {
                this.data.allowSleep = value;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle));
        },
        set: function(value) {
            this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
        get: function() {
            return this.data.angularDamping;
        },
        set: function(value) {
            this.data.angularDamping = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
        get: function() {
            return this.data.angularForce;
        },
        set: function(value) {
            this.data.angularForce = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
        get: function() {
            return this.data.angularVelocity;
        },
        set: function(value) {
            this.data.angularVelocity = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
        get: function() {
            return this.data.damping;
        },
        set: function(value) {
            this.data.damping = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
        get: function() {
            return this.data.fixedRotation;
        },
        set: function(value) {
            if (value !== this.data.fixedRotation) {
                this.data.fixedRotation = value;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
        get: function() {
            return this.data.inertia;
        },
        set: function(value) {
            this.data.inertia = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
        get: function() {
            return this.data.mass;
        },
        set: function(value) {
            if (value !== this.data.mass) {
                this.data.mass = value;
                this.data.updateMassProperties();
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
        get: function() {
            return this.data.type;
        },
        set: function(value) {
            if (value !== this.data.type) {
                this.data.type = value;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
        get: function() {
            return this.data.angle;
        },
        set: function(value) {
            this.data.angle = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function() {
            return this.data.sleepSpeedLimit;
        },
        set: function(value) {
            this.data.sleepSpeedLimit = value;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.data.position[0]);
        },
        set: function(value) {
            this.data.position[0] = this.world.pxmi(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.data.position[1]);
        },
        set: function(value) {
            this.data.position[1] = this.world.pxmi(value);
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
        get: function() {
            return this.data.id;
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
        get: function() {
            return this.debugBody !== null;
        },
        set: function(value) {
            if (value && !this.debugBody) {
                this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data);
            } else if (!value && this.debugBody) {
                this.debugBody.destroy();
                this.debugBody = null;
            }
        }
    });
    Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function() {
            return this._collideWorldBounds;
        },
        set: function(value) {
            if (value && !this._collideWorldBounds) {
                this._collideWorldBounds = true;
                this.updateCollisionMask();
            } else if (!value && this._collideWorldBounds) {
                this._collideWorldBounds = false;
                this.updateCollisionMask();
            }
        }
    });
    Phaser.Physics.P2.BodyDebug = function(game, body, settings) {
        Phaser.Group.call(this, game);
        var defaultSettings = {
            pixelsPerLengthUnit: game.physics.p2.mpx(1),
            debugPolygons: false,
            lineWidth: 1,
            alpha: .5
        };
        this.settings = Phaser.Utils.extend(defaultSettings, settings);
        this.ppu = this.settings.pixelsPerLengthUnit;
        this.ppu = -1 * this.ppu;
        this.body = body;
        this.canvas = new Phaser.Graphics(game);
        this.canvas.alpha = this.settings.alpha;
        this.add(this.canvas);
        this.draw();
        this.updateSpriteTransform();
    };
    Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);
    Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;
    Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function() {
            this.position.x = this.body.position[0] * this.ppu;
            this.position.y = this.body.position[1] * this.ppu;
            this.rotation = this.body.angle;
        },
        draw: function() {
            var angle, child, color, i, j, lineColor, lw, obj, offset, sprite, v, verts, vrot, _j, _ref1;
            obj = this.body;
            sprite = this.canvas;
            sprite.clear();
            color = parseInt(this.randomPastelHex(), 16);
            lineColor = 16711680;
            lw = this.lineWidth;
            if (obj instanceof p2.Body && obj.shapes.length) {
                var l = obj.shapes.length;
                i = 0;
                while (i !== l) {
                    child = obj.shapes[i];
                    offset = child.position || 0;
                    angle = child.angle || 0;
                    if (child instanceof p2.Circle) {
                        this.drawCircle(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.radius * this.ppu, color, lw);
                    } else if (child instanceof p2.Capsule) {
                        this.drawCapsule(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.length * this.ppu, child.radius * this.ppu, lineColor, color, lw);
                    } else if (child instanceof p2.Plane) {
                        this.drawPlane(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, color, lineColor, lw * 5, lw * 10, lw * 10, this.ppu * 100, angle);
                    } else if (child instanceof p2.Line) {
                        this.drawLine(sprite, child.length * this.ppu, lineColor, lw);
                    } else if (child instanceof p2.Box) {
                        this.drawRectangle(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.width * this.ppu, child.height * this.ppu, lineColor, color, lw);
                    } else if (child instanceof p2.Convex) {
                        verts = [];
                        vrot = p2.vec2.create();
                        for (j = _j = 0, _ref1 = child.vertices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                            v = child.vertices[j];
                            p2.vec2.rotate(vrot, v, angle);
                            verts.push([ (vrot[0] + offset[0]) * this.ppu, -(vrot[1] + offset[1]) * this.ppu ]);
                        }
                        this.drawConvex(sprite, verts, child.triangles, lineColor, color, lw, this.settings.debugPolygons, [ offset[0] * this.ppu, -offset[1] * this.ppu ]);
                    }
                    i++;
                }
            }
        },
        drawRectangle: function(g, x, y, angle, w, h, color, fillColor, lineWidth) {
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 0;
            }
            g.lineStyle(lineWidth, color, 1);
            g.beginFill(fillColor);
            g.drawRect(x - w / 2, y - h / 2, w, h);
        },
        drawCircle: function(g, x, y, angle, radius, color, lineWidth) {
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 16777215;
            }
            g.lineStyle(lineWidth, 0, 1);
            g.beginFill(color, 1);
            g.drawCircle(x, y, -radius * 2);
            g.endFill();
            g.moveTo(x, y);
            g.lineTo(x + radius * Math.cos(-angle), y + radius * Math.sin(-angle));
        },
        drawLine: function(g, len, color, lineWidth) {
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 0;
            }
            g.lineStyle(lineWidth * 5, color, 1);
            g.moveTo(-len / 2, 0);
            g.lineTo(len / 2, 0);
        },
        drawConvex: function(g, verts, triangles, color, fillColor, lineWidth, debug, offset) {
            var colors, i, v, v0, v1, x, x0, x1, y, y0, y1;
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 0;
            }
            if (!debug) {
                g.lineStyle(lineWidth, color, 1);
                g.beginFill(fillColor);
                i = 0;
                while (i !== verts.length) {
                    v = verts[i];
                    x = v[0];
                    y = v[1];
                    if (i === 0) {
                        g.moveTo(x, -y);
                    } else {
                        g.lineTo(x, -y);
                    }
                    i++;
                }
                g.endFill();
                if (verts.length > 2) {
                    g.moveTo(verts[verts.length - 1][0], -verts[verts.length - 1][1]);
                    return g.lineTo(verts[0][0], -verts[0][1]);
                }
            } else {
                colors = [ 16711680, 65280, 255 ];
                i = 0;
                while (i !== verts.length + 1) {
                    v0 = verts[i % verts.length];
                    v1 = verts[(i + 1) % verts.length];
                    x0 = v0[0];
                    y0 = v0[1];
                    x1 = v1[0];
                    y1 = v1[1];
                    g.lineStyle(lineWidth, colors[i % colors.length], 1);
                    g.moveTo(x0, -y0);
                    g.lineTo(x1, -y1);
                    g.drawCircle(x0, -y0, lineWidth * 2);
                    i++;
                }
                g.lineStyle(lineWidth, 0, 1);
                return g.drawCircle(offset[0], offset[1], lineWidth * 2);
            }
        },
        drawPath: function(g, path, color, fillColor, lineWidth) {
            var area, i, lastx, lasty, p1x, p1y, p2x, p2y, p3x, p3y, v, x, y;
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 0;
            }
            g.lineStyle(lineWidth, color, 1);
            if (typeof fillColor === "number") {
                g.beginFill(fillColor);
            }
            lastx = null;
            lasty = null;
            i = 0;
            while (i < path.length) {
                v = path[i];
                x = v[0];
                y = v[1];
                if (x !== lastx || y !== lasty) {
                    if (i === 0) {
                        g.moveTo(x, y);
                    } else {
                        p1x = lastx;
                        p1y = lasty;
                        p2x = x;
                        p2y = y;
                        p3x = path[(i + 1) % path.length][0];
                        p3y = path[(i + 1) % path.length][1];
                        area = (p2x - p1x) * (p3y - p1y) - (p3x - p1x) * (p2y - p1y);
                        if (area !== 0) {
                            g.lineTo(x, y);
                        }
                    }
                    lastx = x;
                    lasty = y;
                }
                i++;
            }
            if (typeof fillColor === "number") {
                g.endFill();
            }
            if (path.length > 2 && typeof fillColor === "number") {
                g.moveTo(path[path.length - 1][0], path[path.length - 1][1]);
                g.lineTo(path[0][0], path[0][1]);
            }
        },
        drawPlane: function(g, x0, x1, color, lineColor, lineWidth, diagMargin, diagSize, maxLength, angle) {
            var max, xd, yd;
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 16777215;
            }
            g.lineStyle(lineWidth, lineColor, 11);
            g.beginFill(color);
            max = maxLength;
            g.moveTo(x0, -x1);
            xd = x0 + Math.cos(angle) * this.game.width;
            yd = x1 + Math.sin(angle) * this.game.height;
            g.lineTo(xd, -yd);
            g.moveTo(x0, -x1);
            xd = x0 + Math.cos(angle) * -this.game.width;
            yd = x1 + Math.sin(angle) * -this.game.height;
            g.lineTo(xd, -yd);
        },
        drawCapsule: function(g, x, y, angle, len, radius, color, fillColor, lineWidth) {
            if (lineWidth === undefined) {
                lineWidth = 1;
            }
            if (color === undefined) {
                color = 0;
            }
            g.lineStyle(lineWidth, color, 1);
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            g.beginFill(fillColor, 1);
            g.drawCircle(-len / 2 * c + x, -len / 2 * s + y, -radius * 2);
            g.drawCircle(len / 2 * c + x, len / 2 * s + y, -radius * 2);
            g.endFill();
            g.lineStyle(lineWidth, color, 0);
            g.beginFill(fillColor, 1);
            g.moveTo(-len / 2 * c + radius * s + x, -len / 2 * s + radius * c + y);
            g.lineTo(len / 2 * c + radius * s + x, len / 2 * s + radius * c + y);
            g.lineTo(len / 2 * c - radius * s + x, len / 2 * s - radius * c + y);
            g.lineTo(-len / 2 * c - radius * s + x, -len / 2 * s - radius * c + y);
            g.endFill();
            g.lineStyle(lineWidth, color, 1);
            g.moveTo(-len / 2 * c + radius * s + x, -len / 2 * s + radius * c + y);
            g.lineTo(len / 2 * c + radius * s + x, len / 2 * s + radius * c + y);
            g.moveTo(-len / 2 * c - radius * s + x, -len / 2 * s - radius * c + y);
            g.lineTo(len / 2 * c - radius * s + x, len / 2 * s - radius * c + y);
        },
        randomPastelHex: function() {
            var blue, green, mix, red;
            mix = [ 255, 255, 255 ];
            red = Math.floor(Math.random() * 256);
            green = Math.floor(Math.random() * 256);
            blue = Math.floor(Math.random() * 256);
            red = Math.floor((red + 3 * mix[0]) / 4);
            green = Math.floor((green + 3 * mix[1]) / 4);
            blue = Math.floor((blue + 3 * mix[2]) / 4);
            return this.rgbToHex(red, green, blue);
        },
        rgbToHex: function(r, g, b) {
            return this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
        },
        componentToHex: function(c) {
            var hex;
            hex = c.toString(16);
            if (hex.len === 2) {
                return hex;
            } else {
                return hex + "0";
            }
        }
    });
    Phaser.Physics.P2.Spring = function(world, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
        this.game = world.game;
        this.world = world;
        if (restLength === undefined) {
            restLength = 1;
        }
        if (stiffness === undefined) {
            stiffness = 100;
        }
        if (damping === undefined) {
            damping = 1;
        }
        restLength = world.pxm(restLength);
        var options = {
            restLength: restLength,
            stiffness: stiffness,
            damping: damping
        };
        if (typeof worldA !== "undefined" && worldA !== null) {
            options.worldAnchorA = [ world.pxm(worldA[0]), world.pxm(worldA[1]) ];
        }
        if (typeof worldB !== "undefined" && worldB !== null) {
            options.worldAnchorB = [ world.pxm(worldB[0]), world.pxm(worldB[1]) ];
        }
        if (typeof localA !== "undefined" && localA !== null) {
            options.localAnchorA = [ world.pxm(localA[0]), world.pxm(localA[1]) ];
        }
        if (typeof localB !== "undefined" && localB !== null) {
            options.localAnchorB = [ world.pxm(localB[0]), world.pxm(localB[1]) ];
        }
        this.data = new p2.LinearSpring(bodyA, bodyB, options);
        this.data.parent = this;
    };
    Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;
    Phaser.Physics.P2.RotationalSpring = function(world, bodyA, bodyB, restAngle, stiffness, damping) {
        this.game = world.game;
        this.world = world;
        if (restAngle === undefined) {
            restAngle = null;
        }
        if (stiffness === undefined) {
            stiffness = 100;
        }
        if (damping === undefined) {
            damping = 1;
        }
        if (restAngle) {
            restAngle = world.pxm(restAngle);
        }
        var options = {
            restAngle: restAngle,
            stiffness: stiffness,
            damping: damping
        };
        this.data = new p2.RotationalSpring(bodyA, bodyB, options);
        this.data.parent = this;
    };
    Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;
    Phaser.Physics.P2.Material = function(name) {
        this.name = name;
        p2.Material.call(this);
    };
    Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);
    Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;
    Phaser.Physics.P2.ContactMaterial = function(materialA, materialB, options) {
        p2.ContactMaterial.call(this, materialA, materialB, options);
    };
    Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);
    Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;
    Phaser.Physics.P2.CollisionGroup = function(bitmask) {
        this.mask = bitmask;
    };
    Phaser.Physics.P2.DistanceConstraint = function(world, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
        if (distance === undefined) {
            distance = 100;
        }
        if (localAnchorA === undefined) {
            localAnchorA = [ 0, 0 ];
        }
        if (localAnchorB === undefined) {
            localAnchorB = [ 0, 0 ];
        }
        if (maxForce === undefined) {
            maxForce = Number.MAX_VALUE;
        }
        this.game = world.game;
        this.world = world;
        distance = world.pxm(distance);
        localAnchorA = [ world.pxmi(localAnchorA[0]), world.pxmi(localAnchorA[1]) ];
        localAnchorB = [ world.pxmi(localAnchorB[0]), world.pxmi(localAnchorB[1]) ];
        var options = {
            distance: distance,
            localAnchorA: localAnchorA,
            localAnchorB: localAnchorB,
            maxForce: maxForce
        };
        p2.DistanceConstraint.call(this, bodyA, bodyB, options);
    };
    Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);
    Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;
    Phaser.Physics.P2.GearConstraint = function(world, bodyA, bodyB, angle, ratio) {
        if (angle === undefined) {
            angle = 0;
        }
        if (ratio === undefined) {
            ratio = 1;
        }
        this.game = world.game;
        this.world = world;
        var options = {
            angle: angle,
            ratio: ratio
        };
        p2.GearConstraint.call(this, bodyA, bodyB, options);
    };
    Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);
    Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;
    Phaser.Physics.P2.LockConstraint = function(world, bodyA, bodyB, offset, angle, maxForce) {
        if (offset === undefined) {
            offset = [ 0, 0 ];
        }
        if (angle === undefined) {
            angle = 0;
        }
        if (maxForce === undefined) {
            maxForce = Number.MAX_VALUE;
        }
        this.game = world.game;
        this.world = world;
        offset = [ world.pxm(offset[0]), world.pxm(offset[1]) ];
        var options = {
            localOffsetB: offset,
            localAngleB: angle,
            maxForce: maxForce
        };
        p2.LockConstraint.call(this, bodyA, bodyB, options);
    };
    Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);
    Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;
    Phaser.Physics.P2.PrismaticConstraint = function(world, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
        if (lockRotation === undefined) {
            lockRotation = true;
        }
        if (anchorA === undefined) {
            anchorA = [ 0, 0 ];
        }
        if (anchorB === undefined) {
            anchorB = [ 0, 0 ];
        }
        if (axis === undefined) {
            axis = [ 0, 0 ];
        }
        if (maxForce === undefined) {
            maxForce = Number.MAX_VALUE;
        }
        this.game = world.game;
        this.world = world;
        anchorA = [ world.pxmi(anchorA[0]), world.pxmi(anchorA[1]) ];
        anchorB = [ world.pxmi(anchorB[0]), world.pxmi(anchorB[1]) ];
        var options = {
            localAnchorA: anchorA,
            localAnchorB: anchorB,
            localAxisA: axis,
            maxForce: maxForce,
            disableRotationalLock: !lockRotation
        };
        p2.PrismaticConstraint.call(this, bodyA, bodyB, options);
    };
    Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);
    Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;
    Phaser.Physics.P2.RevoluteConstraint = function(world, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
        if (maxForce === undefined) {
            maxForce = Number.MAX_VALUE;
        }
        if (worldPivot === undefined) {
            worldPivot = null;
        }
        this.game = world.game;
        this.world = world;
        pivotA = [ world.pxmi(pivotA[0]), world.pxmi(pivotA[1]) ];
        pivotB = [ world.pxmi(pivotB[0]), world.pxmi(pivotB[1]) ];
        if (worldPivot) {
            worldPivot = [ world.pxmi(worldPivot[0]), world.pxmi(worldPivot[1]) ];
        }
        var options = {
            worldPivot: worldPivot,
            localPivotA: pivotA,
            localPivotB: pivotB,
            maxForce: maxForce
        };
        p2.RevoluteConstraint.call(this, bodyA, bodyB, options);
    };
    Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);
    Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint;
    Phaser.ImageCollection = function(name, firstgid, width, height, margin, spacing, properties) {
        if (width === undefined || width <= 0) {
            width = 32;
        }
        if (height === undefined || height <= 0) {
            height = 32;
        }
        if (margin === undefined) {
            margin = 0;
        }
        if (spacing === undefined) {
            spacing = 0;
        }
        this.name = name;
        this.firstgid = firstgid | 0;
        this.imageWidth = width | 0;
        this.imageHeight = height | 0;
        this.imageMargin = margin | 0;
        this.imageSpacing = spacing | 0;
        this.properties = properties || {};
        this.images = [];
        this.total = 0;
    };
    Phaser.ImageCollection.prototype = {
        containsImageIndex: function(imageIndex) {
            return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
        },
        addImage: function(gid, image) {
            this.images.push({
                gid: gid,
                image: image
            });
            this.total++;
        }
    };
    Phaser.ImageCollection.prototype.constructor = Phaser.ImageCollection;
    Phaser.Tile = function(layer, index, x, y, width, height) {
        this.layer = layer;
        this.index = index;
        this.x = x;
        this.y = y;
        this.rotation = 0;
        this.flipped = false;
        this.worldX = x * width;
        this.worldY = y * height;
        this.width = width;
        this.height = height;
        this.centerX = Math.abs(width / 2);
        this.centerY = Math.abs(height / 2);
        this.alpha = 1;
        this.properties = {};
        this.scanned = false;
        this.faceTop = false;
        this.faceBottom = false;
        this.faceLeft = false;
        this.faceRight = false;
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.collisionCallback = null;
        this.collisionCallbackContext = this;
    };
    Phaser.Tile.prototype = {
        containsPoint: function(x, y) {
            return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);
        },
        intersects: function(x, y, right, bottom) {
            if (right <= this.worldX) {
                return false;
            }
            if (bottom <= this.worldY) {
                return false;
            }
            if (x >= this.worldX + this.width) {
                return false;
            }
            if (y >= this.worldY + this.height) {
                return false;
            }
            return true;
        },
        setCollisionCallback: function(callback, context) {
            this.collisionCallback = callback;
            this.collisionCallbackContext = context;
        },
        destroy: function() {
            this.collisionCallback = null;
            this.collisionCallbackContext = null;
            this.properties = null;
        },
        setCollision: function(left, right, up, down) {
            this.collideLeft = left;
            this.collideRight = right;
            this.collideUp = up;
            this.collideDown = down;
            this.faceLeft = left;
            this.faceRight = right;
            this.faceTop = up;
            this.faceBottom = down;
        },
        resetCollision: function() {
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false;
        },
        isInteresting: function(collides, faces) {
            if (collides && faces) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback;
            } else if (collides) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
            } else if (faces) {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
            }
            return false;
        },
        copy: function(tile) {
            this.index = tile.index;
            this.alpha = tile.alpha;
            this.properties = tile.properties;
            this.collideUp = tile.collideUp;
            this.collideDown = tile.collideDown;
            this.collideLeft = tile.collideLeft;
            this.collideRight = tile.collideRight;
            this.collisionCallback = tile.collisionCallback;
            this.collisionCallbackContext = tile.collisionCallbackContext;
        }
    };
    Phaser.Tile.prototype.constructor = Phaser.Tile;
    Object.defineProperty(Phaser.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "left", {
        get: function() {
            return this.worldX;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "top", {
        get: function() {
            return this.worldY;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height;
        }
    });
    Phaser.Tilemap = function(game, key, tileWidth, tileHeight, width, height) {
        this.game = game;
        this.key = key;
        var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height);
        if (data === null) {
            return;
        }
        this.width = data.width;
        this.height = data.height;
        this.tileWidth = data.tileWidth;
        this.tileHeight = data.tileHeight;
        this.orientation = data.orientation;
        this.format = data.format;
        this.version = data.version;
        this.properties = data.properties;
        this.widthInPixels = data.widthInPixels;
        this.heightInPixels = data.heightInPixels;
        this.layers = data.layers;
        this.tilesets = data.tilesets;
        this.imagecollections = data.imagecollections;
        this.tiles = data.tiles;
        this.objects = data.objects;
        this.collideIndexes = [];
        this.collision = data.collision;
        this.images = data.images;
        this.currentLayer = 0;
        this.debugMap = [];
        this._results = [];
        this._tempA = 0;
        this._tempB = 0;
    };
    Phaser.Tilemap.CSV = 0;
    Phaser.Tilemap.TILED_JSON = 1;
    Phaser.Tilemap.NORTH = 0;
    Phaser.Tilemap.EAST = 1;
    Phaser.Tilemap.SOUTH = 2;
    Phaser.Tilemap.WEST = 3;
    Phaser.Tilemap.prototype = {
        create: function(name, width, height, tileWidth, tileHeight, group) {
            if (group === undefined) {
                group = this.game.world;
            }
            this.width = width;
            this.height = height;
            this.setTileSize(tileWidth, tileHeight);
            this.layers.length = 0;
            return this.createBlankLayer(name, width, height, tileWidth, tileHeight, group);
        },
        setTileSize: function(tileWidth, tileHeight) {
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.widthInPixels = this.width * tileWidth;
            this.heightInPixels = this.height * tileHeight;
        },
        addTilesetImage: function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
            if (tileset === undefined) {
                return null;
            }
            if (tileWidth === undefined) {
                tileWidth = this.tileWidth;
            }
            if (tileHeight === undefined) {
                tileHeight = this.tileHeight;
            }
            if (tileMargin === undefined) {
                tileMargin = 0;
            }
            if (tileSpacing === undefined) {
                tileSpacing = 0;
            }
            if (gid === undefined) {
                gid = 0;
            }
            if (tileWidth === 0) {
                tileWidth = 32;
            }
            if (tileHeight === 0) {
                tileHeight = 32;
            }
            var img = null;
            if (key === undefined || key === null) {
                key = tileset;
            }
            if (key instanceof Phaser.BitmapData) {
                img = key.canvas;
            } else {
                if (!this.game.cache.checkImageKey(key)) {
                    console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + key + '"');
                    return null;
                }
                img = this.game.cache.getImage(key);
            }
            var idx = this.getTilesetIndex(tileset);
            if (idx === null && this.format === Phaser.Tilemap.TILED_JSON) {
                console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + key + '"');
                return null;
            }
            if (this.tilesets[idx]) {
                this.tilesets[idx].setImage(img);
                return this.tilesets[idx];
            } else {
                var newSet = new Phaser.Tileset(tileset, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {});
                newSet.setImage(img);
                this.tilesets.push(newSet);
                var i = this.tilesets.length - 1;
                var x = tileMargin;
                var y = tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = gid; t < gid + newSet.total; t++) {
                    this.tiles[t] = [ x, y, i ];
                    x += tileWidth + tileSpacing;
                    count++;
                    if (count === newSet.total) {
                        break;
                    }
                    countX++;
                    if (countX === newSet.columns) {
                        x = tileMargin;
                        y += tileHeight + tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === newSet.rows) {
                            break;
                        }
                    }
                }
                return newSet;
            }
            return null;
        },
        createFromObjects: function(name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
            if (exists === undefined) {
                exists = true;
            }
            if (autoCull === undefined) {
                autoCull = false;
            }
            if (group === undefined) {
                group = this.game.world;
            }
            if (CustomClass === undefined) {
                CustomClass = Phaser.Sprite;
            }
            if (adjustY === undefined) {
                adjustY = true;
            }
            if (!this.objects[name]) {
                console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + name);
                return;
            }
            for (var i = 0; i < this.objects[name].length; i++) {
                var found = false;
                var obj = this.objects[name][i];
                if (obj.gid !== undefined && typeof gid === "number" && obj.gid === gid) {
                    found = true;
                } else if (obj.id !== undefined && typeof gid === "number" && obj.id === gid) {
                    found = true;
                } else if (obj.name !== undefined && typeof gid === "string" && obj.name === gid) {
                    found = true;
                }
                if (found) {
                    var sprite = new CustomClass(this.game, parseFloat(obj.x, 10), parseFloat(obj.y, 10), key, frame);
                    sprite.name = obj.name;
                    sprite.visible = obj.visible;
                    sprite.autoCull = autoCull;
                    sprite.exists = exists;
                    if (obj.width) {
                        sprite.width = obj.width;
                    }
                    if (obj.height) {
                        sprite.height = obj.height;
                    }
                    if (obj.rotation) {
                        sprite.angle = obj.rotation;
                    }
                    if (adjustY) {
                        sprite.y -= sprite.height;
                    }
                    group.add(sprite);
                    for (var property in obj.properties) {
                        group.set(sprite, property, obj.properties[property], false, false, 0, true);
                    }
                }
            }
        },
        createFromTiles: function(tiles, replacements, key, layer, group, properties) {
            if (typeof tiles === "number") {
                tiles = [ tiles ];
            }
            if (replacements === undefined || replacements === null) {
                replacements = [];
            } else if (typeof replacements === "number") {
                replacements = [ replacements ];
            }
            layer = this.getLayer(layer);
            if (group === undefined) {
                group = this.game.world;
            }
            if (properties === undefined) {
                properties = {};
            }
            if (properties.customClass === undefined) {
                properties.customClass = Phaser.Sprite;
            }
            if (properties.adjustY === undefined) {
                properties.adjustY = true;
            }
            var lw = this.layers[layer].width;
            var lh = this.layers[layer].height;
            this.copy(0, 0, lw, lh, layer);
            if (this._results.length < 2) {
                return 0;
            }
            var total = 0;
            var sprite;
            for (var i = 1, len = this._results.length; i < len; i++) {
                if (tiles.indexOf(this._results[i].index) !== -1) {
                    sprite = new properties.customClass(this.game, this._results[i].worldX, this._results[i].worldY, key);
                    for (var property in properties) {
                        sprite[property] = properties[property];
                    }
                    group.add(sprite);
                    total++;
                }
            }
            if (replacements.length === 1) {
                for (i = 0; i < tiles.length; i++) {
                    this.replace(tiles[i], replacements[0], 0, 0, lw, lh, layer);
                }
            } else if (replacements.length > 1) {
                for (i = 0; i < tiles.length; i++) {
                    this.replace(tiles[i], replacements[i], 0, 0, lw, lh, layer);
                }
            }
            return total;
        },
        createLayer: function(layer, width, height, group) {
            if (width === undefined) {
                width = this.game.width;
            }
            if (height === undefined) {
                height = this.game.height;
            }
            if (group === undefined) {
                group = this.game.world;
            }
            var index = layer;
            if (typeof layer === "string") {
                index = this.getLayerIndex(layer);
            }
            if (index === null || index > this.layers.length) {
                console.warn("Tilemap.createLayer: Invalid layer ID given: " + index);
                return;
            }
            return group.add(new Phaser.TilemapLayer(this.game, this, index, width, height));
        },
        createBlankLayer: function(name, width, height, tileWidth, tileHeight, group) {
            if (group === undefined) {
                group = this.game.world;
            }
            if (this.getLayerIndex(name) !== null) {
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                return;
            }
            var layer = {
                name: name,
                x: 0,
                y: 0,
                width: width,
                height: height,
                widthInPixels: width * tileWidth,
                heightInPixels: height * tileHeight,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            };
            var row;
            var output = [];
            for (var y = 0; y < height; y++) {
                row = [];
                for (var x = 0; x < width; x++) {
                    row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight));
                }
                output.push(row);
            }
            layer.data = output;
            this.layers.push(layer);
            this.currentLayer = this.layers.length - 1;
            var w = layer.widthInPixels;
            var h = layer.heightInPixels;
            if (w > this.game.width) {
                w = this.game.width;
            }
            if (h > this.game.height) {
                h = this.game.height;
            }
            var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h);
            output.name = name;
            return group.add(output);
        },
        getIndex: function(location, name) {
            for (var i = 0; i < location.length; i++) {
                if (location[i].name === name) {
                    return i;
                }
            }
            return null;
        },
        getLayerIndex: function(name) {
            return this.getIndex(this.layers, name);
        },
        getTilesetIndex: function(name) {
            return this.getIndex(this.tilesets, name);
        },
        getImageIndex: function(name) {
            return this.getIndex(this.images, name);
        },
        getObjectIndex: function(name) {
            return this.getIndex(this.objects, name);
        },
        setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                this.layers[layer].callbacks[indexes] = {
                    callback: callback,
                    callbackContext: callbackContext
                };
            } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                    this.layers[layer].callbacks[indexes[i]] = {
                        callback: callback,
                        callbackContext: callbackContext
                    };
                }
            }
        },
        setTileLocationCallback: function(x, y, width, height, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].setCollisionCallback(callback, callbackContext);
            }
        },
        setCollision: function(indexes, collides, layer, recalculate) {
            if (collides === undefined) {
                collides = true;
            }
            if (recalculate === undefined) {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                return this.setCollisionByIndex(indexes, collides, layer, true);
            } else if (Array.isArray(indexes)) {
                for (var i = 0; i < indexes.length; i++) {
                    this.setCollisionByIndex(indexes[i], collides, layer, false);
                }
                if (recalculate) {
                    this.calculateFaces(layer);
                }
            }
        },
        setCollisionBetween: function(start, stop, collides, layer, recalculate) {
            if (collides === undefined) {
                collides = true;
            }
            if (recalculate === undefined) {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (start > stop) {
                return;
            }
            for (var index = start; index <= stop; index++) {
                this.setCollisionByIndex(index, collides, layer, false);
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByExclusion: function(indexes, collides, layer, recalculate) {
            if (collides === undefined) {
                collides = true;
            }
            if (recalculate === undefined) {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            for (var i = 0, len = this.tiles.length; i < len; i++) {
                if (indexes.indexOf(i) === -1) {
                    this.setCollisionByIndex(i, collides, layer, false);
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByIndex: function(index, collides, layer, recalculate) {
            if (collides === undefined) {
                collides = true;
            }
            if (layer === undefined) {
                layer = this.currentLayer;
            }
            if (recalculate === undefined) {
                recalculate = true;
            }
            if (collides) {
                this.collideIndexes.push(index);
            } else {
                var i = this.collideIndexes.indexOf(index);
                if (i > -1) {
                    this.collideIndexes.splice(i, 1);
                }
            }
            for (var y = 0; y < this.layers[layer].height; y++) {
                for (var x = 0; x < this.layers[layer].width; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile && tile.index === index) {
                        if (collides) {
                            tile.setCollision(true, true, true, true);
                        } else {
                            tile.resetCollision();
                        }
                        tile.faceTop = collides;
                        tile.faceBottom = collides;
                        tile.faceLeft = collides;
                        tile.faceRight = collides;
                    }
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
            return layer;
        },
        getLayer: function(layer) {
            if (layer === undefined) {
                layer = this.currentLayer;
            } else if (typeof layer === "string") {
                layer = this.getLayerIndex(layer);
            } else if (layer instanceof Phaser.TilemapLayer) {
                layer = layer.index;
            }
            return layer;
        },
        setPreventRecalculate: function(value) {
            if (value === true && this.preventingRecalculate !== true) {
                this.preventingRecalculate = true;
                this.needToRecalculate = {};
            }
            if (value === false && this.preventingRecalculate === true) {
                this.preventingRecalculate = false;
                for (var i in this.needToRecalculate) {
                    this.calculateFaces(i);
                }
                this.needToRecalculate = false;
            }
        },
        calculateFaces: function(layer) {
            if (this.preventingRecalculate) {
                this.needToRecalculate[layer] = true;
                return;
            }
            var above = null;
            var below = null;
            var left = null;
            var right = null;
            for (var y = 0, h = this.layers[layer].height; y < h; y++) {
                for (var x = 0, w = this.layers[layer].width; x < w; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile) {
                        above = this.getTileAbove(layer, x, y);
                        below = this.getTileBelow(layer, x, y);
                        left = this.getTileLeft(layer, x, y);
                        right = this.getTileRight(layer, x, y);
                        if (tile.collides) {
                            tile.faceTop = true;
                            tile.faceBottom = true;
                            tile.faceLeft = true;
                            tile.faceRight = true;
                        }
                        if (above && above.collides) {
                            tile.faceTop = false;
                        }
                        if (below && below.collides) {
                            tile.faceBottom = false;
                        }
                        if (left && left.collides) {
                            tile.faceLeft = false;
                        }
                        if (right && right.collides) {
                            tile.faceRight = false;
                        }
                    }
                }
            }
        },
        getTileAbove: function(layer, x, y) {
            if (y > 0) {
                return this.layers[layer].data[y - 1][x];
            }
            return null;
        },
        getTileBelow: function(layer, x, y) {
            if (y < this.layers[layer].height - 1) {
                return this.layers[layer].data[y + 1][x];
            }
            return null;
        },
        getTileLeft: function(layer, x, y) {
            if (x > 0) {
                return this.layers[layer].data[y][x - 1];
            }
            return null;
        },
        getTileRight: function(layer, x, y) {
            if (x < this.layers[layer].width - 1) {
                return this.layers[layer].data[y][x + 1];
            }
            return null;
        },
        setLayer: function(layer) {
            layer = this.getLayer(layer);
            if (this.layers[layer]) {
                this.currentLayer = layer;
            }
        },
        hasTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            return this.layers[layer].data[y][x].index > -1;
        },
        removeTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.hasTile(x, y, layer)) {
                    var tile = this.layers[layer].data[y][x];
                    this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], -1, x, y, this.tileWidth, this.tileHeight);
                    this.layers[layer].dirty = true;
                    this.calculateFaces(layer);
                    return tile;
                }
            }
        },
        removeTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.removeTile(x, y, layer);
        },
        putTile: function(tile, x, y, layer) {
            if (tile === null) {
                return this.removeTile(x, y, layer);
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                var index;
                if (tile instanceof Phaser.Tile) {
                    index = tile.index;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].copy(tile);
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height);
                    }
                } else {
                    index = tile;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].index = index;
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight);
                    }
                }
                if (this.collideIndexes.indexOf(index) > -1) {
                    this.layers[layer].data[y][x].setCollision(true, true, true, true);
                } else {
                    this.layers[layer].data[y][x].resetCollision();
                }
                this.layers[layer].dirty = true;
                this.calculateFaces(layer);
                return this.layers[layer].data[y][x];
            }
            return null;
        },
        putTileWorldXY: function(tile, x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.putTile(tile, x, y, layer);
        },
        searchTileIndex: function(index, skip, reverse, layer) {
            if (skip === undefined) {
                skip = 0;
            }
            if (reverse === undefined) {
                reverse = false;
            }
            layer = this.getLayer(layer);
            var c = 0;
            if (reverse) {
                for (var y = this.layers[layer].height - 1; y >= 0; y--) {
                    for (var x = this.layers[layer].width - 1; x >= 0; x--) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            } else {
                for (var y = 0; y < this.layers[layer].height; y++) {
                    for (var x = 0; x < this.layers[layer].width; x++) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            }
            return null;
        },
        getTile: function(x, y, layer, nonNull) {
            if (nonNull === undefined) {
                nonNull = false;
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.layers[layer].data[y][x].index === -1) {
                    if (nonNull) {
                        return this.layers[layer].data[y][x];
                    } else {
                        return null;
                    }
                } else {
                    return this.layers[layer].data[y][x];
                }
            } else {
                return null;
            }
        },
        getTileWorldXY: function(x, y, tileWidth, tileHeight, layer, nonNull) {
            if (tileWidth === undefined) {
                tileWidth = this.tileWidth;
            }
            if (tileHeight === undefined) {
                tileHeight = this.tileHeight;
            }
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.getTile(x, y, layer, nonNull);
        },
        copy: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            if (!this.layers[layer]) {
                this._results.length = 0;
                return;
            }
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            if (width === undefined) {
                width = this.layers[layer].width;
            }
            if (height === undefined) {
                height = this.layers[layer].height;
            }
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }
            if (width > this.layers[layer].width) {
                width = this.layers[layer].width;
            }
            if (height > this.layers[layer].height) {
                height = this.layers[layer].height;
            }
            this._results.length = 0;
            this._results.push({
                x: x,
                y: y,
                width: width,
                height: height,
                layer: layer
            });
            for (var ty = y; ty < y + height; ty++) {
                for (var tx = x; tx < x + width; tx++) {
                    this._results.push(this.layers[layer].data[ty][tx]);
                }
            }
            return this._results;
        },
        paste: function(x, y, tileblock, layer) {
            if (x === undefined) {
                x = 0;
            }
            if (y === undefined) {
                y = 0;
            }
            layer = this.getLayer(layer);
            if (!tileblock || tileblock.length < 2) {
                return;
            }
            var diffX = x - tileblock[1].x;
            var diffY = y - tileblock[1].y;
            for (var i = 1; i < tileblock.length; i++) {
                this.layers[layer].data[diffY + tileblock[i].y][diffX + tileblock[i].x].copy(tileblock[i]);
            }
            this.layers[layer].dirty = true;
            this.calculateFaces(layer);
        },
        swap: function(tileA, tileB, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._tempA = tileA;
            this._tempB = tileB;
            this._results.forEach(this.swapHandler, this);
            this.paste(x, y, this._results, layer);
        },
        swapHandler: function(value) {
            if (value.index === this._tempA) {
                value.index = this._tempB;
            } else if (value.index === this._tempB) {
                value.index = this._tempA;
            }
        },
        forEach: function(callback, context, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._results.forEach(callback, context);
            this.paste(x, y, this._results, layer);
        },
        replace: function(source, dest, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                if (this._results[i].index === source) {
                    this._results[i].index = dest;
                }
            }
            this.paste(x, y, this._results, layer);
        },
        random: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    var idx = this._results[t].index;
                    if (indexes.indexOf(idx) === -1) {
                        indexes.push(idx);
                    }
                }
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = this.game.rnd.pick(indexes);
            }
            this.paste(x, y, this._results, layer);
        },
        shuffle: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    indexes.push(this._results[t].index);
                }
            }
            Phaser.ArrayUtils.shuffle(indexes);
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = indexes[i - 1];
            }
            this.paste(x, y, this._results, layer);
        },
        fill: function(index, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = index;
            }
            this.paste(x, y, this._results, layer);
        },
        removeAllLayers: function() {
            this.layers.length = 0;
            this.currentLayer = 0;
        },
        dump: function() {
            var txt = "";
            var args = [ "" ];
            for (var y = 0; y < this.layers[this.currentLayer].height; y++) {
                for (var x = 0; x < this.layers[this.currentLayer].width; x++) {
                    txt += "%c  ";
                    if (this.layers[this.currentLayer].data[y][x] > 1) {
                        if (this.debugMap[this.layers[this.currentLayer].data[y][x]]) {
                            args.push("background: " + this.debugMap[this.layers[this.currentLayer].data[y][x]]);
                        } else {
                            args.push("background: #ffffff");
                        }
                    } else {
                        args.push("background: rgb(0, 0, 0)");
                    }
                }
                txt += "\n";
            }
            args[0] = txt;
            console.log.apply(console, args);
        },
        destroy: function() {
            this.removeAllLayers();
            this.data = [];
            this.game = null;
        }
    };
    Phaser.Tilemap.prototype.constructor = Phaser.Tilemap;
    Object.defineProperty(Phaser.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer];
        },
        set: function(value) {
            if (value !== this.currentLayer) {
                this.setLayer(value);
            }
        }
    });
    Phaser.TilemapLayer = function(game, tilemap, index, width, height) {
        width |= 0;
        height |= 0;
        Phaser.Sprite.call(this, game, 0, 0);
        this.map = tilemap;
        this.index = index;
        this.layer = tilemap.layers[index];
        this.canvas = PIXI.CanvasPool.create(this, width, height);
        this.context = this.canvas.getContext("2d");
        this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas)));
        this.type = Phaser.TILEMAPLAYER;
        this.physicsType = Phaser.TILEMAPLAYER;
        this.renderSettings = {
            enableScrollDelta: false,
            overdrawRatio: .2,
            copyCanvas: null
        };
        this.debug = false;
        this.exists = true;
        this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: true,
            debugAlpha: .5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        };
        this.scrollFactorX = 1;
        this.scrollFactorY = 1;
        this.dirty = true;
        this.rayStepRate = 4;
        this._wrap = false;
        this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: tilemap.tileWidth,
            tileHeight: tilemap.tileHeight,
            cw: tilemap.tileWidth,
            ch: tilemap.tileHeight,
            tilesets: []
        };
        this._scrollX = 0;
        this._scrollY = 0;
        this._results = [];
        if (!game.device.canvasBitBltShift) {
            this.renderSettings.copyCanvas = Phaser.TilemapLayer.ensureSharedCopyCanvas();
        }
        this.fixedToCamera = true;
    };
    Phaser.TilemapLayer.prototype = Object.create(Phaser.Sprite.prototype);
    Phaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer;
    Phaser.TilemapLayer.prototype.preUpdateCore = Phaser.Component.Core.preUpdate;
    Phaser.TilemapLayer.sharedCopyCanvas = null;
    Phaser.TilemapLayer.ensureSharedCopyCanvas = function() {
        if (!this.sharedCopyCanvas) {
            this.sharedCopyCanvas = Phaser.Canvas.create(2, 2);
        }
        return this.sharedCopyCanvas;
    };
    Phaser.TilemapLayer.prototype.preUpdate = function() {
        return this.preUpdateCore();
    };
    Phaser.TilemapLayer.prototype.postUpdate = function() {
        Phaser.Component.FixedToCamera.postUpdate.call(this);
        var camera = this.game.camera;
        this.scrollX = camera.x * this.scrollFactorX / this.scale.x;
        this.scrollY = camera.y * this.scrollFactorY / this.scale.y;
        this.render();
    };
    Phaser.TilemapLayer.prototype.destroy = function() {
        PIXI.CanvasPool.remove(this);
        Phaser.Component.Destroy.prototype.destroy.call(this);
    };
    Phaser.TilemapLayer.prototype.resize = function(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.texture.frame.resize(width, height);
        this.texture.width = width;
        this.texture.height = height;
        this.texture.crop.width = width;
        this.texture.crop.height = height;
        this.texture.baseTexture.width = width;
        this.texture.baseTexture.height = height;
        this.texture.baseTexture.dirty();
        this.texture.requiresUpdate = true;
        this.texture._updateUvs();
        this.dirty = true;
    };
    Phaser.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y);
    };
    Phaser.TilemapLayer.prototype._fixX = function(x) {
        if (x < 0) {
            x = 0;
        }
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._scrollX + (x - this._scrollX / this.scrollFactorX);
    };
    Phaser.TilemapLayer.prototype._unfixX = function(x) {
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._scrollX / this.scrollFactorX + (x - this._scrollX);
    };
    Phaser.TilemapLayer.prototype._fixY = function(y) {
        if (y < 0) {
            y = 0;
        }
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._scrollY + (y - this._scrollY / this.scrollFactorY);
    };
    Phaser.TilemapLayer.prototype._unfixY = function(y) {
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._scrollY / this.scrollFactorY + (y - this._scrollY);
    };
    Phaser.TilemapLayer.prototype.getTileX = function(x) {
        return Math.floor(this._fixX(x) / this._mc.tileWidth);
    };
    Phaser.TilemapLayer.prototype.getTileY = function(y) {
        return Math.floor(this._fixY(y) / this._mc.tileHeight);
    };
    Phaser.TilemapLayer.prototype.getTileXY = function(x, y, point) {
        point.x = this.getTileX(x);
        point.y = this.getTileY(y);
        return point;
    };
    Phaser.TilemapLayer.prototype.getRayCastTiles = function(line, stepRate, collides, interestingFace) {
        if (!stepRate) {
            stepRate = this.rayStepRate;
        }
        if (collides === undefined) {
            collides = false;
        }
        if (interestingFace === undefined) {
            interestingFace = false;
        }
        var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);
        if (tiles.length === 0) {
            return [];
        }
        var coords = line.coordinatesOnLine(stepRate);
        var results = [];
        for (var i = 0; i < tiles.length; i++) {
            for (var t = 0; t < coords.length; t++) {
                var tile = tiles[i];
                var coord = coords[t];
                if (tile.containsPoint(coord[0], coord[1])) {
                    results.push(tile);
                    break;
                }
            }
        }
        return results;
    };
    Phaser.TilemapLayer.prototype.getTiles = function(x, y, width, height, collides, interestingFace) {
        if (collides === undefined) {
            collides = false;
        }
        if (interestingFace === undefined) {
            interestingFace = false;
        }
        var fetchAll = !(collides || interestingFace);
        x = this._fixX(x);
        y = this._fixY(y);
        var tx = Math.floor(x / (this._mc.cw * this.scale.x));
        var ty = Math.floor(y / (this._mc.ch * this.scale.y));
        var tw = Math.ceil((x + width) / (this._mc.cw * this.scale.x)) - tx;
        var th = Math.ceil((y + height) / (this._mc.ch * this.scale.y)) - ty;
        while (this._results.length) {
            this._results.pop();
        }
        for (var wy = ty; wy < ty + th; wy++) {
            for (var wx = tx; wx < tx + tw; wx++) {
                var row = this.layer.data[wy];
                if (row && row[wx]) {
                    if (fetchAll || row[wx].isInteresting(collides, interestingFace)) {
                        this._results.push(row[wx]);
                    }
                }
            }
        }
        return this._results.slice();
    };
    Phaser.TilemapLayer.prototype.resolveTileset = function(tileIndex) {
        var tilesets = this._mc.tilesets;
        if (tileIndex < 2e3) {
            while (tilesets.length < tileIndex) {
                tilesets.push(undefined);
            }
        }
        var setIndex = this.map.tiles[tileIndex] && this.map.tiles[tileIndex][2];
        if (setIndex != null) {
            var tileset = this.map.tilesets[setIndex];
            if (tileset && tileset.containsTileIndex(tileIndex)) {
                return tilesets[tileIndex] = tileset;
            }
        }
        return tilesets[tileIndex] = null;
    };
    Phaser.TilemapLayer.prototype.resetTilesetCache = function() {
        var tilesets = this._mc.tilesets;
        while (tilesets.length) {
            tilesets.pop();
        }
    };
    Phaser.TilemapLayer.prototype.setScale = function(xScale, yScale) {
        xScale = xScale || 1;
        yScale = yScale || xScale;
        for (var y = 0; y < this.layer.data.length; y++) {
            var row = this.layer.data[y];
            for (var x = 0; x < row.length; x++) {
                var tile = row[x];
                tile.width = this.map.tileWidth * xScale;
                tile.height = this.map.tileHeight * yScale;
                tile.worldX = tile.x * tile.width;
                tile.worldY = tile.y * tile.height;
            }
        }
        this.scale.setTo(xScale, yScale);
    };
    Phaser.TilemapLayer.prototype.shiftCanvas = function(context, x, y) {
        var canvas = context.canvas;
        var copyW = canvas.width - Math.abs(x);
        var copyH = canvas.height - Math.abs(y);
        var dx = 0;
        var dy = 0;
        var sx = x;
        var sy = y;
        if (x < 0) {
            dx = -x;
            sx = 0;
        }
        if (y < 0) {
            dy = -y;
            sy = 0;
        }
        var copyCanvas = this.renderSettings.copyCanvas;
        if (copyCanvas) {
            if (copyCanvas.width < copyW || copyCanvas.height < copyH) {
                copyCanvas.width = copyW;
                copyCanvas.height = copyH;
            }
            var copyContext = copyCanvas.getContext("2d");
            copyContext.clearRect(0, 0, copyW, copyH);
            copyContext.drawImage(canvas, dx, dy, copyW, copyH, 0, 0, copyW, copyH);
            context.clearRect(sx, sy, copyW, copyH);
            context.drawImage(copyCanvas, 0, 0, copyW, copyH, sx, sy, copyW, copyH);
        } else {
            context.save();
            context.globalCompositeOperation = "copy";
            context.drawImage(canvas, dx, dy, copyW, copyH, sx, sy, copyW, copyH);
            context.restore();
        }
    };
    Phaser.TilemapLayer.prototype.renderRegion = function(scrollX, scrollY, left, top, right, bottom) {
        var context = this.context;
        var width = this.layer.width;
        var height = this.layer.height;
        var tw = this._mc.tileWidth;
        var th = this._mc.tileHeight;
        var tilesets = this._mc.tilesets;
        var lastAlpha = NaN;
        if (!this._wrap) {
            if (left <= right) {
                left = Math.max(0, left);
                right = Math.min(width - 1, right);
            }
            if (top <= bottom) {
                top = Math.max(0, top);
                bottom = Math.min(height - 1, bottom);
            }
        }
        var baseX = left * tw - scrollX;
        var baseY = top * th - scrollY;
        var normStartX = (left + (1 << 20) * width) % width;
        var normStartY = (top + (1 << 20) * height) % height;
        var tx, ty, x, y, xmax, ymax;
        context.fillStyle = this.tileColor;
        for (y = normStartY, ymax = bottom - top, ty = baseY; ymax >= 0; y++, ymax--, ty += th) {
            if (y >= height) {
                y -= height;
            }
            var row = this.layer.data[y];
            for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) {
                if (x >= width) {
                    x -= width;
                }
                var tile = row[x];
                if (!tile || tile.index < 0) {
                    continue;
                }
                var index = tile.index;
                var set = tilesets[index];
                if (set === undefined) {
                    set = this.resolveTileset(index);
                }
                if (tile.alpha !== lastAlpha && !this.debug) {
                    context.globalAlpha = tile.alpha;
                    lastAlpha = tile.alpha;
                }
                if (set) {
                    if (tile.rotation || tile.flipped) {
                        context.save();
                        context.translate(tx + tile.centerX, ty + tile.centerY);
                        context.rotate(tile.rotation);
                        if (tile.flipped) {
                            context.scale(-1, 1);
                        }
                        set.draw(context, -tile.centerX, -tile.centerY, index);
                        context.restore();
                    } else {
                        set.draw(context, tx, ty, index);
                    }
                } else if (this.debugSettings.missingImageFill) {
                    context.fillStyle = this.debugSettings.missingImageFill;
                    context.fillRect(tx, ty, tw, th);
                }
                if (tile.debug && this.debugSettings.debuggedTileOverfill) {
                    context.fillStyle = this.debugSettings.debuggedTileOverfill;
                    context.fillRect(tx, ty, tw, th);
                }
            }
        }
    };
    Phaser.TilemapLayer.prototype.renderDeltaScroll = function(shiftX, shiftY) {
        var scrollX = this._mc.scrollX;
        var scrollY = this._mc.scrollY;
        var renderW = this.canvas.width;
        var renderH = this.canvas.height;
        var tw = this._mc.tileWidth;
        var th = this._mc.tileHeight;
        var left = 0;
        var right = -tw;
        var top = 0;
        var bottom = -th;
        if (shiftX < 0) {
            left = renderW + shiftX;
            right = renderW - 1;
        } else if (shiftX > 0) {
            right = shiftX;
        }
        if (shiftY < 0) {
            top = renderH + shiftY;
            bottom = renderH - 1;
        } else if (shiftY > 0) {
            bottom = shiftY;
        }
        this.shiftCanvas(this.context, shiftX, shiftY);
        left = Math.floor((left + scrollX) / tw);
        right = Math.floor((right + scrollX) / tw);
        top = Math.floor((top + scrollY) / th);
        bottom = Math.floor((bottom + scrollY) / th);
        if (left <= right) {
            this.context.clearRect(left * tw - scrollX, 0, (right - left + 1) * tw, renderH);
            var trueTop = Math.floor((0 + scrollY) / th);
            var trueBottom = Math.floor((renderH - 1 + scrollY) / th);
            this.renderRegion(scrollX, scrollY, left, trueTop, right, trueBottom);
        }
        if (top <= bottom) {
            this.context.clearRect(0, top * th - scrollY, renderW, (bottom - top + 1) * th);
            var trueLeft = Math.floor((0 + scrollX) / tw);
            var trueRight = Math.floor((renderW - 1 + scrollX) / tw);
            this.renderRegion(scrollX, scrollY, trueLeft, top, trueRight, bottom);
        }
    };
    Phaser.TilemapLayer.prototype.renderFull = function() {
        var scrollX = this._mc.scrollX;
        var scrollY = this._mc.scrollY;
        var renderW = this.canvas.width;
        var renderH = this.canvas.height;
        var tw = this._mc.tileWidth;
        var th = this._mc.tileHeight;
        var left = Math.floor(scrollX / tw);
        var right = Math.floor((renderW - 1 + scrollX) / tw);
        var top = Math.floor(scrollY / th);
        var bottom = Math.floor((renderH - 1 + scrollY) / th);
        this.context.clearRect(0, 0, renderW, renderH);
        this.renderRegion(scrollX, scrollY, left, top, right, bottom);
    };
    Phaser.TilemapLayer.prototype.render = function() {
        var redrawAll = false;
        if (!this.visible) {
            return;
        }
        if (this.dirty || this.layer.dirty) {
            this.layer.dirty = false;
            redrawAll = true;
        }
        var renderWidth = this.canvas.width;
        var renderHeight = this.canvas.height;
        var scrollX = this._scrollX | 0;
        var scrollY = this._scrollY | 0;
        var mc = this._mc;
        var shiftX = mc.scrollX - scrollX;
        var shiftY = mc.scrollY - scrollY;
        if (!redrawAll && shiftX === 0 && shiftY === 0 && mc.renderWidth === renderWidth && mc.renderHeight === renderHeight) {
            return;
        }
        this.context.save();
        mc.scrollX = scrollX;
        mc.scrollY = scrollY;
        if (mc.renderWidth !== renderWidth || mc.renderHeight !== renderHeight) {
            mc.renderWidth = renderWidth;
            mc.renderHeight = renderHeight;
        }
        if (this.debug) {
            this.context.globalAlpha = this.debugSettings.debugAlpha;
            if (this.debugSettings.forceFullRedraw) {
                redrawAll = true;
            }
        }
        if (!redrawAll && this.renderSettings.enableScrollDelta && Math.abs(shiftX) + Math.abs(shiftY) < Math.min(renderWidth, renderHeight)) {
            this.renderDeltaScroll(shiftX, shiftY);
        } else {
            this.renderFull();
        }
        if (this.debug) {
            this.context.globalAlpha = 1;
            this.renderDebug();
        }
        this.texture.baseTexture.dirty();
        this.dirty = false;
        this.context.restore();
        return true;
    };
    Phaser.TilemapLayer.prototype.renderDebug = function() {
        var scrollX = this._mc.scrollX;
        var scrollY = this._mc.scrollY;
        var context = this.context;
        var renderW = this.canvas.width;
        var renderH = this.canvas.height;
        var width = this.layer.width;
        var height = this.layer.height;
        var tw = this._mc.tileWidth;
        var th = this._mc.tileHeight;
        var left = Math.floor(scrollX / tw);
        var right = Math.floor((renderW - 1 + scrollX) / tw);
        var top = Math.floor(scrollY / th);
        var bottom = Math.floor((renderH - 1 + scrollY) / th);
        var baseX = left * tw - scrollX;
        var baseY = top * th - scrollY;
        var normStartX = (left + (1 << 20) * width) % width;
        var normStartY = (top + (1 << 20) * height) % height;
        var tx, ty, x, y, xmax, ymax;
        context.strokeStyle = this.debugSettings.facingEdgeStroke;
        for (y = normStartY, ymax = bottom - top, ty = baseY; ymax >= 0; y++, ymax--, ty += th) {
            if (y >= height) {
                y -= height;
            }
            var row = this.layer.data[y];
            for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) {
                if (x >= width) {
                    x -= width;
                }
                var tile = row[x];
                if (!tile || tile.index < 0 || !tile.collides) {
                    continue;
                }
                if (this.debugSettings.collidingTileOverfill) {
                    context.fillStyle = this.debugSettings.collidingTileOverfill;
                    context.fillRect(tx, ty, this._mc.cw, this._mc.ch);
                }
                if (this.debugSettings.facingEdgeStroke) {
                    context.beginPath();
                    if (tile.faceTop) {
                        context.moveTo(tx, ty);
                        context.lineTo(tx + this._mc.cw, ty);
                    }
                    if (tile.faceBottom) {
                        context.moveTo(tx, ty + this._mc.ch);
                        context.lineTo(tx + this._mc.cw, ty + this._mc.ch);
                    }
                    if (tile.faceLeft) {
                        context.moveTo(tx, ty);
                        context.lineTo(tx, ty + this._mc.ch);
                    }
                    if (tile.faceRight) {
                        context.moveTo(tx + this._mc.cw, ty);
                        context.lineTo(tx + this._mc.cw, ty + this._mc.ch);
                    }
                    context.stroke();
                }
            }
        }
    };
    Object.defineProperty(Phaser.TilemapLayer.prototype, "wrap", {
        get: function() {
            return this._wrap;
        },
        set: function(value) {
            this._wrap = value;
            this.dirty = true;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._scrollX;
        },
        set: function(value) {
            this._scrollX = value;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._scrollY;
        },
        set: function(value) {
            this._scrollY = value;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw;
        },
        set: function(value) {
            this._mc.cw = value | 0;
            this.dirty = true;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch;
        },
        set: function(value) {
            this._mc.ch = value | 0;
            this.dirty = true;
        }
    });
    Phaser.TilemapParser = {
        INSERT_NULL: false,
        parse: function(game, key, tileWidth, tileHeight, width, height) {
            if (tileWidth === undefined) {
                tileWidth = 32;
            }
            if (tileHeight === undefined) {
                tileHeight = 32;
            }
            if (width === undefined) {
                width = 10;
            }
            if (height === undefined) {
                height = 10;
            }
            if (key === undefined) {
                return this.getEmptyData();
            }
            if (key === null) {
                return this.getEmptyData(tileWidth, tileHeight, width, height);
            }
            var map = game.cache.getTilemapData(key);
            if (map) {
                if (map.format === Phaser.Tilemap.CSV) {
                    return this.parseCSV(key, map.data, tileWidth, tileHeight);
                } else if (!map.format || map.format === Phaser.Tilemap.TILED_JSON) {
                    return this.parseTiledJSON(map.data);
                }
            } else {
                console.warn("Phaser.TilemapParser.parse - No map data found for key " + key);
            }
        },
        parseCSV: function(key, data, tileWidth, tileHeight) {
            var map = this.getEmptyData();
            data = data.trim();
            var output = [];
            var rows = data.split("\n");
            var height = rows.length;
            var width = 0;
            for (var y = 0; y < rows.length; y++) {
                output[y] = [];
                var column = rows[y].split(",");
                for (var x = 0; x < column.length; x++) {
                    output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight);
                }
                if (width === 0) {
                    width = column.length;
                }
            }
            map.format = Phaser.Tilemap.CSV;
            map.name = key;
            map.width = width;
            map.height = height;
            map.tileWidth = tileWidth;
            map.tileHeight = tileHeight;
            map.widthInPixels = width * tileWidth;
            map.heightInPixels = height * tileHeight;
            map.layers[0].width = width;
            map.layers[0].height = height;
            map.layers[0].widthInPixels = map.widthInPixels;
            map.layers[0].heightInPixels = map.heightInPixels;
            map.layers[0].data = output;
            return map;
        },
        getEmptyData: function(tileWidth, tileHeight, width, height) {
            var map = {};
            map.width = 0;
            map.height = 0;
            map.tileWidth = 0;
            map.tileHeight = 0;
            if (typeof tileWidth !== "undefined" && tileWidth !== null) {
                map.tileWidth = tileWidth;
            }
            if (typeof tileHeight !== "undefined" && tileHeight !== null) {
                map.tileHeight = tileHeight;
            }
            if (typeof width !== "undefined" && width !== null) {
                map.width = width;
            }
            if (typeof height !== "undefined" && height !== null) {
                map.height = height;
            }
            map.orientation = "orthogonal";
            map.version = "1";
            map.properties = {};
            map.widthInPixels = 0;
            map.heightInPixels = 0;
            var layers = [];
            var layer = {
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: []
            };
            layers.push(layer);
            map.layers = layers;
            map.images = [];
            map.objects = {};
            map.collision = {};
            map.tilesets = [];
            map.tiles = [];
            return map;
        },
        parseTiledJSON: function(json) {
            if (json.orientation !== "orthogonal") {
                console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser");
                return null;
            }
            var map = {};
            map.width = json.width;
            map.height = json.height;
            map.tileWidth = json.tilewidth;
            map.tileHeight = json.tileheight;
            map.orientation = json.orientation;
            map.format = Phaser.Tilemap.TILED_JSON;
            map.version = json.version;
            map.properties = json.properties;
            map.widthInPixels = map.width * map.tileWidth;
            map.heightInPixels = map.height * map.tileHeight;
            var layers = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "tilelayer") {
                    continue;
                }
                var curl = json.layers[i];
                var layer = {
                    name: curl.name,
                    x: curl.x,
                    y: curl.y,
                    width: curl.width,
                    height: curl.height,
                    widthInPixels: curl.width * json.tilewidth,
                    heightInPixels: curl.height * json.tileheight,
                    alpha: curl.opacity,
                    visible: curl.visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                if (curl.properties) {
                    layer.properties = curl.properties;
                }
                var x = 0;
                var row = [];
                var output = [];
                var rotation, flipped, flippedVal, gid;
                for (var t = 0, len = curl.data.length; t < len; t++) {
                    rotation = 0;
                    flipped = false;
                    gid = curl.data[t];
                    if (gid > 536870912) {
                        flippedVal = 0;
                        if (gid > 2147483648) {
                            gid -= 2147483648;
                            flippedVal += 4;
                        }
                        if (gid > 1073741824) {
                            gid -= 1073741824;
                            flippedVal += 2;
                        }
                        if (gid > 536870912) {
                            gid -= 536870912;
                            flippedVal += 1;
                        }
                        switch (flippedVal) {
                          case 5:
                            rotation = Math.PI / 2;
                            break;

                          case 6:
                            rotation = Math.PI;
                            break;

                          case 3:
                            rotation = 3 * Math.PI / 2;
                            break;

                          case 4:
                            rotation = 0;
                            flipped = true;
                            break;

                          case 7:
                            rotation = Math.PI / 2;
                            flipped = true;
                            break;

                          case 2:
                            rotation = Math.PI;
                            flipped = true;
                            break;

                          case 1:
                            rotation = 3 * Math.PI / 2;
                            flipped = true;
                            break;
                        }
                    }
                    if (gid > 0) {
                        row.push(new Phaser.Tile(layer, gid, x, output.length, json.tilewidth, json.tileheight));
                        row[row.length - 1].rotation = rotation;
                        row[row.length - 1].flipped = flipped;
                    } else {
                        if (Phaser.TilemapParser.INSERT_NULL) {
                            row.push(null);
                        } else {
                            row.push(new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight));
                        }
                    }
                    x++;
                    if (x === curl.width) {
                        output.push(row);
                        x = 0;
                        row = [];
                    }
                }
                layer.data = output;
                layers.push(layer);
            }
            map.layers = layers;
            var images = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "imagelayer") {
                    continue;
                }
                var curi = json.layers[i];
                var image = {
                    name: curi.name,
                    image: curi.image,
                    x: curi.x,
                    y: curi.y,
                    alpha: curi.opacity,
                    visible: curi.visible,
                    properties: {}
                };
                if (curi.properties) {
                    image.properties = curi.properties;
                }
                images.push(image);
            }
            map.images = images;
            var tilesets = [];
            var imagecollections = [];
            for (var i = 0; i < json.tilesets.length; i++) {
                var set = json.tilesets[i];
                if (set.image) {
                    var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                    if (set.tileproperties) {
                        newSet.tileProperties = set.tileproperties;
                    }
                    newSet.updateTileData(set.imagewidth, set.imageheight);
                    tilesets.push(newSet);
                } else {
                    var newCollection = new Phaser.ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                    for (var i in set.tiles) {
                        var image = set.tiles[i].image;
                        var gid = set.firstgid + parseInt(i, 10);
                        newCollection.addImage(gid, image);
                    }
                    imagecollections.push(newCollection);
                }
            }
            map.tilesets = tilesets;
            map.imagecollections = imagecollections;
            var objects = {};
            var collision = {};
            function slice(obj, fields) {
                var sliced = {};
                for (var k in fields) {
                    var key = fields[k];
                    if (typeof obj[key] !== "undefined") {
                        sliced[key] = obj[key];
                    }
                }
                return sliced;
            }
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "objectgroup") {
                    continue;
                }
                var curo = json.layers[i];
                objects[curo.name] = [];
                collision[curo.name] = [];
                for (var v = 0, len = curo.objects.length; v < len; v++) {
                    if (curo.objects[v].gid) {
                        var object = {
                            gid: curo.objects[v].gid,
                            name: curo.objects[v].name,
                            type: curo.objects[v].hasOwnProperty("type") ? curo.objects[v].type : "",
                            x: curo.objects[v].x,
                            y: curo.objects[v].y,
                            visible: curo.objects[v].visible,
                            properties: curo.objects[v].properties
                        };
                        if (curo.objects[v].rotation) {
                            object.rotation = curo.objects[v].rotation;
                        }
                        objects[curo.name].push(object);
                    } else if (curo.objects[v].polyline) {
                        var object = {
                            name: curo.objects[v].name,
                            type: curo.objects[v].type,
                            x: curo.objects[v].x,
                            y: curo.objects[v].y,
                            width: curo.objects[v].width,
                            height: curo.objects[v].height,
                            visible: curo.objects[v].visible,
                            properties: curo.objects[v].properties
                        };
                        if (curo.objects[v].rotation) {
                            object.rotation = curo.objects[v].rotation;
                        }
                        object.polyline = [];
                        for (var p = 0; p < curo.objects[v].polyline.length; p++) {
                            object.polyline.push([ curo.objects[v].polyline[p].x, curo.objects[v].polyline[p].y ]);
                        }
                        collision[curo.name].push(object);
                        objects[curo.name].push(object);
                    } else if (curo.objects[v].polygon) {
                        var object = slice(curo.objects[v], [ "name", "type", "x", "y", "visible", "rotation", "properties" ]);
                        object.polygon = [];
                        for (var p = 0; p < curo.objects[v].polygon.length; p++) {
                            object.polygon.push([ curo.objects[v].polygon[p].x, curo.objects[v].polygon[p].y ]);
                        }
                        objects[curo.name].push(object);
                    } else if (curo.objects[v].ellipse) {
                        var object = slice(curo.objects[v], [ "name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties" ]);
                        objects[curo.name].push(object);
                    } else {
                        var object = slice(curo.objects[v], [ "name", "type", "x", "y", "width", "height", "visible", "rotation", "properties" ]);
                        object.rectangle = true;
                        objects[curo.name].push(object);
                    }
                }
            }
            map.objects = objects;
            map.collision = collision;
            map.tiles = [];
            for (var i = 0; i < map.tilesets.length; i++) {
                var set = map.tilesets[i];
                var x = set.tileMargin;
                var y = set.tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                    map.tiles[t] = [ x, y, i ];
                    x += set.tileWidth + set.tileSpacing;
                    count++;
                    if (count === set.total) {
                        break;
                    }
                    countX++;
                    if (countX === set.columns) {
                        x = set.tileMargin;
                        y += set.tileHeight + set.tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === set.rows) {
                            break;
                        }
                    }
                }
            }
            var layer;
            var tile;
            var sid;
            var set;
            for (var i = 0; i < map.layers.length; i++) {
                layer = map.layers[i];
                for (var j = 0; j < layer.data.length; j++) {
                    row = layer.data[j];
                    for (var k = 0; k < row.length; k++) {
                        tile = row[k];
                        if (tile === null || tile.index < 0) {
                            continue;
                        }
                        sid = map.tiles[tile.index][2];
                        set = map.tilesets[sid];
                        if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                            tile.properties = Phaser.Utils.mixin(set.tileProperties[tile.index - set.firstgid], tile.properties);
                        }
                    }
                }
            }
            return map;
        }
    };
    Phaser.Tileset = function(name, firstgid, width, height, margin, spacing, properties) {
        if (width === undefined || width <= 0) {
            width = 32;
        }
        if (height === undefined || height <= 0) {
            height = 32;
        }
        if (margin === undefined) {
            margin = 0;
        }
        if (spacing === undefined) {
            spacing = 0;
        }
        this.name = name;
        this.firstgid = firstgid | 0;
        this.tileWidth = width | 0;
        this.tileHeight = height | 0;
        this.tileMargin = margin | 0;
        this.tileSpacing = spacing | 0;
        this.properties = properties || {};
        this.image = null;
        this.rows = 0;
        this.columns = 0;
        this.total = 0;
        this.drawCoords = [];
    };
    Phaser.Tileset.prototype = {
        draw: function(context, x, y, index) {
            var coordIndex = index - this.firstgid << 1;
            if (coordIndex >= 0 && coordIndex + 1 < this.drawCoords.length) {
                context.drawImage(this.image, this.drawCoords[coordIndex], this.drawCoords[coordIndex + 1], this.tileWidth, this.tileHeight, x, y, this.tileWidth, this.tileHeight);
            }
        },
        containsTileIndex: function(tileIndex) {
            return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
        },
        setImage: function(image) {
            this.image = image;
            this.updateTileData(image.width, image.height);
        },
        setSpacing: function(margin, spacing) {
            this.tileMargin = margin | 0;
            this.tileSpacing = spacing | 0;
            if (this.image) {
                this.updateTileData(this.image.width, this.image.height);
            }
        },
        updateTileData: function(imageWidth, imageHeight) {
            var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
            var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
                console.warn("Phaser.Tileset - image tile area is not an even multiple of tile size");
            }
            rowCount = Math.floor(rowCount);
            colCount = Math.floor(colCount);
            if (this.rows && this.rows !== rowCount || this.columns && this.columns !== colCount) {
                console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ");
            }
            this.rows = rowCount;
            this.columns = colCount;
            this.total = rowCount * colCount;
            this.drawCoords.length = 0;
            var tx = this.tileMargin;
            var ty = this.tileMargin;
            for (var y = 0; y < this.rows; y++) {
                for (var x = 0; x < this.columns; x++) {
                    this.drawCoords.push(tx);
                    this.drawCoords.push(ty);
                    tx += this.tileWidth + this.tileSpacing;
                }
                tx = this.tileMargin;
                ty += this.tileHeight + this.tileSpacing;
            }
        }
    };
    Phaser.Tileset.prototype.constructor = Phaser.Tileset;
    Phaser.Particles = function(game) {
        this.game = game;
        this.emitters = {};
        this.ID = 0;
    };
    Phaser.Particles.prototype = {
        add: function(emitter) {
            this.emitters[emitter.name] = emitter;
            return emitter;
        },
        remove: function(emitter) {
            delete this.emitters[emitter.name];
        },
        update: function() {
            for (var key in this.emitters) {
                if (this.emitters[key].exists) {
                    this.emitters[key].update();
                }
            }
        }
    };
    Phaser.Particles.prototype.constructor = Phaser.Particles;
    Phaser.Particles.Arcade = {};
    Phaser.Particles.Arcade.Emitter = function(game, x, y, maxParticles) {
        this.maxParticles = maxParticles || 50;
        Phaser.Group.call(this, game);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = Phaser.EMITTER;
        this.physicsType = Phaser.GROUP;
        this.area = new Phaser.Rectangle(x, y, 1, 1);
        this.minParticleSpeed = new Phaser.Point(-100, -100);
        this.maxParticleSpeed = new Phaser.Point(100, 100);
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this.scaleData = null;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.minParticleAlpha = 1;
        this.maxParticleAlpha = 1;
        this.alphaData = null;
        this.gravity = 100;
        this.particleClass = Phaser.Particle;
        this.particleDrag = new Phaser.Point();
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2e3;
        this.bounce = new Phaser.Point();
        this.on = false;
        this.particleAnchor = new Phaser.Point(.5, .5);
        this.blendMode = Phaser.blendModes.NORMAL;
        this.emitX = x;
        this.emitY = y;
        this.autoScale = false;
        this.autoAlpha = false;
        this.particleBringToTop = false;
        this.particleSendToBack = false;
        this._minParticleScale = new Phaser.Point(1, 1);
        this._maxParticleScale = new Phaser.Point(1, 1);
        this._quantity = 0;
        this._timer = 0;
        this._counter = 0;
        this._flowQuantity = 0;
        this._flowTotal = 0;
        this._explode = true;
        this._frames = null;
    };
    Phaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype);
    Phaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter;
    Phaser.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on && this.game.time.time >= this._timer) {
            this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion;
            if (this._flowTotal !== 0) {
                if (this._flowQuantity > 0) {
                    for (var i = 0; i < this._flowQuantity; i++) {
                        if (this.emitParticle()) {
                            this._counter++;
                            if (this._flowTotal !== -1 && this._counter >= this._flowTotal) {
                                this.on = false;
                                break;
                            }
                        }
                    }
                } else {
                    if (this.emitParticle()) {
                        this._counter++;
                        if (this._flowTotal !== -1 && this._counter >= this._flowTotal) {
                            this.on = false;
                        }
                    }
                }
            } else {
                if (this.emitParticle()) {
                    this._counter++;
                    if (this._quantity > 0 && this._counter >= this._quantity) {
                        this.on = false;
                    }
                }
            }
        }
        var i = this.children.length;
        while (i--) {
            if (this.children[i].exists) {
                this.children[i].update();
            }
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.makeParticles = function(keys, frames, quantity, collide, collideWorldBounds) {
        if (frames === undefined) {
            frames = 0;
        }
        if (quantity === undefined) {
            quantity = this.maxParticles;
        }
        if (collide === undefined) {
            collide = false;
        }
        if (collideWorldBounds === undefined) {
            collideWorldBounds = false;
        }
        var particle;
        var i = 0;
        var rndKey = keys;
        var rndFrame = frames;
        this._frames = frames;
        if (quantity > this.maxParticles) {
            this.maxParticles = quantity;
        }
        while (i < quantity) {
            if (Array.isArray(keys)) {
                rndKey = this.game.rnd.pick(keys);
            }
            if (Array.isArray(frames)) {
                rndFrame = this.game.rnd.pick(frames);
            }
            particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame);
            this.game.physics.arcade.enable(particle, false);
            if (collide) {
                particle.body.checkCollision.any = true;
                particle.body.checkCollision.none = false;
            } else {
                particle.body.checkCollision.none = true;
            }
            particle.body.collideWorldBounds = collideWorldBounds;
            particle.body.skipQuadTree = true;
            particle.exists = false;
            particle.visible = false;
            particle.anchor.copyFrom(this.particleAnchor);
            this.add(particle);
            i++;
        }
        return this;
    };
    Phaser.Particles.Arcade.Emitter.prototype.kill = function() {
        this.on = false;
        this.alive = false;
        this.exists = false;
    };
    Phaser.Particles.Arcade.Emitter.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
    };
    Phaser.Particles.Arcade.Emitter.prototype.explode = function(lifespan, quantity) {
        this._flowTotal = 0;
        this.start(true, lifespan, 0, quantity, false);
    };
    Phaser.Particles.Arcade.Emitter.prototype.flow = function(lifespan, frequency, quantity, total, immediate) {
        if (quantity === undefined || quantity === 0) {
            quantity = 1;
        }
        if (total === undefined) {
            total = -1;
        }
        if (immediate === undefined) {
            immediate = true;
        }
        if (quantity > this.maxParticles) {
            quantity = this.maxParticles;
        }
        this._counter = 0;
        this._flowQuantity = quantity;
        this._flowTotal = total;
        if (immediate) {
            this.start(true, lifespan, frequency, quantity);
            this._counter += quantity;
            this.on = true;
            this._timer = this.game.time.time + frequency * this.game.time.slowMotion;
        } else {
            this.start(false, lifespan, frequency, quantity);
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.start = function(explode, lifespan, frequency, quantity, forceQuantity) {
        if (explode === undefined) {
            explode = true;
        }
        if (lifespan === undefined) {
            lifespan = 0;
        }
        if (frequency === undefined || frequency === null) {
            frequency = 250;
        }
        if (quantity === undefined) {
            quantity = 0;
        }
        if (forceQuantity === undefined) {
            forceQuantity = false;
        }
        if (quantity > this.maxParticles) {
            quantity = this.maxParticles;
        }
        this.revive();
        this.visible = true;
        this.lifespan = lifespan;
        this.frequency = frequency;
        if (explode || forceQuantity) {
            for (var i = 0; i < quantity; i++) {
                this.emitParticle();
            }
        } else {
            this.on = true;
            this._quantity += quantity;
            this._counter = 0;
            this._timer = this.game.time.time + frequency * this.game.time.slowMotion;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.emitParticle = function() {
        var particle = this.getFirstExists(false);
        if (particle === null) {
            return false;
        }
        if (this.width > 1 || this.height > 1) {
            particle.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom));
        } else {
            particle.reset(this.emitX, this.emitY);
        }
        particle.angle = 0;
        particle.lifespan = this.lifespan;
        if (this.particleBringToTop) {
            this.bringToTop(particle);
        } else if (this.particleSendToBack) {
            this.sendToBack(particle);
        }
        if (this.autoScale) {
            particle.setScaleData(this.scaleData);
        } else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) {
            particle.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale));
        } else if (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) {
            particle.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y));
        }
        if (Array.isArray(this._frames === "object")) {
            particle.frame = this.game.rnd.pick(this._frames);
        } else {
            particle.frame = this._frames;
        }
        if (this.autoAlpha) {
            particle.setAlphaData(this.alphaData);
        } else {
            particle.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha);
        }
        particle.blendMode = this.blendMode;
        particle.body.updateBounds();
        particle.body.bounce.setTo(this.bounce.x, this.bounce.y);
        particle.body.velocity.x = this.game.rnd.between(this.minParticleSpeed.x, this.maxParticleSpeed.x);
        particle.body.velocity.y = this.game.rnd.between(this.minParticleSpeed.y, this.maxParticleSpeed.y);
        particle.body.angularVelocity = this.game.rnd.between(this.minRotation, this.maxRotation);
        particle.body.gravity.y = this.gravity;
        particle.body.drag.x = this.particleDrag.x;
        particle.body.drag.y = this.particleDrag.y;
        particle.body.angularDrag = this.angularDrag;
        particle.onEmit();
        return true;
    };
    Phaser.Particles.Arcade.Emitter.prototype.destroy = function() {
        this.game.particles.remove(this);
        Phaser.Group.prototype.destroy.call(this, true, false);
    };
    Phaser.Particles.Arcade.Emitter.prototype.setSize = function(width, height) {
        this.area.width = width;
        this.area.height = height;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setXSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.x = min;
        this.maxParticleSpeed.x = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setYSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.y = min;
        this.maxParticleSpeed.y = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setRotation = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minRotation = min;
        this.maxRotation = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setAlpha = function(min, max, rate, ease, yoyo) {
        if (min === undefined) {
            min = 1;
        }
        if (max === undefined) {
            max = 1;
        }
        if (rate === undefined) {
            rate = 0;
        }
        if (ease === undefined) {
            ease = Phaser.Easing.Linear.None;
        }
        if (yoyo === undefined) {
            yoyo = false;
        }
        this.minParticleAlpha = min;
        this.maxParticleAlpha = max;
        this.autoAlpha = false;
        if (rate > 0 && min !== max) {
            var tweenData = {
                v: min
            };
            var tween = this.game.make.tween(tweenData).to({
                v: max
            }, rate, ease);
            tween.yoyo(yoyo);
            this.alphaData = tween.generateData(60);
            this.alphaData.reverse();
            this.autoAlpha = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.setScale = function(minX, maxX, minY, maxY, rate, ease, yoyo) {
        if (minX === undefined) {
            minX = 1;
        }
        if (maxX === undefined) {
            maxX = 1;
        }
        if (minY === undefined) {
            minY = 1;
        }
        if (maxY === undefined) {
            maxY = 1;
        }
        if (rate === undefined) {
            rate = 0;
        }
        if (ease === undefined) {
            ease = Phaser.Easing.Linear.None;
        }
        if (yoyo === undefined) {
            yoyo = false;
        }
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this._minParticleScale.set(minX, minY);
        this._maxParticleScale.set(maxX, maxY);
        this.autoScale = false;
        if (rate > 0 && (minX !== maxX || minY !== maxY)) {
            var tweenData = {
                x: minX,
                y: minY
            };
            var tween = this.game.make.tween(tweenData).to({
                x: maxX,
                y: maxY
            }, rate, ease);
            tween.yoyo(yoyo);
            this.scaleData = tween.generateData(60);
            this.scaleData.reverse();
            this.autoScale = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.at = function(object) {
        if (object.center) {
            this.emitX = object.center.x;
            this.emitY = object.center.y;
        } else {
            this.emitX = object.world.x + object.anchor.x * object.width;
            this.emitY = object.world.y + object.anchor.y * object.height;
        }
    };
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width;
        },
        set: function(value) {
            this.area.width = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height;
        },
        set: function(value) {
            this.area.height = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX;
        },
        set: function(value) {
            this.emitX = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY;
        },
        set: function(value) {
            this.emitY = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2);
        }
    });
    Phaser.Video = function(game, key, url) {
        if (key === undefined) {
            key = null;
        }
        if (url === undefined) {
            url = null;
        }
        this.game = game;
        this.key = key;
        this.width = 0;
        this.height = 0;
        this.type = Phaser.VIDEO;
        this.disableTextureUpload = false;
        this.touchLocked = false;
        this.onPlay = new Phaser.Signal();
        this.onChangeSource = new Phaser.Signal();
        this.onComplete = new Phaser.Signal();
        this.onAccess = new Phaser.Signal();
        this.onError = new Phaser.Signal();
        this.onTimeout = new Phaser.Signal();
        this.timeout = 15e3;
        this._timeOutID = null;
        this.video = null;
        this.videoStream = null;
        this.isStreaming = false;
        this.retryLimit = 20;
        this.retry = 0;
        this.retryInterval = 500;
        this._retryID = null;
        this._codeMuted = false;
        this._muted = false;
        this._codePaused = false;
        this._paused = false;
        this._pending = false;
        this._autoplay = false;
        if (key && this.game.cache.checkVideoKey(key)) {
            var _video = this.game.cache.getVideo(key);
            if (_video.isBlob) {
                this.createVideoFromBlob(_video.data);
            } else {
                this.video = _video.data;
            }
            this.width = this.video.videoWidth;
            this.height = this.video.videoHeight;
        } else if (url) {
            this.createVideoFromURL(url, false);
        }
        if (this.video && !url) {
            this.baseTexture = new PIXI.BaseTexture(this.video);
            this.baseTexture.forceLoaded(this.width, this.height);
        } else {
            this.baseTexture = new PIXI.BaseTexture(PIXI.TextureCache["__default"].baseTexture.source);
            this.baseTexture.forceLoaded(this.width, this.height);
        }
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, this.width, this.height, "video");
        this.texture.setFrame(this.textureFrame);
        this.texture.valid = false;
        if (key !== null && this.video) {
            this.texture.valid = this.video.canplay;
        }
        this.snapshot = null;
        if (Phaser.BitmapData) {
            this.snapshot = new Phaser.BitmapData(this.game, "", this.width, this.height);
        }
        if (!this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window["PhaserGlobal"] && window["PhaserGlobal"].fakeiOSTouchLock) {
            this.setTouchLock();
        } else {
            if (_video) {
                _video.locked = false;
            }
        }
    };
    Phaser.Video.prototype = {
        connectToMediaStream: function(video, stream) {
            if (video && stream) {
                this.video = video;
                this.videoStream = stream;
                this.isStreaming = true;
                this.baseTexture.source = this.video;
                this.updateTexture(null, this.video.videoWidth, this.video.videoHeight);
                this.onAccess.dispatch(this);
            }
            return this;
        },
        startMediaStream: function(captureAudio, width, height) {
            if (captureAudio === undefined) {
                captureAudio = false;
            }
            if (width === undefined) {
                width = null;
            }
            if (height === undefined) {
                height = null;
            }
            if (!this.game.device.getUserMedia) {
                this.onError.dispatch(this, "No getUserMedia");
                return false;
            }
            if (this.videoStream !== null) {
                if (this.videoStream["active"]) {
                    this.videoStream.active = false;
                } else {
                    this.videoStream.stop();
                }
            }
            this.removeVideoElement();
            this.video = document.createElement("video");
            this.video.setAttribute("autoplay", "autoplay");
            if (width !== null) {
                this.video.width = width;
            }
            if (height !== null) {
                this.video.height = height;
            }
            this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: captureAudio,
                    video: true
                }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
            } catch (error) {
                this.getUserMediaError(error);
            }
            return this;
        },
        getUserMediaTimeout: function() {
            clearTimeout(this._timeOutID);
            this.onTimeout.dispatch(this);
        },
        getUserMediaError: function(event) {
            clearTimeout(this._timeOutID);
            this.onError.dispatch(this, event);
        },
        getUserMediaSuccess: function(stream) {
            clearTimeout(this._timeOutID);
            this.videoStream = stream;
            if (this.video.mozSrcObject !== undefined) {
                this.video.mozSrcObject = stream;
            } else {
                this.video.src = window.URL && window.URL.createObjectURL(stream) || stream;
            }
            var self = this;
            this.video.onloadeddata = function() {
                var retry = 10;
                function checkStream() {
                    if (retry > 0) {
                        if (self.video.videoWidth > 0) {
                            var width = self.video.videoWidth;
                            var height = self.video.videoHeight;
                            if (isNaN(self.video.videoHeight)) {
                                height = width / (4 / 3);
                            }
                            self.video.play();
                            self.isStreaming = true;
                            self.baseTexture.source = self.video;
                            self.updateTexture(null, width, height);
                            self.onAccess.dispatch(self);
                        } else {
                            window.setTimeout(checkStream, 500);
                        }
                    } else {
                        console.warn("Unable to connect to video stream. Webcam error?");
                    }
                    retry--;
                }
                checkStream();
            };
        },
        createVideoFromBlob: function(blob) {
            var _this = this;
            this.video = document.createElement("video");
            this.video.controls = false;
            this.video.setAttribute("autoplay", "autoplay");
            this.video.addEventListener("loadeddata", function(event) {
                _this.updateTexture(event);
            }, true);
            this.video.src = window.URL.createObjectURL(blob);
            this.video.canplay = true;
            return this;
        },
        createVideoFromURL: function(url, autoplay) {
            if (autoplay === undefined) {
                autoplay = false;
            }
            if (this.texture) {
                this.texture.valid = false;
            }
            this.video = document.createElement("video");
            this.video.controls = false;
            if (autoplay) {
                this.video.setAttribute("autoplay", "autoplay");
            }
            this.video.src = url;
            this.video.canplay = true;
            this.video.load();
            this.retry = this.retryLimit;
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
            this.key = url;
            return this;
        },
        updateTexture: function(event, width, height) {
            var change = false;
            if (width === undefined || width === null) {
                width = this.video.videoWidth;
                change = true;
            }
            if (height === undefined || height === null) {
                height = this.video.videoHeight;
            }
            this.width = width;
            this.height = height;
            if (this.baseTexture.source !== this.video) {
                this.baseTexture.source = this.video;
            }
            this.baseTexture.forceLoaded(width, height);
            this.texture.frame.resize(width, height);
            this.texture.width = width;
            this.texture.height = height;
            this.texture.valid = true;
            if (this.snapshot) {
                this.snapshot.resize(width, height);
            }
            if (change && this.key !== null) {
                this.onChangeSource.dispatch(this, width, height);
                if (this._autoplay) {
                    this.video.play();
                    this.onPlay.dispatch(this, this.loop, this.playbackRate);
                }
            }
        },
        complete: function() {
            this.onComplete.dispatch(this);
        },
        play: function(loop, playbackRate) {
            if (loop === undefined) {
                loop = false;
            }
            if (playbackRate === undefined) {
                playbackRate = 1;
            }
            if (this.game.sound.onMute) {
                this.game.sound.onMute.add(this.setMute, this);
                this.game.sound.onUnMute.add(this.unsetMute, this);
                if (this.game.sound.mute) {
                    this.setMute();
                }
            }
            this.game.onPause.add(this.setPause, this);
            this.game.onResume.add(this.setResume, this);
            this.video.addEventListener("ended", this.complete.bind(this), true);
            if (loop) {
                this.video.loop = "loop";
            } else {
                this.video.loop = "";
            }
            this.video.playbackRate = playbackRate;
            if (this.touchLocked) {
                this._pending = true;
            } else {
                this._pending = false;
                if (this.key !== null) {
                    if (this.video.readyState !== 4) {
                        this.retry = this.retryLimit;
                        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                    } else {
                        this.video.addEventListener("playing", this.playHandler.bind(this), true);
                    }
                }
                this.video.play();
                this.onPlay.dispatch(this, loop, playbackRate);
            }
            return this;
        },
        playHandler: function() {
            this.video.removeEventListener("playing", this.playHandler.bind(this));
            this.updateTexture();
        },
        stop: function() {
            if (this.game.sound.onMute) {
                this.game.sound.onMute.remove(this.setMute, this);
                this.game.sound.onUnMute.remove(this.unsetMute, this);
            }
            this.game.onPause.remove(this.setPause, this);
            this.game.onResume.remove(this.setResume, this);
            if (this.isStreaming) {
                if (this.video.mozSrcObject) {
                    this.video.mozSrcObject.stop();
                    this.video.src = null;
                } else {
                    this.video.src = "";
                    if (this.videoStream["active"]) {
                        this.videoStream.active = false;
                    } else {
                        this.videoStream.stop();
                    }
                }
                this.videoStream = null;
                this.isStreaming = false;
            } else {
                this.video.removeEventListener("ended", this.complete.bind(this), true);
                this.video.removeEventListener("playing", this.playHandler.bind(this), true);
                if (this.touchLocked) {
                    this._pending = false;
                } else {
                    this.video.pause();
                }
            }
            return this;
        },
        add: function(object) {
            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    if (object[i]["loadTexture"]) {
                        object[i].loadTexture(this);
                    }
                }
            } else {
                object.loadTexture(this);
            }
            return this;
        },
        addToWorld: function(x, y, anchorX, anchorY, scaleX, scaleY) {
            scaleX = scaleX || 1;
            scaleY = scaleY || 1;
            var image = this.game.add.image(x, y, this);
            image.anchor.set(anchorX, anchorY);
            image.scale.set(scaleX, scaleY);
            return image;
        },
        render: function() {
            if (!this.disableTextureUpload && this.playing) {
                this.baseTexture.dirty();
            }
        },
        setMute: function() {
            if (this._muted) {
                return;
            }
            this._muted = true;
            this.video.muted = true;
        },
        unsetMute: function() {
            if (!this._muted || this._codeMuted) {
                return;
            }
            this._muted = false;
            this.video.muted = false;
        },
        setPause: function() {
            if (this._paused || this.touchLocked) {
                return;
            }
            this._paused = true;
            this.video.pause();
        },
        setResume: function() {
            if (!this._paused || this._codePaused || this.touchLocked) {
                return;
            }
            this._paused = false;
            if (!this.video.ended) {
                this.video.play();
            }
        },
        changeSource: function(src, autoplay) {
            if (autoplay === undefined) {
                autoplay = true;
            }
            this.texture.valid = false;
            this.video.pause();
            this.retry = this.retryLimit;
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
            this.video.src = src;
            this.video.load();
            this._autoplay = autoplay;
            if (!autoplay) {
                this.paused = true;
            }
            return this;
        },
        checkVideoProgress: function() {
            if (this.video.readyState === 4) {
                this.updateTexture();
            } else {
                this.retry--;
                if (this.retry > 0) {
                    this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                } else {
                    console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming);
                }
            }
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this);
            this.touchLocked = true;
        },
        unlock: function() {
            this.touchLocked = false;
            this.video.play();
            this.onPlay.dispatch(this, this.loop, this.playbackRate);
            if (this.key) {
                var _video = this.game.cache.getVideo(this.key);
                if (_video && !_video.isBlob) {
                    _video.locked = false;
                }
            }
            return true;
        },
        grab: function(clear, alpha, blendMode) {
            if (clear === undefined) {
                clear = false;
            }
            if (alpha === undefined) {
                alpha = 1;
            }
            if (blendMode === undefined) {
                blendMode = null;
            }
            if (this.snapshot === null) {
                console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable");
                return;
            }
            if (clear) {
                this.snapshot.cls();
            }
            this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, alpha, blendMode);
            return this.snapshot;
        },
        removeVideoElement: function() {
            if (!this.video) {
                return;
            }
            if (this.video.parentNode) {
                this.video.parentNode.removeChild(this.video);
            }
            while (this.video.hasChildNodes()) {
                this.video.removeChild(this.video.firstChild);
            }
            this.video.removeAttribute("autoplay");
            this.video.removeAttribute("src");
            this.video = null;
        },
        destroy: function() {
            this.stop();
            this.removeVideoElement();
            if (this.touchLocked) {
                this.game.input.touch.removeTouchLockCallback(this.unlock, this);
            }
            if (this._retryID) {
                window.clearTimeout(this._retryID);
            }
        }
    };
    Object.defineProperty(Phaser.Video.prototype, "currentTime", {
        get: function() {
            return this.video ? this.video.currentTime : 0;
        },
        set: function(value) {
            this.video.currentTime = value;
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "duration", {
        get: function() {
            return this.video ? this.video.duration : 0;
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "progress", {
        get: function() {
            return this.video ? this.video.currentTime / this.video.duration : 0;
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(value) {
            value = value || null;
            if (value) {
                if (this._muted) {
                    return;
                }
                this._codeMuted = true;
                this.setMute();
            } else {
                if (!this._muted) {
                    return;
                }
                this._codeMuted = false;
                this.unsetMute();
            }
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(value) {
            value = value || null;
            if (this.touchLocked) {
                return;
            }
            if (value) {
                if (this._paused) {
                    return;
                }
                this._codePaused = true;
                this.setPause();
            } else {
                if (!this._paused) {
                    return;
                }
                this._codePaused = false;
                this.setResume();
            }
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "volume", {
        get: function() {
            return this.video ? this.video.volume : 1;
        },
        set: function(value) {
            if (value < 0) {
                value = 0;
            } else if (value > 1) {
                value = 1;
            }
            if (this.video) {
                this.video.volume = value;
            }
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "playbackRate", {
        get: function() {
            return this.video ? this.video.playbackRate : 1;
        },
        set: function(value) {
            if (this.video) {
                this.video.playbackRate = value;
            }
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "loop", {
        get: function() {
            return this.video ? this.video.loop : false;
        },
        set: function(value) {
            if (value && this.video) {
                this.video.loop = "loop";
            } else if (this.video) {
                this.video.loop = "";
            }
        }
    });
    Object.defineProperty(Phaser.Video.prototype, "playing", {
        get: function() {
            return !(this.video.paused && this.video.ended);
        }
    });
    Phaser.Video.prototype.constructor = Phaser.Video;
    if (PIXI.blendModes === undefined) {
        PIXI.blendModes = Phaser.blendModes;
    }
    if (PIXI.scaleModes === undefined) {
        PIXI.scaleModes = Phaser.scaleModes;
    }
    if (PIXI.Texture.emptyTexture === undefined) {
        PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture());
    }
    if (PIXI.DisplayObject._tempMatrix === undefined) {
        PIXI.DisplayObject._tempMatrix = new PIXI.Matrix();
    }
    if (PIXI.RenderTexture.tempMatrix === undefined) {
        PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();
    }
    if (PIXI.Graphics.POLY === undefined) {
        PIXI.Graphics.POLY = Phaser.POLYGON;
        PIXI.Graphics.RECT = Phaser.RECTANGLE;
        PIXI.Graphics.CIRC = Phaser.CIRCLE;
        PIXI.Graphics.ELIP = Phaser.ELLIPSE;
        PIXI.Graphics.RREC = Phaser.ROUNDEDRECTANGLE;
    }
    PIXI.TextureSilentFail = true;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = Phaser;
        }
        exports.Phaser = Phaser;
    } else if (typeof define !== "undefined" && define.amd) {
        define("Phaser", function() {
            return root.Phaser = Phaser;
        }());
    } else {
        root.Phaser = Phaser;
    }
    return Phaser;
}).call(this);

(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = "2.1.4", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
            return true;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = "length" in obj && obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
            setDocument();
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed && documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType !== 1 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            parent = doc.defaultView;
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            documentIsHTML = !isXML(doc);
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function(div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        if (!selector) {
            return this;
        }
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function(n, elem) {
            var matched = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed, false);
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = "";
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }
    })();
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                    scale = scale || ".5";
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className);
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.attachEvent) {
        window.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    callback = xhrCallbacks[id] = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

!function() {
    var d3 = {
        version: "3.5.6"
    };
    var d3_arraySlice = [].slice, d3_array = function(list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function(list) {
                var i = list.length, array = new Array(i);
                while (i--) array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now) Date.now = function() {
        return +new Date();
    };
    if (d3_document) {
        try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
                d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
                d3_style_setProperty.call(this, name, value + "", priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
    };
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
    };
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        }
        return [ a, c ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
        } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
    };
    d3.mean = function(array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
        }
        if (j) return s / j;
    };
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
    };
    d3.variance = function(array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1) return s / (j - 1);
    };
    d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function(array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function(array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
        return pairs;
    };
    d3.zip = function() {
        if (!(n = arguments.length)) return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    };
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
    };
    d3.keys = function(map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
    };
    d3.values = function(map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
    };
    d3.entries = function(map) {
        var entries = [];
        for (var key in map) entries.push({
            key: key,
            value: map[key]
        });
        return entries;
    };
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function(key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object) map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = "__proto__", d3_map_zero = "\x00";
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
        },
        entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
                key: d3_map_unescape(key),
                value: this._[key]
            });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._) keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._) ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._) return false;
        return true;
    }
    d3.nest = function() {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [ object ]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function(keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length) return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function(array) {
        var set = new d3_Set();
        if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
        }
    }
    var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
    function d3_noop() {}
    d3.dispatch = function() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null) for (type in this) {
                if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
                on: listener
            }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent) e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
    } : function(object, prototype) {
        for (var property in prototype) object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }, d3_selectMatches = function(n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function(n, s) {
            return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0) {
                prefix = name.slice(0, i);
                name = name.slice(i + 1);
            }
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n) if (!value.contains(name[i])) return false;
                } else {
                    value = node.getAttribute("class");
                    while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                }
                return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name]; else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function() {
            this.textContent = "";
        } : function() {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
            this.innerHTML = "";
        } : function() {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }
    d3_selectionPrototype.data = function(value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                        exitNodes[i] = node;
                    } else {
                        nodeByKeyValue.set(keyValue, node);
                    }
                    keyValues[i] = keyValue;
                }
                for (i = -1; ++i < m; ) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0; ) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (;i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (;i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function() {
            return enter;
        };
        update.exit = function() {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function() {
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i]) callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function() {
        return !this.node();
    };
    d3_selectionPrototype.node = function() {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node) return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
        };
    }
    d3.select = function(node) {
        var group;
        if (typeof node === "string") {
            group = [ d3_select(node, d3_document) ];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [ node ];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([ group ]);
    };
    d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = nodes;
            group.parentNode = null;
        }
        return d3_selection([ group ]);
    };
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2) listener = false;
                for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function() {
                    w.on(click, null);
                };
                w.on(click, function() {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
            point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [ point.x, point.y ];
        }
        var rect = container.getBoundingClientRect();
        return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
    }
    d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return d3_mousePoint(container, touch);
            }
        }
    };
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function() {
                var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
                } else {
                    dragOffset = [ 0, 0 ];
                }
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1) return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId)) return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged && d3.event.target === target);
                    dispatch({
                        type: "dragend"
                    });
                }
            };
        }
        drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function(container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
    d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
        var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
            var s = t * S;
            if (dr) {
                var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
            }
            return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
    };
    d3.behavior.zoom = function() {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
                return -d3.event.detail;
            }, "MozMousePixelScroll");
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
            g.each(function() {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.zoom", function() {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween("zoom:zoom", function() {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
                        return function(t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each("interrupt.zoom", function() {
                        zoomended(dispatch);
                    }).each("end.zoom", function() {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function(_) {
            if (!arguments.length) return [ view.x, view.y ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: +_
            };
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
        }
        function point(l) {
            return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
                return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
                return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
                type: "zoomstart"
            });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [ view.x, view.y ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming) dispatch({
                type: "zoomend"
            }), center0 = null;
        }
        function mousedowned() {
            var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged && d3.event.target === target);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function(t) {
                    if (t.identifier in locations0) locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0) break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                    l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
            translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {}
    d3_color.prototype.toString = function() {
        return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360) h -= 360; else if (h < 0) h += 360;
            if (h < 60) return m1 + (m2 - m1) * h / 60;
            if (h < 180) return m2;
            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        format = format.toLowerCase();
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format);
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl":
                {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }

              case "rgb":
                {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
            mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name]; else headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback != null) xhr.on("error", callback).on("load", function(request) {
                callback(null, request);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }
    d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
                if (o) return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function(name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N) return EOF;
                if (eol) return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34) break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10) ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10) eol = true; else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10) ++I, ++k;
                    } else if (c !== delimiterCode) continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null) continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("	", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
        setTimeout(callback, 17);
    };
    d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay, timer = {
            c: callback,
            t: time,
            f: false,
            n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time) time = t1.t;
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
            if (value < 0) value *= -1;
            if (precision) value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            } : function(d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
            var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width) g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width) break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function(specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
            if (precision) precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
            }
            switch (type) {
              case "n":
                comma = true;
                type = "g";
                break;

              case "%":
                scale = 100;
                suffix = "%";
                type = "f";
                break;

              case "p":
                scale = 100;
                suffix = "%";
                type = "r";
                break;

              case "b":
              case "o":
              case "x":
              case "X":
                if (symbol === "#") prefix = "0" + type.toLowerCase();

              case "c":
                exponent = false;

              case "d":
                integer = true;
                precision = 0;
                break;

              case "s":
                scale = -1;
                type = "r";
                break;
            }
            if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision) type = "g";
            if (precision != null) {
                if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
                var fullSuffix = suffix;
                if (integer && value % 1) return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf("."), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma) before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt)) times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1) times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                        if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join("");
            }
            format.parse = function(string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length) return null;
                if ("p" in d) d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function() {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m) return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0) return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function(template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function(string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function(d) {
                return locale_shortDays[d.getDay()];
            },
            A: function(d) {
                return locale_days[d.getDay()];
            },
            b: function(d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function(d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function(d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function(d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function(d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function(d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function(d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function(d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function(d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function(d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function(d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function(d) {
                return d.getDay();
            },
            W: function(d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
            },
            Z: d3_time_zone,
            "%": function() {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
        i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n) formats[i][0] = this(formats[i][0]);
        return function(date) {
            var i = 0, f = formats[i];
            while (!f[1](date)) f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function(locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [ 3 ],
        currency: [ "$", "" ],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: [ "AM", "PM" ],
        days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
        months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
        shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {}
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
        },
        reset: function() {
            this.s = this.t = 0;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function(λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
            sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(λ00, φ00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
        return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function() {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
                range[0] = λ0, range[1] = λ1;
            }
        };
        function point(λ, φ) {
            ranges.push(range = [ λ0 = λ, λ1 = λ ]);
            if (φ < φ0) φ0 = φ;
            if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1) φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0) φ0 = φi;
                } else {
                    if (φ < φ0) φ0 = φ;
                    if (φ > φ1) φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                    } else {
                        if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                    }
                } else {
                    if (λ1 >= λ0) {
                        if (λ < λ0) λ0 = λ;
                        if (λ > λ1) λ1 = λ;
                    } else {
                        if (λ > λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                        }
                    }
                }
            } else {
                point(λ, φ);
            }
            p0 = p, λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = λ0, range[1] = λ1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else λ__ = λ, φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
            range[0] = λ0, range[1] = λ1;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            φ1 = λ1 = -(λ0 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dλ;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
                }
            }
            ranges = range = null;
            return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
        };
    }();
    d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < ε2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < ε2) return [ NaN, NaN ];
        }
        return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ00 = λ, φ00 = φ;
            d3_geo_centroid.point = nextPoint;
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
            nextPoint(λ00, φ00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v) if ((current = current.n) === start) return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(λ, φ) {
                var point = rotate(λ, φ);
                if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                var point = rotate(λ, φ);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(λ, φ) {
                ring.push([ λ, φ ]);
                var point = rotate(λ, φ);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n) return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n) listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(λ, φ) {
                line.push([ λ, φ ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                if (abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                    if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function() {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * halfπ;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
            var s = from[0] < to[0] ? π : -π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m) continue;
            var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
            while (true) {
                if (j === m) j = 0;
                point = ring[j];
                var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                    }
                }
                if (!j++) break;
                λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
            }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(λ, φ) {
                    var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v)) listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two) return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
            var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [ q, d3_geo_spherical(q1) ];
            }
        }
        function code(λ, φ) {
            var r = smallRadius ? radius : π - radius, code = 0;
            if (λ < -r) code |= 1; else if (λ > r) code |= 2;
            if (φ < -r) code |= 4; else if (φ > r) code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dx > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dx > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dy > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dy > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
                x: ax + t0 * dx,
                y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
                x: ax + t1 * dx,
                y: ay + t1 * dy
            };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function() {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
                if (stream) stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function(_) {
                if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream) stream.valid = false, stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function() {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y)) listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_) listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon) ring.push([ x, y ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_) listener.point(x, y); else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v) listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
        p.parallels = function(_) {
            if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = ρ0 - y;
            return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
        var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
        var point, pointStream = {
            point: function(x, y) {
                point = [ x, y ];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(λ, φ) {
                linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function(_) {
            if (!arguments.length) return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
        };
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
        };
        path.projection = function(_) {
            if (!arguments.length) return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
            return project([ x * d3_degrees, y * d3_degrees ]);
        });
        return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function(methods) {
        return {
            stream: function(stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods) transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [ x[0] * k + δx, δy - x[1] * k ];
        }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [ point[0] * k + δx, δy - point[1] * k ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
        }
        projection.stream = function(output) {
            if (stream) stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function(_) {
            if (!arguments.length) return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function(_) {
            if (!arguments.length) return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function(_) {
            if (!arguments.length) return k;
            k = +_;
            return reset();
        };
        projection.translate = function(_) {
            if (!arguments.length) return [ x, y ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function(_) {
            if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function(_) {
            if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x - center[0] * k;
            δy = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream) stream.valid = false, stream = null;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(λ, φ) {
        return [ λ, φ ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(λ, φ) {
        return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
            return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
        };
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
            return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
        }
        rotation.invert = function(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
            return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
        };
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [ 0, 0 ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ ring ]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return circle;
        };
        circle.angle = function(x) {
            if (!arguments.length) return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function(_) {
            if (!arguments.length) return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to) from += direction * τ;
            } else {
                from = radius + direction * τ;
                to = radius - .5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > ε;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > ε;
            }).map(y));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
            };
        };
        graticule.extent = function(_) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
            if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
            if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function(_) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
            if (!arguments.length) return [ DX, DY ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function(_) {
            if (!arguments.length) return [ dx, dy ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [ x, y ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [ x, y ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
            if (!arguments.length) return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function(_) {
            if (!arguments.length) return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
        } : function() {
            return [ x0 * d3_degrees, y0 * d3_degrees ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function(λ, φ) {
            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
            return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
        }
        azimuthal.invert = function(x, y) {
            var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
            return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), t = function(φ) {
            return Math.tan(π / 4 + φ / 2);
        }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
            if (F > 0) {
                if (φ < -halfπ + ε) φ = -halfπ + ε;
            } else {
                if (φ > halfπ - ε) φ = halfπ - ε;
            }
            var ρ = F / Math.pow(t(φ), n);
            return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
        if (abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = G - y;
            return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale(), t = translate();
                    clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function(ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
    };
    (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function(_) {
            return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
        };
        projection.rotate = function(_) {
            return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
            [ _[0], _[1], _[2] - 90 ]);
        };
        return rotate([ 0, 0, 90 ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [ 0, 1 ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
    };
    d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [ x * k, y * k ];
    };
    d3_geom_polygonPrototype.clip = function(subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x: x,
            y: y
        }, previous = beach.P, next = beach.N, disappearing = [ beach ];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > ε) node = node.L; else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ε) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -ε) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -ε) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                        x: x0,
                        y: abs(x2 - x0) < ε ? y2 : y1
                    } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                        x: abs(y2 - y1) < ε ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                        x: x1,
                        y: abs(x2 - x1) < ε ? y2 : y0
                    } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                        x: abs(y2 - y0) < ε ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2) return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L) node = node.L; else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R) node = node.R; else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
                if (!va) va = {
                    x: fx,
                    y: y0
                }; else if (va.y >= y1) return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va) va = {
                    x: fx,
                    y: y1
                }; else if (va.y < y0) return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va) va = {
                        x: (y0 - fb) / fm,
                        y: y0
                    }; else if (va.y >= y1) return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va) va = {
                        x: (y1 - fb) / fm,
                        y: y1
                    }; else if (va.y < y0) return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va) va = {
                        x: x0,
                        y: fm * x0 + fb
                    }; else if (va.x >= x1) return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va) va = {
                        x: x1,
                        y: fm * x1 + fb
                    }; else if (va.x < x0) return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N) after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L) after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node) parent.L = next; else parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._) break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                    var s = e.start();
                    return [ s.x, s.y ];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function(d, i) {
                return {
                    x: Math.round(fx(d, i) / ε) * ε,
                    y: Math.round(fy(d, i) / ε) * ε,
                    i: i
                };
            });
        }
        voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                return edge.l && edge.r;
            }).map(function(edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([ data[i], data[s0.i], data[s1.i] ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) x1_ = d.x;
                    if (d.y < y1_) y1_ = d.y;
                    if (d.x > x2_) x2_ = d.x;
                    if (d.y > y2_) y2_ = d.y;
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) x1_ = x_;
                    if (y_ < y1_) y1_ = y_;
                    if (x_ > x2_) x2_ = x_;
                    if (y_ > y2_) y2_ = y_;
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) x1 = xm; else x2 = xm;
                if (below) y1 = ym; else y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
            y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) switch (i & 3) {
                  case 0:
                    find(node, x1, y1, xm, ym);
                    break;

                  case 1:
                    find(node, xm, y1, x2, ym);
                    break;

                  case 2:
                    find(node, x1, ym, xm, y2);
                    break;

                  case 3:
                    find(node, xm, ym, x2, y2);
                    break;
                }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) s[i] += bs; else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) s[i] += bm; else s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs; else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
        return f;
    }
    d3.interpolators = [ function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    } ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (;i < na; ++i) c[i] = a[i];
        for (;i < nb; ++i) c[i] = b[i];
        return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] != 1 || kb[1] != 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function() {
        return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function(a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function(d, i) {
                    d.sort(function(a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (τ - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: (x - x0) / k
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords) resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
        };
        chord.chords = function() {
            if (!chords) relayout();
            return chords;
        };
        chord.groups = function() {
            if (!groups) relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function() {
        var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) while (++i < n) {
                    o = nodes[i];
                    o.x += (x - o.x) * k;
                    o.y += (y - o.y) * k;
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
        };
        force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) alpha = x; else alpha = 0;
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                d3.timer(force.tick);
            }
            return force;
        };
        force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") o.source = nodes[o.source];
                if (typeof o.target == "number") o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) o.x = position("x", w);
                if (isNaN(o.y)) o.y = position("y", h);
                if (isNaN(o.px)) o.px = o.x;
                if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [ root ], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value) node.value = 0;
                    node.children = childs;
                } else {
                    if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) childs.sort(sort);
                if (value && (parent = node.parent)) parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent) parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [ node ];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0) nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [ node ], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n) nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                return values[j] - values[i];
            } : function(i, j) {
                return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
        };
        pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [ x.call(stack, v, i), y.call(stack, v, i) ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length) return values;
            values = x;
            return stack;
        };
        stack.order = function(x) {
            if (!arguments.length) return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function(x) {
            if (!arguments.length) return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
        };
        stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
        };
        stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o > max) max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (;i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [ d3.min(values), d3.max(values) ];
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
        };
        pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        };
        pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                    if (node.depth > bottom.depth) bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [ root0 ]
            }, queue = [ root1 ], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) continue;
                if (r < rmin) rmin = r;
                if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies) hierarchy.revalue(root);
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
            padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(µ, σ) {
            var n = arguments.length;
            if (n < 2) σ = 1;
            if (n < 1) µ = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            };
        },
        bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
                return random() / m;
            };
        },
        irwinHall: function(m) {
            return function() {
                for (var s = 0, j = 0; j < m; j++) s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function(x) {
                return Math.floor(x / step) * step;
            },
            ceil: function(x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function(d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        } else {
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {}
                for (j = ticks.length; ticks[j - 1] > v; j--) {}
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function(n, format) {
            if (!arguments.length) return d3_scale_logFormat;
            if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
            var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
            Math.floor), e;
            return function(d) {
                return d / pow(f(log(d) + e)) <= k ? format(d) : "";
            };
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
        floor: function(x) {
            return -Math.ceil(-x);
        },
        ceil: function(x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [ [] ]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
            0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
            0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
    var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
    var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
    var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function() {
            return thresholds;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
        };
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) return [ x0, x1 ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [ y, y + 1 / kx ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([ .5 ], [ 0, 1 ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
        };
        scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [ domain[y - 1], domain[y] ];
        };
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([ 0, 1 ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) p1 *= -1;
                if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (x1 != null) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    } else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    } else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                } else {
                    path.push("L", x2, ",", y2);
                }
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                path.push("L", x2, ",", y2);
                if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
        points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfπ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function() {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
            return [ r * Math.cos(a), r * Math.sin(a) ];
        };
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
        };
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function() {
            var lock, active;
            if ((lock = this[ns]) && (active = lock[lock.active])) {
                if (--lock.count) delete lock[lock.active]; else delete this[ns];
                lock.active += .5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; ) {
                        if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
        } : function(node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function(t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null) b = "";
        return function() {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function(node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function(node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
        }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
            d3.timer(function(elapsed) {
                var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed) return start(elapsed - delay);
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id) return stop();
                    var active = lock[lock.active];
                    if (active) {
                        --lock.count;
                        delete lock[lock.active];
                        active.event && active.event.interrupt.call(node, node.__data__, active.index);
                    }
                    lock.active = id;
                    transition.event && transition.event.start.call(node, node.__data__, i);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node, node.__data__, i)) {
                            tweened.push(value);
                        }
                    });
                    ease = transition.ease;
                    duration = transition.duration;
                    d3.timer(function() {
                        timer.c = tick(elapsed || 1) ? d3_true : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id) return 1;
                    var t = elapsed / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node, node.__data__, i);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count) delete lock[id]; else delete node[ns];
                    return 1;
                }
            }, 0, time);
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function() {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
                d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                if (orient === "bottom" || orient === "top") {
                    tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                    text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                    pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                    text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                    pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function(d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
        };
        axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = arguments;
            return axis;
        };
        axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function() {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function() {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([ 0 ]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function(g) {
            g.each(function() {
                var event_ = event.of(this, arguments), extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.brush", function() {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({
                            type: "brushstart"
                        });
                    }).tween("brush:brush", function() {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function(t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                        };
                    }).each("end.brush", function() {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    });
                } else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        };
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
                w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
                w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i) yExtentDomain = null; else xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
            return brush;
        };
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y) x0 = x0[0], x1 = x1[0];
                xExtentDomain = [ x0, x1 ];
                if (x.invert) x0 = x(x0), x1 = x(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x) y0 = y0[1], y1 = y1[1];
                yExtentDomain = [ y0, y1 ];
                if (y.invert) y0 = y(y0), y1 = y(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
            }
            return brush;
        };
        brush.clear = function() {
            if (!brush.empty()) {
                xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                return d / 31536e6;
            }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method) interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function(date) {
                    while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function(date) {
                    while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function(interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
                range: interval
            }, skip ];
            if (method) interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
            return format;
        };
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
    var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
        return d.getMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getMinutes();
    } ], [ "%I %p", function(d) {
        return d.getHours();
    } ], [ "%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getDate() != 1;
    } ], [ "%B", function(d) {
        return d.getMonth();
    } ], [ "%Y", d3_true ] ]);
    var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [ m[0].utc, m[1] ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
        return d.getUTCMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getUTCSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getUTCMinutes();
    } ], [ "%I %p", function(d) {
        return d.getUTCHours();
    } ], [ "%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getUTCDate() != 1;
    } ], [ "%B", function(d) {
        return d.getUTCMonth();
    } ], [ "%Y", d3_true ] ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function(request) {
        return request.responseText;
    });
    d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
    this.d3 = d3;
}();

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var Graph = function() {
            function Graph(graph) {
                var _this = this;
                this.graph = graph;
                var w = $(window);
                var scrollbar = this.getScrollbarWidth();
                this.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;
                var width = w.width() - scrollbar;
                var height = w.height() - scrollbar;
                width *= this.devicePixelRatio;
                height *= this.devicePixelRatio;
                this.min = Math.min(width, height);
                this.max = Math.max(width, height);
                this.game = new Phaser.Game(width, width, Phaser.AUTO, $("body")[0], {
                    preload: this.preload.bind(this),
                    create: this.create.bind(this),
                    update: this.update.bind(this),
                    render: this.render.bind(this)
                }, false, false);
                this.game.forceSingleUpdate = true;
                this.nodes = {};
                this.graph.nodes.forEach(function(node) {
                    node.connections = [];
                    _this.nodes[node.id] = node;
                });
                this.graph.edges.forEach(function(edge) {
                    edge.sourceNode = _this.nodes[edge.source];
                    edge.targetNode = _this.nodes[edge.target];
                    edge.sourceNode.connections.push({
                        target: edge.targetNode,
                        distance: edge.value
                    });
                    edge.targetNode.connections.push({
                        target: edge.sourceNode,
                        distance: edge.value
                    });
                });
                this.d3 = {
                    force: d3.layout.force(),
                    nodes: [],
                    links: [],
                    size: 1500
                };
                this.graph.nodes.forEach(function(node) {
                    node.node = {};
                    _this.d3.nodes.push(node.node);
                });
                this.graph.edges.forEach(function(edge) {
                    _this.d3.links.push({
                        source: edge.sourceNode.node,
                        target: edge.targetNode.node
                    });
                });
                this.colors = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
                this.bmps = {};
                this.groupColors = {};
                this.groups = {};
                this.stroke = 1;
                this.keywordThreshold = 2;
            }
            Graph.prototype.preload = function() {};
            Graph.prototype.create = function() {
                var _this = this;
                this.game.time.advancedTiming = true;
                this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                this.game.stage.backgroundColor = "#FFFFFF";
                this.scale = Math.min(this.game.world.width, this.game.world.height) / 100;
                this.radius = .2;
                this.radius *= this.scale * this.devicePixelRatio;
                this.diameter = this.radius * 2;
                this.d3.force.nodes(this.d3.nodes).links(this.d3.links).size([ this.d3.size, this.d3.size ]).linkStrength(.1).linkDistance(50).charge(-40);
                this.colors.forEach(function(color) {
                    var bmp = _this.game.add.bitmapData(_this.diameter, _this.diameter);
                    bmp.ctx.fillStyle = color;
                    bmp.ctx.beginPath();
                    bmp.ctx.arc(_this.radius, _this.radius, _this.radius - _this.stroke, 0, Math.PI * 2);
                    bmp.ctx.closePath();
                    bmp.ctx.fill();
                    bmp.ctx.lineWidth = _this.stroke;
                    bmp.ctx.strokeStyle = "#7e7e7e";
                    bmp.ctx.stroke();
                    _this.bmps[color] = bmp;
                });
                this.graphics = this.game.add.graphics(0, 0);
                this.graph.nodes.forEach(function(node) {
                    var transversed = {};
                    var color = _this.groupColors[node.group];
                    if (!color) {
                        color = _this.colors[Math.floor(Math.random() * _this.colors.length)];
                        _this.groupColors[node.group] = color;
                        node.color = color;
                    }
                    node.sprite = _this.game.add.sprite(_this.getNodeX(node.node), _this.getNodeY(node.node), _this.bmps[color]);
                    node.sprite.anchor.setTo(.5);
                    if (node.connections.length == 0) {
                        node.sprite.kill();
                    }
                    var group = _this.groups[node.group];
                    if (!group) {
                        group = {
                            group: node.group,
                            nodes: [],
                            keywords: {},
                            color: node.color
                        };
                        _this.groups[group.group] = group;
                    }
                    group.nodes.push(node);
                });
                var textKeywords = [];
                for (var i in this.groups) {
                    var group = this.groups[i];
                    group.nodes.forEach(function(node) {
                        node.keywords.forEach(function(word) {
                            var keyword = group.keywords[word];
                            if (!keyword) {
                                keyword = {
                                    color: group.color,
                                    keyword: word,
                                    nodes: []
                                };
                                group.keywords[keyword.keyword] = keyword;
                            }
                            keyword.nodes.push(node);
                        });
                    });
                    for (var j in group.keywords) {
                        var keyword = group.keywords[j];
                        if (keyword.nodes.length < this.keywordThreshold) {
                            continue;
                        }
                        textKeywords.push(keyword);
                    }
                }
                textKeywords.sort(function(a, b) {
                    return a.nodes.length - b.nodes.length;
                });
                textKeywords.forEach(function(keyword) {
                    var center = _this.calculateCenter(keyword.nodes);
                    keyword.text = _this.game.add.text(center.x, center.y, keyword.keyword, {
                        font: (keyword.nodes.length * 1 + 20) * _this.devicePixelRatio + "px Calibri",
                        fill: keyword.color,
                        align: "center"
                    });
                    keyword.text.fontWeight = "lighter";
                    keyword.text.stroke = "#545454";
                    keyword.text.strokeThickness = 2;
                    keyword.text.anchor.setTo(Math.random(), Math.random());
                });
            };
            Graph.prototype.getScrollbarWidth = function() {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar";
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                outer.style.overflow = "scroll";
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            };
            Graph.prototype.calculateCenter = function(nodes) {
                var x = 0;
                var y = 0;
                nodes.forEach(function(node) {
                    x += node.sprite.x;
                    y += node.sprite.y;
                });
                x /= nodes.length;
                y /= nodes.length;
                return new Phaser.Point(x, y);
            };
            Graph.prototype.transverse = function(node, transversed) {
                var _this = this;
                if (transversed[node.id]) {
                    return node.color;
                } else {
                    if (node.color) {
                        return node.color;
                    }
                    transversed[node.id] = node;
                    node.connections.forEach(function(connection) {
                        var color = _this.transverse(connection.target, transversed);
                        if (color) {
                            return color;
                        }
                    });
                    return null;
                }
            };
            Graph.prototype.getNodeX = function(node) {
                return (node.x - this.d3.size / 2) / this.d3.size * this.max + this.game.width / 2;
            };
            Graph.prototype.getNodeY = function(node) {
                return (node.y - this.d3.size / 2) / this.d3.size * this.max + this.game.height / 2;
            };
            Graph.prototype.update = function() {
                var _this = this;
                this.d3.force.start();
                this.d3.force.tick();
                this.d3.force.stop();
                this.graph.nodes.forEach(function(node) {
                    node.sprite.x = _this.getNodeX(node.node);
                    node.sprite.y = _this.getNodeY(node.node);
                });
                this.graphics.clear();
                this.graph.edges.forEach(function(edge) {
                    _this.graphics.lineStyle(1, 0, .2);
                    var source = edge.sourceNode.sprite;
                    var target = edge.targetNode.sprite;
                    _this.graphics.moveTo(source.x, source.y);
                    _this.graphics.lineTo(target.x, target.y);
                });
                for (var i in this.groups) {
                    var group = this.groups[i];
                    for (var j in group.keywords) {
                        var keyword = group.keywords[j];
                        if (keyword.text) {
                            var center = this.calculateCenter(keyword.nodes);
                            keyword.text.x = center.x;
                            keyword.text.y = center.y;
                        }
                    }
                }
            };
            Graph.prototype.render = function() {};
            return Graph;
        }();
        module.exports = Graph;
    }, {} ],
    2: [ function(require, module, exports) {
        var Graph = require("./graph");
        $(document).ready(function() {
            var today = new Date();
            var month = (today.getMonth() + 1).toString();
            if (month.length < 2) {
                month = "0" + month;
            }
            var date = today.getFullYear() + "-" + month + "-" + today.getDate();
            document.title = document.title + " " + date;
            $.getJSON("/api/topics/filter?day=" + date, function(data, textStatus, jqXHR) {
                var graph = window["graph"] = new Graph(data[0].graph);
            });
        });
    }, {
        "./graph": 1
    } ]
}, {}, [ 2 ]);