!function(a) {
    if ("object" == typeof exports) module.exports = a(); else {
        var b;
        "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), 
        b.p2 = a();
    }
}(function() {
    return function a(b, c, d) {
        function e(g, h) {
            if (!c[g]) {
                if (!b[g]) {
                    var i = "function" == typeof require && require;
                    if (!h && i) return i(g, !0);
                    if (f) return f(g, !0);
                    throw new Error("Cannot find module '" + g + "'");
                }
                var j = c[g] = {
                    exports: {}
                };
                b[g][0].call(j.exports, function(a) {
                    var c = b[g][1][a];
                    return e(c ? c : a);
                }, j, j.exports, a, b, c, d);
            }
            return c[g].exports;
        }
        for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
        return e;
    }({
        1: [ function(a, b) {
            function c() {}
            var d = a("./Scalar");
            b.exports = c, c.lineInt = function(a, b, c) {
                c = c || 0;
                var e, f, g, h, i, j, k, l = [ 0, 0 ];
                return e = a[1][1] - a[0][1], f = a[0][0] - a[1][0], g = e * a[0][0] + f * a[0][1], 
                h = b[1][1] - b[0][1], i = b[0][0] - b[1][0], j = h * b[0][0] + i * b[0][1], k = e * i - h * f, 
                d.eq(k, 0, c) || (l[0] = (i * g - f * j) / k, l[1] = (e * j - h * g) / k), l;
            }, c.segmentsIntersect = function(a, b, c, d) {
                var e = b[0] - a[0], f = b[1] - a[1], g = d[0] - c[0], h = d[1] - c[1];
                if (g * f - h * e == 0) return !1;
                var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e), j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
                return i >= 0 && 1 >= i && j >= 0 && 1 >= j;
            };
        }, {
            "./Scalar": 4
        } ],
        2: [ function(a, b) {
            function c() {}
            b.exports = c, c.area = function(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            }, c.left = function(a, b, d) {
                return c.area(a, b, d) > 0;
            }, c.leftOn = function(a, b, d) {
                return c.area(a, b, d) >= 0;
            }, c.right = function(a, b, d) {
                return c.area(a, b, d) < 0;
            }, c.rightOn = function(a, b, d) {
                return c.area(a, b, d) <= 0;
            };
            var d = [], e = [];
            c.collinear = function(a, b, f, g) {
                if (g) {
                    var h = d, i = e;
                    h[0] = b[0] - a[0], h[1] = b[1] - a[1], i[0] = f[0] - b[0], i[1] = f[1] - b[1];
                    var j = h[0] * i[0] + h[1] * i[1], k = Math.sqrt(h[0] * h[0] + h[1] * h[1]), l = Math.sqrt(i[0] * i[0] + i[1] * i[1]), m = Math.acos(j / (k * l));
                    return g > m;
                }
                return 0 == c.area(a, b, f);
            }, c.sqdist = function(a, b) {
                var c = b[0] - a[0], d = b[1] - a[1];
                return c * c + d * d;
            };
        }, {} ],
        3: [ function(a, b) {
            function c() {
                this.vertices = [];
            }
            function d(a, b, c, d, e) {
                e = e || 0;
                var f = b[1] - a[1], h = a[0] - b[0], i = f * a[0] + h * a[1], j = d[1] - c[1], k = c[0] - d[0], l = j * c[0] + k * c[1], m = f * k - j * h;
                return g.eq(m, 0, e) ? [ 0, 0 ] : [ (k * i - h * l) / m, (f * l - j * i) / m ];
            }
            var e = a("./Line"), f = a("./Point"), g = a("./Scalar");
            b.exports = c, c.prototype.at = function(a) {
                var b = this.vertices, c = b.length;
                return b[0 > a ? a % c + c : a % c];
            }, c.prototype.first = function() {
                return this.vertices[0];
            }, c.prototype.last = function() {
                return this.vertices[this.vertices.length - 1];
            }, c.prototype.clear = function() {
                this.vertices.length = 0;
            }, c.prototype.append = function(a, b, c) {
                if ("undefined" == typeof b) throw new Error("From is not given!");
                if ("undefined" == typeof c) throw new Error("To is not given!");
                if (b > c - 1) throw new Error("lol1");
                if (c > a.vertices.length) throw new Error("lol2");
                if (0 > b) throw new Error("lol3");
                for (var d = b; c > d; d++) this.vertices.push(a.vertices[d]);
            }, c.prototype.makeCCW = function() {
                for (var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c) (b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) && (a = c);
                f.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse();
            }, c.prototype.reverse = function() {
                for (var a = [], b = 0, c = this.vertices.length; b !== c; b++) a.push(this.vertices.pop());
                this.vertices = a;
            }, c.prototype.isReflex = function(a) {
                return f.right(this.at(a - 1), this.at(a), this.at(a + 1));
            };
            var h = [], i = [];
            c.prototype.canSee = function(a, b) {
                var c, d, g = h, j = i;
                if (f.leftOn(this.at(a + 1), this.at(a), this.at(b)) && f.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
                d = f.sqdist(this.at(a), this.at(b));
                for (var k = 0; k !== this.vertices.length; ++k) if ((k + 1) % this.vertices.length !== a && k !== a && f.leftOn(this.at(a), this.at(b), this.at(k + 1)) && f.rightOn(this.at(a), this.at(b), this.at(k)) && (g[0] = this.at(a), 
                g[1] = this.at(b), j[0] = this.at(k), j[1] = this.at(k + 1), c = e.lineInt(g, j), 
                f.sqdist(this.at(a), c) < d)) return !1;
                return !0;
            }, c.prototype.copy = function(a, b, d) {
                var e = d || new c();
                if (e.clear(), b > a) for (var f = a; b >= f; f++) e.vertices.push(this.vertices[f]); else {
                    for (var f = 0; b >= f; f++) e.vertices.push(this.vertices[f]);
                    for (var f = a; f < this.vertices.length; f++) e.vertices.push(this.vertices[f]);
                }
                return e;
            }, c.prototype.getCutEdges = function() {
                for (var a = [], b = [], d = [], e = new c(), f = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g) if (this.isReflex(g)) for (var h = 0; h < this.vertices.length; ++h) if (this.canSee(g, h)) {
                    b = this.copy(g, h, e).getCutEdges(), d = this.copy(h, g, e).getCutEdges();
                    for (var i = 0; i < d.length; i++) b.push(d[i]);
                    b.length < f && (a = b, f = b.length, a.push([ this.at(g), this.at(h) ]));
                }
                return a;
            }, c.prototype.decomp = function() {
                var a = this.getCutEdges();
                return a.length > 0 ? this.slice(a) : [ this ];
            }, c.prototype.slice = function(a) {
                if (0 == a.length) return [ this ];
                if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                    for (var b = [ this ], c = 0; c < a.length; c++) for (var d = a[c], e = 0; e < b.length; e++) {
                        var f = b[e], g = f.slice(d);
                        if (g) {
                            b.splice(e, 1), b.push(g[0], g[1]);
                            break;
                        }
                    }
                    return b;
                }
                var d = a, c = this.vertices.indexOf(d[0]), e = this.vertices.indexOf(d[1]);
                return -1 != c && -1 != e ? [ this.copy(c, e), this.copy(e, c) ] : !1;
            }, c.prototype.isSimple = function() {
                for (var a = this.vertices, b = 0; b < a.length - 1; b++) for (var c = 0; b - 1 > c; c++) if (e.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) return !1;
                for (var b = 1; b < a.length - 2; b++) if (e.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
                return !0;
            }, c.prototype.quickDecomp = function(a, b, e, g, h, i) {
                h = h || 100, i = i || 0, g = g || 25, a = "undefined" != typeof a ? a : [], b = b || [], 
                e = e || [];
                var j = [ 0, 0 ], k = [ 0, 0 ], l = [ 0, 0 ], m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = new c(), u = new c(), v = this, w = this.vertices;
                if (w.length < 3) return a;
                if (i++, i > h) return console.warn("quickDecomp: max level (" + h + ") reached."), 
                a;
                for (var x = 0; x < this.vertices.length; ++x) if (v.isReflex(x)) {
                    b.push(v.vertices[x]), m = n = Number.MAX_VALUE;
                    for (var y = 0; y < this.vertices.length; ++y) f.left(v.at(x - 1), v.at(x), v.at(y)) && f.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) && (l = d(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1)), 
                    f.right(v.at(x + 1), v.at(x), l) && (o = f.sqdist(v.vertices[x], l), n > o && (n = o, 
                    k = l, r = y))), f.left(v.at(x + 1), v.at(x), v.at(y + 1)) && f.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (l = d(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1)), 
                    f.left(v.at(x - 1), v.at(x), l) && (o = f.sqdist(v.vertices[x], l), m > o && (m = o, 
                    j = l, q = y)));
                    if (r == (q + 1) % this.vertices.length) l[0] = (k[0] + j[0]) / 2, l[1] = (k[1] + j[1]) / 2, 
                    e.push(l), q > x ? (t.append(v, x, q + 1), t.vertices.push(l), u.vertices.push(l), 
                    0 != r && u.append(v, r, v.vertices.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, v.vertices.length), 
                    t.append(v, 0, q + 1), t.vertices.push(l), u.vertices.push(l), u.append(v, r, x + 1)); else {
                        if (r > q && (q += this.vertices.length), p = Number.MAX_VALUE, r > q) return a;
                        for (var y = r; q >= y; ++y) f.leftOn(v.at(x - 1), v.at(x), v.at(y)) && f.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = f.sqdist(v.at(x), v.at(y)), 
                        p > o && (p = o, s = y % this.vertices.length));
                        s > x ? (t.append(v, x, s + 1), 0 != s && u.append(v, s, w.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length), 
                        t.append(v, 0, s + 1), u.append(v, s, x + 1));
                    }
                    return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, e, g, h, i), 
                    u.quickDecomp(a, b, e, g, h, i)) : (u.quickDecomp(a, b, e, g, h, i), t.quickDecomp(a, b, e, g, h, i)), 
                    a;
                }
                return a.push(this), a;
            }, c.prototype.removeCollinearPoints = function(a) {
                for (var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c) f.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1), 
                c--, b++);
                return b;
            };
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        } ],
        4: [ function(a, b) {
            function c() {}
            b.exports = c, c.eq = function(a, b, c) {
                return c = c || 0, Math.abs(a - b) < c;
            };
        }, {} ],
        5: [ function(a, b) {
            b.exports = {
                Polygon: a("./Polygon"),
                Point: a("./Point")
            };
        }, {
            "./Point": 2,
            "./Polygon": 3
        } ],
        6: [ function(a, b) {
            b.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: [ "p2.js", "p2", "physics", "engine", "2d" ],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [ {
                    type: "MIT"
                } ],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            };
        }, {} ],
        7: [ function(a, b) {
            function c(a) {
                this.lowerBound = d.create(), a && a.lowerBound && d.copy(this.lowerBound, a.lowerBound), 
                this.upperBound = d.create(), a && a.upperBound && d.copy(this.upperBound, a.upperBound);
            }
            {
                var d = a("../math/vec2");
                a("../utils/Utils");
            }
            b.exports = c;
            var e = d.create();
            c.prototype.setFromPoints = function(a, b, c, f) {
                var g = this.lowerBound, h = this.upperBound;
                "number" != typeof c && (c = 0), 0 !== c ? d.rotate(g, a[0], c) : d.copy(g, a[0]), 
                d.copy(h, g);
                for (var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++) {
                    var l = a[k];
                    if (0 !== c) {
                        var m = l[0], n = l[1];
                        e[0] = i * m - j * n, e[1] = j * m + i * n, l = e;
                    }
                    for (var o = 0; 2 > o; o++) l[o] > h[o] && (h[o] = l[o]), l[o] < g[o] && (g[o] = l[o]);
                }
                b && (d.add(this.lowerBound, this.lowerBound, b), d.add(this.upperBound, this.upperBound, b)), 
                f && (this.lowerBound[0] -= f, this.lowerBound[1] -= f, this.upperBound[0] += f, 
                this.upperBound[1] += f);
            }, c.prototype.copy = function(a) {
                d.copy(this.lowerBound, a.lowerBound), d.copy(this.upperBound, a.upperBound);
            }, c.prototype.extend = function(a) {
                for (var b = 2; b--; ) {
                    var c = a.lowerBound[b];
                    this.lowerBound[b] > c && (this.lowerBound[b] = c);
                    var d = a.upperBound[b];
                    this.upperBound[b] < d && (this.upperBound[b] = d);
                }
            }, c.prototype.overlaps = function(a) {
                var b = this.lowerBound, c = this.upperBound, d = a.lowerBound, e = a.upperBound;
                return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1]);
            }, c.prototype.containsPoint = function(a) {
                var b = this.lowerBound, c = this.upperBound;
                return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1];
            }, c.prototype.overlapsRay = function(a) {
                var b = 1 / a.direction[0], c = 1 / a.direction[1], d = (this.lowerBound[0] - a.from[0]) * b, e = (this.upperBound[0] - a.from[0]) * b, f = (this.lowerBound[1] - a.from[1]) * c, g = (this.upperBound[1] - a.from[1]) * c, h = Math.max(Math.max(Math.min(d, e), Math.min(f, g))), i = Math.min(Math.min(Math.max(d, e), Math.max(f, g)));
                return 0 > i ? -1 : h > i ? -1 : h;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        } ],
        8: [ function(a, b) {
            function c(a) {
                this.type = a, this.result = [], this.world = null, this.boundingVolumeType = c.AABB;
            }
            var d = a("../math/vec2"), e = a("../objects/Body");
            b.exports = c, c.AABB = 1, c.BOUNDING_CIRCLE = 2, c.prototype.setWorld = function(a) {
                this.world = a;
            }, c.prototype.getCollisionPairs = function() {};
            var f = d.create();
            c.boundingRadiusCheck = function(a, b) {
                d.sub(f, a.position, b.position);
                var c = d.squaredLength(f), e = a.boundingRadius + b.boundingRadius;
                return e * e >= c;
            }, c.aabbCheck = function(a, b) {
                return a.getAABB().overlaps(b.getAABB());
            }, c.prototype.boundingVolumeCheck = function(a, b) {
                var d;
                switch (this.boundingVolumeType) {
                  case c.BOUNDING_CIRCLE:
                    d = c.boundingRadiusCheck(a, b);
                    break;

                  case c.AABB:
                    d = c.aabbCheck(a, b);
                    break;

                  default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                }
                return d;
            }, c.canCollide = function(a, b) {
                var c = e.KINEMATIC, d = e.STATIC;
                return a.type === d && b.type === d ? !1 : a.type === c && b.type === d || a.type === d && b.type === c ? !1 : a.type === c && b.type === c ? !1 : a.sleepState === e.SLEEPING && b.sleepState === e.SLEEPING ? !1 : a.sleepState === e.SLEEPING && b.type === d || b.sleepState === e.SLEEPING && a.type === d ? !1 : !0;
            }, c.NAIVE = 1, c.SAP = 2;
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        } ],
        9: [ function(a, b) {
            function c() {
                d.call(this, d.NAIVE);
            }
            {
                var d = (a("../shapes/Circle"), a("../shapes/Plane"), a("../shapes/Shape"), a("../shapes/Particle"), 
                a("../collision/Broadphase"));
                a("../math/vec2");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.getCollisionPairs = function(a) {
                var b = a.bodies, c = this.result;
                c.length = 0;
                for (var e = 0, f = b.length; e !== f; e++) for (var g = b[e], h = 0; e > h; h++) {
                    var i = b[h];
                    d.canCollide(g, i) && this.boundingVolumeCheck(g, i) && c.push(g, i);
                }
                return c;
            }, c.prototype.aabbQuery = function(a, b, c) {
                c = c || [];
                for (var d = a.bodies, e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.aabbNeedsUpdate && f.updateAABB(), f.aabb.overlaps(b) && c.push(f);
                }
                return c;
            };
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        } ],
        10: [ function(a, b) {
            function c() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, 
                this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, 
                this.surfaceVelocity = 0, this.contactEquationPool = new j({
                    size: 32
                }), this.frictionEquationPool = new k({
                    size: 64
                }), this.restitution = 0, this.stiffness = m.DEFAULT_STIFFNESS, this.relaxation = m.DEFAULT_RELAXATION, 
                this.frictionStiffness = m.DEFAULT_STIFFNESS, this.frictionRelaxation = m.DEFAULT_RELAXATION, 
                this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new l(), this.contactSkinSize = .01;
            }
            function d(a, b) {
                f.set(a.vertices[0], .5 * -b.length, -b.radius), f.set(a.vertices[1], .5 * b.length, -b.radius), 
                f.set(a.vertices[2], .5 * b.length, b.radius), f.set(a.vertices[3], .5 * -b.length, b.radius);
            }
            function e(a, b, c, d) {
                for (var e = S, i = T, j = U, k = V, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++) {
                    var p = m[o % m.length], q = m[(o + 1) % m.length];
                    f.rotate(e, p, d), f.rotate(i, q, d), h(e, e, c), h(i, i, c), g(j, e, l), g(k, i, l);
                    var r = f.crossLength(j, k);
                    if (null === n && (n = r), 0 >= r * n) return !1;
                    n = r;
                }
                return !0;
            }
            var f = a("../math/vec2"), g = f.sub, h = f.add, i = f.dot, j = (a("../utils/Utils"), 
            a("../utils/ContactEquationPool")), k = a("../utils/FrictionEquationPool"), l = a("../utils/TupleDictionary"), m = a("../equations/Equation"), n = (a("../equations/ContactEquation"), 
            a("../equations/FrictionEquation"), a("../shapes/Circle")), o = a("../shapes/Convex"), p = a("../shapes/Shape"), q = (a("../objects/Body"), 
            a("../shapes/Box"));
            b.exports = c;
            var r = f.fromValues(0, 1), s = f.fromValues(0, 0), t = f.fromValues(0, 0), u = f.fromValues(0, 0), v = f.fromValues(0, 0), w = f.fromValues(0, 0), x = f.fromValues(0, 0), y = f.fromValues(0, 0), z = f.fromValues(0, 0), A = f.fromValues(0, 0), B = f.fromValues(0, 0), C = f.fromValues(0, 0), D = f.fromValues(0, 0), E = f.fromValues(0, 0), F = f.fromValues(0, 0), G = f.fromValues(0, 0), H = f.fromValues(0, 0), I = f.fromValues(0, 0), J = f.fromValues(0, 0), K = [], L = f.create(), M = f.create();
            c.prototype.bodiesOverlap = function(a, b) {
                for (var c = L, d = M, e = 0, f = a.shapes.length; e !== f; e++) {
                    var g = a.shapes[e];
                    a.toWorldFrame(c, g.position);
                    for (var h = 0, i = b.shapes.length; h !== i; h++) {
                        var j = b.shapes[h];
                        if (b.toWorldFrame(d, j.position), this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0)) return !0;
                    }
                }
                return !1;
            }, c.prototype.collidedLastStep = function(a, b) {
                var c = 0 | a.id, d = 0 | b.id;
                return !!this.collidingBodiesLastStep.get(c, d);
            }, c.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var a = this.contactEquations, b = a.length; b--; ) {
                    var c = a[b], d = c.bodyA.id, e = c.bodyB.id;
                    this.collidingBodiesLastStep.set(d, e, !0);
                }
                for (var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++) this.contactEquationPool.release(f[h]);
                for (var h = 0; h < g.length; h++) this.frictionEquationPool.release(g[h]);
                this.contactEquations.length = this.frictionEquations.length = 0;
            }, c.prototype.createContactEquation = function(a, b, c, d) {
                var e = this.contactEquationPool.get();
                return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.restitution = this.restitution, 
                e.firstImpact = !this.collidedLastStep(a, b), e.stiffness = this.stiffness, e.relaxation = this.relaxation, 
                e.needsUpdate = !0, e.enabled = this.enabledEquations, e.offset = this.contactSkinSize, 
                e;
            }, c.prototype.createFrictionEquation = function(a, b, c, d) {
                var e = this.frictionEquationPool.get();
                return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.setSlipForce(this.slipForce), 
                e.frictionCoefficient = this.frictionCoefficient, e.relativeVelocity = this.surfaceVelocity, 
                e.enabled = this.enabledEquations, e.needsUpdate = !0, e.stiffness = this.frictionStiffness, 
                e.relaxation = this.frictionRelaxation, e.contactEquations.length = 0, e;
            }, c.prototype.createFrictionFromContact = function(a) {
                var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
                return f.copy(b.contactPointA, a.contactPointA), f.copy(b.contactPointB, a.contactPointB), 
                f.rotate90cw(b.t, a.normalA), b.contactEquations.push(a), b;
            }, c.prototype.createFrictionFromAverage = function(a) {
                {
                    var b = this.contactEquations[this.contactEquations.length - 1], c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB), d = b.bodyA;
                    b.bodyB;
                }
                f.set(c.contactPointA, 0, 0), f.set(c.contactPointB, 0, 0), f.set(c.t, 0, 0);
                for (var e = 0; e !== a; e++) b = this.contactEquations[this.contactEquations.length - 1 - e], 
                b.bodyA === d ? (f.add(c.t, c.t, b.normalA), f.add(c.contactPointA, c.contactPointA, b.contactPointA), 
                f.add(c.contactPointB, c.contactPointB, b.contactPointB)) : (f.sub(c.t, c.t, b.normalA), 
                f.add(c.contactPointA, c.contactPointA, b.contactPointB), f.add(c.contactPointB, c.contactPointB, b.contactPointA)), 
                c.contactEquations.push(b);
                var g = 1 / a;
                return f.scale(c.contactPointA, c.contactPointA, g), f.scale(c.contactPointB, c.contactPointB, g), 
                f.normalize(c.t, c.t), f.rotate90cw(c.t, c.t), c;
            }, c.prototype[p.LINE | p.CONVEX] = c.prototype.convexLine = function(a, b, c, d, e, f, g, h, i) {
                return i ? !1 : 0;
            }, c.prototype[p.LINE | p.BOX] = c.prototype.lineBox = function(a, b, c, d, e, f, g, h, i) {
                return i ? !1 : 0;
            };
            var N = new q({
                width: 1,
                height: 1
            }), O = f.create();
            c.prototype[p.CAPSULE | p.CONVEX] = c.prototype[p.CAPSULE | p.BOX] = c.prototype.convexCapsule = function(a, b, c, e, g, h, i, j, k) {
                var l = O;
                f.set(l, h.length / 2, 0), f.rotate(l, l, j), f.add(l, l, i);
                var m = this.circleConvex(g, h, l, j, a, b, c, e, k, h.radius);
                f.set(l, -h.length / 2, 0), f.rotate(l, l, j), f.add(l, l, i);
                var n = this.circleConvex(g, h, l, j, a, b, c, e, k, h.radius);
                if (k && (m || n)) return !0;
                var o = N;
                d(o, h);
                var p = this.convexConvex(a, b, c, e, g, o, i, j, k);
                return p + m + n;
            }, c.prototype[p.CAPSULE | p.LINE] = c.prototype.lineCapsule = function(a, b, c, d, e, f, g, h, i) {
                return i ? !1 : 0;
            };
            var P = f.create(), Q = f.create(), R = new q({
                width: 1,
                height: 1
            });
            c.prototype[p.CAPSULE | p.CAPSULE] = c.prototype.capsuleCapsule = function(a, b, c, e, g, h, i, j, k) {
                for (var l, m = P, n = Q, o = 0, p = 0; 2 > p; p++) {
                    f.set(m, (0 === p ? -1 : 1) * b.length / 2, 0), f.rotate(m, m, e), f.add(m, m, c);
                    for (var q = 0; 2 > q; q++) {
                        f.set(n, (0 === q ? -1 : 1) * h.length / 2, 0), f.rotate(n, n, j), f.add(n, n, i), 
                        this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                        var r = this.circleCircle(a, b, m, e, g, h, n, j, k, b.radius, h.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = l), k && r) return !0;
                        o += r;
                    }
                }
                this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                var s = R;
                d(s, b);
                var t = this.convexCapsule(a, s, c, e, g, h, i, j, k);
                if (this.enableFrictionReduction && (this.enableFriction = l), k && t) return !0;
                if (o += t, this.enableFrictionReduction) {
                    var l = this.enableFriction;
                    this.enableFriction = !1;
                }
                d(s, h);
                var u = this.convexCapsule(g, s, i, j, a, b, c, e, k);
                return this.enableFrictionReduction && (this.enableFriction = l), k && u ? !0 : (o += u, 
                this.enableFrictionReduction && o && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(o)), 
                o);
            }, c.prototype[p.LINE | p.LINE] = c.prototype.lineLine = function(a, b, c, d, e, f, g, h, i) {
                return i ? !1 : 0;
            }, c.prototype[p.PLANE | p.LINE] = c.prototype.planeLine = function(a, b, c, d, e, j, k, l, m) {
                var n = s, o = t, p = u, q = v, B = w, C = x, D = y, E = z, F = A, G = K, H = 0;
                f.set(n, -j.length / 2, 0), f.set(o, j.length / 2, 0), f.rotate(p, n, l), f.rotate(q, o, l), 
                h(p, p, k), h(q, q, k), f.copy(n, p), f.copy(o, q), g(B, o, n), f.normalize(C, B), 
                f.rotate90cw(F, C), f.rotate(E, r, d), G[0] = n, G[1] = o;
                for (var I = 0; I < G.length; I++) {
                    var J = G[I];
                    g(D, J, c);
                    var L = i(D, E);
                    if (0 > L) {
                        if (m) return !0;
                        var M = this.createContactEquation(a, e, b, j);
                        H++, f.copy(M.normalA, E), f.normalize(M.normalA, M.normalA), f.scale(D, E, L), 
                        g(M.contactPointA, J, D), g(M.contactPointA, M.contactPointA, a.position), g(M.contactPointB, J, k), 
                        h(M.contactPointB, M.contactPointB, k), g(M.contactPointB, M.contactPointB, e.position), 
                        this.contactEquations.push(M), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M));
                    }
                }
                return m ? !1 : (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)), 
                H);
            }, c.prototype[p.PARTICLE | p.CAPSULE] = c.prototype.particleCapsule = function(a, b, c, d, e, f, g, h, i) {
                return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0);
            }, c.prototype[p.CIRCLE | p.LINE] = c.prototype.circleLine = function(a, b, c, d, e, j, k, l, m, n, o) {
                var n = n || 0, o = "undefined" != typeof o ? o : b.radius, p = s, q = t, r = u, G = v, H = w, I = x, J = y, L = z, M = A, N = B, O = C, P = D, Q = E, R = F, S = K;
                f.set(L, -j.length / 2, 0), f.set(M, j.length / 2, 0), f.rotate(N, L, l), f.rotate(O, M, l), 
                h(N, N, k), h(O, O, k), f.copy(L, N), f.copy(M, O), g(I, M, L), f.normalize(J, I), 
                f.rotate90cw(H, J), g(P, c, L);
                var T = i(P, H);
                g(G, L, k), g(Q, c, k);
                var U = o + n;
                if (Math.abs(T) < U) {
                    f.scale(p, H, T), g(r, c, p), f.scale(q, H, i(H, Q)), f.normalize(q, q), f.scale(q, q, n), 
                    h(r, r, q);
                    var V = i(J, r), W = i(J, L), X = i(J, M);
                    if (V > W && X > V) {
                        if (m) return !0;
                        var Y = this.createContactEquation(a, e, b, j);
                        return f.scale(Y.normalA, p, -1), f.normalize(Y.normalA, Y.normalA), f.scale(Y.contactPointA, Y.normalA, o), 
                        h(Y.contactPointA, Y.contactPointA, c), g(Y.contactPointA, Y.contactPointA, a.position), 
                        g(Y.contactPointB, r, k), h(Y.contactPointB, Y.contactPointB, k), g(Y.contactPointB, Y.contactPointB, e.position), 
                        this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 
                        1;
                    }
                }
                S[0] = L, S[1] = M;
                for (var Z = 0; Z < S.length; Z++) {
                    var $ = S[Z];
                    if (g(P, $, c), f.squaredLength(P) < Math.pow(U, 2)) {
                        if (m) return !0;
                        var Y = this.createContactEquation(a, e, b, j);
                        return f.copy(Y.normalA, P), f.normalize(Y.normalA, Y.normalA), f.scale(Y.contactPointA, Y.normalA, o), 
                        h(Y.contactPointA, Y.contactPointA, c), g(Y.contactPointA, Y.contactPointA, a.position), 
                        g(Y.contactPointB, $, k), f.scale(R, Y.normalA, -n), h(Y.contactPointB, Y.contactPointB, R), 
                        h(Y.contactPointB, Y.contactPointB, k), g(Y.contactPointB, Y.contactPointB, e.position), 
                        this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 
                        1;
                    }
                }
                return 0;
            }, c.prototype[p.CIRCLE | p.CAPSULE] = c.prototype.circleCapsule = function(a, b, c, d, e, f, g, h, i) {
                return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius);
            }, c.prototype[p.CIRCLE | p.CONVEX] = c.prototype[p.CIRCLE | p.BOX] = c.prototype.circleConvex = function(a, b, c, d, i, j, k, l, m, n) {
                for (var n = "number" == typeof n ? n : b.radius, o = s, p = t, q = u, r = v, x = w, y = B, z = C, A = E, D = F, I = G, J = H, K = !1, L = Number.MAX_VALUE, M = j.vertices, N = 0; N !== M.length + 1; N++) {
                    var O = M[N % M.length], P = M[(N + 1) % M.length];
                    if (f.rotate(o, O, l), f.rotate(p, P, l), h(o, o, k), h(p, p, k), g(q, p, o), f.normalize(r, q), 
                    f.rotate90cw(x, r), f.scale(D, x, -b.radius), h(D, D, c), e(D, j, k, l)) {
                        f.sub(I, o, D);
                        var Q = Math.abs(f.dot(I, x));
                        L > Q && (f.copy(J, D), L = Q, f.scale(A, x, Q), f.add(A, A, D), K = !0);
                    }
                }
                if (K) {
                    if (m) return !0;
                    var R = this.createContactEquation(a, i, b, j);
                    return f.sub(R.normalA, J, c), f.normalize(R.normalA, R.normalA), f.scale(R.contactPointA, R.normalA, n), 
                    h(R.contactPointA, R.contactPointA, c), g(R.contactPointA, R.contactPointA, a.position), 
                    g(R.contactPointB, A, k), h(R.contactPointB, R.contactPointB, k), g(R.contactPointB, R.contactPointB, i.position), 
                    this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 
                    1;
                }
                if (n > 0) for (var N = 0; N < M.length; N++) {
                    var S = M[N];
                    if (f.rotate(z, S, l), h(z, z, k), g(y, z, c), f.squaredLength(y) < Math.pow(n, 2)) {
                        if (m) return !0;
                        var R = this.createContactEquation(a, i, b, j);
                        return f.copy(R.normalA, y), f.normalize(R.normalA, R.normalA), f.scale(R.contactPointA, R.normalA, n), 
                        h(R.contactPointA, R.contactPointA, c), g(R.contactPointA, R.contactPointA, a.position), 
                        g(R.contactPointB, z, k), h(R.contactPointB, R.contactPointB, k), g(R.contactPointB, R.contactPointB, i.position), 
                        this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 
                        1;
                    }
                }
                return 0;
            };
            var S = f.create(), T = f.create(), U = f.create(), V = f.create();
            c.prototype[p.PARTICLE | p.CONVEX] = c.prototype[p.PARTICLE | p.BOX] = c.prototype.particleConvex = function(a, b, c, d, j, k, l, m, n) {
                var o = s, p = t, q = u, r = v, z = w, A = x, C = y, D = B, F = E, G = I, H = J, K = Number.MAX_VALUE, L = !1, M = k.vertices;
                if (!e(c, k, l, m)) return 0;
                if (n) return !0;
                for (var N = 0; N !== M.length + 1; N++) {
                    var O = M[N % M.length], P = M[(N + 1) % M.length];
                    f.rotate(o, O, m), f.rotate(p, P, m), h(o, o, l), h(p, p, l), g(q, p, o), f.normalize(r, q), 
                    f.rotate90cw(z, r), g(D, c, o);
                    {
                        i(D, z);
                    }
                    g(A, o, l), g(C, c, l), f.sub(G, o, c);
                    var Q = Math.abs(f.dot(G, z));
                    K > Q && (K = Q, f.scale(F, z, Q), f.add(F, F, c), f.copy(H, z), L = !0);
                }
                if (L) {
                    var R = this.createContactEquation(a, j, b, k);
                    return f.scale(R.normalA, H, -1), f.normalize(R.normalA, R.normalA), f.set(R.contactPointA, 0, 0), 
                    h(R.contactPointA, R.contactPointA, c), g(R.contactPointA, R.contactPointA, a.position), 
                    g(R.contactPointB, F, l), h(R.contactPointB, R.contactPointB, l), g(R.contactPointB, R.contactPointB, j.position), 
                    this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 
                    1;
                }
                return 0;
            }, c.prototype[p.CIRCLE] = c.prototype.circleCircle = function(a, b, c, d, e, i, j, k, l, m, n) {
                var o = s, m = m || b.radius, n = n || i.radius;
                g(o, c, j);
                var p = m + n;
                if (f.squaredLength(o) > Math.pow(p, 2)) return 0;
                if (l) return !0;
                var q = this.createContactEquation(a, e, b, i);
                return g(q.normalA, j, c), f.normalize(q.normalA, q.normalA), f.scale(q.contactPointA, q.normalA, m), 
                f.scale(q.contactPointB, q.normalA, -n), h(q.contactPointA, q.contactPointA, c), 
                g(q.contactPointA, q.contactPointA, a.position), h(q.contactPointB, q.contactPointB, j), 
                g(q.contactPointB, q.contactPointB, e.position), this.contactEquations.push(q), 
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)), 
                1;
            }, c.prototype[p.PLANE | p.CONVEX] = c.prototype[p.PLANE | p.BOX] = c.prototype.planeConvex = function(a, b, c, d, e, j, k, l, m) {
                var n = s, o = t, p = u, q = 0;
                f.rotate(o, r, d);
                for (var v = 0; v !== j.vertices.length; v++) {
                    var w = j.vertices[v];
                    if (f.rotate(n, w, l), h(n, n, k), g(p, n, c), i(p, o) <= 0) {
                        if (m) return !0;
                        q++;
                        var x = this.createContactEquation(a, e, b, j);
                        g(p, n, c), f.copy(x.normalA, o);
                        var y = i(p, x.normalA);
                        f.scale(p, x.normalA, y), g(x.contactPointB, n, e.position), g(x.contactPointA, n, p), 
                        g(x.contactPointA, x.contactPointA, a.position), this.contactEquations.push(x), 
                        this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x));
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)), 
                q;
            }, c.prototype[p.PARTICLE | p.PLANE] = c.prototype.particlePlane = function(a, b, c, d, e, h, j, k, l) {
                var m = s, n = t;
                k = k || 0, g(m, c, j), f.rotate(n, r, k);
                var o = i(m, n);
                if (o > 0) return 0;
                if (l) return !0;
                var p = this.createContactEquation(e, a, h, b);
                return f.copy(p.normalA, n), f.scale(m, p.normalA, o), g(p.contactPointA, c, m), 
                g(p.contactPointA, p.contactPointA, e.position), g(p.contactPointB, c, a.position), 
                this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 
                1;
            }, c.prototype[p.CIRCLE | p.PARTICLE] = c.prototype.circleParticle = function(a, b, c, d, e, i, j, k, l) {
                var m = s;
                if (g(m, j, c), f.squaredLength(m) > Math.pow(b.radius, 2)) return 0;
                if (l) return !0;
                var n = this.createContactEquation(a, e, b, i);
                return f.copy(n.normalA, m), f.normalize(n.normalA, n.normalA), f.scale(n.contactPointA, n.normalA, b.radius), 
                h(n.contactPointA, n.contactPointA, c), g(n.contactPointA, n.contactPointA, a.position), 
                g(n.contactPointB, j, e.position), this.contactEquations.push(n), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)), 
                1;
            };
            {
                var W = new n({
                    radius: 1
                }), X = f.create(), Y = f.create();
                f.create();
            }
            c.prototype[p.PLANE | p.CAPSULE] = c.prototype.planeCapsule = function(a, b, c, d, e, g, i, j, k) {
                var l = X, m = Y, n = W;
                f.set(l, -g.length / 2, 0), f.rotate(l, l, j), h(l, l, i), f.set(m, g.length / 2, 0), 
                f.rotate(m, m, j), h(m, m, i), n.radius = g.radius;
                var o;
                this.enableFrictionReduction && (o = this.enableFriction, this.enableFriction = !1);
                var p = this.circlePlane(e, n, l, 0, a, b, c, d, k), q = this.circlePlane(e, n, m, 0, a, b, c, d, k);
                if (this.enableFrictionReduction && (this.enableFriction = o), k) return p || q;
                var r = p + q;
                return this.enableFrictionReduction && r && this.frictionEquations.push(this.createFrictionFromAverage(r)), 
                r;
            }, c.prototype[p.CIRCLE | p.PLANE] = c.prototype.circlePlane = function(a, b, c, d, e, j, k, l, m) {
                var n = a, o = b, p = c, q = e, v = k, w = l;
                w = w || 0;
                var x = s, y = t, z = u;
                g(x, p, v), f.rotate(y, r, w);
                var A = i(y, x);
                if (A > o.radius) return 0;
                if (m) return !0;
                var B = this.createContactEquation(q, n, j, b);
                return f.copy(B.normalA, y), f.scale(B.contactPointB, B.normalA, -o.radius), h(B.contactPointB, B.contactPointB, p), 
                g(B.contactPointB, B.contactPointB, n.position), f.scale(z, B.normalA, A), g(B.contactPointA, x, z), 
                h(B.contactPointA, B.contactPointA, v), g(B.contactPointA, B.contactPointA, q.position), 
                this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 
                1;
            }, c.prototype[p.CONVEX] = c.prototype[p.CONVEX | p.BOX] = c.prototype[p.BOX] = c.prototype.convexConvex = function(a, b, d, e, j, k, l, m, n, o) {
                var p = s, q = t, r = u, x = v, B = w, C = y, D = z, E = A, F = 0, o = "number" == typeof o ? o : 0, G = c.findSeparatingAxis(b, d, e, k, l, m, p);
                if (!G) return 0;
                g(D, l, d), i(p, D) > 0 && f.scale(p, p, -1);
                var H = c.getClosestEdge(b, e, p, !0), I = c.getClosestEdge(k, m, p);
                if (-1 === H || -1 === I) return 0;
                for (var J = 0; 2 > J; J++) {
                    var K = H, L = I, M = b, N = k, O = d, P = l, Q = e, R = m, S = a, T = j;
                    if (0 === J) {
                        var U;
                        U = K, K = L, L = U, U = M, M = N, N = U, U = O, O = P, P = U, U = Q, Q = R, R = U, 
                        U = S, S = T, T = U;
                    }
                    for (var V = L; L + 2 > V; V++) {
                        var W = N.vertices[(V + N.vertices.length) % N.vertices.length];
                        f.rotate(q, W, R), h(q, q, P);
                        for (var X = 0, Y = K - 1; K + 2 > Y; Y++) {
                            var Z = M.vertices[(Y + M.vertices.length) % M.vertices.length], $ = M.vertices[(Y + 1 + M.vertices.length) % M.vertices.length];
                            f.rotate(r, Z, Q), f.rotate(x, $, Q), h(r, r, O), h(x, x, O), g(B, x, r), f.rotate90cw(E, B), 
                            f.normalize(E, E), g(D, q, r);
                            var _ = i(E, D);
                            (Y === K && o >= _ || Y !== K && 0 >= _) && X++;
                        }
                        if (X >= 3) {
                            if (n) return !0;
                            var ab = this.createContactEquation(S, T, M, N);
                            F++;
                            var Z = M.vertices[K % M.vertices.length], $ = M.vertices[(K + 1) % M.vertices.length];
                            f.rotate(r, Z, Q), f.rotate(x, $, Q), h(r, r, O), h(x, x, O), g(B, x, r), f.rotate90cw(ab.normalA, B), 
                            f.normalize(ab.normalA, ab.normalA), g(D, q, r);
                            var _ = i(ab.normalA, D);
                            f.scale(C, ab.normalA, _), g(ab.contactPointA, q, O), g(ab.contactPointA, ab.contactPointA, C), 
                            h(ab.contactPointA, ab.contactPointA, O), g(ab.contactPointA, ab.contactPointA, S.position), 
                            g(ab.contactPointB, q, P), h(ab.contactPointB, ab.contactPointB, P), g(ab.contactPointB, ab.contactPointB, T.position), 
                            this.contactEquations.push(ab), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ab));
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && F && this.frictionEquations.push(this.createFrictionFromAverage(F)), 
                F;
            };
            var Z = f.fromValues(0, 0);
            c.projectConvexOntoAxis = function(a, b, c, d, e) {
                var g, h, j = null, k = null, l = Z;
                f.rotate(l, d, -c);
                for (var m = 0; m < a.vertices.length; m++) g = a.vertices[m], h = i(g, l), (null === j || h > j) && (j = h), 
                (null === k || k > h) && (k = h);
                if (k > j) {
                    var n = k;
                    k = j, j = n;
                }
                var o = i(b, d);
                f.set(e, k + o, j + o);
            };
            var $ = f.fromValues(0, 0), _ = f.fromValues(0, 0), ab = f.fromValues(0, 0), bb = f.fromValues(0, 0), cb = f.fromValues(0, 0), db = f.fromValues(0, 0);
            c.findSeparatingAxis = function(a, b, d, e, h, i, j) {
                var k = null, l = !1, m = !1, n = $, o = _, p = ab, r = bb, s = cb, t = db;
                if (a instanceof q && e instanceof q) for (var u = 0; 2 !== u; u++) {
                    var v = a, w = d;
                    1 === u && (v = e, w = i);
                    for (var x = 0; 2 !== x; x++) {
                        0 === x ? f.set(r, 0, 1) : 1 === x && f.set(r, 1, 0), 0 !== w && f.rotate(r, r, w), 
                        c.projectConvexOntoAxis(a, b, d, r, s), c.projectConvexOntoAxis(e, h, i, r, t);
                        var y = s, z = t, A = !1;
                        s[0] > t[0] && (z = s, y = t, A = !0);
                        var B = z[0] - y[1];
                        l = 0 >= B, (null === k || B > k) && (f.copy(j, r), k = B, m = l);
                    }
                } else for (var u = 0; 2 !== u; u++) {
                    var v = a, w = d;
                    1 === u && (v = e, w = i);
                    for (var x = 0; x !== v.vertices.length; x++) {
                        f.rotate(o, v.vertices[x], w), f.rotate(p, v.vertices[(x + 1) % v.vertices.length], w), 
                        g(n, p, o), f.rotate90cw(r, n), f.normalize(r, r), c.projectConvexOntoAxis(a, b, d, r, s), 
                        c.projectConvexOntoAxis(e, h, i, r, t);
                        var y = s, z = t, A = !1;
                        s[0] > t[0] && (z = s, y = t, A = !0);
                        var B = z[0] - y[1];
                        l = 0 >= B, (null === k || B > k) && (f.copy(j, r), k = B, m = l);
                    }
                }
                return m;
            };
            var eb = f.fromValues(0, 0), fb = f.fromValues(0, 0), gb = f.fromValues(0, 0);
            c.getClosestEdge = function(a, b, c, d) {
                var e = eb, h = fb, j = gb;
                f.rotate(e, c, -b), d && f.scale(e, e, -1);
                for (var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++) {
                    g(h, a.vertices[(n + 1) % l], a.vertices[n % l]), f.rotate90cw(j, h), f.normalize(j, j);
                    var o = i(j, e);
                    (-1 === k || o > m) && (k = n % l, m = o);
                }
                return k;
            };
            var hb = f.create(), ib = f.create(), jb = f.create(), kb = f.create(), lb = f.create(), mb = f.create(), nb = f.create();
            c.prototype[p.CIRCLE | p.HEIGHTFIELD] = c.prototype.circleHeightfield = function(a, b, c, d, e, i, j, k, l, m) {
                var n = i.heights, m = m || b.radius, o = i.elementWidth, p = ib, q = hb, r = lb, s = nb, t = mb, u = jb, v = kb, w = Math.floor((c[0] - m - j[0]) / o), x = Math.ceil((c[0] + m - j[0]) / o);
                0 > w && (w = 0), x >= n.length && (x = n.length - 1);
                for (var y = n[w], z = n[x], A = w; x > A; A++) n[A] < z && (z = n[A]), n[A] > y && (y = n[A]);
                if (c[1] - m > y) return l ? !1 : 0;
                for (var B = !1, A = w; x > A; A++) {
                    f.set(u, A * o, n[A]), f.set(v, (A + 1) * o, n[A + 1]), f.add(u, u, j), f.add(v, v, j), 
                    f.sub(t, v, u), f.rotate(t, t, Math.PI / 2), f.normalize(t, t), f.scale(q, t, -m), 
                    f.add(q, q, c), f.sub(p, q, u);
                    var C = f.dot(p, t);
                    if (q[0] >= u[0] && q[0] < v[0] && 0 >= C) {
                        if (l) return !0;
                        B = !0, f.scale(p, t, -C), f.add(r, q, p), f.copy(s, t);
                        var D = this.createContactEquation(e, a, i, b);
                        f.copy(D.normalA, s), f.scale(D.contactPointB, D.normalA, -m), h(D.contactPointB, D.contactPointB, c), 
                        g(D.contactPointB, D.contactPointB, a.position), f.copy(D.contactPointA, r), f.sub(D.contactPointA, D.contactPointA, e.position), 
                        this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
                    }
                }
                if (B = !1, m > 0) for (var A = w; x >= A; A++) if (f.set(u, A * o, n[A]), f.add(u, u, j), 
                f.sub(p, c, u), f.squaredLength(p) < Math.pow(m, 2)) {
                    if (l) return !0;
                    B = !0;
                    var D = this.createContactEquation(e, a, i, b);
                    f.copy(D.normalA, p), f.normalize(D.normalA, D.normalA), f.scale(D.contactPointB, D.normalA, -m), 
                    h(D.contactPointB, D.contactPointB, c), g(D.contactPointB, D.contactPointB, a.position), 
                    g(D.contactPointA, u, j), h(D.contactPointA, D.contactPointA, j), g(D.contactPointA, D.contactPointA, e.position), 
                    this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
                }
                return B ? 1 : 0;
            };
            var ob = f.create(), pb = f.create(), qb = f.create(), rb = new o({
                vertices: [ f.create(), f.create(), f.create(), f.create() ]
            });
            c.prototype[p.BOX | p.HEIGHTFIELD] = c.prototype[p.CONVEX | p.HEIGHTFIELD] = c.prototype.convexHeightfield = function(a, b, c, d, e, g, h, i, j) {
                var k = g.heights, l = g.elementWidth, m = ob, n = pb, o = qb, p = rb, q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l), r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
                0 > q && (q = 0), r >= k.length && (r = k.length - 1);
                for (var s = k[q], t = k[r], u = q; r > u; u++) k[u] < t && (t = k[u]), k[u] > s && (s = k[u]);
                if (a.aabb.lowerBound[1] > s) return j ? !1 : 0;
                for (var v = 0, u = q; r > u; u++) {
                    f.set(m, u * l, k[u]), f.set(n, (u + 1) * l, k[u + 1]), f.add(m, m, h), f.add(n, n, h);
                    var w = 100;
                    f.set(o, .5 * (n[0] + m[0]), .5 * (n[1] + m[1] - w)), f.sub(p.vertices[0], n, o), 
                    f.sub(p.vertices[1], m, o), f.copy(p.vertices[2], p.vertices[1]), f.copy(p.vertices[3], p.vertices[0]), 
                    p.vertices[2][1] -= w, p.vertices[3][1] -= w, v += this.convexConvex(a, b, c, d, e, p, o, 0, j);
                }
                return v;
            };
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        } ],
        11: [ function(a, b) {
            function c(a) {
                a = a || {}, this.from = a.from ? e.fromValues(a.from[0], a.from[1]) : e.create(), 
                this.to = a.to ? e.fromValues(a.to[0], a.to[1]) : e.create(), this.checkCollisionResponse = void 0 !== a.checkCollisionResponse ? a.checkCollisionResponse : !0, 
                this.skipBackfaces = !!a.skipBackfaces, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1, 
                this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1, this.mode = void 0 !== a.mode ? a.mode : c.ANY, 
                this.callback = a.callback || function() {}, this.direction = e.create(), this.length = 1, 
                this.update();
            }
            function d(a, b, c) {
                e.sub(g, c, a);
                var d = e.dot(g, b);
                return e.scale(h, b, d), e.add(h, h, a), e.squaredDistance(c, h);
            }
            b.exports = c;
            {
                var e = a("../math/vec2");
                a("../collision/RaycastResult"), a("../shapes/Shape"), a("../collision/AABB");
            }
            c.prototype.constructor = c, c.CLOSEST = 1, c.ANY = 2, c.ALL = 4, c.prototype.update = function() {
                var a = this.direction;
                e.sub(a, this.to, this.from), this.length = e.length(a), e.normalize(a, a);
            }, c.prototype.intersectBodies = function(a, b) {
                for (var c = 0, d = b.length; !a.shouldStop(this) && d > c; c++) {
                    var e = b[c], f = e.getAABB();
                    (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e);
                }
            };
            var f = e.create();
            c.prototype.intersectBody = function(a, b) {
                var c = this.checkCollisionResponse;
                if (!c || b.collisionResponse) for (var d = f, g = 0, h = b.shapes.length; h > g; g++) {
                    var i = b.shapes[g];
                    if ((!c || i.collisionResponse) && 0 !== (this.collisionGroup & i.collisionMask) && 0 !== (i.collisionGroup & this.collisionMask)) {
                        e.rotate(d, i.position, b.angle), e.add(d, d, b.position);
                        var j = i.angle + b.angle;
                        if (this.intersectShape(a, i, j, d, b), a.shouldStop(this)) break;
                    }
                }
            }, c.prototype.intersectShape = function(a, b, c, e, f) {
                var g = this.from, h = d(g, this.direction, e);
                h > b.boundingRadius * b.boundingRadius || (this._currentBody = f, this._currentShape = b, 
                b.raycast(a, this, e, c), this._currentBody = this._currentShape = null);
            }, c.prototype.getAABB = function(a) {
                var b = this.to, c = this.from;
                e.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])), e.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]));
            };
            e.create();
            c.prototype.reportIntersection = function(a, b, d, f) {
                var g = (this.from, this.to, this._currentShape), h = this._currentBody;
                if (!(this.skipBackfaces && e.dot(d, this.direction) > 0)) switch (this.mode) {
                  case c.ALL:
                    a.set(d, g, h, b, f), this.callback(a);
                    break;

                  case c.CLOSEST:
                    (b < a.fraction || !a.hasHit()) && a.set(d, g, h, b, f);
                    break;

                  case c.ANY:
                    a.set(d, g, h, b, f);
                }
            };
            var g = e.create(), h = e.create();
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        } ],
        12: [ function(a, b) {
            function c() {
                this.normal = d.create(), this.shape = null, this.body = null, this.faceIndex = -1, 
                this.fraction = -1, this.isStopped = !1;
            }
            var d = a("../math/vec2"), e = a("../collision/Ray");
            b.exports = c, c.prototype.reset = function() {
                d.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, 
                this.fraction = -1, this.isStopped = !1;
            }, c.prototype.getHitDistance = function(a) {
                return d.distance(a.from, a.to) * this.fraction;
            }, c.prototype.hasHit = function() {
                return -1 !== this.fraction;
            }, c.prototype.getHitPoint = function(a, b) {
                d.lerp(a, b.from, b.to, this.fraction);
            }, c.prototype.stop = function() {
                this.isStopped = !0;
            }, c.prototype.shouldStop = function(a) {
                return this.isStopped || -1 !== this.fraction && a.mode === e.ANY;
            }, c.prototype.set = function(a, b, c, e, f) {
                d.copy(this.normal, a), this.shape = b, this.body = c, this.fraction = e, this.faceIndex = f;
            };
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        } ],
        13: [ function(a, b) {
            function c() {
                e.call(this, e.SAP), this.axisList = [], this.axisIndex = 0;
                var a = this;
                this._addBodyHandler = function(b) {
                    a.axisList.push(b.body);
                }, this._removeBodyHandler = function(b) {
                    var c = a.axisList.indexOf(b.body);
                    -1 !== c && a.axisList.splice(c, 1);
                };
            }
            var d = a("../utils/Utils"), e = a("../collision/Broadphase");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.setWorld = function(a) {
                this.axisList.length = 0, d.appendArray(this.axisList, a.bodies), a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), 
                a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), 
                this.world = a;
            }, c.sortAxisList = function(a, b) {
                b = 0 | b;
                for (var c = 1, d = a.length; d > c; c++) {
                    for (var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--) a[f + 1] = a[f];
                    a[f + 1] = e;
                }
                return a;
            }, c.prototype.sortList = function() {
                var a = this.axisList, b = this.axisIndex;
                c.sortAxisList(a, b);
            }, c.prototype.getCollisionPairs = function() {
                var a = this.axisList, b = this.result, c = this.axisIndex;
                b.length = 0;
                for (var d = a.length; d--; ) {
                    var f = a[d];
                    f.aabbNeedsUpdate && f.updateAABB();
                }
                this.sortList();
                for (var g = 0, h = 0 | a.length; g !== h; g++) for (var i = a[g], j = g + 1; h > j; j++) {
                    var k = a[j], l = k.aabb.lowerBound[c] <= i.aabb.upperBound[c];
                    if (!l) break;
                    e.canCollide(i, k) && this.boundingVolumeCheck(i, k) && b.push(i, k);
                }
                return b;
            }, c.prototype.aabbQuery = function(a, b, c) {
                c = c || [], this.sortList();
                var d = this.axisIndex, e = "x";
                1 === d && (e = "y"), 2 === d && (e = "z");
                for (var f = this.axisList, g = (b.lowerBound[e], b.upperBound[e], 0); g < f.length; g++) {
                    var h = f[g];
                    h.aabbNeedsUpdate && h.updateAABB(), h.aabb.overlaps(b) && c.push(h);
                }
                return c;
            };
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        } ],
        14: [ function(a, b) {
            function c(a, b, c, e) {
                this.type = c, e = d.defaults(e, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = a, this.bodyB = b, this.collideConnected = e.collideConnected, 
                e.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp());
            }
            b.exports = c;
            var d = a("../utils/Utils");
            c.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            }, c.DISTANCE = 1, c.GEAR = 2, c.LOCK = 3, c.PRISMATIC = 4, c.REVOLUTE = 5, c.prototype.setStiffness = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.stiffness = a, d.needsUpdate = !0;
                }
            }, c.prototype.setRelaxation = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.relaxation = a, d.needsUpdate = !0;
                }
            };
        }, {
            "../utils/Utils": 57
        } ],
        15: [ function(a, b) {
            function c(a, b, c) {
                c = g.defaults(c, {
                    localAnchorA: [ 0, 0 ],
                    localAnchorB: [ 0, 0 ]
                }), d.call(this, a, b, d.DISTANCE, c), this.localAnchorA = f.fromValues(c.localAnchorA[0], c.localAnchorA[1]), 
                this.localAnchorB = f.fromValues(c.localAnchorB[0], c.localAnchorB[1]);
                var h = this.localAnchorA, i = this.localAnchorB;
                if (this.distance = 0, "number" == typeof c.distance) this.distance = c.distance; else {
                    var j = f.create(), k = f.create(), l = f.create();
                    f.rotate(j, h, a.angle), f.rotate(k, i, b.angle), f.add(l, b.position, k), f.sub(l, l, j), 
                    f.sub(l, l, a.position), this.distance = f.length(l);
                }
                var m;
                m = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce;
                var n = new e(a, b, -m, m);
                this.equations = [ n ], this.maxForce = m;
                var l = f.create(), o = f.create(), p = f.create(), q = this;
                n.computeGq = function() {
                    var a = this.bodyA, b = this.bodyB, c = a.position, d = b.position;
                    return f.rotate(o, h, a.angle), f.rotate(p, i, b.angle), f.add(l, d, p), f.sub(l, l, o), 
                    f.sub(l, l, c), f.length(l) - q.distance;
                }, this.setMaxForce(m), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, 
                this.lowerLimit = 0, this.position = 0;
            }
            var d = a("./Constraint"), e = a("../equations/Equation"), f = a("../math/vec2"), g = a("../utils/Utils");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c;
            var h = f.create(), i = f.create(), j = f.create();
            c.prototype.update = function() {
                var a = this.equations[0], b = this.bodyA, c = this.bodyB, d = (this.distance, b.position), e = c.position, g = this.equations[0], k = a.G;
                f.rotate(i, this.localAnchorA, b.angle), f.rotate(j, this.localAnchorB, c.angle), 
                f.add(h, e, j), f.sub(h, h, i), f.sub(h, h, d), this.position = f.length(h);
                var l = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (g.maxForce = 0, 
                g.minForce = -this.maxForce, this.distance = this.upperLimit, l = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (g.maxForce = this.maxForce, 
                g.minForce = 0, this.distance = this.lowerLimit, l = !0), (this.lowerLimitEnabled || this.upperLimitEnabled) && !l) return void (g.enabled = !1);
                g.enabled = !0, f.normalize(h, h);
                var m = f.crossLength(i, h), n = f.crossLength(j, h);
                k[0] = -h[0], k[1] = -h[1], k[2] = -m, k[3] = h[0], k[4] = h[1], k[5] = n;
            }, c.prototype.setMaxForce = function(a) {
                var b = this.equations[0];
                b.minForce = -a, b.maxForce = a;
            }, c.prototype.getMaxForce = function() {
                var a = this.equations[0];
                return a.maxForce;
            };
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        } ],
        16: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, d.GEAR, c), this.ratio = void 0 !== c.ratio ? c.ratio : 1, 
                this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle, c.angle = this.angle, 
                c.ratio = this.ratio, this.equations = [ new e(a, b, c) ], void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque);
            }
            {
                var d = a("./Constraint"), e = (a("../equations/Equation"), a("../equations/AngleLockEquation"));
                a("../math/vec2");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.update = function() {
                var a = this.equations[0];
                a.ratio !== this.ratio && a.setRatio(this.ratio), a.angle = this.angle;
            }, c.prototype.setMaxTorque = function(a) {
                this.equations[0].setMaxTorque(a);
            }, c.prototype.getMaxTorque = function() {
                return this.equations[0].maxForce;
            };
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        17: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, d.LOCK, c);
                var g = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce, h = (c.localAngleB || 0, 
                new f(a, b, -g, g)), i = new f(a, b, -g, g), j = new f(a, b, -g, g), k = e.create(), l = e.create(), m = this;
                h.computeGq = function() {
                    return e.rotate(k, m.localOffsetB, a.angle), e.sub(l, b.position, a.position), e.sub(l, l, k), 
                    l[0];
                }, i.computeGq = function() {
                    return e.rotate(k, m.localOffsetB, a.angle), e.sub(l, b.position, a.position), e.sub(l, l, k), 
                    l[1];
                };
                var n = e.create(), o = e.create();
                j.computeGq = function() {
                    return e.rotate(n, m.localOffsetB, b.angle - m.localAngleB), e.scale(n, n, -1), 
                    e.sub(l, a.position, b.position), e.add(l, l, n), e.rotate(o, n, -Math.PI / 2), 
                    e.normalize(o, o), e.dot(l, o);
                }, this.localOffsetB = e.create(), c.localOffsetB ? e.copy(this.localOffsetB, c.localOffsetB) : (e.sub(this.localOffsetB, b.position, a.position), 
                e.rotate(this.localOffsetB, this.localOffsetB, -a.angle)), this.localAngleB = 0, 
                this.localAngleB = "number" == typeof c.localAngleB ? c.localAngleB : b.angle - a.angle, 
                this.equations.push(h, i, j), this.setMaxForce(g);
            }
            var d = a("./Constraint"), e = a("../math/vec2"), f = a("../equations/Equation");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.setMaxForce = function(a) {
                for (var b = this.equations, c = 0; c < this.equations.length; c++) b[c].maxForce = a, 
                b[c].minForce = -a;
            }, c.prototype.getMaxForce = function() {
                return this.equations[0].maxForce;
            };
            var g = e.create(), h = e.create(), i = e.create(), j = e.fromValues(1, 0), k = e.fromValues(0, 1);
            c.prototype.update = function() {
                var a = this.equations[0], b = this.equations[1], c = this.equations[2], d = this.bodyA, f = this.bodyB;
                e.rotate(g, this.localOffsetB, d.angle), e.rotate(h, this.localOffsetB, f.angle - this.localAngleB), 
                e.scale(h, h, -1), e.rotate(i, h, Math.PI / 2), e.normalize(i, i), a.G[0] = -1, 
                a.G[1] = 0, a.G[2] = -e.crossLength(g, j), a.G[3] = 1, b.G[0] = 0, b.G[1] = -1, 
                b.G[2] = -e.crossLength(g, k), b.G[4] = 1, c.G[0] = -i[0], c.G[1] = -i[1], c.G[3] = i[0], 
                c.G[4] = i[1], c.G[5] = e.crossLength(h, i);
            };
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        18: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, d.PRISMATIC, c);
                var i = g.fromValues(0, 0), j = g.fromValues(1, 0), k = g.fromValues(0, 0);
                c.localAnchorA && g.copy(i, c.localAnchorA), c.localAxisA && g.copy(j, c.localAxisA), 
                c.localAnchorB && g.copy(k, c.localAnchorB), this.localAnchorA = i, this.localAnchorB = k, 
                this.localAxisA = j;
                var l = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE, m = new f(a, b, -l, l), n = new g.create(), o = new g.create(), p = new g.create(), q = new g.create();
                if (m.computeGq = function() {
                    return g.dot(p, q);
                }, m.updateJacobian = function() {
                    var c = this.G, d = a.position, e = b.position;
                    g.rotate(n, i, a.angle), g.rotate(o, k, b.angle), g.add(p, e, o), g.sub(p, p, d), 
                    g.sub(p, p, n), g.rotate(q, j, a.angle + Math.PI / 2), c[0] = -q[0], c[1] = -q[1], 
                    c[2] = -g.crossLength(n, q) + g.crossLength(q, p), c[3] = q[0], c[4] = q[1], c[5] = g.crossLength(o, q);
                }, this.equations.push(m), !c.disableRotationalLock) {
                    var r = new h(a, b, -l, l);
                    this.equations.push(r);
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = "undefined" != typeof c.lowerLimit ? !0 : !1, 
                this.upperLimitEnabled = "undefined" != typeof c.upperLimit ? !0 : !1, this.lowerLimit = "undefined" != typeof c.lowerLimit ? c.lowerLimit : 0, 
                this.upperLimit = "undefined" != typeof c.upperLimit ? c.upperLimit : 1, this.upperLimitEquation = new e(a, b), 
                this.lowerLimitEquation = new e(a, b), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, 
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l, this.motorEquation = new f(a, b), 
                this.motorEnabled = !1, this.motorSpeed = 0;
                {
                    var s = this, t = this.motorEquation;
                    t.computeGW;
                }
                t.computeGq = function() {
                    return 0;
                }, t.computeGW = function() {
                    var a = this.G, b = this.bodyA, c = this.bodyB, d = b.velocity, e = c.velocity, f = b.angularVelocity, g = c.angularVelocity;
                    return this.gmult(a, d, f, e, g) + s.motorSpeed;
                };
            }
            var d = a("./Constraint"), e = a("../equations/ContactEquation"), f = a("../equations/Equation"), g = a("../math/vec2"), h = a("../equations/RotationalLockEquation");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c;
            var i = g.create(), j = g.create(), k = g.create(), l = g.create(), m = g.create(), n = g.create();
            c.prototype.update = function() {
                var a = this.equations, b = a[0], c = this.upperLimit, d = this.lowerLimit, e = this.upperLimitEquation, f = this.lowerLimitEquation, h = this.bodyA, o = this.bodyB, p = this.localAxisA, q = this.localAnchorA, r = this.localAnchorB;
                b.updateJacobian(), g.rotate(i, p, h.angle), g.rotate(l, q, h.angle), g.add(j, l, h.position), 
                g.rotate(m, r, o.angle), g.add(k, m, o.position);
                var s = this.position = g.dot(k, i) - g.dot(j, i);
                if (this.motorEnabled) {
                    var t = this.motorEquation.G;
                    t[0] = i[0], t[1] = i[1], t[2] = g.crossLength(i, m), t[3] = -i[0], t[4] = -i[1], 
                    t[5] = -g.crossLength(i, l);
                }
                if (this.upperLimitEnabled && s > c) g.scale(e.normalA, i, -1), g.sub(e.contactPointA, j, h.position), 
                g.sub(e.contactPointB, k, o.position), g.scale(n, i, c), g.add(e.contactPointA, e.contactPointA, n), 
                -1 === a.indexOf(e) && a.push(e); else {
                    var u = a.indexOf(e);
                    -1 !== u && a.splice(u, 1);
                }
                if (this.lowerLimitEnabled && d > s) g.scale(f.normalA, i, 1), g.sub(f.contactPointA, j, h.position), 
                g.sub(f.contactPointB, k, o.position), g.scale(n, i, d), g.sub(f.contactPointB, f.contactPointB, n), 
                -1 === a.indexOf(f) && a.push(f); else {
                    var u = a.indexOf(f);
                    -1 !== u && a.splice(u, 1);
                }
            }, c.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0);
            }, c.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1), this.motorEnabled = !1;
                }
            }, c.prototype.setLimits = function(a, b) {
                "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, 
                this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, 
                this.upperLimitEnabled = !1);
            };
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        19: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, d.REVOLUTE, c);
                var n = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE;
                this.pivotA = h.create(), this.pivotB = h.create(), c.worldPivot ? (h.sub(this.pivotA, c.worldPivot, a.position), 
                h.sub(this.pivotB, c.worldPivot, b.position), h.rotate(this.pivotA, this.pivotA, -a.angle), 
                h.rotate(this.pivotB, this.pivotB, -b.angle)) : (h.copy(this.pivotA, c.localPivotA), 
                h.copy(this.pivotB, c.localPivotB));
                var o = this.equations = [ new e(a, b, -n, n), new e(a, b, -n, n) ], p = o[0], q = o[1], r = this;
                p.computeGq = function() {
                    return h.rotate(i, r.pivotA, a.angle), h.rotate(j, r.pivotB, b.angle), h.add(m, b.position, j), 
                    h.sub(m, m, a.position), h.sub(m, m, i), h.dot(m, k);
                }, q.computeGq = function() {
                    return h.rotate(i, r.pivotA, a.angle), h.rotate(j, r.pivotB, b.angle), h.add(m, b.position, j), 
                    h.sub(m, m, a.position), h.sub(m, m, i), h.dot(m, l);
                }, q.minForce = p.minForce = -n, q.maxForce = p.maxForce = n, this.motorEquation = new f(a, b), 
                this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, 
                this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new g(a, b), 
                this.lowerLimitEquation = new g(a, b), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0;
            }
            var d = a("./Constraint"), e = a("../equations/Equation"), f = a("../equations/RotationalVelocityEquation"), g = a("../equations/RotationalLockEquation"), h = a("../math/vec2");
            b.exports = c;
            var i = h.create(), j = h.create(), k = h.fromValues(1, 0), l = h.fromValues(0, 1), m = h.create();
            c.prototype = new d(), c.prototype.constructor = c, c.prototype.setLimits = function(a, b) {
                "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, 
                this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, 
                this.upperLimitEnabled = !1);
            }, c.prototype.update = function() {
                var a = this.bodyA, b = this.bodyB, c = this.pivotA, d = this.pivotB, e = this.equations, f = (e[0], 
                e[1], e[0]), g = e[1], m = this.upperLimit, n = this.lowerLimit, o = this.upperLimitEquation, p = this.lowerLimitEquation, q = this.angle = b.angle - a.angle;
                if (this.upperLimitEnabled && q > m) o.angle = m, -1 === e.indexOf(o) && e.push(o); else {
                    var r = e.indexOf(o);
                    -1 !== r && e.splice(r, 1);
                }
                if (this.lowerLimitEnabled && n > q) p.angle = n, -1 === e.indexOf(p) && e.push(p); else {
                    var r = e.indexOf(p);
                    -1 !== r && e.splice(r, 1);
                }
                h.rotate(i, c, a.angle), h.rotate(j, d, b.angle), f.G[0] = -1, f.G[1] = 0, f.G[2] = -h.crossLength(i, k), 
                f.G[3] = 1, f.G[4] = 0, f.G[5] = h.crossLength(j, k), g.G[0] = 0, g.G[1] = -1, g.G[2] = -h.crossLength(i, l), 
                g.G[3] = 0, g.G[4] = 1, g.G[5] = h.crossLength(j, l);
            }, c.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0);
            }, c.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1), this.motorEnabled = !1;
                }
            }, c.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled;
            }, c.prototype.setMotorSpeed = function(a) {
                if (this.motorEnabled) {
                    var b = this.equations.indexOf(this.motorEquation);
                    this.equations[b].relativeVelocity = a;
                }
            }, c.prototype.getMotorSpeed = function() {
                return this.motorEnabled ? this.motorEquation.relativeVelocity : !1;
            };
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        } ],
        20: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0, 
                this.ratio = "number" == typeof c.ratio ? c.ratio : 1, this.setRatio(this.ratio);
            }
            {
                var d = a("./Equation");
                a("../math/vec2");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
            }, c.prototype.setRatio = function(a) {
                var b = this.G;
                b[2] = a, b[5] = -1, this.ratio = a;
            }, c.prototype.setMaxTorque = function(a) {
                this.maxForce = a, this.minForce = -a;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        21: [ function(a, b) {
            function c(a, b) {
                d.call(this, a, b, 0, Number.MAX_VALUE), this.contactPointA = e.create(), this.penetrationVec = e.create(), 
                this.contactPointB = e.create(), this.normalA = e.create(), this.restitution = 0, 
                this.firstImpact = !1, this.shapeA = null, this.shapeB = null;
            }
            var d = a("./Equation"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeB = function(a, b, c) {
                var d = this.bodyA, f = this.bodyB, g = this.contactPointA, h = this.contactPointB, i = d.position, j = f.position, k = this.penetrationVec, l = this.normalA, m = this.G, n = e.crossLength(g, l), o = e.crossLength(h, l);
                m[0] = -l[0], m[1] = -l[1], m[2] = -n, m[3] = l[0], m[4] = l[1], m[5] = o, e.add(k, j, h), 
                e.sub(k, k, i), e.sub(k, k, g);
                var p, q;
                this.firstImpact && 0 !== this.restitution ? (q = 0, p = 1 / b * (1 + this.restitution) * this.computeGW()) : (q = e.dot(l, k) + this.offset, 
                p = this.computeGW());
                var r = this.computeGiMf(), s = -q * a - p * b - c * r;
                return s;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        22: [ function(a, b) {
            function c(a, b, d, f) {
                this.minForce = "undefined" == typeof d ? -Number.MAX_VALUE : d, this.maxForce = "undefined" == typeof f ? Number.MAX_VALUE : f, 
                this.bodyA = a, this.bodyB = b, this.stiffness = c.DEFAULT_STIFFNESS, this.relaxation = c.DEFAULT_RELAXATION, 
                this.G = new e.ARRAY_TYPE(6);
                for (var g = 0; 6 > g; g++) this.G[g] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, 
                this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0;
            }
            b.exports = c;
            {
                var d = a("../math/vec2"), e = a("../utils/Utils");
                a("../objects/Body");
            }
            c.prototype.constructor = c, c.DEFAULT_STIFFNESS = 1e6, c.DEFAULT_RELAXATION = 4, 
            c.prototype.update = function() {
                var a = this.stiffness, b = this.relaxation, c = this.timeStep;
                this.a = 4 / (c * (1 + 4 * b)), this.b = 4 * b / (1 + 4 * b), this.epsilon = 4 / (c * c * a * (1 + 4 * b)), 
                this.needsUpdate = !1;
            }, c.prototype.gmult = function(a, b, c, d, e) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e;
            }, c.prototype.computeB = function(a, b, c) {
                var d = this.computeGW(), e = this.computeGq(), f = this.computeGiMf();
                return -e * a - d * b - f * c;
            };
            var f = d.create(), g = d.create();
            c.prototype.computeGq = function() {
                var a = this.G, b = this.bodyA, c = this.bodyB, d = (b.position, c.position, b.angle), e = c.angle;
                return this.gmult(a, f, d, g, e) + this.offset;
            }, c.prototype.computeGW = function() {
                var a = this.G, b = this.bodyA, c = this.bodyB, d = b.velocity, e = c.velocity, f = b.angularVelocity, g = c.angularVelocity;
                return this.gmult(a, d, f, e, g) + this.relativeVelocity;
            }, c.prototype.computeGWlambda = function() {
                var a = this.G, b = this.bodyA, c = this.bodyB, d = b.vlambda, e = c.vlambda, f = b.wlambda, g = c.wlambda;
                return this.gmult(a, d, f, e, g);
            };
            var h = d.create(), i = d.create();
            c.prototype.computeGiMf = function() {
                var a = this.bodyA, b = this.bodyB, c = a.force, e = a.angularForce, f = b.force, g = b.angularForce, j = a.invMassSolve, k = b.invMassSolve, l = a.invInertiaSolve, m = b.invInertiaSolve, n = this.G;
                return d.scale(h, c, j), d.multiply(h, a.massMultiplier, h), d.scale(i, f, k), d.multiply(i, b.massMultiplier, i), 
                this.gmult(n, h, e * l, i, g * m);
            }, c.prototype.computeGiMGt = function() {
                var a = this.bodyA, b = this.bodyB, c = a.invMassSolve, d = b.invMassSolve, e = a.invInertiaSolve, f = b.invInertiaSolve, g = this.G;
                return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f;
            };
            {
                var j = d.create(), k = d.create(), l = d.create();
                d.create(), d.create(), d.create();
            }
            c.prototype.addToWlambda = function(a) {
                var b = this.bodyA, c = this.bodyB, e = j, f = k, g = l, h = b.invMassSolve, i = c.invMassSolve, m = b.invInertiaSolve, n = c.invInertiaSolve, o = this.G;
                f[0] = o[0], f[1] = o[1], g[0] = o[3], g[1] = o[4], d.scale(e, f, h * a), d.multiply(e, e, b.massMultiplier), 
                d.add(b.vlambda, b.vlambda, e), b.wlambda += m * o[2] * a, d.scale(e, g, i * a), 
                d.multiply(e, e, c.massMultiplier), d.add(c.vlambda, c.vlambda, e), c.wlambda += n * o[5] * a;
            }, c.prototype.computeInvC = function(a) {
                return 1 / (this.computeGiMGt() + a);
            };
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        } ],
        23: [ function(a, b) {
            function c(a, b, c) {
                e.call(this, a, b, -c, c), this.contactPointA = d.create(), this.contactPointB = d.create(), 
                this.t = d.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, 
                this.frictionCoefficient = .3;
            }
            {
                var d = a("../math/vec2"), e = a("./Equation");
                a("../utils/Utils");
            }
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.setSlipForce = function(a) {
                this.maxForce = a, this.minForce = -a;
            }, c.prototype.getSlipForce = function() {
                return this.maxForce;
            }, c.prototype.computeB = function(a, b, c) {
                var e = (this.bodyA, this.bodyB, this.contactPointA), f = this.contactPointB, g = this.t, h = this.G;
                h[0] = -g[0], h[1] = -g[1], h[2] = -d.crossLength(e, g), h[3] = g[0], h[4] = g[1], 
                h[5] = d.crossLength(f, g);
                var i = this.computeGW(), j = this.computeGiMf(), k = -i * b - c * j;
                return k;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        } ],
        24: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0;
                var e = this.G;
                e[2] = 1, e[5] = -1;
            }
            var d = a("./Equation"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c;
            var f = e.create(), g = e.create(), h = e.fromValues(1, 0), i = e.fromValues(0, 1);
            c.prototype.computeGq = function() {
                return e.rotate(f, h, this.bodyA.angle + this.angle), e.rotate(g, i, this.bodyB.angle), 
                e.dot(f, g);
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        25: [ function(a, b) {
            function c(a, b) {
                d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, 
                this.ratio = 1;
            }
            {
                var d = a("./Equation");
                a("../math/vec2");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeB = function(a, b, c) {
                var d = this.G;
                d[2] = -1, d[5] = this.ratio;
                var e = this.computeGiMf(), f = this.computeGW(), g = -f * b - c * e;
                return g;
            };
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        } ],
        26: [ function(a, b) {
            var c = function() {};
            b.exports = c, c.prototype = {
                constructor: c,
                on: function(a, b, c) {
                    b.context = c || this, void 0 === this._listeners && (this._listeners = {});
                    var d = this._listeners;
                    return void 0 === d[a] && (d[a] = []), -1 === d[a].indexOf(b) && d[a].push(b), this;
                },
                has: function(a, b) {
                    if (void 0 === this._listeners) return !1;
                    var c = this._listeners;
                    if (b) {
                        if (void 0 !== c[a] && -1 !== c[a].indexOf(b)) return !0;
                    } else if (void 0 !== c[a]) return !0;
                    return !1;
                },
                off: function(a, b) {
                    if (void 0 === this._listeners) return this;
                    var c = this._listeners, d = c[a].indexOf(b);
                    return -1 !== d && c[a].splice(d, 1), this;
                },
                emit: function(a) {
                    if (void 0 === this._listeners) return this;
                    var b = this._listeners, c = b[a.type];
                    if (void 0 !== c) {
                        a.target = this;
                        for (var d = 0, e = c.length; e > d; d++) {
                            var f = c[d];
                            f.call(f.context, a);
                        }
                    }
                    return this;
                }
            };
        }, {} ],
        27: [ function(a, b) {
            function c(a, b, f) {
                if (f = f || {}, !(a instanceof d && b instanceof d)) throw new Error("First two arguments must be Material instances.");
                this.id = c.idCounter++, this.materialA = a, this.materialB = b, this.friction = "undefined" != typeof f.friction ? Number(f.friction) : .3, 
                this.restitution = "undefined" != typeof f.restitution ? Number(f.restitution) : 0, 
                this.stiffness = "undefined" != typeof f.stiffness ? Number(f.stiffness) : e.DEFAULT_STIFFNESS, 
                this.relaxation = "undefined" != typeof f.relaxation ? Number(f.relaxation) : e.DEFAULT_RELAXATION, 
                this.frictionStiffness = "undefined" != typeof f.frictionStiffness ? Number(f.frictionStiffness) : e.DEFAULT_STIFFNESS, 
                this.frictionRelaxation = "undefined" != typeof f.frictionRelaxation ? Number(f.frictionRelaxation) : e.DEFAULT_RELAXATION, 
                this.surfaceVelocity = "undefined" != typeof f.surfaceVelocity ? Number(f.surfaceVelocity) : 0, 
                this.contactSkinSize = .005;
            }
            var d = a("./Material"), e = a("../equations/Equation");
            b.exports = c, c.idCounter = 0;
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        } ],
        28: [ function(a, b) {
            function c(a) {
                this.id = a || c.idCounter++;
            }
            b.exports = c, c.idCounter = 0;
        }, {} ],
        29: [ function(a, b) {
            var c = {};
            c.GetArea = function(a) {
                if (a.length < 6) return 0;
                for (var b = a.length - 2, c = 0, d = 0; b > d; d += 2) c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
                return c += (a[0] - a[b]) * (a[b + 1] + a[1]), .5 * -c;
            }, c.Triangulate = function(a) {
                var b = a.length >> 1;
                if (3 > b) return [];
                for (var d = [], e = [], f = 0; b > f; f++) e.push(f);
                for (var f = 0, g = b; g > 3; ) {
                    var h = e[(f + 0) % g], i = e[(f + 1) % g], j = e[(f + 2) % g], k = a[2 * h], l = a[2 * h + 1], m = a[2 * i], n = a[2 * i + 1], o = a[2 * j], p = a[2 * j + 1], q = !1;
                    if (c._convex(k, l, m, n, o, p)) {
                        q = !0;
                        for (var r = 0; g > r; r++) {
                            var s = e[r];
                            if (s != h && s != i && s != j && c._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                                q = !1;
                                break;
                            }
                        }
                    }
                    if (q) d.push(h, i, j), e.splice((f + 1) % g, 1), g--, f = 0; else if (f++ > 3 * g) break;
                }
                return d.push(e[0], e[1], e[2]), d;
            }, c._PointInTriangle = function(a, b, c, d, e, f, g, h) {
                var i = g - c, j = h - d, k = e - c, l = f - d, m = a - c, n = b - d, o = i * i + j * j, p = i * k + j * l, q = i * m + j * n, r = k * k + l * l, s = k * m + l * n, t = 1 / (o * r - p * p), u = (r * q - p * s) * t, v = (o * s - p * q) * t;
                return u >= 0 && v >= 0 && 1 > u + v;
            }, c._convex = function(a, b, c, d, e, f) {
                return (b - d) * (e - c) + (c - a) * (f - d) >= 0;
            }, b.exports = c;
        }, {} ],
        30: [ function(a, b) {
            var c = b.exports = {}, d = a("../utils/Utils");
            c.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0];
            }, c.crossVZ = function(a, b, d) {
                return c.rotate(a, b, -Math.PI / 2), c.scale(a, a, d), a;
            }, c.crossZV = function(a, b, d) {
                return c.rotate(a, d, Math.PI / 2), c.scale(a, a, b), a;
            }, c.rotate = function(a, b, c) {
                if (0 !== c) {
                    var d = Math.cos(c), e = Math.sin(c), f = b[0], g = b[1];
                    a[0] = d * f - e * g, a[1] = e * f + d * g;
                } else a[0] = b[0], a[1] = b[1];
            }, c.rotate90cw = function(a, b) {
                var c = b[0], d = b[1];
                a[0] = d, a[1] = -c;
            }, c.toLocalFrame = function(a, b, d, e) {
                c.copy(a, b), c.sub(a, a, d), c.rotate(a, a, -e);
            }, c.toGlobalFrame = function(a, b, d, e) {
                c.copy(a, b), c.rotate(a, a, e), c.add(a, a, d);
            }, c.vectorToLocalFrame = function(a, b, d) {
                c.rotate(a, b, -d);
            }, c.vectorToGlobalFrame = function(a, b, d) {
                c.rotate(a, b, d);
            }, c.centroid = function(a, b, d, e) {
                return c.add(a, b, d), c.add(a, a, e), c.scale(a, a, 1 / 3), a;
            }, c.create = function() {
                var a = new d.ARRAY_TYPE(2);
                return a[0] = 0, a[1] = 0, a;
            }, c.clone = function(a) {
                var b = new d.ARRAY_TYPE(2);
                return b[0] = a[0], b[1] = a[1], b;
            }, c.fromValues = function(a, b) {
                var c = new d.ARRAY_TYPE(2);
                return c[0] = a, c[1] = b, c;
            }, c.copy = function(a, b) {
                return a[0] = b[0], a[1] = b[1], a;
            }, c.set = function(a, b, c) {
                return a[0] = b, a[1] = c, a;
            }, c.add = function(a, b, c) {
                return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
            }, c.subtract = function(a, b, c) {
                return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
            }, c.sub = c.subtract, c.multiply = function(a, b, c) {
                return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
            }, c.mul = c.multiply, c.divide = function(a, b, c) {
                return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
            }, c.div = c.divide, c.scale = function(a, b, c) {
                return a[0] = b[0] * c, a[1] = b[1] * c, a;
            }, c.distance = function(a, b) {
                var c = b[0] - a[0], d = b[1] - a[1];
                return Math.sqrt(c * c + d * d);
            }, c.dist = c.distance, c.squaredDistance = function(a, b) {
                var c = b[0] - a[0], d = b[1] - a[1];
                return c * c + d * d;
            }, c.sqrDist = c.squaredDistance, c.length = function(a) {
                var b = a[0], c = a[1];
                return Math.sqrt(b * b + c * c);
            }, c.len = c.length, c.squaredLength = function(a) {
                var b = a[0], c = a[1];
                return b * b + c * c;
            }, c.sqrLen = c.squaredLength, c.negate = function(a, b) {
                return a[0] = -b[0], a[1] = -b[1], a;
            }, c.normalize = function(a, b) {
                var c = b[0], d = b[1], e = c * c + d * d;
                return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a;
            }, c.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1];
            }, c.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")";
            }, c.lerp = function(a, b, c, d) {
                var e = b[0], f = b[1];
                return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a;
            }, c.reflect = function(a, b, c) {
                var d = b[0] * c[0] + b[1] * c[1];
                a[0] = b[0] - 2 * c[0] * d, a[1] = b[1] - 2 * c[1] * d;
            }, c.getLineSegmentsIntersection = function(a, b, d, e, f) {
                var g = c.getLineSegmentsIntersectionFraction(b, d, e, f);
                return 0 > g ? !1 : (a[0] = b[0] + g * (d[0] - b[0]), a[1] = b[1] + g * (d[1] - b[1]), 
                !0);
            }, c.getLineSegmentsIntersectionFraction = function(a, b, c, d) {
                var e, f, g = b[0] - a[0], h = b[1] - a[1], i = d[0] - c[0], j = d[1] - c[1];
                return e = (-h * (a[0] - c[0]) + g * (a[1] - c[1])) / (-i * h + g * j), f = (i * (a[1] - c[1]) - j * (a[0] - c[0])) / (-i * h + g * j), 
                e >= 0 && 1 >= e && f >= 0 && 1 >= f ? f : -1;
            };
        }, {
            "../utils/Utils": 57
        } ],
        31: [ function(a, b) {
            function c(a) {
                a = a || {}, j.call(this), this.id = a.id || ++c._idCounter, this.world = null, 
                this.shapes = [], this.mass = a.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, 
                this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!a.fixedRotation, 
                this.fixedX = !!a.fixedX, this.fixedY = !!a.fixedY, this.massMultiplier = d.create(), 
                this.position = d.fromValues(0, 0), a.position && d.copy(this.position, a.position), 
                this.interpolatedPosition = d.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = d.fromValues(0, 0), 
                this.previousAngle = 0, this.velocity = d.fromValues(0, 0), a.velocity && d.copy(this.velocity, a.velocity), 
                this.vlambda = d.fromValues(0, 0), this.wlambda = 0, this.angle = a.angle || 0, 
                this.angularVelocity = a.angularVelocity || 0, this.force = d.create(), a.force && d.copy(this.force, a.force), 
                this.angularForce = a.angularForce || 0, this.damping = "number" == typeof a.damping ? a.damping : .1, 
                this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : .1, 
                this.type = c.STATIC, this.type = "undefined" != typeof a.type ? a.type : a.mass ? c.DYNAMIC : c.STATIC, 
                this.boundingRadius = 0, this.aabb = new i(), this.aabbNeedsUpdate = !0, this.allowSleep = void 0 !== a.allowSleep ? a.allowSleep : !0, 
                this.wantsToSleep = !1, this.sleepState = c.AWAKE, this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : .2, 
                this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1, this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1, 
                this.collisionResponse = void 0 !== a.collisionResponse ? a.collisionResponse : !0, 
                this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1, 
                this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10, this.concavePath = null, 
                this._wakeUpAfterNarrowphase = !1, this.updateMassProperties();
            }
            var d = a("../math/vec2"), e = a("poly-decomp"), f = a("../shapes/Convex"), g = a("../collision/RaycastResult"), h = a("../collision/Ray"), i = a("../collision/AABB"), j = a("../events/EventEmitter");
            b.exports = c, c.prototype = new j(), c.prototype.constructor = c, c._idCounter = 0, 
            c.prototype.updateSolveMassProperties = function() {
                this.sleepState === c.SLEEPING || this.type === c.KINEMATIC ? (this.invMassSolve = 0, 
                this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia);
            }, c.prototype.setDensity = function(a) {
                var b = this.getArea();
                this.mass = b * a, this.updateMassProperties();
            }, c.prototype.getArea = function() {
                for (var a = 0, b = 0; b < this.shapes.length; b++) a += this.shapes[b].area;
                return a;
            }, c.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb;
            };
            var k = new i(), l = d.create();
            c.prototype.updateAABB = function() {
                for (var a = this.shapes, b = a.length, c = l, e = this.angle, f = 0; f !== b; f++) {
                    var g = a[f], h = g.angle + e;
                    d.rotate(c, g.position, e), d.add(c, c, this.position), g.computeAABB(k, c, h), 
                    0 === f ? this.aabb.copy(k) : this.aabb.extend(k);
                }
                this.aabbNeedsUpdate = !1;
            }, c.prototype.updateBoundingRadius = function() {
                for (var a = this.shapes, b = a.length, c = 0, e = 0; e !== b; e++) {
                    var f = a[e], g = d.length(f.position), h = f.boundingRadius;
                    g + h > c && (c = g + h);
                }
                this.boundingRadius = c;
            }, c.prototype.addShape = function(a, b, c) {
                if (a.body) throw new Error("A shape can only be added to one body.");
                a.body = this, b ? d.copy(a.position, b) : d.set(a.position, 0, 0), a.angle = c || 0, 
                this.shapes.push(a), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0;
            }, c.prototype.removeShape = function(a) {
                var b = this.shapes.indexOf(a);
                return -1 !== b ? (this.shapes.splice(b, 1), this.aabbNeedsUpdate = !0, a.body = null, 
                !0) : !1;
            }, c.prototype.updateMassProperties = function() {
                if (this.type === c.STATIC || this.type === c.KINEMATIC) this.mass = Number.MAX_VALUE, 
                this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0; else {
                    var a = this.shapes, b = a.length, e = this.mass / b, f = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0; else {
                        for (var g = 0; b > g; g++) {
                            var h = a[g], i = d.squaredLength(h.position), j = h.computeMomentOfInertia(e);
                            f += j + e * i;
                        }
                        this.inertia = f, this.invInertia = f > 0 ? 1 / f : 0;
                    }
                    this.invMass = 1 / this.mass, d.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
                }
            };
            d.create();
            c.prototype.applyForce = function(a, b) {
                if (d.add(this.force, this.force, a), b) {
                    var c = d.crossLength(b, a);
                    this.angularForce += c;
                }
            };
            var m = d.create(), n = d.create(), o = d.create();
            c.prototype.applyForceLocal = function(a, b) {
                b = b || o;
                var c = m, d = n;
                this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyForce(c, d);
            };
            var p = d.create();
            c.prototype.applyImpulse = function(a, b) {
                if (this.type === c.DYNAMIC) {
                    var e = p;
                    if (d.scale(e, a, this.invMass), d.multiply(e, this.massMultiplier, e), d.add(this.velocity, e, this.velocity), 
                    b) {
                        var f = d.crossLength(b, a);
                        f *= this.invInertia, this.angularVelocity += f;
                    }
                }
            };
            var q = d.create(), r = d.create(), s = d.create();
            c.prototype.applyImpulseLocal = function(a, b) {
                b = b || s;
                var c = q, d = r;
                this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyImpulse(c, d);
            }, c.prototype.toLocalFrame = function(a, b) {
                d.toLocalFrame(a, b, this.position, this.angle);
            }, c.prototype.toWorldFrame = function(a, b) {
                d.toGlobalFrame(a, b, this.position, this.angle);
            }, c.prototype.vectorToLocalFrame = function(a, b) {
                d.vectorToLocalFrame(a, b, this.angle);
            }, c.prototype.vectorToWorldFrame = function(a, b) {
                d.vectorToGlobalFrame(a, b, this.angle);
            }, c.prototype.fromPolygon = function(a, b) {
                b = b || {};
                for (var c = this.shapes.length; c >= 0; --c) this.removeShape(this.shapes[c]);
                var g = new e.Polygon();
                if (g.vertices = a, g.makeCCW(), "number" == typeof b.removeCollinearPoints && g.removeCollinearPoints(b.removeCollinearPoints), 
                "undefined" == typeof b.skipSimpleCheck && !g.isSimple()) return !1;
                this.concavePath = g.vertices.slice(0);
                for (var c = 0; c < this.concavePath.length; c++) {
                    var h = [ 0, 0 ];
                    d.copy(h, this.concavePath[c]), this.concavePath[c] = h;
                }
                var i;
                i = b.optimalDecomp ? g.decomp() : g.quickDecomp();
                for (var j = d.create(), c = 0; c !== i.length; c++) {
                    for (var k = new f({
                        vertices: i[c].vertices
                    }), l = 0; l !== k.vertices.length; l++) {
                        var h = k.vertices[l];
                        d.sub(h, h, k.centerOfMass);
                    }
                    d.scale(j, k.centerOfMass, 1), k.updateTriangles(), k.updateCenterOfMass(), k.updateBoundingRadius(), 
                    this.addShape(k, j);
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0;
            };
            var t = (d.fromValues(0, 0), d.fromValues(0, 0)), u = d.fromValues(0, 0), v = d.fromValues(0, 0);
            c.prototype.adjustCenterOfMass = function() {
                var a = t, b = u, c = v, e = 0;
                d.set(b, 0, 0);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    d.scale(a, g.position, g.area), d.add(b, b, a), e += g.area;
                }
                d.scale(c, b, 1 / e);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    d.sub(g.position, g.position, c);
                }
                d.add(this.position, this.position, c);
                for (var f = 0; this.concavePath && f < this.concavePath.length; f++) d.sub(this.concavePath[f], this.concavePath[f], c);
                this.updateMassProperties(), this.updateBoundingRadius();
            }, c.prototype.setZeroForce = function() {
                d.set(this.force, 0, 0), this.angularForce = 0;
            }, c.prototype.resetConstraintVelocity = function() {
                var a = this, b = a.vlambda;
                d.set(b, 0, 0), a.wlambda = 0;
            }, c.prototype.addConstraintVelocity = function() {
                var a = this, b = a.velocity;
                d.add(b, b, a.vlambda), a.angularVelocity += a.wlambda;
            }, c.prototype.applyDamping = function(a) {
                if (this.type === c.DYNAMIC) {
                    var b = this.velocity;
                    d.scale(b, b, Math.pow(1 - this.damping, a)), this.angularVelocity *= Math.pow(1 - this.angularDamping, a);
                }
            }, c.prototype.wakeUp = function() {
                var a = this.sleepState;
                this.sleepState = c.AWAKE, this.idleTime = 0, a !== c.AWAKE && this.emit(c.wakeUpEvent);
            }, c.prototype.sleep = function() {
                this.sleepState = c.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, d.set(this.velocity, 0, 0), 
                d.set(this.force, 0, 0), this.emit(c.sleepEvent);
            }, c.prototype.sleepTick = function(a, b, e) {
                if (this.allowSleep && this.type !== c.SLEEPING) {
                    this.wantsToSleep = !1;
                    var f = (this.sleepState, d.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)), g = Math.pow(this.sleepSpeedLimit, 2);
                    f >= g ? (this.idleTime = 0, this.sleepState = c.AWAKE) : (this.idleTime += e, this.sleepState = c.SLEEPY), 
                    this.idleTime > this.sleepTimeLimit && (b ? this.wantsToSleep = !0 : this.sleep());
                }
            }, c.prototype.overlaps = function(a) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, a);
            };
            var w = d.create(), x = d.create();
            c.prototype.integrate = function(a) {
                var b = this.invMass, c = this.force, e = this.position, f = this.velocity;
                d.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a), 
                d.scale(w, c, a * b), d.multiply(w, this.massMultiplier, w), d.add(f, w, f), this.integrateToTimeOfImpact(a) || (d.scale(x, f, a), 
                d.add(e, e, x), this.fixedRotation || (this.angle += this.angularVelocity * a)), 
                this.aabbNeedsUpdate = !0;
            };
            var y = new g(), z = new h({
                mode: h.ALL
            }), A = d.create(), B = d.create(), C = d.create(), D = d.create();
            c.prototype.integrateToTimeOfImpact = function(a) {
                if (this.ccdSpeedThreshold < 0 || d.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                d.normalize(A, this.velocity), d.scale(B, this.velocity, a), d.add(B, B, this.position), 
                d.sub(C, B, this.position);
                var b, c = this.angularVelocity * a, e = d.length(C), f = 1, g = this;
                if (y.reset(), z.callback = function(a) {
                    a.body !== g && (b = a.body, a.getHitPoint(B, z), d.sub(C, B, g.position), f = d.length(C) / e, 
                    a.stop());
                }, d.copy(z.from, this.position), d.copy(z.to, B), z.update(), this.world.raycast(y, z), 
                !b) return !1;
                var h = this.angle;
                d.copy(D, this.position);
                for (var i = 0, j = 0, k = 0, l = f; l >= j && i < this.ccdIterations; ) {
                    i++, k = (l - j) / 2, d.scale(x, C, f), d.add(this.position, D, x), this.angle = h + c * f, 
                    this.updateAABB();
                    var m = this.aabb.overlaps(b.aabb) && this.world.narrowphase.bodiesOverlap(this, b);
                    m ? j = k : l = k;
                }
                return f = k, d.copy(this.position, D), this.angle = h, d.scale(x, C, f), d.add(this.position, this.position, x), 
                this.fixedRotation || (this.angle += c * f), !0;
            }, c.prototype.getVelocityAtPoint = function(a, b) {
                return d.crossVZ(a, b, this.angularVelocity), d.subtract(a, this.velocity, a), a;
            }, c.sleepyEvent = {
                type: "sleepy"
            }, c.sleepEvent = {
                type: "sleep"
            }, c.wakeUpEvent = {
                type: "wakeup"
            }, c.DYNAMIC = 1, c.STATIC = 2, c.KINEMATIC = 4, c.AWAKE = 0, c.SLEEPY = 1, c.SLEEPING = 2;
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        } ],
        32: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, e.call(this, a, b, c), this.localAnchorA = d.fromValues(0, 0), this.localAnchorB = d.fromValues(0, 0), 
                c.localAnchorA && d.copy(this.localAnchorA, c.localAnchorA), c.localAnchorB && d.copy(this.localAnchorB, c.localAnchorB), 
                c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA), c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
                var f = d.create(), g = d.create();
                this.getWorldAnchorA(f), this.getWorldAnchorB(g);
                var h = d.distance(f, g);
                this.restLength = "number" == typeof c.restLength ? c.restLength : h;
            }
            {
                var d = a("../math/vec2"), e = a("./Spring");
                a("../utils/Utils");
            }
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.setWorldAnchorA = function(a) {
                this.bodyA.toLocalFrame(this.localAnchorA, a);
            }, c.prototype.setWorldAnchorB = function(a) {
                this.bodyB.toLocalFrame(this.localAnchorB, a);
            }, c.prototype.getWorldAnchorA = function(a) {
                this.bodyA.toWorldFrame(a, this.localAnchorA);
            }, c.prototype.getWorldAnchorB = function(a) {
                this.bodyB.toWorldFrame(a, this.localAnchorB);
            };
            var f = d.create(), g = d.create(), h = d.create(), i = d.create(), j = d.create(), k = d.create(), l = d.create(), m = d.create(), n = d.create();
            c.prototype.applyForce = function() {
                var a = this.stiffness, b = this.damping, c = this.restLength, e = this.bodyA, o = this.bodyB, p = f, q = g, r = h, s = i, t = n, u = j, v = k, w = l, x = m;
                this.getWorldAnchorA(u), this.getWorldAnchorB(v), d.sub(w, u, e.position), d.sub(x, v, o.position), 
                d.sub(p, v, u);
                var y = d.len(p);
                d.normalize(q, p), d.sub(r, o.velocity, e.velocity), d.crossZV(t, o.angularVelocity, x), 
                d.add(r, r, t), d.crossZV(t, e.angularVelocity, w), d.sub(r, r, t), d.scale(s, q, -a * (y - c) - b * d.dot(r, q)), 
                d.sub(e.force, e.force, s), d.add(o.force, o.force, s);
                var z = d.crossLength(w, s), A = d.crossLength(x, s);
                e.angularForce -= z, o.angularForce += A;
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        } ],
        33: [ function(a, b) {
            function c(a, b, c) {
                c = c || {}, d.call(this, a, b, c), this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle;
            }
            var d = (a("../math/vec2"), a("./Spring"));
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.applyForce = function() {
                var a = this.stiffness, b = this.damping, c = this.restAngle, d = this.bodyA, e = this.bodyB, f = e.angle - d.angle, g = e.angularVelocity - d.angularVelocity, h = -a * (f - c) - b * g * 0;
                d.angularForce -= h, e.angularForce += h;
            };
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        } ],
        34: [ function(a, b) {
            function c(a, b, c) {
                c = d.defaults(c, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = c.stiffness, this.damping = c.damping, this.bodyA = a, this.bodyB = b;
            }
            var d = (a("../math/vec2"), a("../utils/Utils"));
            b.exports = c, c.prototype.applyForce = function() {};
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        } ],
        35: [ function(a, b) {
            function c(a, b) {
                b = b || {}, this.chassisBody = a, this.wheels = [], this.groundBody = new h({
                    mass: 0
                }), this.world = null;
                var c = this;
                this.preStepCallback = function() {
                    c.update();
                };
            }
            function d(a, b) {
                b = b || {}, this.vehicle = a, this.forwardEquation = new g(a.chassisBody, a.groundBody), 
                this.sideEquation = new g(a.chassisBody, a.groundBody), this.steerValue = 0, this.engineForce = 0, 
                this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5), this.localForwardVector = e.fromValues(0, 1), 
                b.localForwardVector && e.copy(this.localForwardVector, b.localForwardVector), this.localPosition = e.fromValues(0, 0), 
                b.localPosition && e.copy(this.localPosition, b.localPosition), f.apply(this, a.chassisBody, a.groundBody), 
                this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0);
            }
            var e = a("../math/vec2"), f = (a("../utils/Utils"), a("../constraints/Constraint")), g = a("../equations/FrictionEquation"), h = a("../objects/Body");
            b.exports = c, c.prototype.addToWorld = function(a) {
                this.world = a, a.addBody(this.groundBody), a.on("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.addConstraint(c);
                }
            }, c.prototype.removeFromWorld = function() {
                var a = this.world;
                a.removeBody(this.groundBody), a.off("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.removeConstraint(c);
                }
                this.world = null;
            }, c.prototype.addWheel = function(a) {
                var b = new d(this, a);
                return this.wheels.push(b), b;
            }, c.prototype.update = function() {
                for (var a = 0; a < this.wheels.length; a++) this.wheels[a].update();
            }, d.prototype = new f(), d.prototype.setBrakeForce = function(a) {
                this.forwardEquation.setSlipForce(a);
            }, d.prototype.setSideFriction = function(a) {
                this.sideEquation.setSlipForce(a);
            };
            var i = e.create(), j = e.create();
            d.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(j, this.localForwardVector), 
                this.vehicle.chassisBody.getVelocityAtPoint(i, j), e.dot(i, j);
            };
            var k = e.create();
            d.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), 
                e.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), 
                e.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), e.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), 
                this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), 
                e.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), 
                e.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), e.normalize(k, this.forwardEquation.t), 
                e.scale(k, k, this.engineForce), this.vehicle.chassisBody.applyForce(k, this.forwardEquation.contactPointA);
            };
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        } ],
        36: [ function(a, b) {
            var c = b.exports = {
                AABB: a("./collision/AABB"),
                AngleLockEquation: a("./equations/AngleLockEquation"),
                Body: a("./objects/Body"),
                Broadphase: a("./collision/Broadphase"),
                Capsule: a("./shapes/Capsule"),
                Circle: a("./shapes/Circle"),
                Constraint: a("./constraints/Constraint"),
                ContactEquation: a("./equations/ContactEquation"),
                ContactEquationPool: a("./utils/ContactEquationPool"),
                ContactMaterial: a("./material/ContactMaterial"),
                Convex: a("./shapes/Convex"),
                DistanceConstraint: a("./constraints/DistanceConstraint"),
                Equation: a("./equations/Equation"),
                EventEmitter: a("./events/EventEmitter"),
                FrictionEquation: a("./equations/FrictionEquation"),
                FrictionEquationPool: a("./utils/FrictionEquationPool"),
                GearConstraint: a("./constraints/GearConstraint"),
                GSSolver: a("./solver/GSSolver"),
                Heightfield: a("./shapes/Heightfield"),
                Line: a("./shapes/Line"),
                LockConstraint: a("./constraints/LockConstraint"),
                Material: a("./material/Material"),
                Narrowphase: a("./collision/Narrowphase"),
                NaiveBroadphase: a("./collision/NaiveBroadphase"),
                Particle: a("./shapes/Particle"),
                Plane: a("./shapes/Plane"),
                Pool: a("./utils/Pool"),
                RevoluteConstraint: a("./constraints/RevoluteConstraint"),
                PrismaticConstraint: a("./constraints/PrismaticConstraint"),
                Ray: a("./collision/Ray"),
                RaycastResult: a("./collision/RaycastResult"),
                Box: a("./shapes/Box"),
                RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
                SAPBroadphase: a("./collision/SAPBroadphase"),
                Shape: a("./shapes/Shape"),
                Solver: a("./solver/Solver"),
                Spring: a("./objects/Spring"),
                TopDownVehicle: a("./objects/TopDownVehicle"),
                LinearSpring: a("./objects/LinearSpring"),
                RotationalSpring: a("./objects/RotationalSpring"),
                Utils: a("./utils/Utils"),
                World: a("./world/World"),
                vec2: a("./math/vec2"),
                version: a("../package.json").version
            };
            Object.defineProperty(c, "Rectangle", {
                get: function() {
                    return console.warn("The Rectangle class has been renamed to Box."), this.Box;
                }
            });
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        } ],
        37: [ function(a, b) {
            function c(a) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                    width: arguments[0],
                    height: arguments[1]
                }, console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")), 
                a = a || {};
                var b = this.width = a.width || 1, c = this.height = a.height || 1, g = [ d.fromValues(-b / 2, -c / 2), d.fromValues(b / 2, -c / 2), d.fromValues(b / 2, c / 2), d.fromValues(-b / 2, c / 2) ], h = [ d.fromValues(1, 0), d.fromValues(0, 1) ];
                a.vertices = g, a.axes = h, a.type = e.BOX, f.call(this, a);
            }
            var d = a("../math/vec2"), e = a("./Shape"), f = a("./Convex");
            b.exports = c, c.prototype = new f(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function(a) {
                var b = this.width, c = this.height;
                return a * (c * c + b * b) / 12;
            }, c.prototype.updateBoundingRadius = function() {
                var a = this.width, b = this.height;
                this.boundingRadius = Math.sqrt(a * a + b * b) / 2;
            };
            d.create(), d.create(), d.create(), d.create();
            c.prototype.computeAABB = function(a, b, c) {
                a.setFromPoints(this.vertices, b, c, 0);
            }, c.prototype.updateArea = function() {
                this.area = this.width * this.height;
            };
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        } ],
        38: [ function(a, b) {
            function c(a) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                    length: arguments[0],
                    radius: arguments[1]
                }, console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")), 
                a = a || {}, this.length = a.length || 1, this.radius = a.radius || 1, a.type = d.CAPSULE, 
                d.call(this, a);
            }
            var d = a("./Shape"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius, c = this.length + b, d = 2 * b;
                return a * (d * d + c * c) / 12;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2;
            }, c.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length;
            };
            var f = e.create();
            c.prototype.computeAABB = function(a, b, c) {
                var d = this.radius;
                e.set(f, this.length / 2, 0), 0 !== c && e.rotate(f, f, c), e.set(a.upperBound, Math.max(f[0] + d, -f[0] + d), Math.max(f[1] + d, -f[1] + d)), 
                e.set(a.lowerBound, Math.min(f[0] - d, -f[0] - d), Math.min(f[1] - d, -f[1] - d)), 
                e.add(a.lowerBound, a.lowerBound, b), e.add(a.upperBound, a.upperBound, b);
            };
            var g = e.create(), h = e.create(), i = e.create(), j = e.create(), k = e.fromValues(0, 1);
            c.prototype.raycast = function(a, b, c, d) {
                for (var f = b.from, l = b.to, m = (b.direction, g), n = h, o = i, p = j, q = this.length / 2, r = 0; 2 > r; r++) {
                    var s = this.radius * (2 * r - 1);
                    e.set(o, -q, s), e.set(p, q, s), e.toGlobalFrame(o, o, c, d), e.toGlobalFrame(p, p, c, d);
                    var t = e.getLineSegmentsIntersectionFraction(f, l, o, p);
                    if (t >= 0 && (e.rotate(n, k, d), e.scale(n, n, 2 * r - 1), b.reportIntersection(a, t, n, -1), 
                    a.shouldStop(b))) return;
                }
                for (var u = Math.pow(this.radius, 2) + Math.pow(q, 2), r = 0; 2 > r; r++) {
                    e.set(o, q * (2 * r - 1), 0), e.toGlobalFrame(o, o, c, d);
                    var v = Math.pow(l[0] - f[0], 2) + Math.pow(l[1] - f[1], 2), w = 2 * ((l[0] - f[0]) * (f[0] - o[0]) + (l[1] - f[1]) * (f[1] - o[1])), x = Math.pow(f[0] - o[0], 2) + Math.pow(f[1] - o[1], 2) - Math.pow(this.radius, 2), t = Math.pow(w, 2) - 4 * v * x;
                    if (!(0 > t)) if (0 === t) {
                        if (e.lerp(m, f, l, t), e.squaredDistance(m, c) > u && (e.sub(n, m, o), e.normalize(n, n), 
                        b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return;
                    } else {
                        var y = Math.sqrt(t), z = 1 / (2 * v), A = (-w - y) * z, B = (-w + y) * z;
                        if (A >= 0 && 1 >= A && (e.lerp(m, f, l, A), e.squaredDistance(m, c) > u && (e.sub(n, m, o), 
                        e.normalize(n, n), b.reportIntersection(a, A, n, -1), a.shouldStop(b)))) return;
                        if (B >= 0 && 1 >= B && (e.lerp(m, f, l, B), e.squaredDistance(m, c) > u && (e.sub(n, m, o), 
                        e.normalize(n, n), b.reportIntersection(a, B, n, -1), a.shouldStop(b)))) return;
                    }
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        39: [ function(a, b) {
            function c(a) {
                "number" == typeof arguments[0] && (a = {
                    radius: arguments[0]
                }, console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")), 
                a = a || {}, this.radius = a.radius || 1, a.type = d.CIRCLE, d.call(this, a);
            }
            var d = a("./Shape"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius;
                return a * b * b / 2;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius;
            }, c.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius;
            }, c.prototype.computeAABB = function(a, b) {
                var c = this.radius;
                e.set(a.upperBound, c, c), e.set(a.lowerBound, -c, -c), b && (e.add(a.lowerBound, a.lowerBound, b), 
                e.add(a.upperBound, a.upperBound, b));
            };
            var f = e.create(), g = e.create();
            c.prototype.raycast = function(a, b, c) {
                var d = b.from, h = b.to, i = this.radius, j = Math.pow(h[0] - d[0], 2) + Math.pow(h[1] - d[1], 2), k = 2 * ((h[0] - d[0]) * (d[0] - c[0]) + (h[1] - d[1]) * (d[1] - c[1])), l = Math.pow(d[0] - c[0], 2) + Math.pow(d[1] - c[1], 2) - Math.pow(i, 2), m = Math.pow(k, 2) - 4 * j * l, n = f, o = g;
                if (!(0 > m)) if (0 === m) e.lerp(n, d, h, m), e.sub(o, n, c), e.normalize(o, o), 
                b.reportIntersection(a, m, o, -1); else {
                    var p = Math.sqrt(m), q = 1 / (2 * j), r = (-k - p) * q, s = (-k + p) * q;
                    if (r >= 0 && 1 >= r && (e.lerp(n, d, h, r), e.sub(o, n, c), e.normalize(o, o), 
                    b.reportIntersection(a, r, o, -1), a.shouldStop(b))) return;
                    s >= 0 && 1 >= s && (e.lerp(n, d, h, s), e.sub(o, n, c), e.normalize(o, o), b.reportIntersection(a, s, o, -1));
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        40: [ function(a, b) {
            function c(a) {
                Array.isArray(arguments[0]) && (a = {
                    vertices: arguments[0],
                    axes: arguments[1]
                }, console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")), 
                a = a || {}, this.vertices = [];
                for (var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++) {
                    var f = e.create();
                    e.copy(f, b[c]), this.vertices.push(f);
                }
                if (this.axes = [], a.axes) for (var c = 0; c < a.axes.length; c++) {
                    var g = e.create();
                    e.copy(g, a.axes[c]), this.axes.push(g);
                } else for (var c = 0; c < this.vertices.length; c++) {
                    var h = this.vertices[c], i = this.vertices[(c + 1) % this.vertices.length], j = e.create();
                    e.sub(j, i, h), e.rotate90cw(j, j), e.normalize(j, j), this.axes.push(j);
                }
                if (this.centerOfMass = e.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), 
                this.updateCenterOfMass()), this.boundingRadius = 0, a.type = d.CONVEX, d.call(this, a), 
                this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.");
            }
            {
                var d = a("./Shape"), e = a("../math/vec2"), f = a("../math/polyk");
                a("poly-decomp");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c;
            var g = e.create(), h = e.create();
            c.prototype.projectOntoLocalAxis = function(a, b) {
                for (var c, d, f = null, h = null, a = g, i = 0; i < this.vertices.length; i++) c = this.vertices[i], 
                d = e.dot(c, a), (null === f || d > f) && (f = d), (null === h || h > d) && (h = d);
                if (h > f) {
                    var j = h;
                    h = f, f = j;
                }
                e.set(b, h, f);
            }, c.prototype.projectOntoWorldAxis = function(a, b, c, d) {
                var f = h;
                this.projectOntoLocalAxis(a, d), 0 !== c ? e.rotate(f, a, c) : f = a;
                var g = e.dot(b, f);
                e.set(d, d[0] + g, d[1] + g);
            }, c.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var a = [], b = 0; b < this.vertices.length; b++) {
                    var c = this.vertices[b];
                    a.push(c[0], c[1]);
                }
                for (var d = f.Triangulate(a), b = 0; b < d.length; b += 3) {
                    var e = d[b], g = d[b + 1], h = d[b + 2];
                    this.triangles.push([ e, g, h ]);
                }
            };
            {
                var i = e.create(), j = e.create(), k = e.create(), l = e.create(), m = e.create();
                e.create(), e.create(), e.create(), e.create();
            }
            c.prototype.updateCenterOfMass = function() {
                var a = this.triangles, b = this.vertices, d = this.centerOfMass, f = i, g = k, h = l, n = m, o = j;
                e.set(d, 0, 0);
                for (var p = 0, q = 0; q !== a.length; q++) {
                    var r = a[q], g = b[r[0]], h = b[r[1]], n = b[r[2]];
                    e.centroid(f, g, h, n);
                    var s = c.triangleArea(g, h, n);
                    p += s, e.scale(o, f, s), e.add(d, d, o);
                }
                e.scale(d, d, 1 / p);
            }, c.prototype.computeMomentOfInertia = function(a) {
                for (var b = 0, c = 0, d = this.vertices.length, f = d - 1, g = 0; d > g; f = g, 
                g++) {
                    var h = this.vertices[f], i = this.vertices[g], j = Math.abs(e.crossLength(h, i)), k = e.dot(i, i) + e.dot(i, h) + e.dot(h, h);
                    b += j * k, c += j;
                }
                return a / 6 * (b / c);
            }, c.prototype.updateBoundingRadius = function() {
                for (var a = this.vertices, b = 0, c = 0; c !== a.length; c++) {
                    var d = e.squaredLength(a[c]);
                    d > b && (b = d);
                }
                this.boundingRadius = Math.sqrt(b);
            }, c.triangleArea = function(a, b, c) {
                return .5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]));
            }, c.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var a = this.triangles, b = this.vertices, d = 0; d !== a.length; d++) {
                    var e = a[d], f = b[e[0]], g = b[e[1]], h = b[e[2]], i = c.triangleArea(f, g, h);
                    this.area += i;
                }
            }, c.prototype.computeAABB = function(a, b, c) {
                a.setFromPoints(this.vertices, b, c, 0);
            };
            var n = e.create(), o = e.create(), p = e.create();
            c.prototype.raycast = function(a, b, c, d) {
                var f = n, g = o, h = p, i = this.vertices;
                e.toLocalFrame(f, b.from, c, d), e.toLocalFrame(g, b.to, c, d);
                for (var j = i.length, k = 0; j > k && !a.shouldStop(b); k++) {
                    var l = i[k], m = i[(k + 1) % j], q = e.getLineSegmentsIntersectionFraction(f, g, l, m);
                    q >= 0 && (e.sub(h, m, l), e.rotate(h, h, -Math.PI / 2 + d), e.normalize(h, h), 
                    b.reportIntersection(a, q, h, k));
                }
            };
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        } ],
        41: [ function(a, b) {
            function c(a) {
                if (Array.isArray(arguments[0])) {
                    if (a = {
                        heights: arguments[0]
                    }, "object" == typeof arguments[1]) for (var b in arguments[1]) a[b] = arguments[1][b];
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })");
                }
                a = a || {}, this.heights = a.heights ? a.heights.slice(0) : [], this.maxValue = a.maxValue || null, 
                this.minValue = a.minValue || null, this.elementWidth = a.elementWidth || .1, (void 0 === a.maxValue || void 0 === a.minValue) && this.updateMaxMinValues(), 
                a.type = d.HEIGHTFIELD, d.call(this, a);
            }
            {
                var d = a("./Shape"), e = a("../math/vec2");
                a("../utils/Utils");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.updateMaxMinValues = function() {
                for (var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++) {
                    var e = a[d];
                    e > b && (b = e), c > e && (c = e);
                }
                this.maxValue = b, this.minValue = c;
            }, c.prototype.computeMomentOfInertia = function() {
                return Number.MAX_VALUE;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            }, c.prototype.updateArea = function() {
                for (var a = this.heights, b = 0, c = 0; c < a.length - 1; c++) b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
                this.area = b;
            };
            var f = [ e.create(), e.create(), e.create(), e.create() ];
            c.prototype.computeAABB = function(a, b, c) {
                e.set(f[0], 0, this.maxValue), e.set(f[1], this.elementWidth * this.heights.length, this.maxValue), 
                e.set(f[2], this.elementWidth * this.heights.length, this.minValue), e.set(f[3], 0, this.minValue), 
                a.setFromPoints(f, b, c);
            }, c.prototype.getLineSegment = function(a, b, c) {
                var d = this.heights, f = this.elementWidth;
                e.set(a, c * f, d[c]), e.set(b, (c + 1) * f, d[c + 1]);
            }, c.prototype.getSegmentIndex = function(a) {
                return Math.floor(a[0] / this.elementWidth);
            }, c.prototype.getClampedSegmentIndex = function(a) {
                var b = this.getSegmentIndex(a);
                return b = Math.min(this.heights.length, Math.max(b, 0));
            };
            {
                var g = (e.create(), e.create()), h = e.create(), i = e.create(), j = e.create(), k = e.create();
                e.fromValues(0, 1);
            }
            c.prototype.raycast = function(a, b, c, d) {
                var f = b.from, l = b.to, m = (b.direction, g), n = h, o = i, p = j, q = k;
                e.toLocalFrame(p, f, c, d), e.toLocalFrame(q, l, c, d);
                var r = this.getClampedSegmentIndex(p), s = this.getClampedSegmentIndex(q);
                if (r > s) {
                    var t = r;
                    r = s, s = t;
                }
                for (var u = 0; u < this.heights.length - 1; u++) {
                    this.getLineSegment(n, o, u);
                    var v = e.getLineSegmentsIntersectionFraction(p, q, n, o);
                    if (v >= 0 && (e.sub(m, o, n), e.rotate(m, m, d + Math.PI / 2), e.normalize(m, m), 
                    b.reportIntersection(a, v, m, -1), a.shouldStop(b))) return;
                }
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        } ],
        42: [ function(a, b) {
            function c(a) {
                "number" == typeof arguments[0] && (a = {
                    length: arguments[0]
                }, console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")), 
                a = a || {}, this.length = a.length || 1, a.type = d.LINE, d.call(this, a);
            }
            var d = a("./Shape"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function(a) {
                return a * Math.pow(this.length, 2) / 12;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2;
            };
            var f = [ e.create(), e.create() ];
            c.prototype.computeAABB = function(a, b, c) {
                var d = this.length / 2;
                e.set(f[0], -d, 0), e.set(f[1], d, 0), a.setFromPoints(f, b, c, 0);
            };
            var g = (e.create(), e.create()), h = e.create(), i = e.create(), j = e.fromValues(0, 1);
            c.prototype.raycast = function(a, b, c, d) {
                var f = b.from, k = b.to, l = h, m = i, n = this.length / 2;
                e.set(l, -n, 0), e.set(m, n, 0), e.toGlobalFrame(l, l, c, d), e.toGlobalFrame(m, m, c, d);
                var o = e.getLineSegmentsIntersectionFraction(l, m, f, k);
                if (o >= 0) {
                    var p = g;
                    e.rotate(p, j, d), b.reportIntersection(a, o, p, -1);
                }
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        43: [ function(a, b) {
            function c(a) {
                a = a || {}, a.type = d.PARTICLE, d.call(this, a);
            }
            var d = a("./Shape"), e = a("../math/vec2");
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function() {
                return 0;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0;
            }, c.prototype.computeAABB = function(a, b) {
                e.copy(a.lowerBound, b), e.copy(a.upperBound, b);
            };
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        } ],
        44: [ function(a, b) {
            function c(a) {
                a = a || {}, a.type = d.PLANE, d.call(this, a);
            }
            {
                var d = a("./Shape"), e = a("../math/vec2");
                a("../utils/Utils");
            }
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.computeMomentOfInertia = function() {
                return 0;
            }, c.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            }, c.prototype.computeAABB = function(a, b, c) {
                var d = c % (2 * Math.PI), f = e.set, g = Number.MAX_VALUE, h = a.lowerBound, i = a.upperBound;
                0 === d ? (f(h, -g, -g), f(i, g, 0)) : d === Math.PI / 2 ? (f(h, 0, -g), f(i, g, g)) : d === Math.PI ? (f(h, -g, 0), 
                f(i, g, g)) : d === 3 * Math.PI / 2 ? (f(h, -g, -g), f(i, 0, g)) : (f(h, -g, -g), 
                f(i, g, g)), e.add(h, h, b), e.add(i, i, b);
            }, c.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE;
            };
            var f = e.create(), g = (e.create(), e.create(), e.create()), h = e.create();
            c.prototype.raycast = function(a, b, c, d) {
                var i = b.from, j = b.to, k = b.direction, l = f, m = g, n = h;
                e.set(m, 0, 1), e.rotate(m, m, d), e.sub(n, i, c);
                var o = e.dot(n, m);
                e.sub(n, j, c);
                var p = e.dot(n, m);
                if (!(o * p > 0 || e.squaredDistance(i, j) < o * o)) {
                    var q = e.dot(m, k);
                    e.sub(l, i, c);
                    var r = -e.dot(m, l) / q / b.length;
                    b.reportIntersection(a, r, m, -1);
                }
            };
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        } ],
        45: [ function(a, b) {
            function c(a) {
                a = a || {}, this.body = null, this.position = d.fromValues(0, 0), a.position && d.copy(this.position, a.position), 
                this.angle = a.angle || 0, this.type = a.type || 0, this.id = c.idCounter++, this.boundingRadius = 0, 
                this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1, this.collisionResponse = void 0 !== a.collisionResponse ? a.collisionResponse : !0, 
                this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1, this.material = a.material || null, 
                this.area = 0, this.sensor = void 0 !== a.sensor ? a.sensor : !1, this.type && this.updateBoundingRadius(), 
                this.updateArea();
            }
            b.exports = c;
            var d = a("../math/vec2");
            c.idCounter = 0, c.CIRCLE = 1, c.PARTICLE = 2, c.PLANE = 4, c.CONVEX = 8, c.LINE = 16, 
            c.BOX = 32, Object.defineProperty(c, "RECTANGLE", {
                get: function() {
                    return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."), c.BOX;
                }
            }), c.CAPSULE = 64, c.HEIGHTFIELD = 128, c.prototype.computeMomentOfInertia = function() {}, 
            c.prototype.updateBoundingRadius = function() {}, c.prototype.updateArea = function() {}, 
            c.prototype.computeAABB = function() {}, c.prototype.raycast = function() {};
        }, {
            "../math/vec2": 30
        } ],
        46: [ function(a, b) {
            function c(a) {
                f.call(this, a, f.GS), a = a || {}, this.iterations = a.iterations || 10, this.tolerance = a.tolerance || 1e-7, 
                this.arrayStep = 30, this.lambda = new g.ARRAY_TYPE(this.arrayStep), this.Bs = new g.ARRAY_TYPE(this.arrayStep), 
                this.invCs = new g.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, 
                this.usedIterations = 0;
            }
            function d(a) {
                for (var b = a.length; b--; ) a[b] = 0;
            }
            var e = a("../math/vec2"), f = a("./Solver"), g = a("../utils/Utils"), h = a("../equations/FrictionEquation");
            b.exports = c, c.prototype = new f(), c.prototype.constructor = c, c.prototype.solve = function(a, b) {
                this.sortEquations();
                var f = 0, i = this.iterations, j = this.frictionIterations, k = this.equations, l = k.length, m = Math.pow(this.tolerance * l, 2), n = b.bodies, o = b.bodies.length, p = (e.add, 
                e.set, this.useZeroRHS), q = this.lambda;
                if (this.usedIterations = 0, l) for (var r = 0; r !== o; r++) {
                    var s = n[r];
                    s.updateSolveMassProperties();
                }
                q.length < l && (q = this.lambda = new g.ARRAY_TYPE(l + this.arrayStep), this.Bs = new g.ARRAY_TYPE(l + this.arrayStep), 
                this.invCs = new g.ARRAY_TYPE(l + this.arrayStep)), d(q);
                for (var t = this.invCs, u = this.Bs, q = this.lambda, r = 0; r !== k.length; r++) {
                    var v = k[r];
                    (v.timeStep !== a || v.needsUpdate) && (v.timeStep = a, v.update()), u[r] = v.computeB(v.a, v.b, a), 
                    t[r] = v.computeInvC(v.epsilon);
                }
                var v, w, r, x;
                if (0 !== l) {
                    for (r = 0; r !== o; r++) {
                        var s = n[r];
                        s.resetConstraintVelocity();
                    }
                    if (j) {
                        for (f = 0; f !== j; f++) {
                            for (w = 0, x = 0; x !== l; x++) {
                                v = k[x];
                                var y = c.iterateEquation(x, v, v.epsilon, u, t, q, p, a, f);
                                w += Math.abs(y);
                            }
                            if (this.usedIterations++, m >= w * w) break;
                        }
                        for (c.updateMultipliers(k, q, 1 / a), x = 0; x !== l; x++) {
                            var z = k[x];
                            if (z instanceof h) {
                                for (var A = 0, B = 0; B !== z.contactEquations.length; B++) A += z.contactEquations[B].multiplier;
                                A *= z.frictionCoefficient / z.contactEquations.length, z.maxForce = A, z.minForce = -A;
                            }
                        }
                    }
                    for (f = 0; f !== i; f++) {
                        for (w = 0, x = 0; x !== l; x++) {
                            v = k[x];
                            var y = c.iterateEquation(x, v, v.epsilon, u, t, q, p, a, f);
                            w += Math.abs(y);
                        }
                        if (this.usedIterations++, m >= w * w) break;
                    }
                    for (r = 0; r !== o; r++) n[r].addConstraintVelocity();
                    c.updateMultipliers(k, q, 1 / a);
                }
            }, c.updateMultipliers = function(a, b, c) {
                for (var d = a.length; d--; ) a[d].multiplier = b[d] * c;
            }, c.iterateEquation = function(a, b, c, d, e, f, g, h) {
                var i = d[a], j = e[a], k = f[a], l = b.computeGWlambda(), m = b.maxForce, n = b.minForce;
                g && (i = 0);
                var o = j * (i - l - c * k), p = k + o;
                return n * h > p ? o = n * h - k : p > m * h && (o = m * h - k), f[a] += o, b.addToWlambda(o), 
                o;
            };
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        } ],
        47: [ function(a, b) {
            function c(a, b) {
                a = a || {}, d.call(this), this.type = b, this.equations = [], this.equationSortFunction = a.equationSortFunction || !1;
            }
            var d = (a("../utils/Utils"), a("../events/EventEmitter"));
            b.exports = c, c.prototype = new d(), c.prototype.constructor = c, c.prototype.solve = function() {
                throw new Error("Solver.solve should be implemented by subclasses!");
            };
            var e = {
                bodies: []
            };
            c.prototype.solveIsland = function(a, b) {
                this.removeAllEquations(), b.equations.length && (this.addEquations(b.equations), 
                e.bodies.length = 0, b.getBodies(e.bodies), e.bodies.length && this.solve(a, e));
            }, c.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction);
            }, c.prototype.addEquation = function(a) {
                a.enabled && this.equations.push(a);
            }, c.prototype.addEquations = function(a) {
                for (var b = 0, c = a.length; b !== c; b++) {
                    var d = a[b];
                    d.enabled && this.equations.push(d);
                }
            }, c.prototype.removeEquation = function(a) {
                var b = this.equations.indexOf(a);
                -1 !== b && this.equations.splice(b, 1);
            }, c.prototype.removeAllEquations = function() {
                this.equations.length = 0;
            }, c.GS = 1, c.ISLAND = 2;
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        } ],
        48: [ function(a, b) {
            function c() {
                e.apply(this, arguments);
            }
            var d = a("../equations/ContactEquation"), e = a("./Pool");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.create = function() {
                return new d();
            }, c.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = null, this;
            };
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        } ],
        49: [ function(a, b) {
            function c() {
                e.apply(this, arguments);
            }
            var d = a("../equations/FrictionEquation"), e = a("./Pool");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.create = function() {
                return new d();
            }, c.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = null, this;
            };
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        } ],
        50: [ function(a, b) {
            function c() {
                e.apply(this, arguments);
            }
            var d = a("../world/IslandNode"), e = a("./Pool");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.create = function() {
                return new d();
            }, c.prototype.destroy = function(a) {
                return a.reset(), this;
            };
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        } ],
        51: [ function(a, b) {
            function c() {
                e.apply(this, arguments);
            }
            var d = a("../world/Island"), e = a("./Pool");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.create = function() {
                return new d();
            }, c.prototype.destroy = function(a) {
                return a.reset(), this;
            };
        }, {
            "../world/Island": 58,
            "./Pool": 55
        } ],
        52: [ function(a, b) {
            function c() {
                this.overlappingShapesLastState = new d(), this.overlappingShapesCurrentState = new d(), 
                this.recordPool = new e({
                    size: 16
                }), this.tmpDict = new d(), this.tmpArray1 = [];
            }
            {
                var d = a("./TupleDictionary"), e = (a("./OverlapKeeperRecord"), a("./OverlapKeeperRecordPool"));
                a("./Utils");
            }
            b.exports = c, c.prototype.tick = function() {
                for (var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--; ) {
                    {
                        var d = a.keys[c], e = a.getByKey(d);
                        b.getByKey(d);
                    }
                    e && this.recordPool.release(e);
                }
                a.reset(), a.copy(b), b.reset();
            }, c.prototype.setOverlapping = function(a, b, c, d) {
                var e = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
                if (!e.get(b.id, d.id)) {
                    var f = this.recordPool.get();
                    f.set(a, b, c, d), e.set(b.id, d.id, f);
                }
            }, c.prototype.getNewOverlaps = function(a) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a);
            }, c.prototype.getEndOverlaps = function(a) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a);
            }, c.prototype.bodiesAreOverlapping = function(a, b) {
                for (var c = this.overlappingShapesCurrentState, d = c.keys.length; d--; ) {
                    var e = c.keys[d], f = c.data[e];
                    if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a) return !0;
                }
                return !1;
            }, c.prototype.getDiff = function(a, b, c) {
                var c = c || [], d = a, e = b;
                c.length = 0;
                for (var f = e.keys.length; f--; ) {
                    var g = e.keys[f], h = e.data[g];
                    if (!h) throw new Error("Key " + g + " had no data!");
                    var i = d.data[g];
                    i || c.push(h);
                }
                return c;
            }, c.prototype.isNewOverlap = function(a, b) {
                var c = 0 | a.id, d = 0 | b.id, e = this.overlappingShapesLastState, f = this.overlappingShapesCurrentState;
                return !e.get(c, d) && !!f.get(c, d);
            }, c.prototype.getNewBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a);
            }, c.prototype.getEndBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a);
            }, c.prototype.getBodyDiff = function(a, b) {
                b = b || [];
                for (var c = this.tmpDict, d = a.length; d--; ) {
                    var e = a[d];
                    c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e);
                }
                for (d = c.keys.length; d--; ) {
                    var e = c.getByKey(c.keys[d]);
                    e && b.push(e.bodyA, e.bodyB);
                }
                return c.reset(), b;
            };
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        } ],
        53: [ function(a, b) {
            function c(a, b, c, d) {
                this.shapeA = b, this.shapeB = d, this.bodyA = a, this.bodyB = c;
            }
            b.exports = c, c.prototype.set = function(a, b, d, e) {
                c.call(this, a, b, d, e);
            };
        }, {} ],
        54: [ function(a, b) {
            function c() {
                e.apply(this, arguments);
            }
            var d = a("./OverlapKeeperRecord"), e = a("./Pool");
            b.exports = c, c.prototype = new e(), c.prototype.constructor = c, c.prototype.create = function() {
                return new d();
            }, c.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = a.shapeA = a.shapeB = null, this;
            };
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        } ],
        55: [ function(a, b) {
            function c(a) {
                a = a || {}, this.objects = [], void 0 !== a.size && this.resize(a.size);
            }
            b.exports = c, c.prototype.resize = function(a) {
                for (var b = this.objects; b.length > a; ) b.pop();
                for (;b.length < a; ) b.push(this.create());
                return this;
            }, c.prototype.get = function() {
                var a = this.objects;
                return a.length ? a.pop() : this.create();
            }, c.prototype.release = function(a) {
                return this.destroy(a), this.objects.push(a), this;
            };
        }, {} ],
        56: [ function(a, b) {
            function c() {
                this.data = {}, this.keys = [];
            }
            var d = a("./Utils");
            b.exports = c, c.prototype.getKey = function(a, b) {
                return a = 0 | a, b = 0 | b, (0 | a) === (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a);
            }, c.prototype.getByKey = function(a) {
                return a = 0 | a, this.data[a];
            }, c.prototype.get = function(a, b) {
                return this.data[this.getKey(a, b)];
            }, c.prototype.set = function(a, b, c) {
                if (!c) throw new Error("No data!");
                var d = this.getKey(a, b);
                return this.data[d] || this.keys.push(d), this.data[d] = c, d;
            }, c.prototype.reset = function() {
                for (var a = this.data, b = this.keys, c = b.length; c--; ) delete a[b[c]];
                b.length = 0;
            }, c.prototype.copy = function(a) {
                this.reset(), d.appendArray(this.keys, a.keys);
                for (var b = a.keys.length; b--; ) {
                    var c = a.keys[b];
                    this.data[c] = a.data[c];
                }
            };
        }, {
            "./Utils": 57
        } ],
        57: [ function(a, b) {
            function c() {}
            b.exports = c, c.appendArray = function(a, b) {
                if (b.length < 15e4) a.push.apply(a, b); else for (var c = 0, d = b.length; c !== d; ++c) a.push(b[c]);
            }, c.splice = function(a, b, c) {
                c = c || 1;
                for (var d = b, e = a.length - c; e > d; d++) a[d] = a[d + c];
                a.length = e;
            }, c.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, 
            c.extend = function(a, b) {
                for (var c in b) a[c] = b[c];
            }, c.defaults = function(a, b) {
                a = a || {};
                for (var c in b) c in a || (a[c] = b[c]);
                return a;
            };
        }, {} ],
        58: [ function(a, b) {
            function c() {
                this.equations = [], this.bodies = [];
            }
            var d = a("../objects/Body");
            b.exports = c, c.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0;
            };
            var e = [];
            c.prototype.getBodies = function(a) {
                var b = a || [], c = this.equations;
                e.length = 0;
                for (var d = 0; d !== c.length; d++) {
                    var f = c[d];
                    -1 === e.indexOf(f.bodyA.id) && (b.push(f.bodyA), e.push(f.bodyA.id)), -1 === e.indexOf(f.bodyB.id) && (b.push(f.bodyB), 
                    e.push(f.bodyB.id));
                }
                return b;
            }, c.prototype.wantsToSleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    var b = this.bodies[a];
                    if (b.type === d.DYNAMIC && !b.wantsToSleep) return !1;
                }
                return !0;
            }, c.prototype.sleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    var b = this.bodies[a];
                    b.sleep();
                }
                return !0;
            };
        }, {
            "../objects/Body": 31
        } ],
        59: [ function(a, b) {
            function c() {
                this.nodePool = new d({
                    size: 16
                }), this.islandPool = new e({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = [];
            }
            var d = (a("../math/vec2"), a("./Island"), a("./IslandNode"), a("./../utils/IslandNodePool")), e = a("./../utils/IslandPool"), f = a("../objects/Body");
            b.exports = c, c.getUnvisitedNode = function(a) {
                for (var b = a.length, c = 0; c !== b; c++) {
                    var d = a[c];
                    if (!d.visited && d.body.type === f.DYNAMIC) return d;
                }
                return !1;
            }, c.prototype.visit = function(a, b, c) {
                b.push(a.body);
                for (var d = a.equations.length, e = 0; e !== d; e++) {
                    var f = a.equations[e];
                    -1 === c.indexOf(f) && c.push(f);
                }
            }, c.prototype.bfs = function(a, b, d) {
                var e = this.queue;
                for (e.length = 0, e.push(a), a.visited = !0, this.visit(a, b, d); e.length; ) for (var g, h = e.pop(); g = c.getUnvisitedNode(h.neighbors); ) g.visited = !0, 
                this.visit(g, b, d), g.body.type === f.DYNAMIC && e.push(g);
            }, c.prototype.split = function(a) {
                for (var b = a.bodies, d = this.nodes, e = this.equations; d.length; ) this.nodePool.release(d.pop());
                for (var f = 0; f !== b.length; f++) {
                    var g = this.nodePool.get();
                    g.body = b[f], d.push(g);
                }
                for (var h = 0; h !== e.length; h++) {
                    var i = e[h], f = b.indexOf(i.bodyA), j = b.indexOf(i.bodyB), k = d[f], l = d[j];
                    k.neighbors.push(l), l.neighbors.push(k), k.equations.push(i), l.equations.push(i);
                }
                for (var m = this.islands, f = 0; f < m.length; f++) this.islandPool.release(m[f]);
                m.length = 0;
                for (var n; n = c.getUnvisitedNode(d); ) {
                    var o = this.islandPool.get();
                    this.bfs(n, o.bodies, o.equations), m.push(o);
                }
                return m;
            };
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        } ],
        60: [ function(a, b) {
            function c(a) {
                this.body = a, this.neighbors = [], this.equations = [], this.visited = !1;
            }
            b.exports = c, c.prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null;
            };
        }, {} ],
        61: [ function(a, b) {
            function c(a) {
                k.apply(this), a = a || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], 
                this.solver = a.solver || new d(), this.narrowphase = new q(this), this.islandManager = new t(), 
                this.gravity = e.fromValues(0, -9.78), a.gravity && e.copy(this.gravity, a.gravity), 
                this.frictionGravity = e.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, 
                this.useFrictionGravityOnZeroGravity = !0, this.broadphase = a.broadphase || new p(), 
                this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new m(), 
                this.defaultContactMaterial = new n(this.defaultMaterial, this.defaultMaterial), 
                this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, 
                this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], 
                this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], 
                this.islandSplit = "undefined" != typeof a.islandSplit ? !!a.islandSplit : !0, this.emitImpactEvent = !0, 
                this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = c.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new s();
            }
            {
                var d = a("../solver/GSSolver"), e = (a("../solver/Solver"), a("../collision/Ray"), 
                a("../math/vec2")), f = a("../shapes/Circle"), g = a("../shapes/Convex"), h = (a("../shapes/Line"), 
                a("../shapes/Plane")), i = a("../shapes/Capsule"), j = a("../shapes/Particle"), k = a("../events/EventEmitter"), l = a("../objects/Body"), m = (a("../shapes/Shape"), 
                a("../objects/LinearSpring"), a("../material/Material")), n = a("../material/ContactMaterial"), o = (a("../constraints/DistanceConstraint"), 
                a("../constraints/Constraint"), a("../constraints/LockConstraint"), a("../constraints/RevoluteConstraint"), 
                a("../constraints/PrismaticConstraint"), a("../constraints/GearConstraint"), a("../../package.json"), 
                a("../collision/Broadphase"), a("../collision/AABB")), p = a("../collision/SAPBroadphase"), q = a("../collision/Narrowphase"), r = a("../utils/Utils"), s = a("../utils/OverlapKeeper"), t = a("./IslandManager");
                a("../objects/RotationalSpring");
            }
            b.exports = c, c.prototype = new Object(k.prototype), c.prototype.constructor = c, 
            c.NO_SLEEPING = 1, c.BODY_SLEEPING = 2, c.ISLAND_SLEEPING = 4, c.prototype.addConstraint = function(a) {
                this.constraints.push(a);
            }, c.prototype.addContactMaterial = function(a) {
                this.contactMaterials.push(a);
            }, c.prototype.removeContactMaterial = function(a) {
                var b = this.contactMaterials.indexOf(a);
                -1 !== b && r.splice(this.contactMaterials, b, 1);
            }, c.prototype.getContactMaterial = function(a, b) {
                for (var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++) {
                    var f = c[d];
                    if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id) return f;
                }
                return !1;
            }, c.prototype.removeConstraint = function(a) {
                var b = this.constraints.indexOf(a);
                -1 !== b && r.splice(this.constraints, b, 1);
            };
            {
                var u = (e.create(), e.create(), e.create(), e.create(), e.create(), e.create(), 
                e.create()), v = e.fromValues(0, 0), w = e.fromValues(0, 0);
                e.fromValues(0, 0), e.fromValues(0, 0);
            }
            c.prototype.step = function(a, b, c) {
                if (c = c || 10, b = b || 0, 0 === b) this.internalStep(a), this.time += a; else {
                    this.accumulator += b;
                    for (var d = 0; this.accumulator >= a && c > d; ) this.internalStep(a), this.time += a, 
                    this.accumulator -= a, d++;
                    for (var f = this.accumulator % a / a, g = 0; g !== this.bodies.length; g++) {
                        var h = this.bodies[g];
                        e.lerp(h.interpolatedPosition, h.previousPosition, h.position, f), h.interpolatedAngle = h.previousAngle + f * (h.angle - h.previousAngle);
                    }
                }
            };
            var x = [];
            c.prototype.internalStep = function(a) {
                this.stepping = !0;
                var b = this.springs.length, d = this.springs, f = this.bodies, g = this.gravity, h = this.solver, i = this.bodies.length, j = this.broadphase, k = this.narrowphase, m = this.constraints, n = u, o = (e.scale, 
                e.add), p = (e.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = a, this.useWorldGravityAsFrictionGravity) {
                    var q = e.length(this.gravity);
                    0 === q && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = q);
                }
                if (this.applyGravity) for (var s = 0; s !== i; s++) {
                    var t = f[s], v = t.force;
                    t.type === l.DYNAMIC && t.sleepState !== l.SLEEPING && (e.scale(n, g, t.mass * t.gravityScale), 
                    o(v, v, n));
                }
                if (this.applySpringForces) for (var s = 0; s !== b; s++) {
                    var w = d[s];
                    w.applyForce();
                }
                if (this.applyDamping) for (var s = 0; s !== i; s++) {
                    var t = f[s];
                    t.type === l.DYNAMIC && t.applyDamping(a);
                }
                for (var y = j.getCollisionPairs(this), z = this.disabledBodyCollisionPairs, s = z.length - 2; s >= 0; s -= 2) for (var A = y.length - 2; A >= 0; A -= 2) (z[s] === y[A] && z[s + 1] === y[A + 1] || z[s + 1] === y[A] && z[s] === y[A + 1]) && y.splice(A, 2);
                var B = m.length;
                for (s = 0; s !== B; s++) {
                    var C = m[s];
                    if (!C.collideConnected) for (var A = y.length - 2; A >= 0; A -= 2) (C.bodyA === y[A] && C.bodyB === y[A + 1] || C.bodyB === y[A] && C.bodyA === y[A + 1]) && y.splice(A, 2);
                }
                this.postBroadphaseEvent.pairs = y, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, 
                k.reset(this);
                for (var s = 0, D = y.length; s !== D; s += 2) for (var E = y[s], F = y[s + 1], G = 0, H = E.shapes.length; G !== H; G++) for (var I = E.shapes[G], J = I.position, K = I.angle, L = 0, M = F.shapes.length; L !== M; L++) {
                    var N = F.shapes[L], O = N.position, P = N.angle, Q = this.defaultContactMaterial;
                    if (I.material && N.material) {
                        var R = this.getContactMaterial(I.material, N.material);
                        R && (Q = R);
                    }
                    this.runNarrowphase(k, E, I, J, K, F, N, O, P, Q, this.frictionGravity);
                }
                for (var s = 0; s !== i; s++) {
                    var S = f[s];
                    S._wakeUpAfterNarrowphase && (S.wakeUp(), S._wakeUpAfterNarrowphase = !1);
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(x);
                    for (var T = this.endContactEvent, L = x.length; L--; ) {
                        var U = x[L];
                        T.shapeA = U.shapeA, T.shapeB = U.shapeB, T.bodyA = U.bodyA, T.bodyB = U.bodyB, 
                        this.emit(T);
                    }
                    x.length = 0;
                }
                var V = this.preSolveEvent;
                V.contactEquations = k.contactEquations, V.frictionEquations = k.frictionEquations, 
                this.emit(V), V.contactEquations = V.frictionEquations = null;
                var B = m.length;
                for (s = 0; s !== B; s++) m[s].update();
                if (k.contactEquations.length || k.frictionEquations.length || B) if (this.islandSplit) {
                    for (p.equations.length = 0, r.appendArray(p.equations, k.contactEquations), r.appendArray(p.equations, k.frictionEquations), 
                    s = 0; s !== B; s++) r.appendArray(p.equations, m[s].equations);
                    p.split(this);
                    for (var s = 0; s !== p.islands.length; s++) {
                        var W = p.islands[s];
                        W.equations.length && h.solveIsland(a, W);
                    }
                } else {
                    for (h.addEquations(k.contactEquations), h.addEquations(k.frictionEquations), s = 0; s !== B; s++) h.addEquations(m[s].equations);
                    this.solveConstraints && h.solve(a, this), h.removeAllEquations();
                }
                for (var s = 0; s !== i; s++) {
                    var S = f[s];
                    S.integrate(a);
                }
                for (var s = 0; s !== i; s++) f[s].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) for (var X = this.impactEvent, s = 0; s !== k.contactEquations.length; s++) {
                    var Y = k.contactEquations[s];
                    Y.firstImpact && (X.bodyA = Y.bodyA, X.bodyB = Y.bodyB, X.shapeA = Y.shapeA, X.shapeB = Y.shapeB, 
                    X.contactEquation = Y, this.emit(X));
                }
                if (this.sleepMode === c.BODY_SLEEPING) for (s = 0; s !== i; s++) f[s].sleepTick(this.time, !1, a); else if (this.sleepMode === c.ISLAND_SLEEPING && this.islandSplit) {
                    for (s = 0; s !== i; s++) f[s].sleepTick(this.time, !0, a);
                    for (var s = 0; s < this.islandManager.islands.length; s++) {
                        var W = this.islandManager.islands[s];
                        W.wantsToSleep() && W.sleep();
                    }
                }
                this.stepping = !1;
                for (var Z = this.bodiesToBeRemoved, s = 0; s !== Z.length; s++) this.removeBody(Z[s]);
                Z.length = 0, this.emit(this.postStepEvent);
            }, c.prototype.runNarrowphase = function(a, b, c, d, f, g, h, i, j, k, m) {
                if (0 !== (c.collisionGroup & h.collisionMask) && 0 !== (h.collisionGroup & c.collisionMask)) {
                    e.rotate(v, d, b.angle), e.rotate(w, i, g.angle), e.add(v, v, b.position), e.add(w, w, g.position);
                    var n = f + b.angle, o = j + g.angle;
                    a.enableFriction = k.friction > 0, a.frictionCoefficient = k.friction;
                    var p;
                    p = b.type === l.STATIC || b.type === l.KINEMATIC ? g.mass : g.type === l.STATIC || g.type === l.KINEMATIC ? b.mass : b.mass * g.mass / (b.mass + g.mass), 
                    a.slipForce = k.friction * m * p, a.restitution = k.restitution, a.surfaceVelocity = k.surfaceVelocity, 
                    a.frictionStiffness = k.frictionStiffness, a.frictionRelaxation = k.frictionRelaxation, 
                    a.stiffness = k.stiffness, a.relaxation = k.relaxation, a.contactSkinSize = k.contactSkinSize, 
                    a.enabledEquations = b.collisionResponse && g.collisionResponse && c.collisionResponse && h.collisionResponse;
                    var q = a[c.type | h.type], r = 0;
                    if (q) {
                        var s = c.sensor || h.sensor, t = a.frictionEquations.length;
                        r = c.type < h.type ? q.call(a, b, c, v, n, g, h, w, o, s) : q.call(a, g, h, w, o, b, c, v, n, s);
                        var u = a.frictionEquations.length - t;
                        if (r) {
                            if (b.allowSleep && b.type === l.DYNAMIC && b.sleepState === l.SLEEPING && g.sleepState === l.AWAKE && g.type !== l.STATIC) {
                                var x = e.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2), y = Math.pow(g.sleepSpeedLimit, 2);
                                x >= 2 * y && (b._wakeUpAfterNarrowphase = !0);
                            }
                            if (g.allowSleep && g.type === l.DYNAMIC && g.sleepState === l.SLEEPING && b.sleepState === l.AWAKE && b.type !== l.STATIC) {
                                var z = e.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2), A = Math.pow(b.sleepSpeedLimit, 2);
                                z >= 2 * A && (g._wakeUpAfterNarrowphase = !0);
                            }
                            if (this.overlapKeeper.setOverlapping(b, c, g, h), this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                                var B = this.beginContactEvent;
                                if (B.shapeA = c, B.shapeB = h, B.bodyA = b, B.bodyB = g, B.contactEquations.length = 0, 
                                "number" == typeof r) for (var C = a.contactEquations.length - r; C < a.contactEquations.length; C++) B.contactEquations.push(a.contactEquations[C]);
                                this.emit(B);
                            }
                            if ("number" == typeof r && u > 1) for (var C = a.frictionEquations.length - u; C < a.frictionEquations.length; C++) {
                                var D = a.frictionEquations[C];
                                D.setSlipForce(D.getSlipForce() / u);
                            }
                        }
                    }
                }
            }, c.prototype.addSpring = function(a) {
                this.springs.push(a);
                var b = this.addSpringEvent;
                b.spring = a, this.emit(b), b.spring = null;
            }, c.prototype.removeSpring = function(a) {
                var b = this.springs.indexOf(a);
                -1 !== b && r.splice(this.springs, b, 1);
            }, c.prototype.addBody = function(a) {
                if (-1 === this.bodies.indexOf(a)) {
                    this.bodies.push(a), a.world = this;
                    var b = this.addBodyEvent;
                    b.body = a, this.emit(b), b.body = null;
                }
            }, c.prototype.removeBody = function(a) {
                if (this.stepping) this.bodiesToBeRemoved.push(a); else {
                    a.world = null;
                    var b = this.bodies.indexOf(a);
                    -1 !== b && (r.splice(this.bodies, b, 1), this.removeBodyEvent.body = a, a.resetConstraintVelocity(), 
                    this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null);
                }
            }, c.prototype.getBodyById = function(a) {
                for (var b = this.bodies, c = 0; c < b.length; c++) {
                    var d = b[c];
                    if (d.id === a) return d;
                }
                return !1;
            }, c.prototype.disableBodyCollision = function(a, b) {
                this.disabledBodyCollisionPairs.push(a, b);
            }, c.prototype.enableBodyCollision = function(a, b) {
                for (var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2) if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b) return void c.splice(d, 2);
            }, c.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var a = this.constraints, b = a.length - 1; b >= 0; b--) this.removeConstraint(a[b]);
                for (var d = this.bodies, b = d.length - 1; b >= 0; b--) this.removeBody(d[b]);
                for (var e = this.springs, b = e.length - 1; b >= 0; b--) this.removeSpring(e[b]);
                for (var f = this.contactMaterials, b = f.length - 1; b >= 0; b--) this.removeContactMaterial(f[b]);
                c.apply(this);
            };
            var y = e.create(), z = (e.fromValues(0, 0), e.fromValues(0, 0));
            c.prototype.hitTest = function(a, b, c) {
                c = c || 0;
                var d = new l({
                    position: a
                }), k = new j(), m = a, n = 0, o = y, p = z;
                d.addShape(k);
                for (var q = this.narrowphase, r = [], s = 0, t = b.length; s !== t; s++) for (var u = b[s], v = 0, w = u.shapes.length; v !== w; v++) {
                    var x = u.shapes[v];
                    e.rotate(o, x.position, u.angle), e.add(o, o, u.position);
                    var A = x.angle + u.angle;
                    (x instanceof f && q.circleParticle(u, x, o, A, d, k, m, n, !0) || x instanceof g && q.particleConvex(d, k, m, n, u, x, o, A, !0) || x instanceof h && q.particlePlane(d, k, m, n, u, x, o, A, !0) || x instanceof i && q.particleCapsule(d, k, m, n, u, x, o, A, !0) || x instanceof j && e.squaredLength(e.sub(p, o, a)) < c * c) && r.push(u);
                }
                return r;
            }, c.prototype.setGlobalStiffness = function(a) {
                for (var b = this.constraints, c = 0; c !== b.length; c++) for (var d = b[c], e = 0; e !== d.equations.length; e++) {
                    var f = d.equations[e];
                    f.stiffness = a, f.needsUpdate = !0;
                }
                for (var g = this.contactMaterials, c = 0; c !== g.length; c++) {
                    var d = g[c];
                    d.stiffness = d.frictionStiffness = a;
                }
                var d = this.defaultContactMaterial;
                d.stiffness = d.frictionStiffness = a;
            }, c.prototype.setGlobalRelaxation = function(a) {
                for (var b = 0; b !== this.constraints.length; b++) for (var c = this.constraints[b], d = 0; d !== c.equations.length; d++) {
                    var e = c.equations[d];
                    e.relaxation = a, e.needsUpdate = !0;
                }
                for (var b = 0; b !== this.contactMaterials.length; b++) {
                    var c = this.contactMaterials[b];
                    c.relaxation = c.frictionRelaxation = a;
                }
                var c = this.defaultContactMaterial;
                c.relaxation = c.frictionRelaxation = a;
            };
            var A = new o(), B = [];
            c.prototype.raycast = function(a, b) {
                return b.getAABB(A), this.broadphase.aabbQuery(this, A, B), b.intersectBodies(a, B), 
                B.length = 0, a.hasHit();
            };
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        } ]
    }, {}, [ 36 ])(36);
}), function() {
    var a = this, b = b || {};
    return b.WEBGL_RENDERER = 0, b.CANVAS_RENDERER = 1, b.VERSION = "v2.2.8", b._UID = 0, 
    "undefined" != typeof Float32Array ? (b.Float32Array = Float32Array, b.Uint16Array = Uint16Array, 
    b.Uint32Array = Uint32Array, b.ArrayBuffer = ArrayBuffer) : (b.Float32Array = Array, 
    b.Uint16Array = Array), b.PI_2 = 2 * Math.PI, b.RAD_TO_DEG = 180 / Math.PI, b.DEG_TO_RAD = Math.PI / 180, 
    b.RETINA_PREFIX = "@2x", b.defaultRenderOptions = {
        view: null,
        transparent: !1,
        antialias: !1,
        preserveDrawingBuffer: !1,
        resolution: 1,
        clearBeforeRender: !0,
        autoResize: !1
    }, b.DisplayObject = function() {
        this.position = new b.Point(0, 0), this.scale = new b.Point(1, 1), this.transformCallback = null, 
        this.transformCallbackContext = null, this.pivot = new b.Point(0, 0), this.rotation = 0, 
        this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, 
        this.stage = null, this.worldAlpha = 1, this.worldTransform = new b.Matrix(), this.worldPosition = new b.Point(0, 0), 
        this.worldScale = new b.Point(1, 1), this.worldRotation = 0, this._sr = 0, this._cr = 1, 
        this.filterArea = null, this._bounds = new b.Rectangle(0, 0, 1, 1), this._currentBounds = null, 
        this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1;
    }, b.DisplayObject.prototype.constructor = b.DisplayObject, b.DisplayObject.prototype.destroy = function() {
        if (this.children) {
            for (var a = this.children.length; a--; ) this.children[a].destroy();
            this.children = [];
        }
        this.transformCallback = null, this.transformCallbackContext = null, this.hitArea = null, 
        this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, 
        this._bounds = null, this._currentBounds = null, this._mask = null, this.renderable = !1, 
        this._destroyCachedSprite();
    }, Object.defineProperty(b.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var a = this;
            do {
                if (!a.visible) return !1;
                a = a.parent;
            } while (a);
            return !0;
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(a) {
            this._mask && (this._mask.isMask = !1), this._mask = a, this._mask && (this._mask.isMask = !0);
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters;
        },
        set: function(a) {
            if (a) {
                for (var c = [], d = 0; d < a.length; d++) for (var e = a[d].passes, f = 0; f < e.length; f++) c.push(e[f]);
                this._filterBlock = {
                    target: this,
                    filterPasses: c
                };
            }
            this._filters = a, this.blendMode && this.blendMode === b.blendModes.MULTIPLY && (this.blendMode = b.blendModes.NORMAL);
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(a) {
            this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), 
            this._cacheAsBitmap = a);
        }
    }), b.DisplayObject.prototype.updateTransform = function(a) {
        if (a || this.parent || this.game) {
            var c = this.parent;
            a ? c = a : this.parent || (c = this.game.world);
            var d, e, f, g, h, i, j = c.worldTransform, k = this.worldTransform;
            this.rotation % b.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, 
            this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), d = this._cr * this.scale.x, 
            e = this._sr * this.scale.x, f = -this._sr * this.scale.y, g = this._cr * this.scale.y, 
            h = this.position.x, i = this.position.y, (this.pivot.x || this.pivot.y) && (h -= this.pivot.x * d + this.pivot.y * f, 
            i -= this.pivot.x * e + this.pivot.y * g), k.a = d * j.a + e * j.c, k.b = d * j.b + e * j.d, 
            k.c = f * j.a + g * j.c, k.d = f * j.b + g * j.d, k.tx = h * j.a + i * j.c + j.tx, 
            k.ty = h * j.b + i * j.d + j.ty) : (d = this.scale.x, g = this.scale.y, h = this.position.x - this.pivot.x * d, 
            i = this.position.y - this.pivot.y * g, k.a = d * j.a, k.b = d * j.b, k.c = g * j.c, 
            k.d = g * j.d, k.tx = h * j.a + i * j.c + j.tx, k.ty = h * j.b + i * j.d + j.ty), 
            this.worldAlpha = this.alpha * c.worldAlpha, this.worldPosition.set(k.tx, k.ty), 
            this.worldScale.set(Math.sqrt(k.a * k.a + k.b * k.b), Math.sqrt(k.c * k.c + k.d * k.d)), 
            this.worldRotation = Math.atan2(-k.c, k.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, k, j);
        }
    }, b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform, 
    b.DisplayObject.prototype.getBounds = function(a) {
        return a = a, b.EmptyRectangle;
    }, b.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(b.identityMatrix);
    }, b.DisplayObject.prototype.setStageReference = function(a) {
        this.stage = a;
    }, b.DisplayObject.prototype.preUpdate = function() {}, b.DisplayObject.prototype.generateTexture = function(a, c, d) {
        var e = this.getLocalBounds(), f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
        return b.DisplayObject._tempMatrix.tx = -e.x, b.DisplayObject._tempMatrix.ty = -e.y, 
        f.render(this, b.DisplayObject._tempMatrix), f;
    }, b.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite();
    }, b.DisplayObject.prototype.toGlobal = function(a) {
        return this.displayObjectUpdateTransform(), this.worldTransform.apply(a);
    }, b.DisplayObject.prototype.toLocal = function(a, b) {
        return b && (a = b.toGlobal(a)), this.displayObjectUpdateTransform(), this.worldTransform.applyInverse(a);
    }, b.DisplayObject.prototype._renderCachedSprite = function(a) {
        this._cachedSprite.worldAlpha = this.worldAlpha, a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
    }, b.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = !1;
        var a = this.getLocalBounds();
        if (this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(1 | a.width, 1 | a.height); else {
            var c = new b.RenderTexture(1 | a.width, 1 | a.height);
            this._cachedSprite = new b.Sprite(c), this._cachedSprite.worldTransform = this.worldTransform;
        }
        var d = this._filters;
        this._filters = null, this._cachedSprite.filters = d, b.DisplayObject._tempMatrix.tx = -a.x, 
        b.DisplayObject._tempMatrix.ty = -a.y, this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0), 
        this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), 
        this._filters = d, this._cacheAsBitmap = !0;
    }, b.DisplayObject.prototype._destroyCachedSprite = function() {
        this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null);
    }, b.DisplayObject.prototype._renderWebGL = function(a) {
        a = a;
    }, b.DisplayObject.prototype._renderCanvas = function(a) {
        a = a;
    }, Object.defineProperty(b.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(a) {
            this.position.x = a;
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(a) {
            this.position.y = a;
        }
    }), b.DisplayObjectContainer = function() {
        b.DisplayObject.call(this), this.children = [];
    }, b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype), 
    b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer, Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function(a) {
            var b = this.getLocalBounds().width;
            this.scale.x = 0 !== b ? a / b : 1, this._width = a;
        }
    }), Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function(a) {
            var b = this.getLocalBounds().height;
            this.scale.y = 0 !== b ? a / b : 1, this._height = a;
        }
    }), b.DisplayObjectContainer.prototype.addChild = function(a) {
        return this.addChildAt(a, this.children.length);
    }, b.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
        if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), 
        a.parent = this, this.children.splice(b, 0, a), this.stage && a.setStageReference(this.stage), 
        a;
        throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length);
    }, b.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
        if (a !== b) {
            var c = this.getChildIndex(a), d = this.getChildIndex(b);
            if (0 > c || 0 > d) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[c] = b, this.children[d] = a;
        }
    }, b.DisplayObjectContainer.prototype.getChildIndex = function(a) {
        var b = this.children.indexOf(a);
        if (-1 === b) throw new Error("The supplied DisplayObject must be a child of the caller");
        return b;
    }, b.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
        if (0 > b || b >= this.children.length) throw new Error("The supplied index is out of bounds");
        var c = this.getChildIndex(a);
        this.children.splice(c, 1), this.children.splice(b, 0, a);
    }, b.DisplayObjectContainer.prototype.getChildAt = function(a) {
        if (0 > a || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[a];
    }, b.DisplayObjectContainer.prototype.removeChild = function(a) {
        var b = this.children.indexOf(a);
        if (-1 !== b) return this.removeChildAt(b);
    }, b.DisplayObjectContainer.prototype.removeChildAt = function(a) {
        var b = this.getChildAt(a);
        return this.stage && b.removeStageReference(), b.parent = void 0, this.children.splice(a, 1), 
        b;
    }, b.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
        var c = a || 0, d = "number" == typeof b ? b : this.children.length, e = d - c;
        if (e > 0 && d >= e) {
            for (var f = this.children.splice(c, e), g = 0; g < f.length; g++) {
                var h = f[g];
                this.stage && h.removeStageReference(), h.parent = void 0;
            }
            return f;
        }
        if (0 === e && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
    }, b.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform();
    }, b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform, 
    b.DisplayObjectContainer.prototype.getBounds = function() {
        if (0 === this.children.length) return b.EmptyRectangle;
        for (var a, c, d, e = 1 / 0, f = 1 / 0, g = -1 / 0, h = -1 / 0, i = !1, j = 0, k = this.children.length; k > j; j++) {
            var l = this.children[j];
            l.visible && (i = !0, a = this.children[j].getBounds(), e = e < a.x ? e : a.x, f = f < a.y ? f : a.y, 
            c = a.width + a.x, d = a.height + a.y, g = g > c ? g : c, h = h > d ? h : d);
        }
        if (!i) return b.EmptyRectangle;
        var m = this._bounds;
        return m.x = e, m.y = f, m.width = g - e, m.height = h - f, m;
    }, b.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = b.identityMatrix;
        for (var c = 0, d = this.children.length; d > c; c++) this.children[c].updateTransform();
        var e = this.getBounds();
        return this.worldTransform = a, e;
    }, b.DisplayObjectContainer.prototype.setStageReference = function(a) {
        this.stage = a;
        for (var b = 0; b < this.children.length; b++) this.children[b].setStageReference(a);
    }, b.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var a = 0; a < this.children.length; a++) this.children[a].removeStageReference();
        this.stage = null;
    }, b.DisplayObjectContainer.prototype._renderWebGL = function(a) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            var b;
            if (this._mask || this._filters) {
                for (this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), 
                this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), 
                b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), 
                a.spriteBatch.start();
            } else for (b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
        }
    }, b.DisplayObjectContainer.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            this._mask && a.maskManager.pushMask(this._mask, a);
            for (var b = 0; b < this.children.length; b++) this.children[b]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, b.Sprite = function(a) {
        b.DisplayObjectContainer.call(this), this.anchor = new b.Point(), this.texture = a || b.Texture.emptyTexture, 
        this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, 
        this.blendMode = b.blendModes.NORMAL, this.shader = null, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), 
        this.renderable = !0;
    }, b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Sprite.prototype.constructor = b.Sprite, 
    Object.defineProperty(b.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(b.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), b.Sprite.prototype.setTexture = function(a, b) {
        void 0 !== b && this.texture.baseTexture.destroy(), this.texture = a, this.texture.valid = !0;
    }, b.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height);
    }, b.Sprite.prototype.getBounds = function(a) {
        var b = this.texture.frame.width, c = this.texture.frame.height, d = b * (1 - this.anchor.x), e = b * -this.anchor.x, f = c * (1 - this.anchor.y), g = c * -this.anchor.y, h = a || this.worldTransform, i = h.a, j = h.b, k = h.c, l = h.d, m = h.tx, n = h.ty, o = -1 / 0, p = -1 / 0, q = 1 / 0, r = 1 / 0;
        if (0 === j && 0 === k) 0 > i && (i *= -1), 0 > l && (l *= -1), q = i * e + m, o = i * d + m, 
        r = l * g + n, p = l * f + n; else {
            var s = i * e + k * g + m, t = l * g + j * e + n, u = i * d + k * g + m, v = l * g + j * d + n, w = i * d + k * f + m, x = l * f + j * d + n, y = i * e + k * f + m, z = l * f + j * e + n;
            q = q > s ? s : q, q = q > u ? u : q, q = q > w ? w : q, q = q > y ? y : q, r = r > t ? t : r, 
            r = r > v ? v : r, r = r > x ? x : r, r = r > z ? z : r, o = s > o ? s : o, o = u > o ? u : o, 
            o = w > o ? w : o, o = y > o ? y : o, p = t > p ? t : p, p = v > p ? v : p, p = x > p ? x : p, 
            p = z > p ? z : p;
        }
        var A = this._bounds;
        return A.x = q, A.width = o - q, A.y = r, A.height = p - r, this._currentBounds = A, 
        A;
    }, b.Sprite.prototype._renderWebGL = function(a, b) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var c = this.worldTransform;
            if (b && (c = b), this._mask || this._filters) {
                var d = a.spriteBatch;
                this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (d.stop(), 
                a.maskManager.pushMask(this.mask, a), d.start()), d.render(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a);
                d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), 
                d.start();
            } else {
                a.spriteBatch.render(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a, c);
            }
        }
    }, b.Sprite.prototype._renderCanvas = function(a, c) {
        if (!(this.visible === !1 || 0 === this.alpha || this.renderable === !1 || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var d = this.worldTransform;
            if (c && (d = c), this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, 
            a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a), 
            this.texture.valid) {
                var e = this.texture.baseTexture.resolution / a.resolution;
                a.context.globalAlpha = this.worldAlpha, a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, 
                a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR);
                var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width, g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
                a.roundPixels ? (a.context.setTransform(d.a, d.b, d.c, d.d, d.tx * a.resolution | 0, d.ty * a.resolution | 0), 
                f |= 0, g |= 0) : a.context.setTransform(d.a, d.b, d.c, d.d, d.tx * a.resolution, d.ty * a.resolution);
                var h = this.texture.crop.width, i = this.texture.crop.height;
                if (f /= e, g /= e, 16777215 !== this.tint) (this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint), 
                this.cachedTint = this.tint), a.context.drawImage(this.tintedTexture, 0, 0, h, i, f, g, h / e, i / e); else {
                    var j = this.texture.crop.x, k = this.texture.crop.y;
                    a.context.drawImage(this.texture.baseTexture.source, j, k, h, i, f, g, h / e, i / e);
                }
            }
            for (var l = 0; l < this.children.length; l++) this.children[l]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, b.Sprite.fromFrame = function(a) {
        var c = b.TextureCache[a];
        if (!c) throw new Error('The frameId "' + a + '" does not exist in the texture cache' + this);
        return new b.Sprite(c);
    }, b.Sprite.fromImage = function(a, c, d) {
        var e = b.Texture.fromImage(a, c, d);
        return new b.Sprite(e);
    }, b.SpriteBatch = function(a) {
        b.DisplayObjectContainer.call(this), this.textureThing = a, this.ready = !1;
    }, b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype), 
    b.SpriteBatch.prototype.constructor = b.SpriteBatch, b.SpriteBatch.prototype.initWebGL = function(a) {
        this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a), this.ready = !0;
    }, b.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
    }, b.SpriteBatch.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(a.gl), 
        this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl), a.spriteBatch.stop(), 
        a.shaderManager.setShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), 
        this.fastSpriteBatch.render(this), a.spriteBatch.start());
    }, b.SpriteBatch.prototype._renderCanvas = function(a) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var b = a.context;
            b.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
                var f = this.children[e];
                if (f.visible) {
                    var g = f.texture, h = g.frame;
                    if (b.globalAlpha = this.worldAlpha * f.alpha, f.rotation % (2 * Math.PI) === 0) d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), 
                    d = !1), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width * f.scale.x + f.position.x + .5 | 0, f.anchor.y * -h.height * f.scale.y + f.position.y + .5 | 0, h.width * f.scale.x, h.height * f.scale.y); else {
                        d || (d = !0), f.displayObjectUpdateTransform();
                        var i = f.worldTransform;
                        a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | i.tx, 0 | i.ty) : b.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), 
                        b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height);
                    }
                }
            }
        }
    }, b.Stage = function(a) {
        b.DisplayObjectContainer.call(this), this.worldTransform = new b.Matrix(), this.stage = this, 
        this.setBackgroundColor(a);
    }, b.Stage.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Stage.prototype.constructor = b.Stage, 
    b.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform();
    }, b.Stage.prototype.setBackgroundColor = function(a) {
        this.backgroundColor = a || 0, this.backgroundColorSplit = b.hex2rgb(this.backgroundColor);
        var c = this.backgroundColor.toString(16);
        c = "000000".substr(0, 6 - c.length) + c, this.backgroundColorString = "#" + c;
    }, b.hex2rgb = function(a) {
        return [ (a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255 ];
    }, b.rgb2hex = function(a) {
        return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    }, b.canUseNewCanvasBlendModes = function() {
        if (void 0 === document) return !1;
        var a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/", c = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", d = new Image();
        d.src = a + "AP804Oa6" + c;
        var e = new Image();
        e.src = a + "/wCKxvRF" + c;
        var f = b.CanvasPool.create(this, 6, 1), g = f.getContext("2d");
        if (g.globalCompositeOperation = "multiply", g.drawImage(d, 0, 0), g.drawImage(e, 2, 0), 
        !g.getImageData(2, 0, 1, 1)) return !1;
        var h = g.getImageData(2, 0, 1, 1).data;
        return b.CanvasPool.remove(this), 255 === h[0] && 0 === h[1] && 0 === h[2];
    }, b.getNextPowerOfTwo = function(a) {
        if (a > 0 && 0 === (a & a - 1)) return a;
        for (var b = 1; a > b; ) b <<= 1;
        return b;
    }, b.isPowerOfTwo = function(a, b) {
        return a > 0 && 0 === (a & a - 1) && b > 0 && 0 === (b & b - 1);
    }, b.PolyK = {}, b.PolyK.Triangulate = function(a) {
        var c = !0, d = a.length >> 1;
        if (3 > d) return [];
        for (var e = [], f = [], g = 0; d > g; g++) f.push(g);
        g = 0;
        for (var h = d; h > 3; ) {
            var i = f[(g + 0) % h], j = f[(g + 1) % h], k = f[(g + 2) % h], l = a[2 * i], m = a[2 * i + 1], n = a[2 * j], o = a[2 * j + 1], p = a[2 * k], q = a[2 * k + 1], r = !1;
            if (b.PolyK._convex(l, m, n, o, p, q, c)) {
                r = !0;
                for (var s = 0; h > s; s++) {
                    var t = f[s];
                    if (t !== i && t !== j && t !== k && b.PolyK._PointInTriangle(a[2 * t], a[2 * t + 1], l, m, n, o, p, q)) {
                        r = !1;
                        break;
                    }
                }
            }
            if (r) e.push(i, j, k), f.splice((g + 1) % h, 1), h--, g = 0; else if (g++ > 3 * h) {
                if (!c) return null;
                for (e = [], f = [], g = 0; d > g; g++) f.push(g);
                g = 0, h = d, c = !1;
            }
        }
        return e.push(f[0], f[1], f[2]), e;
    }, b.PolyK._PointInTriangle = function(a, b, c, d, e, f, g, h) {
        var i = g - c, j = h - d, k = e - c, l = f - d, m = a - c, n = b - d, o = i * i + j * j, p = i * k + j * l, q = i * m + j * n, r = k * k + l * l, s = k * m + l * n, t = 1 / (o * r - p * p), u = (r * q - p * s) * t, v = (o * s - p * q) * t;
        return u >= 0 && v >= 0 && 1 > u + v;
    }, b.PolyK._convex = function(a, b, c, d, e, f, g) {
        return (b - d) * (e - c) + (c - a) * (f - d) >= 0 === g;
    }, b.CanvasPool = {
        create: function(a, c, d) {
            var e, f = b.CanvasPool.getFirst();
            if (-1 === f) {
                var g = {
                    parent: a,
                    canvas: document.createElement("canvas")
                };
                b.CanvasPool.pool.push(g), e = g.canvas;
            } else b.CanvasPool.pool[f].parent = a, e = b.CanvasPool.pool[f].canvas;
            return void 0 !== c && (e.width = c, e.height = d), e;
        },
        getFirst: function() {
            for (var a = b.CanvasPool.pool, c = 0; c < a.length; c++) if (null === a[c].parent) return c;
            return -1;
        },
        remove: function(a) {
            for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].parent === a && (c[d].parent = null);
        },
        removeByCanvas: function(a) {
            for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].canvas === a && (c[d].parent = null);
        },
        getTotal: function() {
            for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) null !== a[d].parent && c++;
            return c;
        },
        getFree: function() {
            for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) null === a[d].parent && c++;
            return c;
        }
    }, b.CanvasPool.pool = [], b.initDefaultShaders = function() {}, b.CompileVertexShader = function(a, c) {
        return b._CompileShader(a, c, a.VERTEX_SHADER);
    }, b.CompileFragmentShader = function(a, c) {
        return b._CompileShader(a, c, a.FRAGMENT_SHADER);
    }, b._CompileShader = function(a, b, c) {
        var d = b;
        Array.isArray(b) && (d = b.join("\n"));
        var e = a.createShader(c);
        return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), 
        null);
    }, b.compileProgram = function(a, c, d) {
        var e = b.CompileFragmentShader(a, d), f = b.CompileVertexShader(a, c), g = a.createProgram();
        return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || window.console.log("Could not initialise shaders"), 
        g;
    }, b.PixiShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
        this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], 
        this.init();
    }, b.PixiShader.prototype.constructor = b.PixiShader, b.PixiShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), 
        this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
        for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
        this.initUniforms(), this.program = c;
    }, b.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var a, b = this.gl;
        for (var c in this.uniforms) {
            a = this.uniforms[c];
            var d = a.type;
            "sampler2D" === d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" === d || "mat3" === d || "mat4" === d ? (a.glMatrix = !0, 
            a.glValueLength = 1, "mat2" === d ? a.glFunc = b.uniformMatrix2fv : "mat3" === d ? a.glFunc = b.uniformMatrix3fv : "mat4" === d && (a.glFunc = b.uniformMatrix4fv)) : (a.glFunc = b["uniform" + d], 
            a.glValueLength = "2f" === d || "2i" === d ? 2 : "3f" === d || "3i" === d ? 3 : "4f" === d || "4i" === d ? 4 : 1);
        }
    }, b.PixiShader.prototype.initSampler2D = function(a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
            var b = this.gl;
            if (b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), 
            a.textureData) {
                var c = a.textureData, d = c.magFilter ? c.magFilter : b.LINEAR, e = c.minFilter ? c.minFilter : b.LINEAR, f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE, g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE, h = c.luminance ? b.LUMINANCE : b.RGBA;
                if (c.repeat && (f = b.REPEAT, g = b.REPEAT), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), 
                c.width) {
                    var i = c.width ? c.width : 512, j = c.height ? c.height : 2, k = c.border ? c.border : 0;
                    b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null);
                } else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), 
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g);
            }
            b.uniform1i(a.uniformLocation, this.textureCount), a._init = !0, this.textureCount++;
        }
    }, b.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var a, c = this.gl;
        for (var d in this.uniforms) a = this.uniforms[d], 1 === a.glValueLength ? a.glMatrix === !0 ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(c, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (c.activeTexture(c["TEXTURE" + this.textureCount]), 
        a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]), 
        c.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a));
    }, b.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}" ], 
    b.PixiFastShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ], 
        this.textureCount = 0, this.init();
    }, b.PixiFastShader.prototype.constructor = b.PixiFastShader, b.PixiFastShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), 
        this.uMatrix = a.getUniformLocation(c, "uMatrix"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), 
        this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord"), this.aScale = a.getAttribLocation(c, "aScale"), 
        this.aRotation = a.getAttribLocation(c, "aRotation"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), 
        this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ], 
        this.program = c;
    }, b.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.StripShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ], 
        this.init();
    }, b.StripShader.prototype.constructor = b.StripShader, b.StripShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.colorAttribute = a.getAttribLocation(c, "aColor"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.attributes = [ this.aVertexPosition, this.aTextureCoord ], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), 
        this.alpha = a.getUniformLocation(c, "alpha"), this.program = c;
    }, b.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, b.PrimitiveShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ], 
        this.init();
    }, b.PrimitiveShader.prototype.constructor = b.PrimitiveShader, b.PrimitiveShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), 
        this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), 
        this.program = c;
    }, b.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.ComplexPrimitiveShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ], 
        this.init();
    }, b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader, b.ComplexPrimitiveShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), 
        this.color = a.getUniformLocation(c, "color"), this.flipY = a.getUniformLocation(c, "flipY"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), 
        this.program = c;
    }, b.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, b.WebGLGraphics = function() {}, b.WebGLGraphics.renderGraphics = function(a, c) {
        var d, e = c.gl, f = c.projection, g = c.offset, h = c.shaderManager.primitiveShader;
        a.dirty && b.WebGLGraphics.updateGraphics(a, e);
        for (var i = a._webGL[e.id], j = 0; j < i.data.length; j++) 1 === i.data[j].mode ? (d = i.data[j], 
        c.stencilManager.pushStencil(a, d, c), e.drawElements(e.TRIANGLE_FAN, 4, e.UNSIGNED_SHORT, 2 * (d.indices.length - 4)), 
        c.stencilManager.popStencil(a, d, c)) : (d = i.data[j], c.shaderManager.setShader(h), 
        h = c.shaderManager.primitiveShader, e.uniformMatrix3fv(h.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        e.uniform1f(h.flipY, 1), e.uniform2f(h.projectionVector, f.x, -f.y), e.uniform2f(h.offsetVector, -g.x, -g.y), 
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint)), e.uniform1f(h.alpha, a.worldAlpha), 
        e.bindBuffer(e.ARRAY_BUFFER, d.buffer), e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, !1, 24, 0), 
        e.vertexAttribPointer(h.colorAttribute, 4, e.FLOAT, !1, 24, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, d.indexBuffer), 
        e.drawElements(e.TRIANGLE_STRIP, d.indices.length, e.UNSIGNED_SHORT, 0));
    }, b.WebGLGraphics.updateGraphics = function(a, c) {
        var d = a._webGL[c.id];
        d || (d = a._webGL[c.id] = {
            lastIndex: 0,
            data: [],
            gl: c
        }), a.dirty = !1;
        var e;
        if (a.clearDirty) {
            for (a.clearDirty = !1, e = 0; e < d.data.length; e++) {
                var f = d.data[e];
                f.reset(), b.WebGLGraphics.graphicsDataPool.push(f);
            }
            d.data = [], d.lastIndex = 0;
        }
        var g;
        for (e = d.lastIndex; e < a.graphicsData.length; e++) {
            var h = a.graphicsData[e];
            if (h.type === b.Graphics.POLY) {
                if (h.points = h.shape.points.slice(), h.shape.closed && (h.points[0] !== h.points[h.points.length - 2] || h.points[1] !== h.points[h.points.length - 1]) && h.points.push(h.points[0], h.points[1]), 
                h.fill && h.points.length >= 6) if (h.points.length < 12) {
                    g = b.WebGLGraphics.switchMode(d, 0);
                    var i = b.WebGLGraphics.buildPoly(h, g);
                    i || (g = b.WebGLGraphics.switchMode(d, 1), b.WebGLGraphics.buildComplexPoly(h, g));
                } else g = b.WebGLGraphics.switchMode(d, 1), b.WebGLGraphics.buildComplexPoly(h, g);
                h.lineWidth > 0 && (g = b.WebGLGraphics.switchMode(d, 0), b.WebGLGraphics.buildLine(h, g));
            } else g = b.WebGLGraphics.switchMode(d, 0), h.type === b.Graphics.RECT ? b.WebGLGraphics.buildRectangle(h, g) : h.type === b.Graphics.CIRC || h.type === b.Graphics.ELIP ? b.WebGLGraphics.buildCircle(h, g) : h.type === b.Graphics.RREC && b.WebGLGraphics.buildRoundedRectangle(h, g);
            d.lastIndex++;
        }
        for (e = 0; e < d.data.length; e++) g = d.data[e], g.dirty && g.upload();
    }, b.WebGLGraphics.switchMode = function(a, c) {
        var d;
        return a.data.length ? (d = a.data[a.data.length - 1], (d.mode !== c || 1 === c) && (d = b.WebGLGraphics.graphicsDataPool.pop() || new b.WebGLGraphicsData(a.gl), 
        d.mode = c, a.data.push(d))) : (d = b.WebGLGraphics.graphicsDataPool.pop() || new b.WebGLGraphicsData(a.gl), 
        d.mode = c, a.data.push(d)), d.dirty = !0, d;
    }, b.WebGLGraphics.buildRectangle = function(a, c) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height;
        if (a.fill) {
            var i = b.hex2rgb(a.fillColor), j = a.fillAlpha, k = i[0] * j, l = i[1] * j, m = i[2] * j, n = c.points, o = c.indices, p = n.length / 6;
            n.push(e, f), n.push(k, l, m, j), n.push(e + g, f), n.push(k, l, m, j), n.push(e, f + h), 
            n.push(k, l, m, j), n.push(e + g, f + h), n.push(k, l, m, j), o.push(p, p, p + 1, p + 2, p + 3, p + 3);
        }
        if (a.lineWidth) {
            var q = a.points;
            a.points = [ e, f, e + g, f, e + g, f + h, e, f + h, e, f ], b.WebGLGraphics.buildLine(a, c), 
            a.points = q;
        }
    }, b.WebGLGraphics.buildRoundedRectangle = function(a, c) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height, i = d.radius, j = [];
        if (j.push(e, f + i), j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e, f + h - i, e, f + h, e + i, f + h)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + g - i, f + h, e + g, f + h, e + g, f + h - i)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + g, f + i, e + g, f, e + g - i, f)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + i, f, e, f, e, f + i)), a.fill) {
            var k = b.hex2rgb(a.fillColor), l = a.fillAlpha, m = k[0] * l, n = k[1] * l, o = k[2] * l, p = c.points, q = c.indices, r = p.length / 6, s = b.PolyK.Triangulate(j), t = 0;
            for (t = 0; t < s.length; t += 3) q.push(s[t] + r), q.push(s[t] + r), q.push(s[t + 1] + r), 
            q.push(s[t + 2] + r), q.push(s[t + 2] + r);
            for (t = 0; t < j.length; t++) p.push(j[t], j[++t], m, n, o, l);
        }
        if (a.lineWidth) {
            var u = a.points;
            a.points = j, b.WebGLGraphics.buildLine(a, c), a.points = u;
        }
    }, b.WebGLGraphics.quadraticBezierCurve = function(a, b, c, d, e, f) {
        function g(a, b, c) {
            var d = b - a;
            return a + d * c;
        }
        for (var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; n >= q; q++) p = q / n, 
        h = g(a, c, p), i = g(b, d, p), j = g(c, e, p), k = g(d, f, p), l = g(h, j, p), 
        m = g(i, k, p), o.push(l, m);
        return o;
    }, b.WebGLGraphics.buildCircle = function(a, c) {
        var d, e, f = a.shape, g = f.x, h = f.y;
        a.type === b.Graphics.CIRC ? (d = f.radius, e = f.radius) : (d = f.width, e = f.height);
        var i = 40, j = 2 * Math.PI / i, k = 0;
        if (a.fill) {
            var l = b.hex2rgb(a.fillColor), m = a.fillAlpha, n = l[0] * m, o = l[1] * m, p = l[2] * m, q = c.points, r = c.indices, s = q.length / 6;
            for (r.push(s), k = 0; i + 1 > k; k++) q.push(g, h, n, o, p, m), q.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e, n, o, p, m), 
            r.push(s++, s++);
            r.push(s - 1);
        }
        if (a.lineWidth) {
            var t = a.points;
            for (a.points = [], k = 0; i + 1 > k; k++) a.points.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e);
            b.WebGLGraphics.buildLine(a, c), a.points = t;
        }
    }, b.WebGLGraphics.buildLine = function(a, c) {
        var d = 0, e = a.points;
        if (0 !== e.length) {
            if (a.lineWidth % 2) for (d = 0; d < e.length; d++) e[d] += .5;
            var f = new b.Point(e[0], e[1]), g = new b.Point(e[e.length - 2], e[e.length - 1]);
            if (f.x === g.x && f.y === g.y) {
                e = e.slice(), e.pop(), e.pop(), g = new b.Point(e[e.length - 2], e[e.length - 1]);
                var h = g.x + .5 * (f.x - g.x), i = g.y + .5 * (f.y - g.y);
                e.unshift(h, i), e.push(h, i);
            }
            var j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G = c.points, H = c.indices, I = e.length / 2, J = e.length, K = G.length / 6, L = a.lineWidth / 2, M = b.hex2rgb(a.lineColor), N = a.lineAlpha, O = M[0] * N, P = M[1] * N, Q = M[2] * N;
            for (l = e[0], m = e[1], n = e[2], o = e[3], r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), 
            r /= F, s /= F, r *= L, s *= L, G.push(l - r, m - s, O, P, Q, N), G.push(l + r, m + s, O, P, Q, N), 
            d = 1; I - 1 > d; d++) l = e[2 * (d - 1)], m = e[2 * (d - 1) + 1], n = e[2 * d], 
            o = e[2 * d + 1], p = e[2 * (d + 1)], q = e[2 * (d + 1) + 1], r = -(m - o), s = l - n, 
            F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, t = -(o - q), u = n - p, 
            F = Math.sqrt(t * t + u * u), t /= F, u /= F, t *= L, u *= L, x = -s + m - (-s + o), 
            y = -r + n - (-r + l), z = (-r + l) * (-s + o) - (-r + n) * (-s + m), A = -u + q - (-u + o), 
            B = -t + n - (-t + p), C = (-t + p) * (-u + o) - (-t + n) * (-u + q), D = x * B - A * y, 
            Math.abs(D) < .1 ? (D += 10.1, G.push(n - r, o - s, O, P, Q, N), G.push(n + r, o + s, O, P, Q, N)) : (j = (y * C - B * z) / D, 
            k = (A * z - x * C) / D, E = (j - n) * (j - n) + (k - o) + (k - o), E > 19600 ? (v = r - t, 
            w = s - u, F = Math.sqrt(v * v + w * w), v /= F, w /= F, v *= L, w *= L, G.push(n - v, o - w), 
            G.push(O, P, Q, N), G.push(n + v, o + w), G.push(O, P, Q, N), G.push(n - v, o - w), 
            G.push(O, P, Q, N), J++) : (G.push(j, k), G.push(O, P, Q, N), G.push(n - (j - n), o - (k - o)), 
            G.push(O, P, Q, N)));
            for (l = e[2 * (I - 2)], m = e[2 * (I - 2) + 1], n = e[2 * (I - 1)], o = e[2 * (I - 1) + 1], 
            r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, 
            G.push(n - r, o - s), G.push(O, P, Q, N), G.push(n + r, o + s), G.push(O, P, Q, N), 
            H.push(K), d = 0; J > d; d++) H.push(K++);
            H.push(K - 1);
        }
    }, b.WebGLGraphics.buildComplexPoly = function(a, c) {
        var d = a.points.slice();
        if (!(d.length < 6)) {
            var e = c.indices;
            c.points = d, c.alpha = a.fillAlpha, c.color = b.hex2rgb(a.fillColor);
            for (var f, g, h = 1 / 0, i = -1 / 0, j = 1 / 0, k = -1 / 0, l = 0; l < d.length; l += 2) f = d[l], 
            g = d[l + 1], h = h > f ? f : h, i = f > i ? f : i, j = j > g ? g : j, k = g > k ? g : k;
            d.push(h, j, i, j, i, k, h, k);
            var m = d.length / 2;
            for (l = 0; m > l; l++) e.push(l);
        }
    }, b.WebGLGraphics.buildPoly = function(a, c) {
        var d = a.points;
        if (!(d.length < 6)) {
            var e = c.points, f = c.indices, g = d.length / 2, h = b.hex2rgb(a.fillColor), i = a.fillAlpha, j = h[0] * i, k = h[1] * i, l = h[2] * i, m = b.PolyK.Triangulate(d);
            if (!m) return !1;
            var n = e.length / 6, o = 0;
            for (o = 0; o < m.length; o += 3) f.push(m[o] + n), f.push(m[o] + n), f.push(m[o + 1] + n), 
            f.push(m[o + 2] + n), f.push(m[o + 2] + n);
            for (o = 0; g > o; o++) e.push(d[2 * o], d[2 * o + 1], j, k, l, i);
            return !0;
        }
    }, b.WebGLGraphics.graphicsDataPool = [], b.WebGLGraphicsData = function(a) {
        this.gl = a, this.color = [ 0, 0, 0 ], this.points = [], this.indices = [], this.buffer = a.createBuffer(), 
        this.indexBuffer = a.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0;
    }, b.WebGLGraphicsData.prototype.reset = function() {
        this.points = [], this.indices = [];
    }, b.WebGLGraphicsData.prototype.upload = function() {
        var a = this.gl;
        this.glPoints = new b.Float32Array(this.points), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), 
        a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW), this.glIndicies = new b.Uint16Array(this.indices), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW), 
        this.dirty = !1;
    }, b.glContexts = [], b.instances = [], b.WebGLRenderer = function(a, c, d) {
        if (d) for (var e in b.defaultRenderOptions) void 0 === d[e] && (d[e] = b.defaultRenderOptions[e]); else d = b.defaultRenderOptions;
        b.defaultRenderer || (b.defaultRenderer = this), this.type = b.WEBGL_RENDERER, this.resolution = d.resolution, 
        this.transparent = d.transparent, this.autoResize = d.autoResize || !1, this.preserveDrawingBuffer = d.preserveDrawingBuffer, 
        this.clearBeforeRender = d.clearBeforeRender, this.width = a || 800, this.height = c || 600, 
        this.view = d.view || document.createElement("canvas"), this._contextOptions = {
            alpha: this.transparent,
            antialias: d.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: d.preserveDrawingBuffer
        }, this.projection = new b.Point(), this.offset = new b.Point(0, 0), this.shaderManager = new b.WebGLShaderManager(), 
        this.spriteBatch = new b.WebGLSpriteBatch(), this.maskManager = new b.WebGLMaskManager(), 
        this.filterManager = new b.WebGLFilterManager(), this.stencilManager = new b.WebGLStencilManager(), 
        this.blendModeManager = new b.WebGLBlendModeManager(), this.renderSession = {}, 
        this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, 
        this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, 
        this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, 
        this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, 
        this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes();
    }, b.WebGLRenderer.prototype.constructor = b.WebGLRenderer, b.WebGLRenderer.prototype.initContext = function() {
        var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = a, !a) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = a.id = b.WebGLRenderer.glContextId++, b.glContexts[this.glContextId] = a, 
        b.instances[this.glContextId] = this, a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), 
        a.enable(a.BLEND), this.shaderManager.setContext(a), this.spriteBatch.setContext(a), 
        this.maskManager.setContext(a), this.filterManager.setContext(a), this.blendModeManager.setContext(a), 
        this.stencilManager.setContext(a), this.renderSession.gl = this.gl, this.resize(this.width, this.height);
    }, b.WebGLRenderer.prototype.render = function(a) {
        if (!this.contextLost) {
            this.__stage !== a && (this.__stage = a), a.updateTransform();
            var b = this.gl;
            b.viewport(0, 0, this.width, this.height), b.bindFramebuffer(b.FRAMEBUFFER, null), 
            this.clearBeforeRender && (this.transparent ? b.clearColor(0, 0, 0, 0) : b.clearColor(a.backgroundColorSplit[0], a.backgroundColorSplit[1], a.backgroundColorSplit[2], 1), 
            b.clear(b.COLOR_BUFFER_BIT)), this.renderDisplayObject(a, this.projection);
        }
    }, b.WebGLRenderer.prototype.renderDisplayObject = function(a, c, d, e) {
        this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL), this.renderSession.drawCount = 0, 
        this.renderSession.flipY = d ? -1 : 1, this.renderSession.projection = c, this.renderSession.offset = this.offset, 
        this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, d), 
        a._renderWebGL(this.renderSession, e), this.spriteBatch.end();
    }, b.WebGLRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, 
        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
        this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), 
        this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution;
    }, b.WebGLRenderer.prototype.updateTexture = function(a) {
        if (a.hasLoaded) {
            var c = this.gl;
            return a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()), c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]), 
            c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), 
            a.mipmap && b.isPowerOfTwo(a.width, a.height) ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST), 
            c.generateMipmap(c.TEXTURE_2D)) : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), 
            a._powerOf2 ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT)) : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)), a._dirty[c.id] = !1, 
            a._glTextures[c.id];
        }
    }, b.WebGLRenderer.prototype.destroy = function() {
        b.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, 
        this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), 
        this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, 
        this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, 
        b.CanvasPool.remove(this), b.instances[this.glContextId] = null, b.WebGLRenderer.glContextId--;
    }, b.WebGLRenderer.prototype.mapBlendModes = function() {
        var a = this.gl;
        b.blendModesWebGL || (b.blendModesWebGL = [], b.blendModesWebGL[b.blendModes.NORMAL] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.ADD] = [ a.SRC_ALPHA, a.DST_ALPHA ], b.blendModesWebGL[b.blendModes.MULTIPLY] = [ a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SCREEN] = [ a.SRC_ALPHA, a.ONE ], b.blendModesWebGL[b.blendModes.OVERLAY] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.DARKEN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.LIGHTEN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.COLOR_DODGE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.COLOR_BURN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.HARD_LIGHT] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SOFT_LIGHT] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.DIFFERENCE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.EXCLUSION] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.HUE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SATURATION] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.COLOR] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.LUMINOSITY] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ]);
    }, b.WebGLRenderer.glContextId = 0, b.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999;
    }, b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager, b.WebGLBlendModeManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
        if (this.currentBlendMode === a) return !1;
        this.currentBlendMode = a;
        var c = b.blendModesWebGL[this.currentBlendMode];
        return this.gl.blendFunc(c[0], c[1]), !0;
    }, b.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    }, b.WebGLMaskManager = function() {}, b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager, 
    b.WebGLMaskManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLMaskManager.prototype.pushMask = function(a, c) {
        var d = c.gl;
        a.dirty && b.WebGLGraphics.updateGraphics(a, d), a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c);
    }, b.WebGLMaskManager.prototype.popMask = function(a, b) {
        var c = this.gl;
        b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b);
    }, b.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    }, b.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0;
    }, b.WebGLStencilManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
        var d = this.gl;
        this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), 
        d.clear(d.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(b);
        var e = this.count;
        d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), 
        1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), 
        this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), 
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), 
        this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255), 
        this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), 
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), 
        d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)), 
        d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), this.count++;
    }, b.WebGLStencilManager.prototype.bindGraphics = function(a, c, d) {
        this._currentGraphics = a;
        var e, f = this.gl, g = d.projection, h = d.offset;
        1 === c.mode ? (e = d.shaderManager.complexPrimitiveShader, d.shaderManager.setShader(e), 
        f.uniform1f(e.flipY, d.flipY), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), 
        f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform3fv(e.color, c.color), f.uniform1f(e.alpha, a.worldAlpha * c.alpha), 
        f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 8, 0), 
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer)) : (e = d.shaderManager.primitiveShader, 
        d.shaderManager.setShader(e), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        f.uniform1f(e.flipY, d.flipY), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), 
        f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform1f(e.alpha, a.worldAlpha), 
        f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 24, 0), 
        f.vertexAttribPointer(e.colorAttribute, 4, f.FLOAT, !1, 24, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer));
    }, b.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
        var d = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) d.disable(d.STENCIL_TEST); else {
            var e = this.count;
            this.bindGraphics(a, b, c), d.colorMask(!1, !1, !1, !1), 1 === b.mode ? (this.reverse = !this.reverse, 
            this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), 
            d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), 
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), 
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)), 
            d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
        }
    }, b.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null;
    }, b.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var a = 0; a < this.maxAttibs; a++) this.attribState[a] = !1;
        this.stack = [];
    }, b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager, b.WebGLShaderManager.prototype.setContext = function(a) {
        this.gl = a, this.primitiveShader = new b.PrimitiveShader(a), this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a), 
        this.defaultShader = new b.PixiShader(a), this.fastShader = new b.PixiFastShader(a), 
        this.stripShader = new b.StripShader(a), this.setShader(this.defaultShader);
    }, b.WebGLShaderManager.prototype.setAttribs = function(a) {
        var b;
        for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            this.tempAttribState[c] = !0;
        }
        var d = this.gl;
        for (b = 0; b < this.attribState.length; b++) this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], 
        this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b));
    }, b.WebGLShaderManager.prototype.setShader = function(a) {
        return this._currentId === a._UID ? !1 : (this._currentId = a._UID, this.currentShader = a, 
        this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0);
    }, b.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), 
        this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), 
        this.stripShader.destroy(), this.gl = null;
    }, b.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var a = 4 * this.size * 4 * this.vertSize, c = 6 * this.size;
        this.vertices = new b.ArrayBuffer(a), this.positions = new b.Float32Array(this.vertices), 
        this.colors = new b.Uint32Array(this.vertices), this.indices = new b.Uint16Array(c), 
        this.lastIndexCount = 0;
        for (var d = 0, e = 0; c > d; d += 6, e += 4) this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, 
        this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, 
        this.indices[d + 5] = e + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, 
        this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], 
        this.defaultShader = new b.AbstractFilter([ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ]);
    }, b.WebGLSpriteBatch.prototype.setContext = function(a) {
        this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW), 
        this.currentBlendMode = 99999;
        var c = new b.PixiShader(a);
        c.fragmentSrc = this.defaultShader.fragmentSrc, c.uniforms = {}, c.init(), this.defaultShader.shaders[a.id] = c;
    }, b.WebGLSpriteBatch.prototype.begin = function(a) {
        this.renderSession = a, this.shader = this.renderSession.shaderManager.defaultShader, 
        this.start();
    }, b.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    }, b.WebGLSpriteBatch.prototype.render = function(a, b) {
        var c = a.texture, d = a.worldTransform;
        b && (d = b), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture);
        var e = c._uvs;
        if (e) {
            var f, g, h, i, j = a.anchor.x, k = a.anchor.y;
            if (c.trim) {
                var l = c.trim;
                g = l.x - j * l.width, f = g + c.crop.width, i = l.y - k * l.height, h = i + c.crop.height;
            } else f = c.frame.width * (1 - j), g = c.frame.width * -j, h = c.frame.height * (1 - k), 
            i = c.frame.height * -k;
            var m = 4 * this.currentBatchSize * this.vertSize, n = c.baseTexture.resolution, o = d.a / n, p = d.b / n, q = d.c / n, r = d.d / n, s = d.tx, t = d.ty, u = this.colors, v = this.positions;
            this.renderSession.roundPixels ? (v[m] = o * g + q * i + s | 0, v[m + 1] = r * i + p * g + t | 0, 
            v[m + 5] = o * f + q * i + s | 0, v[m + 6] = r * i + p * f + t | 0, v[m + 10] = o * f + q * h + s | 0, 
            v[m + 11] = r * h + p * f + t | 0, v[m + 15] = o * g + q * h + s | 0, v[m + 16] = r * h + p * g + t | 0) : (v[m] = o * g + q * i + s, 
            v[m + 1] = r * i + p * g + t, v[m + 5] = o * f + q * i + s, v[m + 6] = r * i + p * f + t, 
            v[m + 10] = o * f + q * h + s, v[m + 11] = r * h + p * f + t, v[m + 15] = o * g + q * h + s, 
            v[m + 16] = r * h + p * g + t), v[m + 2] = e.x0, v[m + 3] = e.y0, v[m + 7] = e.x1, 
            v[m + 8] = e.y1, v[m + 12] = e.x2, v[m + 13] = e.y2, v[m + 17] = e.x3, v[m + 18] = e.y3;
            var w = a.tint;
            u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * a.worldAlpha << 24), 
            this.sprites[this.currentBatchSize++] = a;
        }
    }, b.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
        var c = a.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture), 
        a._uvs || (a._uvs = new b.TextureUvs());
        var d = a._uvs, e = c.baseTexture.width, f = c.baseTexture.height;
        a.tilePosition.x %= e * a.tileScaleOffset.x, a.tilePosition.y %= f * a.tileScaleOffset.y;
        var g = a.tilePosition.x / (e * a.tileScaleOffset.x), h = a.tilePosition.y / (f * a.tileScaleOffset.y), i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x), j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
        d.x0 = 0 - g, d.y0 = 0 - h, d.x1 = 1 * i - g, d.y1 = 0 - h, d.x2 = 1 * i - g, d.y2 = 1 * j - h, 
        d.x3 = 0 - g, d.y3 = 1 * j - h;
        var k = a.tint, l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * a.worldAlpha << 24), m = this.positions, n = this.colors, o = a.width, p = a.height, q = a.anchor.x, r = a.anchor.y, s = o * (1 - q), t = o * -q, u = p * (1 - r), v = p * -r, w = 4 * this.currentBatchSize * this.vertSize, x = c.baseTexture.resolution, y = a.worldTransform, z = y.a / x, A = y.b / x, B = y.c / x, C = y.d / x, D = y.tx, E = y.ty;
        m[w++] = z * t + B * v + D, m[w++] = C * v + A * t + E, m[w++] = d.x0, m[w++] = d.y0, 
        n[w++] = l, m[w++] = z * s + B * v + D, m[w++] = C * v + A * s + E, m[w++] = d.x1, 
        m[w++] = d.y1, n[w++] = l, m[w++] = z * s + B * u + D, m[w++] = C * u + A * s + E, 
        m[w++] = d.x2, m[w++] = d.y2, n[w++] = l, m[w++] = z * t + B * u + D, m[w++] = C * u + A * t + E, 
        m[w++] = d.x3, m[w++] = d.y3, n[w++] = l, this.sprites[this.currentBatchSize++] = a;
    }, b.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a, c = this.gl;
            if (this.dirty) {
                this.dirty = !1, c.activeTexture(c.TEXTURE0), c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer), 
                c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a = this.defaultShader.shaders[c.id];
                var d = 4 * this.vertSize;
                c.vertexAttribPointer(a.aVertexPosition, 2, c.FLOAT, !1, d, 0), c.vertexAttribPointer(a.aTextureCoord, 2, c.FLOAT, !1, d, 8), 
                c.vertexAttribPointer(a.colorAttribute, 4, c.UNSIGNED_BYTE, !0, d, 16);
            }
            if (this.currentBatchSize > .5 * this.size) c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices); else {
                var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                c.bufferSubData(c.ARRAY_BUFFER, 0, e);
            }
            for (var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; r > q; q++) {
                if (i = this.sprites[q], f = i.tilingTexture ? i.tilingTexture.baseTexture : i.texture.baseTexture, 
                g = i.blendMode, h = i.shader || this.defaultShader, o = m !== g, p = n !== h, (l !== f || o || p) && (this.renderBatch(l, j, k), 
                k = q, j = 0, l = f, o && (m = g, this.renderSession.blendModeManager.setBlendMode(m)), 
                p)) {
                    n = h, a = n.shaders[c.id], a || (a = new b.PixiShader(c), a.fragmentSrc = n.fragmentSrc, 
                    a.uniforms = n.uniforms, a.init(), n.shaders[c.id] = a), this.renderSession.shaderManager.setShader(a), 
                    a.dirty && a.syncUniforms();
                    var s = this.renderSession.projection;
                    c.uniform2f(a.projectionVector, s.x, s.y);
                    var t = this.renderSession.offset;
                    c.uniform2f(a.offsetVector, t.x, t.y);
                }
                j++;
            }
            this.renderBatch(l, j, k), this.currentBatchSize = 0;
        }
    }, b.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
        if (0 !== b) {
            var d = this.gl;
            a._dirty[d.id] ? this.renderSession.renderer.updateTexture(a) : d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]), 
            d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++;
        }
    }, b.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0;
    }, b.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0;
    }, b.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), 
        this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null;
    }, b.WebGLFastSpriteBatch = function(a) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var c = 4 * this.size * this.vertSize, d = 6 * this.maxSize;
        this.vertices = new b.Float32Array(c), this.indices = new b.Uint16Array(d), this.vertexBuffer = null, 
        this.indexBuffer = null, this.lastIndexCount = 0;
        for (var e = 0, f = 0; d > e; e += 6, f += 4) this.indices[e + 0] = f + 0, this.indices[e + 1] = f + 1, 
        this.indices[e + 2] = f + 2, this.indices[e + 3] = f + 0, this.indices[e + 4] = f + 2, 
        this.indices[e + 5] = f + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, 
        this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(a);
    }, b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch, b.WebGLFastSpriteBatch.prototype.setContext = function(a) {
        this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
    }, b.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
        this.renderSession = b, this.shader = this.renderSession.shaderManager.fastShader, 
        this.matrix = a.worldTransform.toArray(!0), this.start();
    }, b.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    }, b.WebGLFastSpriteBatch.prototype.render = function(a) {
        var b = a.children, c = b[0];
        if (c.texture._uvs) {
            this.currentBaseTexture = c.texture.baseTexture, c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), 
            this.renderSession.blendModeManager.setBlendMode(c.blendMode));
            for (var d = 0, e = b.length; e > d; d++) this.renderSprite(b[d]);
            this.flush();
        }
    }, b.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
        if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || (this.flush(), 
        this.currentBaseTexture = a.texture.baseTexture, a.texture._uvs))) {
            var b, c, d, e, f, g, h, i, j = this.vertices;
            if (b = a.texture._uvs, c = a.texture.frame.width, d = a.texture.frame.height, a.texture.trim) {
                var k = a.texture.trim;
                f = k.x - a.anchor.x * k.width, e = f + a.texture.crop.width, h = k.y - a.anchor.y * k.height, 
                g = h + a.texture.crop.height;
            } else e = a.texture.frame.width * (1 - a.anchor.x), f = a.texture.frame.width * -a.anchor.x, 
            g = a.texture.frame.height * (1 - a.anchor.y), h = a.texture.frame.height * -a.anchor.y;
            i = 4 * this.currentBatchSize * this.vertSize, j[i++] = f, j[i++] = h, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x0, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = h, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x1, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = g, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x2, j[i++] = b.y2, j[i++] = a.alpha, j[i++] = f, j[i++] = g, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x3, j[i++] = b.y3, j[i++] = a.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush();
        }
    }, b.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a = this.gl;
            if (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a), 
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]), this.currentBatchSize > .5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices); else {
                var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b);
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, 
            this.renderSession.drawCount++;
        }
    }, b.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    }, b.WebGLFastSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var c = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0), a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8), 
        a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16), a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24), 
        a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28), a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36);
    }, b.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0;
    }, b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager, b.WebGLFilterManager.prototype.setContext = function(a) {
        this.gl = a, this.texturePool = [], this.initShaderBuffers();
    }, b.WebGLFilterManager.prototype.begin = function(a, b) {
        this.renderSession = a, this.defaultShader = a.shaderManager.defaultShader;
        var c = this.renderSession.projection;
        this.width = 2 * c.x, this.height = 2 * -c.y, this.buffer = b;
    }, b.WebGLFilterManager.prototype.pushFilter = function(a) {
        var c = this.gl, d = this.renderSession.projection, e = this.renderSession.offset;
        a._filterArea = a.target.filterArea || a.target.getBounds(), this.filterStack.push(a);
        var f = a.filterPasses[0];
        this.offsetX += a._filterArea.x, this.offsetY += a._filterArea.y;
        var g = this.texturePool.pop();
        g ? g.resize(this.width, this.height) : g = new b.FilterTexture(this.gl, this.width, this.height), 
        c.bindTexture(c.TEXTURE_2D, g.texture);
        var h = a._filterArea, i = f.padding;
        h.x -= i, h.y -= i, h.width += 2 * i, h.height += 2 * i, h.x < 0 && (h.x = 0), h.width > this.width && (h.width = this.width), 
        h.y < 0 && (h.y = 0), h.height > this.height && (h.height = this.height), c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer), 
        c.viewport(0, 0, h.width, h.height), d.x = h.width / 2, d.y = -h.height / 2, e.x = -h.x, 
        e.y = -h.y, c.colorMask(!0, !0, !0, !0), c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT), 
        a._glFilterTexture = g;
    }, b.WebGLFilterManager.prototype.popFilter = function() {
        var a = this.gl, c = this.filterStack.pop(), d = c._filterArea, e = c._glFilterTexture, f = this.renderSession.projection, g = this.renderSession.offset;
        if (c.filterPasses.length > 1) {
            a.viewport(0, 0, d.width, d.height), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), 
            this.vertexArray[0] = 0, this.vertexArray[1] = d.height, this.vertexArray[2] = d.width, 
            this.vertexArray[3] = d.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, 
            this.vertexArray[6] = d.width, this.vertexArray[7] = 0, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), 
            a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, 
            this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, 
            this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
            var h = e, i = this.texturePool.pop();
            i || (i = new b.FilterTexture(this.gl, this.width, this.height)), i.resize(this.width, this.height), 
            a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.clear(a.COLOR_BUFFER_BIT), a.disable(a.BLEND);
            for (var j = 0; j < c.filterPasses.length - 1; j++) {
                var k = c.filterPasses[j];
                a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), 
                this.applyFilterPass(k, d, d.width, d.height);
                var l = h;
                h = i, i = l;
            }
            a.enable(a.BLEND), e = h, this.texturePool.push(i);
        }
        var m = c.filterPasses[c.filterPasses.length - 1];
        this.offsetX -= d.x, this.offsetY -= d.y;
        var n = this.width, o = this.height, p = 0, q = 0, r = this.buffer;
        if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0); else {
            var s = this.filterStack[this.filterStack.length - 1];
            d = s._filterArea, n = d.width, o = d.height, p = d.x, q = d.y, r = s._glFilterTexture.frameBuffer;
        }
        f.x = n / 2, f.y = -o / 2, g.x = p, g.y = q, d = c._filterArea;
        var t = d.x - p, u = d.y - q;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = t, this.vertexArray[1] = u + d.height, 
        this.vertexArray[2] = t + d.width, this.vertexArray[3] = u + d.height, this.vertexArray[4] = t, 
        this.vertexArray[5] = u, this.vertexArray[6] = t + d.width, this.vertexArray[7] = u, 
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), 
        this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, 
        this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, 
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray), a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution), 
        a.bindFramebuffer(a.FRAMEBUFFER, r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture), 
        this.applyFilterPass(m, d, n, o), this.texturePool.push(e), c._glFilterTexture = null;
    }, b.WebGLFilterManager.prototype.applyFilterPass = function(a, c, d, e) {
        var f = this.gl, g = a.shaders[f.id];
        g || (g = new b.PixiShader(f), g.fragmentSrc = a.fragmentSrc, g.uniforms = a.uniforms, 
        g.init(), a.shaders[f.id] = g), this.renderSession.shaderManager.setShader(g), f.uniform2f(g.projectionVector, d / 2, -e / 2), 
        f.uniform2f(g.offsetVector, 0, 0), a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, 
        a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0], 
        a.uniforms.dimensions.value[3] = this.vertexArray[5]), g.syncUniforms(), f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer), 
        f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer), 
        f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer), 
        f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer), 
        f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), this.renderSession.drawCount++;
    }, b.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var a = this.gl;
        this.vertexBuffer = a.createBuffer(), this.uvBuffer = a.createBuffer(), this.colorBuffer = a.createBuffer(), 
        this.indexBuffer = a.createBuffer(), this.vertexArray = new b.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW), 
        this.uvArray = new b.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), 
        a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW), this.colorArray = new b.Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]), 
        a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), a.STATIC_DRAW);
    }, b.WebGLFilterManager.prototype.destroy = function() {
        var a = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for (var b = 0; b < this.texturePool.length; b++) this.texturePool[b].destroy();
        this.texturePool = null, a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), 
        a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer);
    }, b.FilterTexture = function(a, c, d, e) {
        this.gl = a, this.frameBuffer = a.createFramebuffer(), this.texture = a.createTexture(), 
        e = e || b.scaleModes.DEFAULT, a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), 
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), 
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 
        a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), 
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0), 
        this.renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer), 
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer), 
        this.resize(c, d);
    }, b.FilterTexture.prototype.constructor = b.FilterTexture, b.FilterTexture.prototype.clear = function() {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT);
    }, b.FilterTexture.prototype.resize = function(a, b) {
        if (this.width !== a || this.height !== b) {
            this.width = a, this.height = b;
            var c = this.gl;
            c.bindTexture(c.TEXTURE_2D, this.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null), 
            c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b);
        }
    }, b.FilterTexture.prototype.destroy = function() {
        var a = this.gl;
        a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), this.frameBuffer = null, 
        this.texture = null;
    }, b.CanvasBuffer = function(a, c) {
        this.width = a, this.height = c, this.canvas = b.CanvasPool.create(this, this.width, this.height), 
        this.context = this.canvas.getContext("2d"), this.canvas.width = a, this.canvas.height = c;
    }, b.CanvasBuffer.prototype.constructor = b.CanvasBuffer, b.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height);
    }, b.CanvasBuffer.prototype.resize = function(a, b) {
        this.width = this.canvas.width = a, this.height = this.canvas.height = b;
    }, b.CanvasBuffer.prototype.destroy = function() {
        b.CanvasPool.remove(this);
    }, b.CanvasMaskManager = function() {}, b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager, 
    b.CanvasMaskManager.prototype.pushMask = function(a, c) {
        var d = c.context;
        d.save();
        var e = a.alpha, f = a.worldTransform, g = c.resolution;
        d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), b.CanvasGraphics.renderGraphicsMask(a, d), 
        d.clip(), a.worldAlpha = e;
    }, b.CanvasMaskManager.prototype.popMask = function(a) {
        a.context.restore();
    }, b.CanvasTinter = function() {}, b.CanvasTinter.getTintedTexture = function(a, c) {
        var d = a.tintedTexture || b.CanvasPool.create(this);
        return b.CanvasTinter.tintMethod(a.texture, c, d), d;
    }, b.CanvasTinter.tintWithMultiply = function(a, b, c) {
        var d = c.getContext("2d"), e = a.crop;
        (c.width !== e.width || c.height !== e.height) && (c.width = e.width, c.height = e.height), 
        d.clearRect(0, 0, e.width, e.height), d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), 
        d.fillRect(0, 0, e.width, e.height), d.globalCompositeOperation = "multiply", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height), 
        d.globalCompositeOperation = "destination-atop", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
    }, b.CanvasTinter.tintWithPerPixel = function(a, c, d) {
        var e = d.getContext("2d"), f = a.crop;
        d.width = f.width, d.height = f.height, e.globalCompositeOperation = "copy", e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
        for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4) if (l[m + 0] *= h, 
        l[m + 1] *= i, l[m + 2] *= j, !b.CanvasTinter.canHandleAlpha) {
            var n = l[m + 3];
            l[m + 0] /= 255 / n, l[m + 1] /= 255 / n, l[m + 2] /= 255 / n;
        }
        e.putImageData(k, 0, 0);
    }, b.CanvasTinter.checkInverseAlpha = function() {
        var a = new b.CanvasBuffer(2, 1);
        a.context.fillStyle = "rgba(10, 20, 30, 0.5)", a.context.fillRect(0, 0, 1, 1);
        var c = a.context.getImageData(0, 0, 1, 1);
        if (null === c) return !1;
        a.context.putImageData(c, 1, 0);
        var d = a.context.getImageData(1, 0, 1, 1);
        return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3];
    }, b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha(), b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes(), 
    b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel, 
    b.CanvasRenderer = function(a, c, d) {
        if (d) for (var e in b.defaultRenderOptions) void 0 === d[e] && (d[e] = b.defaultRenderOptions[e]); else d = b.defaultRenderOptions;
        b.defaultRenderer || (b.defaultRenderer = this), this.type = b.CANVAS_RENDERER, 
        this.resolution = d.resolution, this.clearBeforeRender = d.clearBeforeRender, this.transparent = d.transparent, 
        this.autoResize = d.autoResize || !1, this.width = a || 800, this.height = c || 600, 
        this.width *= this.resolution, this.height *= this.resolution, this.view = d.view || b.CanvasPool.create(this, this.width, this.height), 
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.view.width = this.width * this.resolution, this.view.height = this.height * this.resolution, 
        this.count = 0, this.maskManager = new b.CanvasMaskManager(), this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null,
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(a, c), "imageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "oImageSmoothingEnabled" : "msImageSmoothingEnabled" in this.context && (this.renderSession.smoothProperty = "msImageSmoothingEnabled");
    }, b.CanvasRenderer.prototype.constructor = b.CanvasRenderer, b.CanvasRenderer.prototype.render = function(a) {
        a.updateTransform(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, 
        this.renderSession.currentBlendMode = b.blendModes.NORMAL, this.context.globalCompositeOperation = b.blendModesCanvas[b.blendModes.NORMAL], 
        navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", 
        this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : (this.context.fillStyle = a.backgroundColorString, 
        this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(a);
    }, b.CanvasRenderer.prototype.destroy = function(a) {
        void 0 === a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), 
        this.view = null, this.context = null, this.maskManager = null, this.renderSession = null;
    }, b.CanvasRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, 
        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
        this.view.style.height = this.height / this.resolution + "px");
    }, b.CanvasRenderer.prototype.renderDisplayObject = function(a, b, c) {
        this.renderSession.context = b || this.context, this.renderSession.resolution = this.resolution, 
        a._renderCanvas(this.renderSession, c);
    }, b.CanvasRenderer.prototype.mapBlendModes = function() {
        b.blendModesCanvas || (b.blendModesCanvas = [], b.canUseNewCanvasBlendModes() ? (b.blendModesCanvas[b.blendModes.NORMAL] = "source-over", 
        b.blendModesCanvas[b.blendModes.ADD] = "lighter", b.blendModesCanvas[b.blendModes.MULTIPLY] = "multiply", 
        b.blendModesCanvas[b.blendModes.SCREEN] = "screen", b.blendModesCanvas[b.blendModes.OVERLAY] = "overlay", 
        b.blendModesCanvas[b.blendModes.DARKEN] = "darken", b.blendModesCanvas[b.blendModes.LIGHTEN] = "lighten", 
        b.blendModesCanvas[b.blendModes.COLOR_DODGE] = "color-dodge", b.blendModesCanvas[b.blendModes.COLOR_BURN] = "color-burn", 
        b.blendModesCanvas[b.blendModes.HARD_LIGHT] = "hard-light", b.blendModesCanvas[b.blendModes.SOFT_LIGHT] = "soft-light", 
        b.blendModesCanvas[b.blendModes.DIFFERENCE] = "difference", b.blendModesCanvas[b.blendModes.EXCLUSION] = "exclusion", 
        b.blendModesCanvas[b.blendModes.HUE] = "hue", b.blendModesCanvas[b.blendModes.SATURATION] = "saturation", 
        b.blendModesCanvas[b.blendModes.COLOR] = "color", b.blendModesCanvas[b.blendModes.LUMINOSITY] = "luminosity") : (b.blendModesCanvas[b.blendModes.NORMAL] = "source-over", 
        b.blendModesCanvas[b.blendModes.ADD] = "lighter", b.blendModesCanvas[b.blendModes.MULTIPLY] = "source-over", 
        b.blendModesCanvas[b.blendModes.SCREEN] = "source-over", b.blendModesCanvas[b.blendModes.OVERLAY] = "source-over", 
        b.blendModesCanvas[b.blendModes.DARKEN] = "source-over", b.blendModesCanvas[b.blendModes.LIGHTEN] = "source-over", 
        b.blendModesCanvas[b.blendModes.COLOR_DODGE] = "source-over", b.blendModesCanvas[b.blendModes.COLOR_BURN] = "source-over", 
        b.blendModesCanvas[b.blendModes.HARD_LIGHT] = "source-over", b.blendModesCanvas[b.blendModes.SOFT_LIGHT] = "source-over", 
        b.blendModesCanvas[b.blendModes.DIFFERENCE] = "source-over", b.blendModesCanvas[b.blendModes.EXCLUSION] = "source-over", 
        b.blendModesCanvas[b.blendModes.HUE] = "source-over", b.blendModesCanvas[b.blendModes.SATURATION] = "source-over", 
        b.blendModesCanvas[b.blendModes.COLOR] = "source-over", b.blendModesCanvas[b.blendModes.LUMINOSITY] = "source-over"));
    }, b.CanvasGraphics = function() {}, b.CanvasGraphics.renderGraphics = function(a, c) {
        var d = a.worldAlpha;
        a.dirty && (this.updateGraphicsTint(a), a.dirty = !1);
        for (var e = 0; e < a.graphicsData.length; e++) {
            var f = a.graphicsData[e], g = f.shape, h = f._fillTint, i = f._lineTint;
            if (c.lineWidth = f.lineWidth, f.type === b.Graphics.POLY) {
                c.beginPath();
                var j = g.points;
                c.moveTo(j[0], j[1]);
                for (var k = 1; k < j.length / 2; k++) c.lineTo(j[2 * k], j[2 * k + 1]);
                g.closed && c.lineTo(j[0], j[1]), j[0] === j[j.length - 2] && j[1] === j[j.length - 1] && c.closePath(), 
                f.fill && (c.globalAlpha = f.fillAlpha * d, c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), 
                c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
                c.stroke());
            } else if (f.type === b.Graphics.RECT) (f.fillColor || 0 === f.fillColor) && (c.globalAlpha = f.fillAlpha * d, 
            c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fillRect(g.x, g.y, g.width, g.height)), 
            f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
            c.strokeRect(g.x, g.y, g.width, g.height)); else if (f.type === b.Graphics.CIRC) c.beginPath(), 
            c.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), c.closePath(), f.fill && (c.globalAlpha = f.fillAlpha * d, 
            c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, 
            c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), c.stroke()); else if (f.type === b.Graphics.ELIP) {
                var l = 2 * g.width, m = 2 * g.height, n = g.x - l / 2, o = g.y - m / 2;
                c.beginPath();
                var p = .5522848, q = l / 2 * p, r = m / 2 * p, s = n + l, t = o + m, u = n + l / 2, v = o + m / 2;
                c.moveTo(n, v), c.bezierCurveTo(n, v - r, u - q, o, u, o), c.bezierCurveTo(u + q, o, s, v - r, s, v), 
                c.bezierCurveTo(s, v + r, u + q, t, u, t), c.bezierCurveTo(u - q, t, n, v + r, n, v), 
                c.closePath(), f.fill && (c.globalAlpha = f.fillAlpha * d, c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), 
                c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
                c.stroke());
            } else if (f.type === b.Graphics.RREC) {
                var w = g.x, x = g.y, y = g.width, z = g.height, A = g.radius, B = Math.min(y, z) / 2 | 0;
                A = A > B ? B : A, c.beginPath(), c.moveTo(w, x + A), c.lineTo(w, x + z - A), c.quadraticCurveTo(w, x + z, w + A, x + z), 
                c.lineTo(w + y - A, x + z), c.quadraticCurveTo(w + y, x + z, w + y, x + z - A), 
                c.lineTo(w + y, x + A), c.quadraticCurveTo(w + y, x, w + y - A, x), c.lineTo(w + A, x), 
                c.quadraticCurveTo(w, x, w, x + A), c.closePath(), (f.fillColor || 0 === f.fillColor) && (c.globalAlpha = f.fillAlpha * d, 
                c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, 
                c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), c.stroke());
            }
        }
    }, b.CanvasGraphics.renderGraphicsMask = function(a, c) {
        var d = a.graphicsData.length;
        if (0 !== d) {
            c.beginPath();
            for (var e = 0; d > e; e++) {
                var f = a.graphicsData[e], g = f.shape;
                if (f.type === b.Graphics.POLY) {
                    var h = g.points;
                    c.moveTo(h[0], h[1]);
                    for (var i = 1; i < h.length / 2; i++) c.lineTo(h[2 * i], h[2 * i + 1]);
                    h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && c.closePath();
                } else if (f.type === b.Graphics.RECT) c.rect(g.x, g.y, g.width, g.height), c.closePath(); else if (f.type === b.Graphics.CIRC) c.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), 
                c.closePath(); else if (f.type === b.Graphics.ELIP) {
                    var j = 2 * g.width, k = 2 * g.height, l = g.x - j / 2, m = g.y - k / 2, n = .5522848, o = j / 2 * n, p = k / 2 * n, q = l + j, r = m + k, s = l + j / 2, t = m + k / 2;
                    c.moveTo(l, t), c.bezierCurveTo(l, t - p, s - o, m, s, m), c.bezierCurveTo(s + o, m, q, t - p, q, t), 
                    c.bezierCurveTo(q, t + p, s + o, r, s, r), c.bezierCurveTo(s - o, r, l, t + p, l, t), 
                    c.closePath();
                } else if (f.type === b.Graphics.RREC) {
                    var u = g.x, v = g.y, w = g.width, x = g.height, y = g.radius, z = Math.min(w, x) / 2 | 0;
                    y = y > z ? z : y, c.moveTo(u, v + y), c.lineTo(u, v + x - y), c.quadraticCurveTo(u, v + x, u + y, v + x), 
                    c.lineTo(u + w - y, v + x), c.quadraticCurveTo(u + w, v + x, u + w, v + x - y), 
                    c.lineTo(u + w, v + y), c.quadraticCurveTo(u + w, v, u + w - y, v), c.lineTo(u + y, v), 
                    c.quadraticCurveTo(u, v, u, v + y), c.closePath();
                }
            }
        }
    }, b.CanvasGraphics.updateGraphicsTint = function(a) {
        if (16777215 !== a.tint) for (var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
            var f = a.graphicsData[e], g = 0 | f.fillColor, h = 0 | f.lineColor;
            f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255, 
            f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255;
        }
    }, b.BaseTextureCache = {}, b.BaseTextureCacheIdGenerator = 0, b.BaseTexture = function(a, c) {
        this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = c || b.scaleModes.DEFAULT, 
        this.hasLoaded = !1, this.source = a, this._UID = b._UID++, this.premultipliedAlpha = !0, 
        this._glTextures = [], this.mipmap = !1, this._dirty = [ !0, !0, !0, !0 ], a && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, 
        this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, 
        this.dirty()), this.imageUrl = null, this._powerOf2 = !1);
    }, b.BaseTexture.prototype.constructor = b.BaseTexture, b.BaseTexture.prototype.forceLoaded = function(a, b) {
        this.hasLoaded = !0, this.width = a, this.height = b, this.dirty();
    }, b.BaseTexture.prototype.destroy = function() {
        this.imageUrl ? (delete b.BaseTextureCache[this.imageUrl], delete b.TextureCache[this.imageUrl], 
        this.imageUrl = null, navigator.isCocoonJS || (this.source.src = "")) : this.source && this.source._pixiId && (b.CanvasPool.removeByCanvas(this.source), 
        delete b.BaseTextureCache[this.source._pixiId]), this.source = null, this.unloadFromGPU();
    }, b.BaseTexture.prototype.updateSourceImage = function(a) {
        this.hasLoaded = !1, this.source.src = null, this.source.src = a;
    }, b.BaseTexture.prototype.dirty = function() {
        for (var a = 0; a < this._glTextures.length; a++) this._dirty[a] = !0;
    }, b.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var a = this._glTextures.length - 1; a >= 0; a--) {
            var c = this._glTextures[a], d = b.glContexts[a];
            d && c && d.deleteTexture(c);
        }
        this._glTextures.length = 0, this.dirty();
    }, b.BaseTexture.fromImage = function(a, c, d) {
        var e = b.BaseTextureCache[a];
        if (void 0 === c && -1 === a.indexOf("data:") && (c = !0), !e) {
            var f = new Image();
            c && (f.crossOrigin = ""), f.src = a, e = new b.BaseTexture(f, d), e.imageUrl = a, 
            b.BaseTextureCache[a] = e, -1 !== a.indexOf(b.RETINA_PREFIX + ".") && (e.resolution = 2);
        }
        return e;
    }, b.BaseTexture.fromCanvas = function(a, c) {
        a._pixiId || (a._pixiId = "canvas_" + b.TextureCacheIdGenerator++), 0 === a.width && (a.width = 1), 
        0 === a.height && (a.height = 1);
        var d = b.BaseTextureCache[a._pixiId];
        return d || (d = new b.BaseTexture(a, c), b.BaseTextureCache[a._pixiId] = d), d;
    }, b.TextureCache = {}, b.FrameCache = {}, b.TextureSilentFail = !1, b.TextureCacheIdGenerator = 0, 
    b.Texture = function(a, c, d, e) {
        this.noFrame = !1, c || (this.noFrame = !0, c = new b.Rectangle(0, 0, 1, 1)), a instanceof b.Texture && (a = a.baseTexture), 
        this.baseTexture = a, this.frame = c, this.trim = e, this.valid = !1, this.isTiling = !1, 
        this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, 
        this.height = 0, this.crop = d || new b.Rectangle(0, 0, 1, 1), a.hasLoaded && (this.noFrame && (c = new b.Rectangle(0, 0, a.width, a.height)), 
        this.setFrame(c));
    }, b.Texture.prototype.constructor = b.Texture, b.Texture.prototype.onBaseTextureLoaded = function() {
        var a = this.baseTexture;
        this.noFrame && (this.frame = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(this.frame);
    }, b.Texture.prototype.destroy = function(a) {
        a && this.baseTexture.destroy(), this.valid = !1;
    }, b.Texture.prototype.setFrame = function(a) {
        if (this.noFrame = !1, this.frame = a, this.width = a.width, this.height = a.height, 
        this.crop.x = a.x, this.crop.y = a.y, this.crop.width = a.width, this.crop.height = a.height, 
        !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) {
            if (!b.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            return void (this.valid = !1);
        }
        this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded, 
        this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, 
        this.frame.height = this.trim.height), this.valid && this._updateUvs();
    }, b.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new b.TextureUvs());
        var a = this.crop, c = this.baseTexture.width, d = this.baseTexture.height;
        this._uvs.x0 = a.x / c, this._uvs.y0 = a.y / d, this._uvs.x1 = (a.x + a.width) / c, 
        this._uvs.y1 = a.y / d, this._uvs.x2 = (a.x + a.width) / c, this._uvs.y2 = (a.y + a.height) / d, 
        this._uvs.x3 = a.x / c, this._uvs.y3 = (a.y + a.height) / d;
    }, b.Texture.fromImage = function(a, c, d) {
        var e = b.TextureCache[a];
        return e || (e = new b.Texture(b.BaseTexture.fromImage(a, c, d)), b.TextureCache[a] = e), 
        e;
    }, b.Texture.fromFrame = function(a) {
        var c = b.TextureCache[a];
        if (!c) throw new Error('The frameId "' + a + '" does not exist in the texture cache ');
        return c;
    }, b.Texture.fromCanvas = function(a, c) {
        var d = b.BaseTexture.fromCanvas(a, c);
        return new b.Texture(d);
    }, b.Texture.addTextureToCache = function(a, c) {
        b.TextureCache[c] = a;
    }, b.Texture.removeTextureFromCache = function(a) {
        var c = b.TextureCache[a];
        return delete b.TextureCache[a], delete b.BaseTextureCache[a], c;
    }, b.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, 
        this.y3 = 0;
    }, b.RenderTexture = function(a, c, d, e, f) {
        if (this.width = a || 100, this.height = c || 100, this.resolution = f || 1, this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
        this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
        this.baseTexture = new b.BaseTexture(), this.baseTexture.width = this.width * this.resolution, 
        this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], 
        this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT, 
        this.baseTexture.hasLoaded = !0, b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), 
        this.renderer = d || b.defaultRenderer, this.renderer.type === b.WEBGL_RENDERER) {
            var g = this.renderer.gl;
            this.baseTexture._dirty[g.id] = !1, this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode), 
            this.baseTexture._glTextures[g.id] = this.textureBuffer.texture, this.render = this.renderWebGL, 
            this.projection = new b.Point(.5 * this.width, .5 * -this.height);
        } else this.render = this.renderCanvas, this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), 
        this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix(), this._updateUvs();
    }, b.RenderTexture.prototype = Object.create(b.Texture.prototype), b.RenderTexture.prototype.constructor = b.RenderTexture, 
    b.RenderTexture.prototype.resize = function(a, c, d) {
        (a !== this.width || c !== this.height) && (this.valid = a > 0 && c > 0, this.width = a, 
        this.height = c, this.frame.width = this.crop.width = a * this.resolution, this.frame.height = this.crop.height = c * this.resolution, 
        d && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), 
        this.renderer.type === b.WEBGL_RENDERER && (this.projection.x = this.width / 2, 
        this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height));
    }, b.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), 
        this.textureBuffer.clear());
    }, b.RenderTexture.prototype.renderWebGL = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1);
            for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
            var f = this.renderer.gl;
            f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer), 
            c && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b), 
            this.renderer.spriteBatch.dirty = !0;
        }
    }, b.RenderTexture.prototype.renderCanvas = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(), b && d.append(b);
            for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
            c && this.textureBuffer.clear();
            var f = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(a, this.textureBuffer.context, b), 
            this.renderer.resolution = f;
        }
    }, b.RenderTexture.prototype.getImage = function() {
        var a = new Image();
        return a.src = this.getBase64(), a;
    }, b.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    }, b.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === b.WEBGL_RENDERER) {
            var a = this.renderer.gl, c = this.textureBuffer.width, d = this.textureBuffer.height, e = new Uint8Array(4 * c * d);
            a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e), 
            a.bindFramebuffer(a.FRAMEBUFFER, null);
            var f = new b.CanvasBuffer(c, d), g = f.context.getImageData(0, 0, c, d);
            return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas;
        }
        return this.textureBuffer.canvas;
    }, b.AbstractFilter = function(a, b) {
        this.passes = [ this ], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = b || {}, 
        this.fragmentSrc = a || [];
    }, b.AbstractFilter.prototype.constructor = b.AbstractFilter, b.AbstractFilter.prototype.syncUniforms = function() {
        for (var a = 0, b = this.shaders.length; b > a; a++) this.shaders[a].dirty = !0;
    }, b.Strip = function(a) {
        b.DisplayObjectContainer.call(this), this.texture = a, this.uvs = new b.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]), 
        this.vertices = new b.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]), this.colors = new b.Float32Array([ 1, 1, 1, 1 ]), 
        this.indices = new b.Uint16Array([ 0, 1, 2, 3 ]), this.dirty = !0, this.blendMode = b.blendModes.NORMAL, 
        this.canvasPadding = 0, this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP;
    }, b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Strip.prototype.constructor = b.Strip, 
    b.Strip.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), 
        a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start());
    }, b.Strip.prototype._initWebGL = function(a) {
        var b = a.gl;
        this._vertexBuffer = b.createBuffer(), this._indexBuffer = b.createBuffer(), this._uvBuffer = b.createBuffer(), 
        this._colorBuffer = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), 
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW);
    }, b.Strip.prototype._renderStrip = function(a) {
        var c = a.gl, d = a.projection, e = a.offset, f = a.shaderManager.stripShader, g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
        a.blendModeManager.setBlendMode(this.blendMode), c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)), 
        c.uniform2f(f.projectionVector, d.x, -d.y), c.uniform2f(f.offsetVector, -e.x, -e.y), 
        c.uniform1f(f.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), 
        c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), 
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW), 
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), 
        this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), 
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW)) : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), 
        c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), 
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), 
        c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), 
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0);
    }, b.Strip.prototype._renderCanvas = function(a) {
        var c = a.context, d = this.worldTransform;
        a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | d.tx, 0 | d.ty) : c.setTransform(d.a, d.b, d.c, d.d, d.tx, d.ty), 
        this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c);
    }, b.Strip.prototype._renderCanvasTriangleStrip = function(a) {
        var b = this.vertices, c = this.uvs, d = b.length / 2;
        this.count++;
        for (var e = 0; d - 2 > e; e++) {
            var f = 2 * e;
            this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4);
        }
    }, b.Strip.prototype._renderCanvasTriangles = function(a) {
        var b = this.vertices, c = this.uvs, d = this.indices, e = d.length;
        this.count++;
        for (var f = 0; e > f; f += 3) {
            var g = 2 * d[f], h = 2 * d[f + 1], i = 2 * d[f + 2];
            this._renderCanvasDrawTriangle(a, b, c, g, h, i);
        }
    }, b.Strip.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
        var g = this.texture.baseTexture.source, h = this.texture.width, i = this.texture.height, j = b[d], k = b[e], l = b[f], m = b[d + 1], n = b[e + 1], o = b[f + 1], p = c[d] * h, q = c[e] * h, r = c[f] * h, s = c[d + 1] * i, t = c[e + 1] * i, u = c[f + 1] * i;
        if (this.canvasPadding > 0) {
            var v = this.canvasPadding / this.worldTransform.a, w = this.canvasPadding / this.worldTransform.d, x = (j + k + l) / 3, y = (m + n + o) / 3, z = j - x, A = m - y, B = Math.sqrt(z * z + A * A);
            j = x + z / B * (B + v), m = y + A / B * (B + w), z = k - x, A = n - y, B = Math.sqrt(z * z + A * A), 
            k = x + z / B * (B + v), n = y + A / B * (B + w), z = l - x, A = o - y, B = Math.sqrt(z * z + A * A), 
            l = x + z / B * (B + v), o = y + A / B * (B + w);
        }
        a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), 
        a.clip();
        var C = p * t + s * r + q * u - t * r - s * q - p * u, D = j * t + s * l + k * u - t * l - s * k - j * u, E = p * k + j * r + q * l - k * r - j * q - p * l, F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u, G = m * t + s * o + n * u - t * o - s * n - m * u, H = p * n + m * r + q * o - n * r - m * q - p * o, I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
        a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore();
    }, b.Strip.prototype.renderStripFlat = function(a) {
        var b = this.context, c = a.vertices, d = c.length / 2;
        this.count++, b.beginPath();
        for (var e = 1; d - 2 > e; e++) {
            var f = 2 * e, g = c[f], h = c[f + 2], i = c[f + 4], j = c[f + 1], k = c[f + 3], l = c[f + 5];
            b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l);
        }
        b.fillStyle = "#FF0000", b.fill(), b.closePath();
    }, b.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0;
    }, b.Strip.prototype.getBounds = function(a) {
        for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -1 / 0, k = -1 / 0, l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; p > o; o += 2) {
            var q = n[o], r = n[o + 1], s = d * q + f * r + h, t = g * r + e * q + i;
            l = l > s ? s : l, m = m > t ? t : m, j = s > j ? s : j, k = t > k ? t : k;
        }
        if (l === -1 / 0 || 1 / 0 === k) return b.EmptyRectangle;
        var u = this._bounds;
        return u.x = l, u.width = j - l, u.y = m, u.height = k - m, this._currentBounds = u, 
        u;
    }, b.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    }, b.Rope = function(a, c) {
        b.Strip.call(this, a), this.points = c, this.vertices = new b.Float32Array(4 * c.length), 
        this.uvs = new b.Float32Array(4 * c.length), this.colors = new b.Float32Array(2 * c.length), 
        this.indices = new b.Uint16Array(2 * c.length), this.refresh();
    }, b.Rope.prototype = Object.create(b.Strip.prototype), b.Rope.prototype.constructor = b.Rope, 
    b.Rope.prototype.refresh = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var b = this.uvs, c = a[0], d = this.indices, e = this.colors;
            this.count -= .2, b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1, e[0] = 1, e[1] = 1, d[0] = 0, 
            d[1] = 1;
            for (var f, g, h, i = a.length, j = 1; i > j; j++) f = a[j], g = 4 * j, h = j / (i - 1), 
            j % 2 ? (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1) : (b[g] = h, b[g + 1] = 0, 
            b[g + 2] = h, b[g + 3] = 1), g = 2 * j, e[g] = 1, e[g + 1] = 1, g = 2 * j, d[g] = g, 
            d[g + 1] = g + 1, c = f;
        }
    }, b.Rope.prototype.updateTransform = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var c, d = a[0], e = {
                x: 0,
                y: 0
            };
            this.count -= .2;
            for (var f, g, h, i, j, k = this.vertices, l = a.length, m = 0; l > m; m++) f = a[m], 
            g = 4 * m, c = m < a.length - 1 ? a[m + 1] : f, e.y = -(c.x - d.x), e.x = c.y - d.y, 
            h = 10 * (1 - m / (l - 1)), h > 1 && (h = 1), i = Math.sqrt(e.x * e.x + e.y * e.y), 
            j = this.texture.height / 2, e.x /= i, e.y /= i, e.x *= j, e.y *= j, k[g] = f.x + e.x, 
            k[g + 1] = f.y + e.y, k[g + 2] = f.x - e.x, k[g + 3] = f.y - e.y, d = f;
            b.DisplayObjectContainer.prototype.updateTransform.call(this);
        }
    }, b.Rope.prototype.setTexture = function(a) {
        this.texture = a;
    }, b.TilingSprite = function(a, c, d) {
        b.Sprite.call(this, a), this._width = c || 128, this._height = d || 128, this.tileScale = new b.Point(1, 1), 
        this.tileScaleOffset = new b.Point(1, 1), this.tilePosition = new b.Point(), this.renderable = !0, 
        this.tint = 16777215, this.textureDebug = !1, this.blendMode = b.blendModes.NORMAL, 
        this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, 
        this.frameWidth = 0, this.frameHeight = 0;
    }, b.TilingSprite.prototype = Object.create(b.Sprite.prototype), b.TilingSprite.prototype.constructor = b.TilingSprite, 
    b.TilingSprite.prototype.setTexture = function(a) {
        this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215);
    }, b.TilingSprite.prototype._renderWebGL = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            if (this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), 
            this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), 
            this.refreshTexture) {
                if (this.generateTilingTexture(!0), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture), 
                this.tilingTexture.needsUpdate = !1);
            }
            a.spriteBatch.renderTilingSprite(this);
            for (var b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
            a.spriteBatch.stop(), this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this._mask, a), 
            a.spriteBatch.start();
        }
    }, b.TilingSprite.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            var c = a.context;
            this._mask && a.maskManager.pushMask(this._mask, a), c.globalAlpha = this.worldAlpha;
            var d = this.worldTransform, e = a.resolution;
            if (c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, d.tx * e, d.ty * e), this.refreshTexture) {
                if (this.generateTilingTexture(!1), !this.tilingTexture) return;
                this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            }
            var f = a.currentBlendMode;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]);
            var g = this.tilePosition, h = this.tileScale;
            g.x %= this.tilingTexture.baseTexture.width, g.y %= this.tilingTexture.baseTexture.height, 
            c.scale(h.x, h.y), c.translate(g.x + this.anchor.x * -this._width, g.y + this.anchor.y * -this._height), 
            c.fillStyle = this.tilePattern;
            var i = -g.x, j = -g.y, k = this._width / h.x, l = this._height / h.y;
            a.roundPixels && (i |= 0, j |= 0, k |= 0, l |= 0), c.fillRect(i, j, k, l), c.scale(1 / h.x, 1 / h.y), 
            c.translate(-g.x + this.anchor.x * this._width, -g.y + this.anchor.y * this._height), 
            this._mask && a.maskManager.popMask(a);
            for (var m = 0; m < this.children.length; m++) this.children[m]._renderCanvas(a);
            f !== this.blendMode && (a.currentBlendMode = f, c.globalCompositeOperation = b.blendModesCanvas[f]);
        }
    }, b.TilingSprite.prototype.onTextureUpdate = function() {}, b.TilingSprite.prototype.generateTilingTexture = function(a) {
        if (this.texture.baseTexture.hasLoaded) {
            var c = this.texture, d = c.frame, e = this._frame.sourceSizeW, f = this._frame.sourceSizeH, g = 0, h = 0;
            this._frame.trimmed && (g = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), 
            a && (e = b.getNextPowerOfTwo(e), f = b.getNextPowerOfTwo(f)), this.canvasBuffer ? (this.canvasBuffer.resize(e, f), 
            this.tilingTexture.baseTexture.width = e, this.tilingTexture.baseTexture.height = f, 
            this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new b.CanvasBuffer(e, f), 
            this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas), 
            this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", 
            this.canvasBuffer.context.strokeRect(0, 0, e, f));
            var i = c.crop.width, j = c.crop.height;
            (i !== e || j !== f) && (i = e, j = f), this.canvasBuffer.context.drawImage(c.baseTexture.source, c.crop.x, c.crop.y, c.crop.width, c.crop.height, g, h, i, j), 
            this.tileScaleOffset.x = d.width / e, this.tileScaleOffset.y = d.height / f, this.refreshTexture = !1, 
            this.tilingTexture.baseTexture._powerOf2 = !0;
        }
    }, b.TilingSprite.prototype.getBounds = function() {
        var a = this._width, b = this._height, c = a * (1 - this.anchor.x), d = a * -this.anchor.x, e = b * (1 - this.anchor.y), f = b * -this.anchor.y, g = this.worldTransform, h = g.a, i = g.b, j = g.c, k = g.d, l = g.tx, m = g.ty, n = h * d + j * f + l, o = k * f + i * d + m, p = h * c + j * f + l, q = k * f + i * c + m, r = h * c + j * e + l, s = k * e + i * c + m, t = h * d + j * e + l, u = k * e + i * d + m, v = -1 / 0, w = -1 / 0, x = 1 / 0, y = 1 / 0;
        x = x > n ? n : x, x = x > p ? p : x, x = x > r ? r : x, x = x > t ? t : x, y = y > o ? o : y, 
        y = y > q ? q : y, y = y > s ? s : y, y = y > u ? u : y, v = n > v ? n : v, v = p > v ? p : v, 
        v = r > v ? r : v, v = t > v ? t : v, w = o > w ? o : w, w = q > w ? q : w, w = s > w ? s : w, 
        w = u > w ? u : w;
        var z = this._bounds;
        return z.x = x, z.width = v - x, z.y = y, z.height = w - y, this._currentBounds = z, 
        z;
    }, b.TilingSprite.prototype.destroy = function() {
        this.canvasBuffer.destroy(), b.Sprite.prototype.destroy.call(this), this.tileScale = null, 
        this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), 
        this.tilingTexture = null);
    }, Object.defineProperty(b.TilingSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(a) {
            this._width = a;
        }
    }), Object.defineProperty(b.TilingSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(a) {
            this._height = a;
        }
    }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b), 
    exports.PIXI = b) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
        return a.PIXI = b;
    }()) : a.PIXI = b, b;
}.call(this), function() {
    function a(a, b) {
        this._scaleFactor = a, this._deltaMode = b, this.originalEvent = null;
    }
    var b = this, c = c || {
        VERSION: "2.4.3",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        },
        PIXI: PIXI || {}
    };
    if (Math.trunc || (Math.trunc = function(a) {
        return 0 > a ? Math.ceil(a) : Math.floor(a);
    }), Function.prototype.bind || (Function.prototype.bind = function() {
        var a = Array.prototype.slice;
        return function(b) {
            function c() {
                var f = e.concat(a.call(arguments));
                d.apply(this instanceof c ? this : b, f);
            }
            var d = this, e = a.call(arguments, 1);
            if ("function" != typeof d) throw new TypeError();
            return c.prototype = function f(a) {
                return a && (f.prototype = a), this instanceof f ? void 0 : new f();
            }(d.prototype), c;
        };
    }()), Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" == Object.prototype.toString.call(a);
    }), Array.prototype.forEach || (Array.prototype.forEach = function(a) {
        "use strict";
        if (void 0 === this || null === this) throw new TypeError();
        var b = Object(this), c = b.length >>> 0;
        if ("function" != typeof a) throw new TypeError();
        for (var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; c > e; e++) e in b && a.call(d, b[e], e, b);
    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
        var d = function(a) {
            var b = new Array();
            window[a] = function(a) {
                if ("number" == typeof a) {
                    Array.call(this, a), this.length = a;
                    for (var b = 0; b < this.length; b++) this[b] = 0;
                } else {
                    Array.call(this, a.length), this.length = a.length;
                    for (var b = 0; b < this.length; b++) this[b] = a[b];
                }
            }, window[a].prototype = b, window[a].constructor = window[a];
        };
        d("Uint32Array"), d("Int16Array");
    }
    window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, 
    window.console.warn = window.console.assert = function() {}), c.Utils = {
        getProperty: function(a, b) {
            for (var c = b.split("."), d = c.pop(), e = c.length, f = 1, g = c[0]; e > f && (a = a[g]); ) g = c[f], 
            f++;
            return a ? a[d] : null;
        },
        setProperty: function(a, b, c) {
            for (var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; f > g && (a = a[h]); ) h = d[g], 
            g++;
            return a && (a[e] = c), a;
        },
        chanceRoll: function(a) {
            return void 0 === a && (a = 50), a > 0 && 100 * Math.random() <= a;
        },
        randomChoice: function(a, b) {
            return Math.random() < .5 ? a : b;
        },
        parseDimension: function(a, b) {
            var c = 0, d = 0;
            return "string" == typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100, 
            d = 0 === b ? window.innerWidth * c : window.innerHeight * c) : d = parseInt(a, 10) : d = a, 
            d;
        },
        pad: function(a, b, c, d) {
            if (void 0 === b) var b = 0;
            if (void 0 === c) var c = " ";
            if (void 0 === d) var d = 3;
            var e = 0;
            if (b + 1 >= a.length) switch (d) {
              case 1:
                a = new Array(b + 1 - a.length).join(c) + a;
                break;

              case 3:
                var f = Math.ceil((e = b - a.length) / 2), g = e - f;
                a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                break;

              default:
                a += new Array(b + 1 - a.length).join(c);
            }
            return a;
        },
        isPlainObject: function(a) {
            if ("object" != typeof a || a.nodeType || a === a.window) return !1;
            try {
                if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (b) {
                return !1;
            }
            return !0;
        },
        extend: function() {
            var a, b, d, e, f, g, h = arguments[0] || {}, i = 1, j = arguments.length, k = !1;
            for ("boolean" == typeof h && (k = h, h = arguments[1] || {}, i = 2), j === i && (h = this, 
            --i); j > i; i++) if (null != (a = arguments[i])) for (b in a) d = h[b], e = a[b], 
            h !== e && (k && e && (c.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, 
            g = d && Array.isArray(d) ? d : []) : g = d && c.Utils.isPlainObject(d) ? d : {}, 
            h[b] = c.Utils.extend(k, g, e)) : void 0 !== e && (h[b] = e));
            return h;
        },
        mixinPrototype: function(a, b, c) {
            void 0 === c && (c = !1);
            for (var d = Object.keys(b), e = 0; e < d.length; e++) {
                var f = d[e], g = b[f];
                !c && f in a || (!g || "function" != typeof g.get && "function" != typeof g.set ? a[f] = g : "function" == typeof g.clone ? a[f] = g.clone() : Object.defineProperty(a, f, g));
            }
        },
        mixin: function(a, b) {
            if (!a || "object" != typeof a) return b;
            for (var d in a) {
                var e = a[d];
                if (!e.childNodes && !e.cloneNode) {
                    var f = typeof a[d];
                    b[d] = a[d] && "object" === f ? typeof b[d] === f ? c.Utils.mixin(a[d], b[d]) : c.Utils.mixin(a[d], new e.constructor()) : a[d];
                }
            }
            return b;
        }
    }, c.Circle = function(a, b, d) {
        a = a || 0, b = b || 0, d = d || 0, this.x = a, this.y = b, this._diameter = d, 
        this._radius = 0, d > 0 && (this._radius = .5 * d), this.type = c.CIRCLE;
    }, c.Circle.prototype = {
        circumference: function() {
            return 2 * Math.PI * this._radius;
        },
        random: function(a) {
            void 0 === a && (a = new c.Point());
            var b = 2 * Math.PI * Math.random(), d = Math.random() + Math.random(), e = d > 1 ? 2 - d : d, f = e * Math.cos(b), g = e * Math.sin(b);
            return a.x = this.x + f * this.radius, a.y = this.y + g * this.radius, a;
        },
        getBounds: function() {
            return new c.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
        },
        setTo: function(a, b, c) {
            return this.x = a, this.y = b, this._diameter = c, this._radius = .5 * c, this;
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.diameter);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.diameter = this._diameter, a;
        },
        distance: function(a, b) {
            var d = c.Math.distance(this.x, this.y, a.x, a.y);
            return b ? Math.round(d) : d;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c.Circle(this.x, this.y, this.diameter) : a.setTo(this.x, this.y, this.diameter), 
            a;
        },
        contains: function(a, b) {
            return c.Circle.contains(this, a, b);
        },
        circumferencePoint: function(a, b, d) {
            return c.Circle.circumferencePoint(this, a, b, d);
        },
        offset: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y);
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        }
    }, c.Circle.prototype.constructor = c.Circle, Object.defineProperty(c.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter;
        },
        set: function(a) {
            a > 0 && (this._diameter = a, this._radius = .5 * a);
        }
    }), Object.defineProperty(c.Circle.prototype, "radius", {
        get: function() {
            return this._radius;
        },
        set: function(a) {
            a > 0 && (this._radius = a, this._diameter = 2 * a);
        }
    }), Object.defineProperty(c.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius;
        },
        set: function(a) {
            a > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - a;
        }
    }), Object.defineProperty(c.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius;
        },
        set: function(a) {
            a < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.x;
        }
    }), Object.defineProperty(c.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius;
        },
        set: function(a) {
            a > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - a;
        }
    }), Object.defineProperty(c.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius;
        },
        set: function(a) {
            a < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.y;
        }
    }), Object.defineProperty(c.Circle.prototype, "area", {
        get: function() {
            return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
        }
    }), Object.defineProperty(c.Circle.prototype, "empty", {
        get: function() {
            return 0 === this._diameter;
        },
        set: function(a) {
            a === !0 && this.setTo(0, 0, 0);
        }
    }), c.Circle.contains = function(a, b, c) {
        if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
            var d = (a.x - b) * (a.x - b), e = (a.y - c) * (a.y - c);
            return d + e <= a.radius * a.radius;
        }
        return !1;
    }, c.Circle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.diameter == b.diameter;
    }, c.Circle.intersects = function(a, b) {
        return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
    }, c.Circle.circumferencePoint = function(a, b, d, e) {
        return void 0 === d && (d = !1), void 0 === e && (e = new c.Point()), d === !0 && (b = c.Math.degToRad(b)), 
        e.x = a.x + a.radius * Math.cos(b), e.y = a.y + a.radius * Math.sin(b), e;
    }, c.Circle.intersectsRectangle = function(a, b) {
        var c = Math.abs(a.x - b.x - b.halfWidth), d = b.halfWidth + a.radius;
        if (c > d) return !1;
        var e = Math.abs(a.y - b.y - b.halfHeight), f = b.halfHeight + a.radius;
        if (e > f) return !1;
        if (c <= b.halfWidth || e <= b.halfHeight) return !0;
        var g = c - b.halfWidth, h = e - b.halfHeight, i = g * g, j = h * h, k = a.radius * a.radius;
        return k >= i + j;
    }, PIXI.Circle = c.Circle, c.Ellipse = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, 
        this.height = e, this.type = c.ELLIPSE;
    }, c.Ellipse.prototype = {
        setTo: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        getBounds: function() {
            return new c.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, 
            a;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c.Ellipse(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), 
            a;
        },
        contains: function(a, b) {
            return c.Ellipse.contains(this, a, b);
        },
        random: function(a) {
            void 0 === a && (a = new c.Point());
            var b = Math.random() * Math.PI * 2, d = Math.random();
            return a.x = Math.sqrt(d) * Math.cos(b), a.y = Math.sqrt(d) * Math.sin(b), a.x = this.x + a.x * this.width / 2, 
            a.y = this.y + a.y * this.height / 2, a;
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        }
    }, c.Ellipse.prototype.constructor = c.Ellipse, Object.defineProperty(c.Ellipse.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(a) {
            this.x = a;
        }
    }), Object.defineProperty(c.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(a) {
            this.width = a < this.x ? 0 : a - this.x;
        }
    }), Object.defineProperty(c.Ellipse.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(a) {
            this.y = a;
        }
    }), Object.defineProperty(c.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(a) {
            this.height = a < this.y ? 0 : a - this.y;
        }
    }), Object.defineProperty(c.Ellipse.prototype, "empty", {
        get: function() {
            return 0 === this.width || 0 === this.height;
        },
        set: function(a) {
            a === !0 && this.setTo(0, 0, 0, 0);
        }
    }), c.Ellipse.contains = function(a, b, c) {
        if (a.width <= 0 || a.height <= 0) return !1;
        var d = (b - a.x) / a.width - .5, e = (c - a.y) / a.height - .5;
        return d *= d, e *= e, .25 > d + e;
    }, PIXI.Ellipse = c.Ellipse, c.Line = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.start = new c.Point(a, b), 
        this.end = new c.Point(d, e), this.type = c.LINE;
    }, c.Line.prototype = {
        setTo: function(a, b, c, d) {
            return this.start.setTo(a, b), this.end.setTo(c, d), this;
        },
        fromSprite: function(a, b, c) {
            return void 0 === c && (c = !1), c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y);
        },
        fromAngle: function(a, b, c, d) {
            return this.start.setTo(a, b), this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d), 
            this;
        },
        rotate: function(a, b) {
            var c = (this.start.x + this.end.x) / 2, d = (this.start.y + this.end.y) / 2;
            return this.start.rotate(c, d, a, b), this.end.rotate(c, d, a, b), this;
        },
        rotateAround: function(a, b, c, d) {
            return this.start.rotate(a, b, c, d), this.end.rotate(a, b, c, d), this;
        },
        intersects: function(a, b, d) {
            return c.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d);
        },
        reflect: function(a) {
            return c.Line.reflect(this, a);
        },
        midPoint: function(a) {
            return void 0 === a && (a = new c.Point()), a.x = (this.start.x + this.end.x) / 2, 
            a.y = (this.start.y + this.end.y) / 2, a;
        },
        centerOn: function(a, b) {
            var c = (this.start.x + this.end.x) / 2, d = (this.start.y + this.end.y) / 2, e = a - c, f = b - d;
            this.start.add(e, f), this.end.add(e, f);
        },
        pointOnLine: function(a, b) {
            return (a - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (b - this.start.y);
        },
        pointOnSegment: function(a, b) {
            var c = Math.min(this.start.x, this.end.x), d = Math.max(this.start.x, this.end.x), e = Math.min(this.start.y, this.end.y), f = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(a, b) && a >= c && d >= a && b >= e && f >= b;
        },
        random: function(a) {
            void 0 === a && (a = new c.Point());
            var b = Math.random();
            return a.x = this.start.x + b * (this.end.x - this.start.x), a.y = this.start.y + b * (this.end.y - this.start.y), 
            a;
        },
        coordinatesOnLine: function(a, b) {
            void 0 === a && (a = 1), void 0 === b && (b = []);
            var c = Math.round(this.start.x), d = Math.round(this.start.y), e = Math.round(this.end.x), f = Math.round(this.end.y), g = Math.abs(e - c), h = Math.abs(f - d), i = e > c ? 1 : -1, j = f > d ? 1 : -1, k = g - h;
            b.push([ c, d ]);
            for (var l = 1; c != e || d != f; ) {
                var m = k << 1;
                m > -h && (k -= h, c += i), g > m && (k += g, d += j), l % a === 0 && b.push([ c, d ]), 
                l++;
            }
            return b;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c.Line(this.start.x, this.start.y, this.end.x, this.end.y) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y), 
            a;
        }
    }, Object.defineProperty(c.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        }
    }), Object.defineProperty(c.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        }
    }), Object.defineProperty(c.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        }
    }), Object.defineProperty(c.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
        }
    }), Object.defineProperty(c.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x);
        }
    }), Object.defineProperty(c.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y);
        }
    }), Object.defineProperty(c.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x);
        }
    }), Object.defineProperty(c.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y);
        }
    }), Object.defineProperty(c.Line.prototype, "normalX", {
        get: function() {
            return Math.cos(this.angle - 1.5707963267948966);
        }
    }), Object.defineProperty(c.Line.prototype, "normalY", {
        get: function() {
            return Math.sin(this.angle - 1.5707963267948966);
        }
    }), Object.defineProperty(c.Line.prototype, "normalAngle", {
        get: function() {
            return c.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
        }
    }), c.Line.intersectsPoints = function(a, b, d, e, f, g) {
        void 0 === f && (f = !0), void 0 === g && (g = new c.Point());
        var h = b.y - a.y, i = e.y - d.y, j = a.x - b.x, k = d.x - e.x, l = b.x * a.y - a.x * b.y, m = e.x * d.y - d.x * e.y, n = h * k - i * j;
        if (0 === n) return null;
        if (g.x = (j * m - k * l) / n, g.y = (i * l - h * m) / n, f) {
            var o = (e.y - d.y) * (b.x - a.x) - (e.x - d.x) * (b.y - a.y), p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o, q = ((b.x - a.x) * (a.y - d.y) - (b.y - a.y) * (a.x - d.x)) / o;
            return p >= 0 && 1 >= p && q >= 0 && 1 >= q ? g : null;
        }
        return g;
    }, c.Line.intersects = function(a, b, d, e) {
        return c.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e);
    }, c.Line.reflect = function(a, b) {
        return 2 * b.normalAngle - 3.141592653589793 - a.angle;
    }, c.Matrix = function(a, b, d, e, f, g) {
        a = a || 1, b = b || 0, d = d || 0, e = e || 1, f = f || 0, g = g || 0, this.a = a, 
        this.b = b, this.c = d, this.d = e, this.tx = f, this.ty = g, this.type = c.MATRIX;
    }, c.Matrix.prototype = {
        fromArray: function(a) {
            return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5]);
        },
        setTo: function(a, b, c, d, e, f) {
            return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f, 
            this;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (a.a = this.a, 
            a.b = this.b, a.c = this.c, a.d = this.d, a.tx = this.tx, a.ty = this.ty), a;
        },
        copyTo: function(a) {
            return a.copyFrom(this), a;
        },
        copyFrom: function(a) {
            return this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d, this.tx = a.tx, this.ty = a.ty, 
            this;
        },
        toArray: function(a, b) {
            return void 0 === b && (b = new PIXI.Float32Array(9)), a ? (b[0] = this.a, b[1] = this.b, 
            b[2] = 0, b[3] = this.c, b[4] = this.d, b[5] = 0, b[6] = this.tx, b[7] = this.ty, 
            b[8] = 1) : (b[0] = this.a, b[1] = this.c, b[2] = this.tx, b[3] = this.b, b[4] = this.d, 
            b[5] = this.ty, b[6] = 0, b[7] = 0, b[8] = 1), b;
        },
        apply: function(a, b) {
            return void 0 === b && (b = new c.Point()), b.x = this.a * a.x + this.c * a.y + this.tx, 
            b.y = this.b * a.x + this.d * a.y + this.ty, b;
        },
        applyInverse: function(a, b) {
            void 0 === b && (b = new c.Point());
            var d = 1 / (this.a * this.d + this.c * -this.b), e = a.x, f = a.y;
            return b.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d, 
            b.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d, 
            b;
        },
        translate: function(a, b) {
            return this.tx += a, this.ty += b, this;
        },
        scale: function(a, b) {
            return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, 
            this;
        },
        rotate: function(a) {
            var b = Math.cos(a), c = Math.sin(a), d = this.a, e = this.c, f = this.tx;
            return this.a = d * b - this.b * c, this.b = d * c + this.b * b, this.c = e * b - this.d * c, 
            this.d = e * c + this.d * b, this.tx = f * b - this.ty * c, this.ty = f * c + this.ty * b, 
            this;
        },
        append: function(a) {
            var b = this.a, c = this.b, d = this.c, e = this.d;
            return this.a = a.a * b + a.b * d, this.b = a.a * c + a.b * e, this.c = a.c * b + a.d * d, 
            this.d = a.c * c + a.d * e, this.tx = a.tx * b + a.ty * d + this.tx, this.ty = a.tx * c + a.ty * e + this.ty, 
            this;
        },
        identity: function() {
            return this.setTo(1, 0, 0, 1, 0, 0);
        }
    }, c.identityMatrix = new c.Matrix(), PIXI.Matrix = c.Matrix, PIXI.identityMatrix = c.identityMatrix, 
    c.Point = function(a, b) {
        a = a || 0, b = b || 0, this.x = a, this.y = b, this.type = c.POINT;
    }, c.Point.prototype = {
        copyFrom: function(a) {
            return this.setTo(a.x, a.y);
        },
        invert: function() {
            return this.setTo(this.y, this.x);
        },
        setTo: function(a, b) {
            return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this;
        },
        set: function(a, b) {
            return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this;
        },
        add: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        subtract: function(a, b) {
            return this.x -= a, this.y -= b, this;
        },
        multiply: function(a, b) {
            return this.x *= a, this.y *= b, this;
        },
        divide: function(a, b) {
            return this.x /= a, this.y /= b, this;
        },
        clampX: function(a, b) {
            return this.x = c.Math.clamp(this.x, a, b), this;
        },
        clampY: function(a, b) {
            return this.y = c.Math.clamp(this.y, a, b), this;
        },
        clamp: function(a, b) {
            return this.x = c.Math.clamp(this.x, a, b), this.y = c.Math.clamp(this.y, a, b), 
            this;
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new c.Point(this.x, this.y) : a.setTo(this.x, this.y), 
            a;
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a;
        },
        distance: function(a, b) {
            return c.Point.distance(this, a, b);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        angle: function(a, b) {
            return void 0 === b && (b = !1), b ? c.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x);
        },
        rotate: function(a, b, d, e, f) {
            return c.Point.rotate(this, a, b, d, e, f);
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function(a) {
            return this.normalize().multiply(a, a);
        },
        normalize: function() {
            if (!this.isZero()) {
                var a = this.getMagnitude();
                this.x /= a, this.y /= a;
            }
            return this;
        },
        isZero: function() {
            return 0 === this.x && 0 === this.y;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        perp: function() {
            return this.setTo(-this.y, this.x);
        },
        rperp: function() {
            return this.setTo(this.y, -this.x);
        },
        normalRightHand: function() {
            return this.setTo(-1 * this.y, this.x);
        },
        floor: function() {
            return this.setTo(Math.floor(this.x), Math.floor(this.y));
        },
        ceil: function() {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        }
    }, c.Point.prototype.constructor = c.Point, c.Point.add = function(a, b, d) {
        return void 0 === d && (d = new c.Point()), d.x = a.x + b.x, d.y = a.y + b.y, d;
    }, c.Point.subtract = function(a, b, d) {
        return void 0 === d && (d = new c.Point()), d.x = a.x - b.x, d.y = a.y - b.y, d;
    }, c.Point.multiply = function(a, b, d) {
        return void 0 === d && (d = new c.Point()), d.x = a.x * b.x, d.y = a.y * b.y, d;
    }, c.Point.divide = function(a, b, d) {
        return void 0 === d && (d = new c.Point()), d.x = a.x / b.x, d.y = a.y / b.y, d;
    }, c.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    }, c.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
    }, c.Point.negative = function(a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(-a.x, -a.y);
    }, c.Point.multiplyAdd = function(a, b, d, e) {
        return void 0 === e && (e = new c.Point()), e.setTo(a.x + b.x * d, a.y + b.y * d);
    }, c.Point.interpolate = function(a, b, d, e) {
        return void 0 === e && (e = new c.Point()), e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d);
    }, c.Point.perp = function(a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(-a.y, a.x);
    }, c.Point.rperp = function(a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(a.y, -a.x);
    }, c.Point.distance = function(a, b, d) {
        var e = c.Math.distance(a.x, a.y, b.x, b.y);
        return d ? Math.round(e) : e;
    }, c.Point.project = function(a, b, d) {
        void 0 === d && (d = new c.Point());
        var e = a.dot(b) / b.getMagnitudeSq();
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
    }, c.Point.projectUnit = function(a, b, d) {
        void 0 === d && (d = new c.Point());
        var e = a.dot(b);
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
    }, c.Point.normalRightHand = function(a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(-1 * a.y, a.x);
    }, c.Point.normalize = function(a, b) {
        void 0 === b && (b = new c.Point());
        var d = a.getMagnitude();
        return 0 !== d && b.setTo(a.x / d, a.y / d), b;
    }, c.Point.rotate = function(a, b, d, e, f, g) {
        if (f && (e = c.Math.degToRad(e)), void 0 === g) {
            a.subtract(b, d);
            var h = Math.sin(e), i = Math.cos(e), j = i * a.x - h * a.y, k = h * a.x + i * a.y;
            a.x = j + b, a.y = k + d;
        } else {
            var l = e + Math.atan2(a.y - d, a.x - b);
            a.x = b + g * Math.cos(l), a.y = d + g * Math.sin(l);
        }
        return a;
    }, c.Point.centroid = function(a, b) {
        if (void 0 === b && (b = new c.Point()), "[object Array]" !== Object.prototype.toString.call(a)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var d = a.length;
        if (1 > d) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === d) return b.copyFrom(a[0]), b;
        for (var e = 0; d > e; e++) c.Point.add(b, a[e], b);
        return b.divide(d, d), b;
    }, c.Point.parse = function(a, b, d) {
        b = b || "x", d = d || "y";
        var e = new c.Point();
        return a[b] && (e.x = parseInt(a[b], 10)), a[d] && (e.y = parseInt(a[d], 10)), e;
    }, PIXI.Point = c.Point, c.Polygon = function() {
        this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), 
        this.closed = !0, this.type = c.POLYGON;
    }, c.Polygon.prototype = {
        toNumberArray: function(a) {
            void 0 === a && (a = []);
            for (var b = 0; b < this._points.length; b++) "number" == typeof this._points[b] ? (a.push(this._points[b]), 
            a.push(this._points[b + 1]), b++) : (a.push(this._points[b].x), a.push(this._points[b].y));
            return a;
        },
        flatten: function() {
            return this._points = this.toNumberArray(), this;
        },
        clone: function(a) {
            var b = this._points.slice();
            return void 0 === a || null === a ? a = new c.Polygon(b) : a.setTo(b), a;
        },
        contains: function(a, b) {
            for (var c = this._points.length, d = !1, e = -1, f = c - 1; ++e < c; f = e) {
                var g = this._points[e].x, h = this._points[e].y, i = this._points[f].x, j = this._points[f].y;
                (b >= h && j > b || b >= j && h > b) && (i - g) * (b - h) / (j - h) + g > a && (d = !d);
            }
            return d;
        },
        setTo: function(a) {
            if (this.area = 0, this._points = [], arguments.length > 0) {
                Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
                for (var b = Number.MAX_VALUE, c = 0, d = a.length; d > c; c++) {
                    if ("number" == typeof a[c]) {
                        var e = new PIXI.Point(a[c], a[c + 1]);
                        c++;
                    } else var e = new PIXI.Point(a[c].x, a[c].y);
                    this._points.push(e), e.y < b && (b = e.y);
                }
                this.calculateArea(b);
            }
            return this;
        },
        calculateArea: function(a) {
            for (var b, c, d, e, f = 0, g = this._points.length; g > f; f++) b = this._points[f], 
            c = f === g - 1 ? this._points[0] : this._points[f + 1], d = (b.y - a + (c.y - a)) / 2, 
            e = b.x - c.x, this.area += d * e;
            return this.area;
        }
    }, c.Polygon.prototype.constructor = c.Polygon, Object.defineProperty(c.Polygon.prototype, "points", {
        get: function() {
            return this._points;
        },
        set: function(a) {
            null != a ? this.setTo(a) : this.setTo();
        }
    }), PIXI.Polygon = c.Polygon, c.Rectangle = function(a, b, d, e) {
        a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, 
        this.height = e, this.type = c.RECTANGLE;
    }, c.Rectangle.prototype = {
        offset: function(a, b) {
            return this.x += a, this.y += b, this;
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y);
        },
        setTo: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        scale: function(a, b) {
            return void 0 === b && (b = a), this.width *= a, this.height *= b, this;
        },
        centerOn: function(a, b) {
            return this.centerX = a, this.centerY = b, this;
        },
        floor: function() {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y);
        },
        floorAll: function() {
            this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), 
            this.height = Math.floor(this.height);
        },
        ceil: function() {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y);
        },
        ceilAll: function() {
            this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), 
            this.height = Math.ceil(this.height);
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function(a) {
            return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, 
            a;
        },
        inflate: function(a, b) {
            return c.Rectangle.inflate(this, a, b);
        },
        size: function(a) {
            return c.Rectangle.size(this, a);
        },
        resize: function(a, b) {
            return this.width = a, this.height = b, this;
        },
        clone: function(a) {
            return c.Rectangle.clone(this, a);
        },
        contains: function(a, b) {
            return c.Rectangle.contains(this, a, b);
        },
        containsRect: function(a) {
            return c.Rectangle.containsRect(a, this);
        },
        equals: function(a) {
            return c.Rectangle.equals(this, a);
        },
        intersection: function(a, b) {
            return c.Rectangle.intersection(this, a, b);
        },
        intersects: function(a) {
            return c.Rectangle.intersects(this, a);
        },
        intersectsRaw: function(a, b, d, e, f) {
            return c.Rectangle.intersectsRaw(this, a, b, d, e, f);
        },
        union: function(a, b) {
            return c.Rectangle.union(this, a, b);
        },
        random: function(a) {
            return void 0 === a && (a = new c.Point()), a.x = this.randomX, a.y = this.randomY, 
            a;
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        }
    }, Object.defineProperty(c.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2);
        }
    }), Object.defineProperty(c.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2);
        }
    }), Object.defineProperty(c.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(a) {
            this.height = a <= this.y ? 0 : a - this.y;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "bottomLeft", {
        get: function() {
            return new c.Point(this.x, this.bottom);
        },
        set: function(a) {
            this.x = a.x, this.bottom = a.y;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new c.Point(this.right, this.bottom);
        },
        set: function(a) {
            this.right = a.x, this.bottom = a.y;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(a) {
            this.width = a >= this.right ? 0 : this.right - a, this.x = a;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(a) {
            this.width = a <= this.x ? 0 : a - this.x;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "perimeter", {
        get: function() {
            return 2 * this.width + 2 * this.height;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth;
        },
        set: function(a) {
            this.x = a - this.halfWidth;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight;
        },
        set: function(a) {
            this.y = a - this.halfHeight;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(a) {
            a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "topLeft", {
        get: function() {
            return new c.Point(this.x, this.y);
        },
        set: function(a) {
            this.x = a.x, this.y = a.y;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "topRight", {
        get: function() {
            return new c.Point(this.x + this.width, this.y);
        },
        set: function(a) {
            this.right = a.x, this.y = a.y;
        }
    }), Object.defineProperty(c.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height;
        },
        set: function(a) {
            a === !0 && this.setTo(0, 0, 0, 0);
        }
    }), c.Rectangle.prototype.constructor = c.Rectangle, c.Rectangle.inflate = function(a, b, c) {
        return a.x -= b, a.width += 2 * b, a.y -= c, a.height += 2 * c, a;
    }, c.Rectangle.inflatePoint = function(a, b) {
        return c.Rectangle.inflate(a, b.x, b.y);
    }, c.Rectangle.size = function(a, b) {
        return void 0 === b || null === b ? b = new c.Point(a.width, a.height) : b.setTo(a.width, a.height), 
        b;
    }, c.Rectangle.clone = function(a, b) {
        return void 0 === b || null === b ? b = new c.Rectangle(a.x, a.y, a.width, a.height) : b.setTo(a.x, a.y, a.width, a.height), 
        b;
    }, c.Rectangle.contains = function(a, b, c) {
        return a.width <= 0 || a.height <= 0 ? !1 : b >= a.x && b < a.right && c >= a.y && c < a.bottom;
    }, c.Rectangle.containsRaw = function(a, b, c, d, e, f) {
        return e >= a && a + c > e && f >= b && b + d > f;
    }, c.Rectangle.containsPoint = function(a, b) {
        return c.Rectangle.contains(a, b.x, b.y);
    }, c.Rectangle.containsRect = function(a, b) {
        return a.volume > b.volume ? !1 : a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
    }, c.Rectangle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
    }, c.Rectangle.sameDimensions = function(a, b) {
        return a.width === b.width && a.height === b.height;
    }, c.Rectangle.intersection = function(a, b, d) {
        return void 0 === d && (d = new c.Rectangle()), c.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), 
        d.y = Math.max(a.y, b.y), d.width = Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y), 
        d;
    }, c.Rectangle.intersects = function(a, b) {
        return a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0 ? !1 : !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    }, c.Rectangle.intersectsRaw = function(a, b, c, d, e, f) {
        return void 0 === f && (f = 0), !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f);
    }, c.Rectangle.union = function(a, b, d) {
        return void 0 === d && (d = new c.Rectangle()), d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
    }, c.Rectangle.aabb = function(a, b) {
        void 0 === b && (b = new c.Rectangle());
        var d = Number.MIN_VALUE, e = Number.MAX_VALUE, f = Number.MIN_VALUE, g = Number.MAX_VALUE;
        return a.forEach(function(a) {
            a.x > d && (d = a.x), a.x < e && (e = a.x), a.y > f && (f = a.y), a.y < g && (g = a.y);
        }), b.setTo(e, g, d - e, f - g), b;
    }, PIXI.Rectangle = c.Rectangle, PIXI.EmptyRectangle = new c.Rectangle(0, 0, 0, 0), 
    c.RoundedRectangle = function(a, b, d, e, f) {
        void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), void 0 === e && (e = 0), 
        void 0 === f && (f = 20), this.x = a, this.y = b, this.width = d, this.height = e, 
        this.radius = f || 20, this.type = c.ROUNDEDRECTANGLE;
    }, c.RoundedRectangle.prototype = {
        clone: function() {
            return new c.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        },
        contains: function(a, b) {
            if (this.width <= 0 || this.height <= 0) return !1;
            var c = this.x;
            if (a >= c && a <= c + this.width) {
                var d = this.y;
                if (b >= d && b <= d + this.height) return !0;
            }
            return !1;
        }
    }, c.RoundedRectangle.prototype.constructor = c.RoundedRectangle, PIXI.RoundedRectangle = c.RoundedRectangle, 
    c.Camera = function(a, b, d, e, f, g) {
        this.game = a, this.world = a.world, this.id = 0, this.view = new c.Rectangle(d, e, f, g), 
        this.bounds = new c.Rectangle(d, e, f, g), this.deadzone = null, this.visible = !0, 
        this.roundPx = !0, this.atLimit = {
            x: !1,
            y: !1
        }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, 
        this._targetPosition = new c.Point(), this._edge = 0, this._position = new c.Point();
    }, c.Camera.FOLLOW_LOCKON = 0, c.Camera.FOLLOW_PLATFORMER = 1, c.Camera.FOLLOW_TOPDOWN = 2, 
    c.Camera.FOLLOW_TOPDOWN_TIGHT = 3, c.Camera.prototype = {
        preUpdate: function() {
            this.totalInView = 0;
        },
        follow: function(a, b) {
            void 0 === b && (b = c.Camera.FOLLOW_LOCKON), this.target = a;
            var d;
            switch (b) {
              case c.Camera.FOLLOW_PLATFORMER:
                var e = this.width / 8, f = this.height / 3;
                this.deadzone = new c.Rectangle((this.width - e) / 2, (this.height - f) / 2 - .25 * f, e, f);
                break;

              case c.Camera.FOLLOW_TOPDOWN:
                d = Math.max(this.width, this.height) / 4, this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - d) / 2, d, d);
                break;

              case c.Camera.FOLLOW_TOPDOWN_TIGHT:
                d = Math.max(this.width, this.height) / 8, this.deadzone = new c.Rectangle((this.width - d) / 2, (this.height - d) / 2, d, d);
                break;

              case c.Camera.FOLLOW_LOCKON:
                this.deadzone = null;
                break;

              default:
                this.deadzone = null;
            }
        },
        unfollow: function() {
            this.target = null;
        },
        focusOn: function(a) {
            this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight));
        },
        focusOnXY: function(a, b) {
            this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight));
        },
        update: function() {
            this.target && this.updateTarget(), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), 
            this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y;
        },
        updateTarget: function() {
            this._targetPosition.copyFrom(this.target), this.target.parent && this._targetPosition.multiply(this.target.parent.worldTransform.a, this.target.parent.worldTransform.d), 
            this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this._targetPosition.x - this.deadzone.left : this._edge > this.deadzone.right && (this.view.x = this._targetPosition.x - this.deadzone.right), 
            this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this._targetPosition.y - this.deadzone.top : this._edge > this.deadzone.bottom && (this.view.y = this._targetPosition.y - this.deadzone.bottom)) : (this.view.x = this._targetPosition.x - this.view.halfWidth, 
            this.view.y = this._targetPosition.y - this.view.halfHeight);
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds);
        },
        checkBounds: function() {
            this.atLimit.x = !1, this.atLimit.y = !1, this.view.x <= this.bounds.x && (this.atLimit.x = !0, 
            this.view.x = this.bounds.x), this.view.right >= this.bounds.right && (this.atLimit.x = !0, 
            this.view.x = this.bounds.right - this.width), this.view.y <= this.bounds.top && (this.atLimit.y = !0, 
            this.view.y = this.bounds.top), this.view.bottom >= this.bounds.bottom && (this.atLimit.y = !0, 
            this.view.y = this.bounds.bottom - this.height);
        },
        setPosition: function(a, b) {
            this.view.x = a, this.view.y = b, this.bounds && this.checkBounds();
        },
        setSize: function(a, b) {
            this.view.width = a, this.view.height = b;
        },
        reset: function() {
            this.target = null, this.view.x = 0, this.view.y = 0;
        }
    }, c.Camera.prototype.constructor = c.Camera, Object.defineProperty(c.Camera.prototype, "x", {
        get: function() {
            return this.view.x;
        },
        set: function(a) {
            this.view.x = a, this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c.Camera.prototype, "y", {
        get: function() {
            return this.view.y;
        },
        set: function(a) {
            this.view.y = a, this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c.Camera.prototype, "position", {
        get: function() {
            return this._position.set(this.view.centerX, this.view.centerY), this._position;
        },
        set: function(a) {
            "undefined" != typeof a.x && (this.view.x = a.x), "undefined" != typeof a.y && (this.view.y = a.y), 
            this.bounds && this.checkBounds();
        }
    }), Object.defineProperty(c.Camera.prototype, "width", {
        get: function() {
            return this.view.width;
        },
        set: function(a) {
            this.view.width = a;
        }
    }), Object.defineProperty(c.Camera.prototype, "height", {
        get: function() {
            return this.view.height;
        },
        set: function(a) {
            this.view.height = a;
        }
    }), c.Create = function(a) {
        this.game = a, this.bmd = a.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context, 
        this.palettes = [ {
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
        }, {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
        }, {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
        } ];
    }, c.Create.PALETTE_ARNE = 0, c.Create.PALETTE_JMP = 1, c.Create.PALETTE_CGA = 2, 
    c.Create.PALETTE_C64 = 3, c.Create.PALETTE_JAPANESE_MACHINE = 4, c.Create.prototype = {
        texture: function(a, b, c, d, e) {
            void 0 === c && (c = 8), void 0 === d && (d = c), void 0 === e && (e = 0);
            var f = b[0].length * c, g = b.length * d;
            this.bmd.resize(f, g), this.bmd.clear();
            for (var h = 0; h < b.length; h++) for (var i = b[h], j = 0; j < i.length; j++) {
                var k = i[j];
                "." !== k && " " !== k && (this.ctx.fillStyle = this.palettes[e][k], this.ctx.fillRect(j * c, h * d, c, d));
            }
            return this.bmd.generateTexture(a);
        },
        grid: function(a, b, c, d, e, f) {
            this.bmd.resize(b, c), this.ctx.fillStyle = f;
            for (var g = 0; c > g; g += e) this.ctx.fillRect(0, g, b, 1);
            for (var h = 0; b > h; h += d) this.ctx.fillRect(h, 0, 1, c);
            return this.bmd.generateTexture(a);
        }
    }, c.Create.prototype.constructor = c.Create, c.State = function() {
        this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, 
        this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, 
        this.scale = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, 
        this.particles = null, this.physics = null, this.rnd = null;
    }, c.State.prototype = {
        init: function() {},
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        preRender: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        resumed: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    }, c.State.prototype.constructor = c.State, c.StateManager = function(a, b) {
        this.game = a, this.states = {}, this._pendingState = null, "undefined" != typeof b && null !== b && (this._pendingState = b), 
        this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], 
        this.current = "", this.onStateChange = new c.Signal(), this.onInitCallback = null, 
        this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, 
        this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, 
        this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, 
        this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null;
    }, c.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), 
            null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0);
        },
        add: function(a, b, d) {
            void 0 === d && (d = !1);
            var e;
            return b instanceof c.State ? e = b : "object" == typeof b ? (e = b, e.game = this.game) : "function" == typeof b && (e = new b(this.game)), 
            this.states[a] = e, d && (this.game.isBooted ? this.start(a) : this._pendingState = a), 
            e;
        },
        remove: function(a) {
            this.current === a && (this.callbackContext = null, this.onInitCallback = null, 
            this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, 
            this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, 
            this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, 
            this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), 
            delete this.states[a];
        },
        start: function(a, b, c) {
            void 0 === b && (b = !0), void 0 === c && (c = !1), this.checkState(a) && (this._pendingState = a, 
            this._clearWorld = b, this._clearCache = c, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)));
        },
        restart: function(a, b) {
            void 0 === a && (a = !0), void 0 === b && (b = !1), this._pendingState = this.current, 
            this._clearWorld = a, this._clearCache = b, arguments.length > 2 && (this._args = Array.prototype.splice.call(arguments, 2));
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                var a = this.current;
                if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, a), 
                this.current !== this._pendingState) return;
                this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 
                0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete();
            }
        },
        clearCurrentState: function() {
            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), 
            this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), 
            this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), 
            this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), 
            this._clearCache === !0 && this.game.cache.destroy()));
        },
        checkState: function(a) {
            if (this.states[a]) {
                var b = !1;
                return (this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) && (b = !0), 
                b === !1 ? (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), 
                !1) : !0;
            }
            return console.warn("Phaser.StateManager - No state found with the key: " + a), 
            !1;
        },
        link: function(a) {
            this.states[a].game = this.game, this.states[a].add = this.game.add, this.states[a].make = this.game.make, 
            this.states[a].camera = this.game.camera, this.states[a].cache = this.game.cache, 
            this.states[a].input = this.game.input, this.states[a].load = this.game.load, this.states[a].math = this.game.math, 
            this.states[a].sound = this.game.sound, this.states[a].scale = this.game.scale, 
            this.states[a].state = this, this.states[a].stage = this.game.stage, this.states[a].time = this.game.time, 
            this.states[a].tweens = this.game.tweens, this.states[a].world = this.game.world, 
            this.states[a].particles = this.game.particles, this.states[a].rnd = this.game.rnd, 
            this.states[a].physics = this.game.physics, this.states[a].key = a;
        },
        unlink: function(a) {
            this.states[a] && (this.states[a].game = null, this.states[a].add = null, this.states[a].make = null, 
            this.states[a].camera = null, this.states[a].cache = null, this.states[a].input = null, 
            this.states[a].load = null, this.states[a].math = null, this.states[a].sound = null, 
            this.states[a].scale = null, this.states[a].state = null, this.states[a].stage = null, 
            this.states[a].time = null, this.states[a].tweens = null, this.states[a].world = null, 
            this.states[a].particles = null, this.states[a].rnd = null, this.states[a].physics = null);
        },
        setCurrentState: function(a) {
            this.callbackContext = this.states[a], this.link(a), this.onInitCallback = this.states[a].init || this.dummy, 
            this.onPreloadCallback = this.states[a].preload || null, this.onLoadRenderCallback = this.states[a].loadRender || null, 
            this.onLoadUpdateCallback = this.states[a].loadUpdate || null, this.onCreateCallback = this.states[a].create || null, 
            this.onUpdateCallback = this.states[a].update || null, this.onPreRenderCallback = this.states[a].preRender || null, 
            this.onRenderCallback = this.states[a].render || null, this.onResizeCallback = this.states[a].resize || null, 
            this.onPausedCallback = this.states[a].paused || null, this.onResumedCallback = this.states[a].resumed || null, 
            this.onPauseUpdateCallback = this.states[a].pauseUpdate || null, this.onShutDownCallback = this.states[a].shutdown || this.dummy, 
            "" !== this.current && this.game.physics.reset(), this.current = a, this._created = !1, 
            this.onInitCallback.apply(this.callbackContext, this._args), a === this._pendingState && (this._args = []), 
            this.game._kickstart = !0;
        },
        getCurrentState: function() {
            return this.states[this.current];
        },
        loadComplete: function() {
            this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0;
        },
        pause: function() {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game);
        },
        resume: function() {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game);
        },
        update: function() {
            this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        pauseUpdate: function() {
            this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        preRender: function(a) {
            this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a);
        },
        resize: function(a, b) {
            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b);
        },
        render: function() {
            this._created ? this.onRenderCallback && (this.game.renderType === c.CANVAS ? (this.game.context.save(), 
            this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), 
            this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game);
        },
        destroy: function() {
            this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, 
            this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, 
            this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, 
            this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, 
            this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, 
            this.current = "";
        }
    }, c.StateManager.prototype.constructor = c.StateManager, Object.defineProperty(c.StateManager.prototype, "created", {
        get: function() {
            return this._created;
        }
    }), c.Signal = function() {}, c.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !0,
        validateListener: function(a, b) {
            if ("function" != typeof a) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
        },
        _registerListener: function(a, b, d, e, f) {
            var g, h = this._indexOfListener(a, d);
            if (-1 !== h) {
                if (g = this._bindings[h], g.isOnce() !== b) throw new Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.");
            } else g = new c.SignalBinding(this, a, b, d, e, f), this._addBinding(g);
            return this.memorize && this._prevParams && g.execute(this._prevParams), g;
        },
        _addBinding: function(a) {
            this._bindings || (this._bindings = []);
            var b = this._bindings.length;
            do b--; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
            this._bindings.splice(b + 1, 0, a);
        },
        _indexOfListener: function(a, b) {
            if (!this._bindings) return -1;
            void 0 === b && (b = null);
            for (var c, d = this._bindings.length; d--; ) if (c = this._bindings[d], c._listener === a && c.context === b) return d;
            return -1;
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b);
        },
        add: function(a, b, c) {
            this.validateListener(a, "add");
            var d = [];
            if (arguments.length > 3) for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
            return this._registerListener(a, !1, b, c, d);
        },
        addOnce: function(a, b, c) {
            this.validateListener(a, "addOnce");
            var d = [];
            if (arguments.length > 3) for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
            return this._registerListener(a, !0, b, c, d);
        },
        remove: function(a, b) {
            this.validateListener(a, "remove");
            var c = this._indexOfListener(a, b);
            return -1 !== c && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)), 
            a;
        },
        removeAll: function(a) {
            if (void 0 === a && (a = null), this._bindings) {
                for (var b = this._bindings.length; b--; ) a ? this._bindings[b].context === a && (this._bindings[b]._destroy(), 
                this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
                a || (this._bindings.length = 0);
            }
        },
        getNumListeners: function() {
            return this._bindings ? this._bindings.length : 0;
        },
        halt: function() {
            this._shouldPropagate = !1;
        },
        dispatch: function() {
            if (this.active && this._bindings) {
                var a, b = Array.prototype.slice.call(arguments), c = this._bindings.length;
                if (this.memorize && (this._prevParams = b), c) {
                    a = this._bindings.slice(), this._shouldPropagate = !0;
                    do c--; while (a[c] && this._shouldPropagate && a[c].execute(b) !== !1);
                }
            }
        },
        forget: function() {
            this._prevParams && (this._prevParams = null);
        },
        dispose: function() {
            this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null);
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    }, Object.defineProperty(c.Signal.prototype, "boundDispatch", {
        get: function() {
            var a = this;
            return this._boundDispatch || (this._boundDispatch = function() {
                return a.dispatch.apply(a, arguments);
            });
        }
    }), c.Signal.prototype.constructor = c.Signal, c.SignalBinding = function(a, b, c, d, e, f) {
        this._listener = b, c && (this._isOnce = !0), null != d && (this.context = d), this._signal = a, 
        e && (this._priority = e), f && f.length && (this._args = f);
    }, c.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function(a) {
            var b, c;
            return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, 
            this._args && (c = c.concat(this._args)), b = this._listener.apply(this.context, c), 
            this.callCount++, this._isOnce && this.detach()), b;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal, delete this._listener, delete this.context;
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    }, c.SignalBinding.prototype.constructor = c.SignalBinding, c.Filter = function(a, b, d) {
        this.game = a, this.type = c.WEBGL_FILTER, this.passes = [ this ], this.shaders = [], 
        this.dirty = !0, this.padding = 0, this.prevPoint = new c.Point();
        var e = new Date();
        if (this.uniforms = {
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            time: {
                type: "1f",
                value: 0
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            date: {
                type: "4fv",
                value: [ e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds() ]
            },
            sampleRate: {
                type: "1f",
                value: 44100
            },
            iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            }
        }, b) for (var f in b) this.uniforms[f] = b[f];
        this.fragmentSrc = d || "";
    }, c.Filter.prototype = {
        init: function() {},
        setResolution: function(a, b) {
            this.uniforms.resolution.value.x = a, this.uniforms.resolution.value.y = b;
        },
        update: function(a) {
            if ("undefined" != typeof a) {
                var b = a.x / this.game.width, c = 1 - a.y / this.game.height;
                (b !== this.prevPoint.x || c !== this.prevPoint.y) && (this.uniforms.mouse.value.x = b.toFixed(2), 
                this.uniforms.mouse.value.y = c.toFixed(2), this.prevPoint.set(b, c));
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        destroy: function() {
            this.game = null;
        }
    }, c.Filter.prototype.constructor = c.Filter, Object.defineProperty(c.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x;
        },
        set: function(a) {
            this.uniforms.resolution.value.x = a;
        }
    }), Object.defineProperty(c.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y;
        },
        set: function(a) {
            this.uniforms.resolution.value.y = a;
        }
    }), c.Plugin = function(a, b) {
        void 0 === b && (b = null), this.game = a, this.parent = b, this.active = !1, this.visible = !1, 
        this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, 
        this.hasPostRender = !1;
    }, c.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null, this.parent = null, this.active = !1, this.visible = !1;
        }
    }, c.Plugin.prototype.constructor = c.Plugin, c.PluginManager = function(a) {
        this.game = a, this.plugins = [], this._len = 0, this._i = 0;
    }, c.PluginManager.prototype = {
        add: function(a) {
            var b = Array.prototype.splice.call(arguments, 1), c = !1;
            return "function" == typeof a ? a = new a(this.game, this) : (a.game = this.game, 
            a.parent = this), "function" == typeof a.preUpdate && (a.hasPreUpdate = !0, c = !0), 
            "function" == typeof a.update && (a.hasUpdate = !0, c = !0), "function" == typeof a.postUpdate && (a.hasPostUpdate = !0, 
            c = !0), "function" == typeof a.render && (a.hasRender = !0, c = !0), "function" == typeof a.postRender && (a.hasPostRender = !0, 
            c = !0), c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0), 
            (a.hasRender || a.hasPostRender) && (a.visible = !0), this._len = this.plugins.push(a), 
            "function" == typeof a.init && a.init.apply(a, b), a) : null;
        },
        remove: function(a) {
            for (this._i = this._len; this._i--; ) if (this.plugins[this._i] === a) return a.destroy(), 
            this.plugins.splice(this._i, 1), void this._len--;
        },
        removeAll: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].destroy();
            this.plugins.length = 0, this._len = 0;
        },
        preUpdate: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate();
        },
        update: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update();
        },
        postUpdate: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate();
        },
        render: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render();
        },
        postRender: function() {
            for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender();
        },
        destroy: function() {
            this.removeAll(), this.game = null;
        }
    }, c.PluginManager.prototype.constructor = c.PluginManager, c.Stage = function(a) {
        this.game = a, PIXI.Stage.call(this, 0), this.name = "_stage_root", this.disableVisibilityChange = !1, 
        this.exists = !0, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, 
        this._backgroundColor = 0, a.config && this.parseConfig(a.config);
    }, c.Stage.prototype = Object.create(PIXI.Stage.prototype), c.Stage.prototype.constructor = c.Stage, 
    c.Stage.prototype.parseConfig = function(a) {
        a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange), 
        a.backgroundColor && (this.backgroundColor = a.backgroundColor);
    }, c.Stage.prototype.boot = function() {
        c.DOM.getOffset(this.game.canvas, this.offset), c.Canvas.setUserSelect(this.game.canvas, "none"), 
        c.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility();
    }, c.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
    }, c.Stage.prototype.update = function() {
        for (var a = this.children.length; a--; ) this.children[a].update();
    }, c.Stage.prototype.postUpdate = function() {
        if (this.game.world.camera.target) {
            this.game.world.camera.target.postUpdate(), this.game.world.camera.update();
            for (var a = this.children.length; a--; ) this.children[a] !== this.game.world.camera.target && this.children[a].postUpdate();
        } else {
            this.game.world.camera.update();
            for (var a = this.children.length; a--; ) this.children[a].postUpdate();
        }
    }, c.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform();
    }, c.Stage.prototype.checkVisibility = function() {
        this._hiddenVar = void 0 !== document.webkitHidden ? "webkitvisibilitychange" : void 0 !== document.mozHidden ? "mozvisibilitychange" : void 0 !== document.msHidden ? "msvisibilitychange" : void 0 !== document.hidden ? "visibilitychange" : null;
        var a = this;
        this._onChange = function(b) {
            return a.visibilityChange(b);
        }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), 
        window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, 
        window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
            c.Stage.prototype.visibilityChange.call(a, {
                type: "pause"
            });
        }), CocoonJS.App.onActivated.addEventListener(function() {
            c.Stage.prototype.visibilityChange.call(a, {
                type: "resume"
            });
        }));
    }, c.Stage.prototype.visibilityChange = function(a) {
        return "pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type ? void ("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : ("pageshow" === a.type || "focus" === a.type) && this.game.focusGain(a)) : void (this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a)));
    }, c.Stage.prototype.setBackgroundColor = function(a) {
        var b = c.Color.valueToColor(a);
        this._backgroundColor = c.Color.getColor(b.r, b.g, b.b), this.backgroundColorSplit = [ b.r / 255, b.g / 255, b.b / 255 ], 
        this.backgroundColorString = c.Color.RGBtoString(b.r, b.g, b.b, 255, "#");
    }, c.Stage.prototype.destroy = function() {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), 
        window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null;
    }, Object.defineProperty(c.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor;
        },
        set: function(a) {
            this.game.transparent || this.setBackgroundColor(a);
        }
    }), Object.defineProperty(c.Stage.prototype, "smoothed", {
        get: function() {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
        },
        set: function(a) {
            PIXI.scaleModes.DEFAULT = a ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST;
        }
    }), c.Group = function(a, b, d, e, f, g) {
        void 0 === e && (e = !1), void 0 === f && (f = !1), void 0 === g && (g = c.Physics.ARCADE), 
        this.game = a, void 0 === b && (b = a.world), this.name = d || "group", this.z = 0, 
        PIXI.DisplayObjectContainer.call(this), e ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : b && (b.addChild(this), 
        this.z = b.children.length), this.type = c.GROUP, this.physicsType = c.GROUP, this.alive = !0, 
        this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = c.Sprite, 
        this.cursor = null, this.enableBody = f, this.enableBodyDebug = !1, this.physicsBodyType = g, 
        this.physicsSortDirection = null, this.onDestroy = new c.Signal(), this.cursorIndex = 0, 
        this.fixedToCamera = !1, this.cameraOffset = new c.Point(), this.hash = [], this._sortProperty = "z";
    }, c.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.Group.prototype.constructor = c.Group, 
    c.Group.RETURN_NONE = 0, c.Group.RETURN_TOTAL = 1, c.Group.RETURN_CHILD = 2, c.Group.SORT_ASCENDING = -1, 
    c.Group.SORT_DESCENDING = 1, c.Group.prototype.add = function(a, b) {
        return void 0 === b && (b = !1), a.parent !== this && (this.addChild(a), a.z = this.children.length, 
        this.enableBody && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), 
        !b && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a)), 
        a;
    }, c.Group.prototype.addToHash = function(a) {
        if (a.parent === this) {
            var b = this.hash.indexOf(a);
            if (-1 === b) return this.hash.push(a), !0;
        }
        return !1;
    }, c.Group.prototype.removeFromHash = function(a) {
        if (a) {
            var b = this.hash.indexOf(a);
            if (-1 !== b) return this.hash.splice(b, 1), !0;
        }
        return !1;
    }, c.Group.prototype.addMultiple = function(a, b) {
        if (a instanceof c.Group) a.moveAll(this, b); else if (Array.isArray(a)) for (var d = 0; d < a.length; d++) this.add(a[d], b);
        return a;
    }, c.Group.prototype.addAt = function(a, b, c) {
        return void 0 === c && (c = !1), a.parent !== this && (this.addChildAt(a, b), this.updateZ(), 
        this.enableBody && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), 
        !c && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a)), 
        a;
    }, c.Group.prototype.getAt = function(a) {
        return 0 > a || a >= this.children.length ? -1 : this.getChildAt(a);
    }, c.Group.prototype.create = function(a, b, c, d, e) {
        void 0 === e && (e = !0);
        var f = new this.classType(this.game, a, b, c, d);
        return f.exists = e, f.visible = e, f.alive = e, this.addChild(f), f.z = this.children.length, 
        this.enableBody && this.game.physics.enable(f, this.physicsBodyType, this.enableBodyDebug), 
        f.events && f.events.onAddedToGroup$dispatch(f, this), null === this.cursor && (this.cursor = f), 
        f;
    }, c.Group.prototype.createMultiple = function(a, b, c, d) {
        void 0 === d && (d = !1);
        for (var e = 0; a > e; e++) this.create(0, 0, b, c, d);
    }, c.Group.prototype.updateZ = function() {
        for (var a = this.children.length; a--; ) this.children[a].z = a;
    }, c.Group.prototype.resetCursor = function(a) {
        return void 0 === a && (a = 0), a > this.children.length - 1 && (a = 0), this.cursor ? (this.cursorIndex = a, 
        this.cursor = this.children[this.cursorIndex], this.cursor) : void 0;
    }, c.Group.prototype.next = function() {
        return this.cursor ? (this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, 
        this.cursor = this.children[this.cursorIndex], this.cursor) : void 0;
    }, c.Group.prototype.previous = function() {
        return this.cursor ? (0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, 
        this.cursor = this.children[this.cursorIndex], this.cursor) : void 0;
    }, c.Group.prototype.swap = function(a, b) {
        this.swapChildren(a, b), this.updateZ();
    }, c.Group.prototype.bringToTop = function(a) {
        return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0), 
        this.add(a, !0)), a;
    }, c.Group.prototype.sendToBack = function(a) {
        return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0), this.addAt(a, 0, !0)), 
        a;
    }, c.Group.prototype.moveUp = function(a) {
        if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
            var b = this.getIndex(a), c = this.getAt(b + 1);
            c && this.swap(a, c);
        }
        return a;
    }, c.Group.prototype.moveDown = function(a) {
        if (a.parent === this && this.getIndex(a) > 0) {
            var b = this.getIndex(a), c = this.getAt(b - 1);
            c && this.swap(a, c);
        }
        return a;
    }, c.Group.prototype.xy = function(a, b, c) {
        return 0 > a || a > this.children.length ? -1 : (this.getChildAt(a).x = b, void (this.getChildAt(a).y = c));
    }, c.Group.prototype.reverse = function() {
        this.children.reverse(), this.updateZ();
    }, c.Group.prototype.getIndex = function(a) {
        return this.children.indexOf(a);
    }, c.Group.prototype.replace = function(a, b) {
        var d = this.getIndex(a);
        return -1 !== d ? (b.parent && (b.parent instanceof c.Group ? b.parent.remove(b) : b.parent.removeChild(b)), 
        this.remove(a), this.addAt(b, d), a) : void 0;
    }, c.Group.prototype.hasProperty = function(a, b) {
        var c = b.length;
        return 1 === c && b[0] in a ? !0 : 2 === c && b[0] in a && b[1] in a[b[0]] ? !0 : 3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] ? !0 : 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]] ? !0 : !1;
    }, c.Group.prototype.setProperty = function(a, b, c, d, e) {
        if (void 0 === e && (e = !1), d = d || 0, !this.hasProperty(a, b) && (!e || d > 0)) return !1;
        var f = b.length;
        return 1 === f ? 0 === d ? a[b[0]] = c : 1 == d ? a[b[0]] += c : 2 == d ? a[b[0]] -= c : 3 == d ? a[b[0]] *= c : 4 == d && (a[b[0]] /= c) : 2 === f ? 0 === d ? a[b[0]][b[1]] = c : 1 == d ? a[b[0]][b[1]] += c : 2 == d ? a[b[0]][b[1]] -= c : 3 == d ? a[b[0]][b[1]] *= c : 4 == d && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === d ? a[b[0]][b[1]][b[2]] = c : 1 == d ? a[b[0]][b[1]][b[2]] += c : 2 == d ? a[b[0]][b[1]][b[2]] -= c : 3 == d ? a[b[0]][b[1]][b[2]] *= c : 4 == d && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === d ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 == d ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 == d ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 == d ? a[b[0]][b[1]][b[2]][b[3]] *= c : 4 == d && (a[b[0]][b[1]][b[2]][b[3]] /= c)), 
        !0;
    }, c.Group.prototype.checkProperty = function(a, b, d, e) {
        return void 0 === e && (e = !1), !c.Utils.getProperty(a, b) && e ? !1 : c.Utils.getProperty(a, b) !== d ? !1 : !0;
    }, c.Group.prototype.set = function(a, b, c, d, e, f, g) {
        return void 0 === g && (g = !1), b = b.split("."), void 0 === d && (d = !1), void 0 === e && (e = !1), 
        (d === !1 || d && a.alive) && (e === !1 || e && a.visible) ? this.setProperty(a, b, c, f, g) : void 0;
    }, c.Group.prototype.setAll = function(a, b, c, d, e, f) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === f && (f = !1), a = a.split("."), 
        e = e || 0;
        for (var g = 0; g < this.children.length; g++) (!c || c && this.children[g].alive) && (!d || d && this.children[g].visible) && this.setProperty(this.children[g], a, b, e, f);
    }, c.Group.prototype.setAllChildren = function(a, b, d, e, f, g) {
        void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === g && (g = !1), f = f || 0;
        for (var h = 0; h < this.children.length; h++) (!d || d && this.children[h].alive) && (!e || e && this.children[h].visible) && (this.children[h] instanceof c.Group ? this.children[h].setAllChildren(a, b, d, e, f, g) : this.setProperty(this.children[h], a.split("."), b, f, g));
    }, c.Group.prototype.checkAll = function(a, b, c, d, e) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === e && (e = !1);
        for (var f = 0; f < this.children.length; f++) if ((!c || c && this.children[f].alive) && (!d || d && this.children[f].visible) && !this.checkProperty(this.children[f], a, b, e)) return !1;
        return !0;
    }, c.Group.prototype.addAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 1);
    }, c.Group.prototype.subAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 2);
    }, c.Group.prototype.multiplyAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 3);
    }, c.Group.prototype.divideAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 4);
    }, c.Group.prototype.callAllExists = function(a, b) {
        var c;
        if (arguments.length > 2) {
            c = [];
            for (var d = 2; d < arguments.length; d++) c.push(arguments[d]);
        }
        for (var d = 0; d < this.children.length; d++) this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c);
    }, c.Group.prototype.callbackFromArray = function(a, b, c) {
        if (1 == c) {
            if (a[b[0]]) return a[b[0]];
        } else if (2 == c) {
            if (a[b[0]][b[1]]) return a[b[0]][b[1]];
        } else if (3 == c) {
            if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]];
        } else if (4 == c) {
            if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]];
        } else if (a[b]) return a[b];
        return !1;
    }, c.Group.prototype.callAll = function(a, b) {
        if (void 0 !== a) {
            a = a.split(".");
            var c = a.length;
            if (void 0 === b || null === b || "" === b) b = null; else if ("string" == typeof b) {
                b = b.split(".");
                var d = b.length;
            }
            var e;
            if (arguments.length > 2) {
                e = [];
                for (var f = 2; f < arguments.length; f++) e.push(arguments[f]);
            }
            for (var g = null, h = null, f = 0; f < this.children.length; f++) g = this.callbackFromArray(this.children[f], a, c), 
            b && g ? (h = this.callbackFromArray(this.children[f], b, d), g && g.apply(h, e)) : g && g.apply(this.children[f], e);
        }
    }, c.Group.prototype.preUpdate = function() {
        if (this.pendingDestroy) return this.destroy(), !1;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        for (var a = this.children.length; a--; ) this.children[a].preUpdate();
        return !0;
    }, c.Group.prototype.update = function() {
        for (var a = this.children.length; a--; ) this.children[a].update();
    }, c.Group.prototype.postUpdate = function() {
        this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
        for (var a = this.children.length; a--; ) this.children[a].postUpdate();
    }, c.Group.prototype.filter = function(a, b) {
        for (var d = -1, e = this.children.length, f = []; ++d < e; ) {
            var g = this.children[d];
            (!b || b && g.exists) && a(g, d, this.children) && f.push(g);
        }
        return new c.ArraySet(f);
    }, c.Group.prototype.forEach = function(a, b, c) {
        if (void 0 === c && (c = !1), arguments.length <= 3) for (var d = 0; d < this.children.length; d++) (!c || c && this.children[d].exists) && a.call(b, this.children[d]); else {
            for (var e = [ null ], d = 3; d < arguments.length; d++) e.push(arguments[d]);
            for (var d = 0; d < this.children.length; d++) (!c || c && this.children[d].exists) && (e[0] = this.children[d], 
            a.apply(b, e));
        }
    }, c.Group.prototype.forEachExists = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [ null ];
            for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d);
    }, c.Group.prototype.forEachAlive = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [ null ];
            for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d);
    }, c.Group.prototype.forEachDead = function(a, b) {
        var d;
        if (arguments.length > 2) {
            d = [ null ];
            for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d);
    }, c.Group.prototype.sort = function(a, b) {
        this.children.length < 2 || (void 0 === a && (a = "z"), void 0 === b && (b = c.Group.SORT_ASCENDING), 
        this._sortProperty = a, this.children.sort(b === c.Group.SORT_ASCENDING ? this.ascendingSortHandler.bind(this) : this.descendingSortHandler.bind(this)), 
        this.updateZ());
    }, c.Group.prototype.customSort = function(a, b) {
        this.children.length < 2 || (this.children.sort(a.bind(b)), this.updateZ());
    }, c.Group.prototype.ascendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
    }, c.Group.prototype.descendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
    }, c.Group.prototype.iterate = function(a, b, d, e, f, g) {
        if (d === c.Group.RETURN_TOTAL && 0 === this.children.length) return 0;
        for (var h = 0, i = 0; i < this.children.length; i++) if (this.children[i][a] === b && (h++, 
        e && (g ? (g[0] = this.children[i], e.apply(f, g)) : e.call(f, this.children[i])), 
        d === c.Group.RETURN_CHILD)) return this.children[i];
        return d === c.Group.RETURN_TOTAL ? h : null;
    }, c.Group.prototype.getFirstExists = function(a) {
        return "boolean" != typeof a && (a = !0), this.iterate("exists", a, c.Group.RETURN_CHILD);
    }, c.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", !0, c.Group.RETURN_CHILD);
    }, c.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", !1, c.Group.RETURN_CHILD);
    }, c.Group.prototype.getTop = function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : void 0;
    }, c.Group.prototype.getBottom = function() {
        return this.children.length > 0 ? this.children[0] : void 0;
    }, c.Group.prototype.countLiving = function() {
        return this.iterate("alive", !0, c.Group.RETURN_TOTAL);
    }, c.Group.prototype.countDead = function() {
        return this.iterate("alive", !1, c.Group.RETURN_TOTAL);
    }, c.Group.prototype.getRandom = function(a, b) {
        return 0 === this.children.length ? null : (a = a || 0, b = b || this.children.length, 
        c.ArrayUtils.getRandomItem(this.children, a, b));
    }, c.Group.prototype.remove = function(a, b, c) {
        if (void 0 === b && (b = !1), void 0 === c && (c = !1), 0 === this.children.length || -1 === this.children.indexOf(a)) return !1;
        c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
        var d = this.removeChild(a);
        return this.removeFromHash(a), this.updateZ(), this.cursor === a && this.next(), 
        b && d && d.destroy(!0), !0;
    }, c.Group.prototype.moveAll = function(a, b) {
        if (void 0 === b && (b = !1), this.children.length > 0 && a instanceof c.Group) {
            do a.add(this.children[0], b); while (this.children.length > 0);
            this.hash = [], this.cursor = null;
        }
        return a;
    }, c.Group.prototype.removeAll = function(a, b) {
        if (void 0 === a && (a = !1), void 0 === b && (b = !1), 0 !== this.children.length) {
            do {
                !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                var c = this.removeChild(this.children[0]);
                this.removeFromHash(c), a && c && c.destroy(!0);
            } while (this.children.length > 0);
            this.hash = [], this.cursor = null;
        }
    }, c.Group.prototype.removeBetween = function(a, b, c, d) {
        if (void 0 === b && (b = this.children.length - 1), void 0 === c && (c = !1), void 0 === d && (d = !1), 
        0 !== this.children.length) {
            if (a > b || 0 > a || b > this.children.length) return !1;
            for (var e = b; e >= a; ) {
                !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
                var f = this.removeChild(this.children[e]);
                this.removeFromHash(f), c && f && f.destroy(!0), this.cursor === this.children[e] && (this.cursor = null), 
                e--;
            }
            this.updateZ();
        }
    }, c.Group.prototype.destroy = function(a, b) {
        null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0), void 0 === b && (b = !1), 
        this.onDestroy.dispatch(this, a, b), this.removeAll(a), this.cursor = null, this.filters = null, 
        this.pendingDestroy = !1, b || (this.parent && this.parent.removeChild(this), this.game = null, 
        this.exists = !1));
    }, Object.defineProperty(c.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", !0, c.Group.RETURN_TOTAL);
        }
    }), Object.defineProperty(c.Group.prototype, "length", {
        get: function() {
            return this.children.length;
        }
    }), Object.defineProperty(c.Group.prototype, "angle", {
        get: function() {
            return c.Math.radToDeg(this.rotation);
        },
        set: function(a) {
            this.rotation = c.Math.degToRad(a);
        }
    }), c.World = function(a) {
        c.Group.call(this, a, null, "__world", !1), this.bounds = new c.Rectangle(0, 0, a.width, a.height), 
        this.camera = null, this._definedSize = !1, this._width = a.width, this._height = a.height, 
        this.game.state.onStateChange.add(this.stateChange, this);
    }, c.World.prototype = Object.create(c.Group.prototype), c.World.prototype.constructor = c.World, 
    c.World.prototype.boot = function() {
        this.camera = new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), 
        this.camera.displayObject = this, this.camera.scale = this.scale, this.game.camera = this.camera, 
        this.game.stage.addChild(this);
    }, c.World.prototype.stateChange = function() {
        this.x = 0, this.y = 0, this.camera.reset();
    }, c.World.prototype.setBounds = function(a, b, c, d) {
        this._definedSize = !0, this._width = c, this._height = d, this.bounds.setTo(a, b, c, d), 
        this.x = a, this.y = b, this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)), 
        this.game.physics.setBoundsToWorld();
    }, c.World.prototype.resize = function(a, b) {
        this._definedSize && (a < this._width && (a = this._width), b < this._height && (b = this._height)), 
        this.bounds.width = a, this.bounds.height = b, this.game.camera.setBoundsToWorld(), 
        this.game.physics.setBoundsToWorld();
    }, c.World.prototype.shutdown = function() {
        this.destroy(!0, !0);
    }, c.World.prototype.wrap = function(a, b, c, d, e) {
        void 0 === b && (b = 0), void 0 === c && (c = !1), void 0 === d && (d = !0), void 0 === e && (e = !0), 
        c ? (a.getBounds(), d && (a.x + a._currentBounds.width < this.bounds.x ? a.x = this.bounds.right : a.x > this.bounds.right && (a.x = this.bounds.left)), 
        e && (a.y + a._currentBounds.height < this.bounds.top ? a.y = this.bounds.bottom : a.y > this.bounds.bottom && (a.y = this.bounds.top))) : (d && a.x + b < this.bounds.x ? a.x = this.bounds.right + b : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b), 
        e && a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b));
    }, Object.defineProperty(c.World.prototype, "width", {
        get: function() {
            return this.bounds.width;
        },
        set: function(a) {
            a < this.game.width && (a = this.game.width), this.bounds.width = a, this._width = a, 
            this._definedSize = !0;
        }
    }), Object.defineProperty(c.World.prototype, "height", {
        get: function() {
            return this.bounds.height;
        },
        set: function(a) {
            a < this.game.height && (a = this.game.height), this.bounds.height = a, this._height = a, 
            this._definedSize = !0;
        }
    }), Object.defineProperty(c.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth;
        }
    }), Object.defineProperty(c.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight;
        }
    }), Object.defineProperty(c.World.prototype, "randomX", {
        get: function() {
            return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width);
        }
    }), Object.defineProperty(c.World.prototype, "randomY", {
        get: function() {
            return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height);
        }
    }), c.FlexGrid = function(a, b, d) {
        this.game = a.game, this.manager = a, this.width = b, this.height = d, this.boundsCustom = new c.Rectangle(0, 0, b, d), 
        this.boundsFluid = new c.Rectangle(0, 0, b, d), this.boundsFull = new c.Rectangle(0, 0, b, d), 
        this.boundsNone = new c.Rectangle(0, 0, b, d), this.positionCustom = new c.Point(0, 0), 
        this.positionFluid = new c.Point(0, 0), this.positionFull = new c.Point(0, 0), this.positionNone = new c.Point(0, 0), 
        this.scaleCustom = new c.Point(1, 1), this.scaleFluid = new c.Point(1, 1), this.scaleFluidInversed = new c.Point(1, 1), 
        this.scaleFull = new c.Point(1, 1), this.scaleNone = new c.Point(1, 1), this.customWidth = 0, 
        this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = b / d, 
        this.ratioV = d / b, this.multiplier = 0, this.layers = [];
    }, c.FlexGrid.prototype = {
        setSize: function(a, b) {
            this.width = a, this.height = b, this.ratioH = a / b, this.ratioV = b / a, this.scaleNone = new c.Point(1, 1), 
            this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh();
        },
        createCustomLayer: function(a, b, d, e) {
            void 0 === e && (e = !0), this.customWidth = a, this.customHeight = b, this.boundsCustom.width = a, 
            this.boundsCustom.height = b;
            var f = new c.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
            return e && this.game.world.add(f), this.layers.push(f), "undefined" != typeof d && null !== typeof d && f.addMultiple(d), 
            f;
        },
        createFluidLayer: function(a, b) {
            void 0 === b && (b = !0);
            var d = new c.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            return b && this.game.world.add(d), this.layers.push(d), "undefined" != typeof a && null !== typeof a && d.addMultiple(a), 
            d;
        },
        createFullLayer: function(a) {
            var b = new c.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), 
            b;
        },
        createFixedLayer: function(a) {
            var b = new c.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), 
            b;
        },
        reset: function() {
            for (var a = this.layers.length; a--; ) this.layers[a].persist || (this.layers[a].position = null, 
            this.layers[a].scale = null, this.layers.slice(a, 1));
        },
        onResize: function(a, b) {
            this.ratioH = a / b, this.ratioV = b / a, this.refresh(a, b);
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), 
            this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), 
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), 
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), 
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), 
            this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), 
            this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), 
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), 
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), 
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        fitSprite: function(a) {
            this.manager.scaleSprite(a), a.x = this.manager.bounds.centerX, a.y = this.manager.bounds.centerY;
        },
        debug: function() {
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), 
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1);
        }
    }, c.FlexGrid.prototype.constructor = c.FlexGrid, c.FlexLayer = function(a, b, d, e) {
        c.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1), this.manager = a.manager, 
        this.grid = a, this.persist = !1, this.position = b, this.bounds = d, this.scale = e, 
        this.topLeft = d.topLeft, this.topMiddle = new c.Point(d.halfWidth, 0), this.topRight = d.topRight, 
        this.bottomLeft = d.bottomLeft, this.bottomMiddle = new c.Point(d.halfWidth, d.bottom), 
        this.bottomRight = d.bottomRight;
    }, c.FlexLayer.prototype = Object.create(c.Group.prototype), c.FlexLayer.prototype.constructor = c.FlexLayer, 
    c.FlexLayer.prototype.resize = function() {}, c.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), 
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), 
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    }, c.ScaleManager = function(a, b, d) {
        this.game = a, this.dom = c.DOM, this.grid = null, this.width = 0, this.height = 0, 
        this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, 
        this.offset = new c.Point(), this.forceLandscape = !1, this.forcePortrait = !1, 
        this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, 
        this.onOrientationChange = new c.Signal(), this.enterIncorrectOrientation = new c.Signal(), 
        this.leaveIncorrectOrientation = new c.Signal(), this.fullScreenTarget = null, this._createdFullScreenTarget = null, 
        this.onFullScreenInit = new c.Signal(), this.onFullScreenChange = new c.Signal(), 
        this.onFullScreenError = new c.Signal(), this.screenOrientation = this.dom.getScreenOrientation(), 
        this.scaleFactor = new c.Point(1, 1), this.scaleFactorInversed = new c.Point(1, 1), 
        this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        }, this.bounds = new c.Rectangle(), this.aspectRatio = 0, this.sourceAspectRatio = 0, 
        this.event = null, this.windowConstraints = {
            right: "layout",
            bottom: ""
        }, this.compatibility = {
            supportsFullScreen: !1,
            orientationFallback: null,
            noMargins: !1,
            scrollTo: null,
            forceMinimumDocumentHeight: !1,
            canExpandParent: !0,
            clickTrampoline: ""
        }, this._scaleMode = c.ScaleManager.NO_SCALE, this._fullScreenScaleMode = c.ScaleManager.NO_SCALE, 
        this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new c.Point(1, 1), 
        this.trackParentInterval = 2e3, this.onSizeChange = new c.Signal(), this.onResize = null, 
        this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, 
        this._gameSize = new c.Rectangle(), this._userScaleFactor = new c.Point(1, 1), this._userScaleTrim = new c.Point(0, 0), 
        this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, 
        this._parentBounds = new c.Rectangle(), this._tempBounds = new c.Rectangle(), this._lastReportedCanvasSize = new c.Rectangle(), 
        this._lastReportedGameSize = new c.Rectangle(), this._booted = !1, a.config && this.parseConfig(a.config), 
        this.setupScale(b, d);
    }, c.ScaleManager.EXACT_FIT = 0, c.ScaleManager.NO_SCALE = 1, c.ScaleManager.SHOW_ALL = 2, 
    c.ScaleManager.RESIZE = 3, c.ScaleManager.USER_SCALE = 4, c.ScaleManager.prototype = {
        boot: function() {
            var a = this.compatibility;
            a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, 
            this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (a.scrollTo = this.game.device.android && !this.game.device.chrome ? new c.Point(0, 1) : new c.Point(0, 0)), 
            this.game.device.desktop ? (a.orientationFallback = "screen", a.clickTrampoline = "when-not-mouse") : (a.orientationFallback = "", 
            a.clickTrampoline = "");
            var b = this;
            this._orientationChange = function(a) {
                return b.orientationChange(a);
            }, this._windowResize = function(a) {
                return b.windowResize(a);
            }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), 
            this.compatibility.supportsFullScreen && (this._fullScreenChange = function(a) {
                return b.fullScreenChange(a);
            }, this._fullScreenError = function(a) {
                return b.fullScreenError(a);
            }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), 
            document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), 
            document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), 
            document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), 
            document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), 
            this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), 
            this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), 
            this.grid = new c.FlexGrid(this, this.width, this.height), this._booted = !0, this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, 
            this._pendingScaleMode = null);
        },
        parseConfig: function(a) {
            a.scaleMode && (this._booted ? this.scaleMode = a.scaleMode : this._pendingScaleMode = a.scaleMode), 
            a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode), a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget);
        },
        setupScale: function(a, b) {
            var d, e = new c.Rectangle();
            "" !== this.game.parent && ("string" == typeof this.game.parent ? d = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)), 
            d ? (this.parentNode = d, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), 
            e.width = this._parentBounds.width, e.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, 
            this.parentIsWindow = !0, e.width = this.dom.visualBounds.width, e.height = this.dom.visualBounds.height, 
            this.offset.set(0, 0));
            var f = 0, g = 0;
            "number" == typeof a ? f = a : (this.parentScaleFactor.x = parseInt(a, 10) / 100, 
            f = e.width * this.parentScaleFactor.x), "number" == typeof b ? g = b : (this.parentScaleFactor.y = parseInt(b, 10) / 100, 
            g = e.height * this.parentScaleFactor.y), this._gameSize.setTo(0, 0, f, g), this.updateDimensions(f, g, !1);
        },
        _gameResumed: function() {
            this.queueUpdate(!0);
        },
        setGameSize: function(a, b) {
            this._gameSize.setTo(0, 0, a, b), this.currentScaleMode !== c.ScaleManager.RESIZE && this.updateDimensions(a, b, !0), 
            this.queueUpdate(!0);
        },
        setUserScale: function(a, b, c, d) {
            this._userScaleFactor.setTo(a, b), this._userScaleTrim.setTo(0 | c, 0 | d), this.queueUpdate(!0);
        },
        setResizeCallback: function(a, b) {
            this.onResize = a, this.onResizeContext = b;
        },
        signalSizeChange: function() {
            if (!c.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !c.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var a = this.width, b = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, a, b), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), 
                this.grid.onResize(a, b), this.onSizeChange.dispatch(this, a, b), this.currentScaleMode === c.ScaleManager.RESIZE && (this.game.state.resize(a, b), 
                this.game.load.resize(a, b));
            }
        },
        setMinMax: function(a, b, c, d) {
            this.minWidth = a, this.minHeight = b, "undefined" != typeof c && (this.maxWidth = c), 
            "undefined" != typeof d && (this.maxHeight = d);
        },
        preUpdate: function() {
            if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                var a = this._updateThrottle;
                this._updateThrottleReset = a >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                var b = this._parentBounds.width, d = this._parentBounds.height, e = this.getParentBounds(this._parentBounds), f = e.width !== b || e.height !== d, g = this.updateOrientationState();
                (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e), 
                this.updateLayout(), this.signalSizeChange());
                var h = 2 * this._updateThrottle;
                this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)), this._updateThrottle = c.Math.clamp(h, 25, this.trackParentInterval), 
                this._lastUpdate = this.game.time.time;
            }
        },
        pauseUpdate: function() {
            this.preUpdate(), this._updateThrottle = this.trackParentInterval;
        },
        updateDimensions: function(a, b, c) {
            this.width = a * this.parentScaleFactor.x, this.height = b * this.parentScaleFactor.y, 
            this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, 
            this.updateScalingAndBounds(), c && (this.game.renderer.resize(this.width, this.height), 
            this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height));
        },
        updateScalingAndBounds: function() {
            this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, 
            this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, 
            this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), 
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
        },
        forceOrientation: function(a, b) {
            void 0 === b && (b = !1), this.forceLandscape = a, this.forcePortrait = b, this.queueUpdate(!0);
        },
        classifyOrientation: function(a) {
            return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null;
        },
        updateOrientationState: function() {
            var a = this.screenOrientation, b = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), 
            this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var c = a !== this.screenOrientation, d = b !== this.incorrectOrientation;
            return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), 
            (c || d) && this.onOrientationChange.dispatch(this, a, b), c || d;
        },
        orientationChange: function(a) {
            this.event = a, this.queueUpdate(!0);
        },
        windowResize: function(a) {
            this.event = a, this.queueUpdate(!0);
        },
        scrollTop: function() {
            var a = this.compatibility.scrollTo;
            a && window.scrollTo(a.x, a.y);
        },
        refresh: function() {
            this.scrollTop(), this.queueUpdate(!0);
        },
        updateLayout: function() {
            var a = this.currentScaleMode;
            if (a === c.ScaleManager.RESIZE) return void this.reflowGame();
            if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), 
            this.incorrectOrientation ? this.setMaximum() : a === c.ScaleManager.EXACT_FIT ? this.setExactFit() : a === c.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), 
            this.resetCanvas(), this.setShowAll()) : this.setShowAll() : a === c.ScaleManager.NO_SCALE ? (this.width = this.game.width, 
            this.height = this.game.height) : a === c.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, 
            this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), 
            !this.compatibility.canExpandParent && (a === c.ScaleManager.SHOW_ALL || a === c.ScaleManager.USER_SCALE)) {
                var b = this.getParentBounds(this._tempBounds);
                this.width = Math.min(this.width, b.width), this.height = Math.min(this.height, b.height);
            }
            this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas();
        },
        getParentBounds: function(a) {
            var b = a || new c.Rectangle(), d = this.boundingParent, e = this.dom.visualBounds, f = this.dom.layoutBounds;
            if (d) {
                var g = d.getBoundingClientRect();
                b.setTo(g.left, g.top, g.width, g.height);
                var h = this.windowConstraints;
                if (h.right) {
                    var i = "layout" === h.right ? f : e;
                    b.right = Math.min(b.right, i.width);
                }
                if (h.bottom) {
                    var i = "layout" === h.bottom ? f : e;
                    b.bottom = Math.min(b.bottom, i.height);
                }
            } else b.setTo(0, 0, e.width, e.height);
            return b.setTo(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)), 
            b;
        },
        alignCanvas: function(a, b) {
            var c = this.getParentBounds(this._tempBounds), d = this.game.canvas, e = this.margin;
            if (a) {
                e.left = e.right = 0;
                var f = d.getBoundingClientRect();
                if (this.width < c.width && !this.incorrectOrientation) {
                    var g = f.left - c.x, h = c.width / 2 - this.width / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.left = Math.round(i);
                }
                d.style.marginLeft = e.left + "px", 0 !== e.left && (e.right = -(c.width - f.width - e.left), 
                d.style.marginRight = e.right + "px");
            }
            if (b) {
                e.top = e.bottom = 0;
                var f = d.getBoundingClientRect();
                if (this.height < c.height && !this.incorrectOrientation) {
                    var g = f.top - c.y, h = c.height / 2 - this.height / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.top = Math.round(i);
                }
                d.style.marginTop = e.top + "px", 0 !== e.top && (e.bottom = -(c.height - f.height - e.top), 
                d.style.marginBottom = e.bottom + "px");
            }
            e.x = e.left, e.y = e.top;
        },
        reflowGame: function() {
            this.resetCanvas("", "");
            var a = this.getParentBounds(this._tempBounds);
            this.updateDimensions(a.width, a.height, !0);
        },
        reflowCanvas: function() {
            this.incorrectOrientation || (this.width = c.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), 
            this.height = c.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), 
            this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), 
            this.updateScalingAndBounds();
        },
        resetCanvas: function(a, b) {
            void 0 === a && (a = this.width + "px"), void 0 === b && (b = this.height + "px");
            var c = this.game.canvas;
            this.compatibility.noMargins || (c.style.marginLeft = "", c.style.marginTop = "", 
            c.style.marginRight = "", c.style.marginBottom = ""), c.style.width = a, c.style.height = b;
        },
        queueUpdate: function(a) {
            a && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset;
        },
        reset: function(a) {
            a && this.grid.reset();
        },
        setMaximum: function() {
            this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height;
        },
        setShowAll: function(a) {
            var b, c = this.getParentBounds(this._tempBounds), d = c.width, e = c.height;
            b = a ? Math.max(e / this.game.height, d / this.game.width) : Math.min(e / this.game.height, d / this.game.width), 
            this.width = Math.round(this.game.width * b), this.height = Math.round(this.game.height * b);
        },
        setExactFit: function() {
            var a = this.getParentBounds(this._tempBounds);
            this.width = a.width, this.height = a.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), 
            this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)));
        },
        createFullScreenTarget: function() {
            var a = document.createElement("div");
            return a.style.margin = "0", a.style.padding = "0", a.style.background = "#000", 
            a;
        },
        startFullScreen: function(a, b) {
            if (this.isFullScreen) return !1;
            if (!this.compatibility.supportsFullScreen) {
                var d = this;
                return void setTimeout(function() {
                    d.fullScreenError();
                }, 10);
            }
            if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                var e = this.game.input;
                if (e.activePointer && e.activePointer !== e.mousePointer && (b || b !== !1)) return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [ a, !1 ]);
            }
            "undefined" != typeof a && this.game.renderType === c.CANVAS && (this.game.stage.smoothed = a);
            var f = this.fullScreenTarget;
            f || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), 
            f = this._createdFullScreenTarget);
            var g = {
                targetElement: f
            };
            if (this.onFullScreenInit.dispatch(this, g), this._createdFullScreenTarget) {
                var h = this.game.canvas, i = h.parentNode;
                i.insertBefore(f, h), f.appendChild(h);
            }
            return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](), 
            !0;
        },
        stopFullScreen: function() {
            return this.isFullScreen && this.compatibility.supportsFullScreen ? (document[this.game.device.cancelFullscreen](), 
            !0) : !1;
        },
        cleanupCreatedTarget: function() {
            var a = this._createdFullScreenTarget;
            if (a && a.parentNode) {
                var b = a.parentNode;
                b.insertBefore(this.game.canvas, a), b.removeChild(a);
            }
            this._createdFullScreenTarget = null;
        },
        prepScreenMode: function(a) {
            var b = !!this._createdFullScreenTarget, d = this._createdFullScreenTarget || this.fullScreenTarget;
            a ? (b || this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT) && d !== this.game.canvas && (this._fullScreenRestore = {
                targetWidth: d.style.width,
                targetHeight: d.style.height
            }, d.style.width = "100%", d.style.height = "100%") : (this._fullScreenRestore && (d.style.width = this._fullScreenRestore.targetWidth, 
            d.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), 
            this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas());
        },
        fullScreenChange: function(a) {
            this.event = a, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), 
            this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), 
            this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height);
        },
        fullScreenError: function(a) {
            this.event = a, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), 
            this.onFullScreenError.dispatch(this);
        },
        scaleSprite: function(a, b, c, d) {
            if (void 0 === b && (b = this.width), void 0 === c && (c = this.height), void 0 === d && (d = !1), 
            !a || !a.scale) return a;
            if (a.scale.x = 1, a.scale.y = 1, a.width <= 0 || a.height <= 0 || 0 >= b || 0 >= c) return a;
            var e = b, f = a.height * b / a.width, g = a.width * c / a.height, h = c, i = g > b;
            return i = i ? d : !d, i ? (a.width = Math.floor(e), a.height = Math.floor(f)) : (a.width = Math.floor(g), 
            a.height = Math.floor(h)), a;
        },
        destroy: function() {
            this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), 
            window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), 
            document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), 
            document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), 
            document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), 
            document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), 
            document.removeEventListener("fullscreenerror", this._fullScreenError, !1));
        }
    }, c.ScaleManager.prototype.constructor = c.ScaleManager, Object.defineProperty(c.ScaleManager.prototype, "boundingParent", {
        get: function() {
            if (this.parentIsWindow || this.isFullScreen && !this._createdFullScreenTarget) return null;
            var a = this.game.canvas && this.game.canvas.parentNode;
            return a || null;
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode;
        },
        set: function(a) {
            return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), 
            this.queueUpdate(!0)), this._scaleMode = a), this._scaleMode;
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function() {
            return this._fullScreenScaleMode;
        },
        set: function(a) {
            return a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), 
            this._fullScreenScaleMode = a, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = a), 
            this._fullScreenScaleMode;
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "currentScaleMode", {
        get: function() {
            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function() {
            return this._pageAlignHorizontally;
        },
        set: function(a) {
            a !== this._pageAlignHorizontally && (this._pageAlignHorizontally = a, this.queueUpdate(!0));
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignVertically", {
        get: function() {
            return this._pageAlignVertically;
        },
        set: function(a) {
            a !== this._pageAlignVertically && (this._pageAlignVertically = a, this.queueUpdate(!0));
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return "portrait" === this.classifyOrientation(this.screenOrientation);
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return "landscape" === this.classifyOrientation(this.screenOrientation);
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "isGamePortrait", {
        get: function() {
            return this.height > this.width;
        }
    }), Object.defineProperty(c.ScaleManager.prototype, "isGameLandscape", {
        get: function() {
            return this.width > this.height;
        }
    }), c.Game = function(a, b, d, e, f, g, h, i) {
        return this.id = c.GAMES.push(this) - 1, this.config = null, this.physicsConfig = i, 
        this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, 
        this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, 
        this.renderer = null, this.renderType = c.AUTO, this.state = null, this.isBooted = !1, 
        this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, 
        this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, 
        this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, 
        this.physics = null, this.plugins = null, this.rnd = null, this.device = c.Device, 
        this.camera = null, this.canvas = null, this.context = null, this.debug = null, 
        this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, 
        this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, 
        this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, 
        this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, 
        this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new c.Signal(), 
        this.forceSingleUpdate = !1, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
            enableDebug: !0
        }, "undefined" != typeof a && (this._width = a), "undefined" != typeof b && (this._height = b), 
        "undefined" != typeof d && (this.renderType = d), "undefined" != typeof e && (this.parent = e), 
        "undefined" != typeof g && (this.transparent = g), "undefined" != typeof h && (this.antialias = h), 
        this.rnd = new c.RandomDataGenerator([ (Date.now() * Math.random()).toString() ]), 
        this.state = new c.StateManager(this, f)), this.device.whenReady(this.boot, this), 
        this;
    }, c.Game.prototype = {
        parseConfig: function(a) {
            this.config = a, void 0 === a.enableDebug && (this.config.enableDebug = !0), a.width && (this._width = a.width), 
            a.height && (this._height = a.height), a.renderer && (this.renderType = a.renderer), 
            a.parent && (this.parent = a.parent), a.transparent && (this.transparent = a.transparent), 
            a.antialias && (this.antialias = a.antialias), a.resolution && (this.resolution = a.resolution), 
            a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer), 
            a.physicsConfig && (this.physicsConfig = a.physicsConfig);
            var b = [ (Date.now() * Math.random()).toString() ];
            a.seed && (b = a.seed), this.rnd = new c.RandomDataGenerator(b);
            var d = null;
            a.state && (d = a.state), this.state = new c.StateManager(this, d);
        },
        boot: function() {
            this.isBooted || (this.onPause = new c.Signal(), this.onResume = new c.Signal(), 
            this.onBlur = new c.Signal(), this.onFocus = new c.Signal(), this.isBooted = !0, 
            this.math = c.Math, this.scale = new c.ScaleManager(this, this._width, this._height), 
            this.stage = new c.Stage(this), this.setUpRenderer(), this.world = new c.World(this), 
            this.add = new c.GameObjectFactory(this), this.make = new c.GameObjectCreator(this), 
            this.cache = new c.Cache(this), this.load = new c.Loader(this), this.time = new c.Time(this), 
            this.tweens = new c.TweenManager(this), this.input = new c.Input(this), this.sound = new c.SoundManager(this), 
            this.physics = new c.Physics(this, this.physicsConfig), this.particles = new c.Particles(this), 
            this.create = new c.Create(this), this.plugins = new c.PluginManager(this), this.net = new c.Net(this), 
            this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), 
            this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new c.Utils.Debug(this), 
            this.debug.boot()) : this.debug = {
                preUpdate: function() {},
                update: function() {},
                reset: function() {}
            }, this.showDebugHeader(), this.isRunning = !0, this.raf = this.config && this.config.forceSetTimeOut ? new c.RequestAnimationFrame(this, this.config.forceSetTimeOut) : new c.RequestAnimationFrame(this, !1), 
            this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), 
            this.raf.start());
        },
        showDebugHeader: function() {
            if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                var a = c.VERSION, b = "Canvas", d = "HTML Audio", e = 1;
                if (this.renderType === c.WEBGL ? (b = "WebGL", e++) : this.renderType == c.HEADLESS && (b = "Headless"), 
                this.device.webAudio && (d = "WebAudio", e++), this.device.chrome) {
                    for (var f = [ "%c %c %c Phaser v" + a + " | Pixi.js " + PIXI.VERSION + " | " + b + " | " + d + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #9854d8", "background: #6c2ca7", "color: #ffffff; background: #450f78;", "background: #6c2ca7", "background: #9854d8", "background: #ffffff" ], g = 0; 3 > g; g++) f.push(e > g ? "color: #ff2424; background: #fff" : "color: #959595; background: #fff");
                    console.log.apply(console, f);
                } else window.console && console.log("Phaser v" + a + " | Pixi.js " + PIXI.VERSION + " | " + b + " | " + d + " | http://phaser.io");
            }
        },
        setUpRenderer: function() {
            if (this.canvas = c.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), 
            this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", 
            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === c.CANVAS ? !0 : !1), 
            this.renderType === c.HEADLESS || this.renderType === c.CANVAS || this.renderType === c.AUTO && this.device.webGL === !1) {
                if (!this.device.canvas) throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                this.renderType === c.AUTO && (this.renderType = c.CANVAS), this.renderer = new PIXI.CanvasRenderer(this.width, this.height, {
                    view: this.canvas,
                    transparent: this.transparent,
                    resolution: this.resolution,
                    clearBeforeRender: !0
                }), this.context = this.renderer.context;
            } else this.renderType = c.WEBGL, this.renderer = new PIXI.WebGLRenderer(this.width, this.height, {
                view: this.canvas,
                transparent: this.transparent,
                resolution: this.resolution,
                antialias: this.antialias,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            }), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), 
            this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
            this.renderType !== c.HEADLESS && (this.stage.smoothed = this.antialias, c.Canvas.addToDOM(this.canvas, this.parent, !1), 
            c.Canvas.setTouchAction(this.canvas));
        },
        contextLost: function(a) {
            a.preventDefault(), this.renderer.contextLost = !0;
        },
        contextRestored: function() {
            this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1;
        },
        update: function(a) {
            if (this.time.update(a), this._kickstart) return this.updateLogic(1 / this.time.desiredFps), 
            this.stage.updateTransform(), this.updateRender(this.time.slowMotion * this.time.desiredFps), 
            void (this._kickstart = !1);
            if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, 
            this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps); else {
                var b = 1e3 * this.time.slowMotion / this.time.desiredFps;
                this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
                var c = 0;
                for (this.updatesThisFrame = Math.floor(this._deltaTime / b), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b, 
                this.currentUpdateID = c, this.updateLogic(1 / this.time.desiredFps), this.stage.updateTransform(), 
                c++, !this.forceSingleUpdate || 1 !== c); ) ;
                c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0), 
                this._lastCount = c, this.updateRender(this._deltaTime / b);
            }
        },
        updateLogic: function(a) {
            this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), 
            this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), 
            this.debug.preUpdate(), this.world.camera.preUpdate(), this.physics.preUpdate(), 
            this.state.preUpdate(a), this.plugins.preUpdate(a), this.stage.preUpdate(), this.state.update(), 
            this.stage.update(), this.tweens.update(a), this.sound.update(), this.input.update(), 
            this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), 
            this.plugins.postUpdate());
        },
        updateRender: function(a) {
            this.lockRender || (this.state.preRender(a), this.renderer.render(this.stage), this.plugins.render(a), 
            this.state.render(a), this.plugins.postRender(a));
        },
        enableStep: function() {
            this.stepping = !0, this.pendingStep = !1, this.stepCount = 0;
        },
        disableStep: function() {
            this.stepping = !1, this.pendingStep = !1;
        },
        step: function() {
            this.pendingStep = !1, this.stepCount++;
        },
        destroy: function() {
            this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), 
            this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.state = null, 
            this.cache = null, this.input = null, this.load = null, this.sound = null, this.stage = null, 
            this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), 
            c.Canvas.removeFromDOM(this.canvas), c.GAMES[this.id] = null;
        },
        gamePaused: function(a) {
            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.setMute(), 
            this.onPause.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !0));
        },
        gameResumed: function(a) {
            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), 
            this.input.reset(), this.sound.unsetMute(), this.onResume.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !1));
        },
        focusLoss: function(a) {
            this.onBlur.dispatch(a), this.stage.disableVisibilityChange || this.gamePaused(a);
        },
        focusGain: function(a) {
            this.onFocus.dispatch(a), this.stage.disableVisibilityChange || this.gameResumed(a);
        }
    }, c.Game.prototype.constructor = c.Game, Object.defineProperty(c.Game.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(a) {
            a === !0 ? (this._paused === !1 && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), 
            this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, 
            this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), 
            this._codePaused = !1);
        }
    }), c.Input = function(a) {
        this.game = a, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], 
        this.pollRate = 0, this.enabled = !0, this.multiInputOverride = c.Input.MOUSE_TOUCH_COMBINE, 
        this.position = null, this.speed = null, this.circle = null, this.scale = null, 
        this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, 
        this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, 
        this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, 
        this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, 
        this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, 
        this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, 
        this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, 
        this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, 
        this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new c.ArraySet(), 
        this._localPoint = new c.Point(), this._pollCounter = 0, this._oldPosition = null, 
        this._x = 0, this._y = 0;
    }, c.Input.MOUSE_OVERRIDES_TOUCH = 0, c.Input.TOUCH_OVERRIDES_MOUSE = 1, c.Input.MOUSE_TOUCH_COMBINE = 2, 
    c.Input.MAX_POINTERS = 10, c.Input.prototype = {
        boot: function() {
            this.mousePointer = new c.Pointer(this.game, 0), this.addPointer(), this.addPointer(), 
            this.mouse = new c.Mouse(this.game), this.touch = new c.Touch(this.game), this.mspointer = new c.MSPointer(this.game), 
            c.Keyboard && (this.keyboard = new c.Keyboard(this.game)), c.Gamepad && (this.gamepad = new c.Gamepad(this.game)), 
            this.onDown = new c.Signal(), this.onUp = new c.Signal(), this.onTap = new c.Signal(), 
            this.onHold = new c.Signal(), this.scale = new c.Point(1, 1), this.speed = new c.Point(), 
            this.position = new c.Point(), this._oldPosition = new c.Point(), this.circle = new c.Circle(0, 0, 44), 
            this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), 
            this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), 
            this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
            var a = this;
            this._onClickTrampoline = function(b) {
                a.onClickTrampoline(b);
            }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1);
        },
        destroy: function() {
            this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), 
            this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), 
            this.game.canvas.removeEventListener("click", this._onClickTrampoline);
        },
        addMoveCallback: function(a, b) {
            this.moveCallbacks.push({
                callback: a,
                context: b
            });
        },
        deleteMoveCallback: function(a, b) {
            for (var c = this.moveCallbacks.length; c--; ) if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) return void this.moveCallbacks.splice(c, 1);
        },
        addPointer: function() {
            if (this.pointers.length >= c.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + c.Input.MAX_POINTERS + " pointers reached."), 
            null;
            var a = this.pointers.length + 1, b = new c.Pointer(this.game, a);
            return this.pointers.push(b), this["pointer" + a] = b, b;
        },
        update: function() {
            if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, 
            this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
            for (var a = 0; a < this.pointers.length; a++) this.pointers[a].update();
            this._pollCounter = 0;
        },
        reset: function(a) {
            if (this.game.isBooted && !this.resetLocked) {
                void 0 === a && (a = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(a), 
                this.gamepad && this.gamepad.reset();
                for (var b = 0; b < this.pointers.length; b++) this.pointers[b].reset();
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), 
                a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), 
                this.onDown = new c.Signal(), this.onUp = new c.Signal(), this.onTap = new c.Signal(), 
                this.onHold = new c.Signal(), this.moveCallbacks = []), this._pollCounter = 0;
            }
        },
        resetSpeed: function(a, b) {
            this._oldPosition.setTo(a, b), this.speed.setTo(0, 0);
        },
        startPointer: function(a) {
            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
            if (!this.pointer1.active) return this.pointer1.start(a);
            if (!this.pointer2.active) return this.pointer2.start(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (!c.active) return c.start(a);
            }
            return null;
        },
        updatePointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.move(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.move(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier) return c.move(a);
            }
            return null;
        },
        stopPointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.stop(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.stop(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier) return c.stop(a);
            }
            return null;
        },
        countActivePointers: function(a) {
            void 0 === a && (a = this.pointers.length);
            for (var b = a, c = 0; c < this.pointers.length && b > 0; c++) {
                var d = this.pointers[c];
                d.active && b--;
            }
            return a - b;
        },
        getPointer: function(a) {
            void 0 === a && (a = !1);
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active === a) return c;
            }
            return null;
        },
        getPointerFromIdentifier: function(a) {
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.identifier === a) return c;
            }
            return null;
        },
        getPointerFromId: function(a) {
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.pointerId === a) return c;
            }
            return null;
        },
        getLocalPosition: function(a, b, d) {
            void 0 === d && (d = new c.Point());
            var e = a.worldTransform, f = 1 / (e.a * e.d + e.c * -e.b);
            return d.setTo(e.d * f * b.x + -e.c * f * b.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * b.y + -e.b * f * b.x + (-e.ty * e.a + e.tx * e.b) * f);
        },
        hitTest: function(a, b, d) {
            if (!a.worldVisible) return !1;
            if (this.getLocalPosition(a, b, this._localPoint), d.copyFrom(this._localPoint), 
            a.hitArea && a.hitArea.contains) return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
            if (a instanceof c.TileSprite) {
                var e = a.width, f = a.height, g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
                }
            } else if (a instanceof PIXI.Sprite) {
                var e = a.texture.frame.width, f = a.texture.frame.height, g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
                }
            } else if (a instanceof c.Graphics) for (var i = 0; i < a.graphicsData.length; i++) {
                var j = a.graphicsData[i];
                if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) return !0;
            }
            for (var i = 0, k = a.children.length; k > i; i++) if (this.hitTest(a.children[i], b, d)) return !0;
            return !1;
        },
        onClickTrampoline: function() {
            this.activePointer.processClickTrampolines();
        }
    }, c.Input.prototype.constructor = c.Input, Object.defineProperty(c.Input.prototype, "x", {
        get: function() {
            return this._x;
        },
        set: function(a) {
            this._x = Math.floor(a);
        }
    }), Object.defineProperty(c.Input.prototype, "y", {
        get: function() {
            return this._y;
        },
        set: function(a) {
            this._y = Math.floor(a);
        }
    }), Object.defineProperty(c.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate;
        }
    }), Object.defineProperty(c.Input.prototype, "totalInactivePointers", {
        get: function() {
            return this.pointers.length - this.countActivePointers();
        }
    }), Object.defineProperty(c.Input.prototype, "totalActivePointers", {
        get: function() {
            return this.countActivePointers();
        }
    }), Object.defineProperty(c.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x;
        }
    }), Object.defineProperty(c.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y;
        }
    }), c.Mouse = function(a) {
        this.game = a, this.input = a.input, this.callbackContext = this.game, this.mouseDownCallback = null, 
        this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, 
        this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, 
        this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new c.Signal(), 
        this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, 
        this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null;
    }, c.Mouse.NO_BUTTON = -1, c.Mouse.LEFT_BUTTON = 0, c.Mouse.MIDDLE_BUTTON = 1, c.Mouse.RIGHT_BUTTON = 2, 
    c.Mouse.BACK_BUTTON = 3, c.Mouse.FORWARD_BUTTON = 4, c.Mouse.WHEEL_UP = 1, c.Mouse.WHEEL_DOWN = -1, 
    c.Mouse.prototype = {
        start: function() {
            if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                var b = this;
                this._onMouseDown = function(a) {
                    return b.onMouseDown(a);
                }, this._onMouseMove = function(a) {
                    return b.onMouseMove(a);
                }, this._onMouseUp = function(a) {
                    return b.onMouseUp(a);
                }, this._onMouseUpGlobal = function(a) {
                    return b.onMouseUpGlobal(a);
                }, this._onMouseOut = function(a) {
                    return b.onMouseOut(a);
                }, this._onMouseOver = function(a) {
                    return b.onMouseOver(a);
                }, this._onMouseWheel = function(a) {
                    return b.onMouseWheel(a);
                };
                var c = this.game.canvas;
                c.addEventListener("mousedown", this._onMouseDown, !0), c.addEventListener("mousemove", this._onMouseMove, !0), 
                c.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), 
                c.addEventListener("mouseover", this._onMouseOver, !0), c.addEventListener("mouseout", this._onMouseOut, !0));
                var d = this.game.device.wheelEvent;
                d && (c.addEventListener(d, this._onMouseWheel, !0), "mousewheel" === d ? this._wheelEvent = new a(-1 / 40, 1) : "DOMMouseScroll" === d && (this._wheelEvent = new a(1, 1)));
            }
        },
        onMouseDown: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.start(a));
        },
        onMouseMove: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.move(a));
        },
        onMouseUp: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.stop(a));
        },
        onMouseUpGlobal: function(a) {
            this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), 
            a.identifier = 0, this.input.mousePointer.stop(a));
        },
        onMouseOut: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, 
            this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && this.stopOnGameOut && (a.identifier = 0, 
            this.input.mousePointer.stop(a));
        },
        onMouseOver: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !0, 
            this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a);
        },
        onMouseWheel: function(a) {
            this._wheelEvent && (a = this._wheelEvent.bindEvent(a)), this.event = a, this.capture && a.preventDefault(), 
            this.wheelDelta = c.Math.clamp(-a.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a);
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var a = this.game.canvas;
                a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, 
                a.requestPointerLock();
                var b = this;
                this._pointerLockChange = function(a) {
                    return b.pointerLockChange(a);
                }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), 
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
            }
        },
        pointerLockChange: function(a) {
            var b = this.game.canvas;
            document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0, 
            this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a));
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, 
            document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), 
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("mousedown", this._onMouseDown, !0), a.removeEventListener("mousemove", this._onMouseMove, !0), 
            a.removeEventListener("mouseup", this._onMouseUp, !0), a.removeEventListener("mouseover", this._onMouseOver, !0), 
            a.removeEventListener("mouseout", this._onMouseOut, !0);
            var b = this.game.device.wheelEvent;
            b && a.removeEventListener(b, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), 
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), 
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), 
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        }
    }, c.Mouse.prototype.constructor = c.Mouse, a.prototype = {}, a.prototype.constructor = a, 
    a.prototype.bindEvent = function(b) {
        if (!a._stubsGenerated && b) {
            var c = function(a) {
                return function() {
                    var b = this.originalEvent[a];
                    return "function" != typeof b ? b : b.bind(this.originalEvent);
                };
            };
            for (var d in b) d in a.prototype || Object.defineProperty(a.prototype, d, {
                get: c(d)
            });
            a._stubsGenerated = !0;
        }
        return this.originalEvent = b, this;
    }, Object.defineProperties(a.prototype, {
        type: {
            value: "wheel"
        },
        deltaMode: {
            get: function() {
                return this._deltaMode;
            }
        },
        deltaY: {
            get: function() {
                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
            }
        },
        deltaX: {
            get: function() {
                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
            }
        },
        deltaZ: {
            value: 0
        }
    }), c.MSPointer = function(a) {
        this.game = a, this.input = a.input, this.callbackContext = this.game, this.pointerDownCallback = null, 
        this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, 
        this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, 
        this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, 
        this._onMSPointerOut = null, this._onMSPointerOver = null;
    }, c.MSPointer.prototype = {
        start: function() {
            if (null === this._onMSPointerDown) {
                var a = this;
                if (this.game.device.mspointer) {
                    this._onMSPointerDown = function(b) {
                        return a.onPointerDown(b);
                    }, this._onMSPointerMove = function(b) {
                        return a.onPointerMove(b);
                    }, this._onMSPointerUp = function(b) {
                        return a.onPointerUp(b);
                    }, this._onMSPointerUpGlobal = function(b) {
                        return a.onPointerUpGlobal(b);
                    }, this._onMSPointerOut = function(b) {
                        return a.onPointerOut(b);
                    }, this._onMSPointerOver = function(b) {
                        return a.onPointerOver(b);
                    };
                    var b = this.game.canvas;
                    b.addEventListener("MSPointerDown", this._onMSPointerDown, !1), b.addEventListener("MSPointerMove", this._onMSPointerMove, !1), 
                    b.addEventListener("MSPointerUp", this._onMSPointerUp, !1), b.addEventListener("pointerdown", this._onMSPointerDown, !1), 
                    b.addEventListener("pointermove", this._onMSPointerMove, !1), b.addEventListener("pointerup", this._onMSPointerUp, !1), 
                    b.style["-ms-content-zooming"] = "none", b.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), 
                    b.addEventListener("MSPointerOver", this._onMSPointerOver, !0), b.addEventListener("MSPointerOut", this._onMSPointerOut, !0), 
                    window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), b.addEventListener("pointerover", this._onMSPointerOver, !0), 
                    b.addEventListener("pointerout", this._onMSPointerOut, !0));
                }
            }
        },
        onPointerDown: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a));
        },
        onPointerMove: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a));
        },
        onPointerUp: function(a) {
            this.event = a, this.capture && a.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a), 
            this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a));
        },
        onPointerUpGlobal: function(a) {
            if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && b.withinGame && this.onPointerUp(a);
            } else this.onPointerUp(a);
        },
        onPointerOut: function(a) {
            if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !1; else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !1);
            }
            this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a), 
            this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (a.identifier = 0, 
            b ? b.stop(a) : this.input.mousePointer.stop(a));
        },
        onPointerOver: function(a) {
            if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !0; else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !0);
            }
            this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a);
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("MSPointerDown", this._onMSPointerDown), a.removeEventListener("MSPointerMove", this._onMSPointerMove), 
            a.removeEventListener("MSPointerUp", this._onMSPointerUp), a.removeEventListener("MSPointerOver", this._onMSPointerOver), 
            a.removeEventListener("MSPointerOut", this._onMSPointerOut), a.removeEventListener("pointerdown", this._onMSPointerDown), 
            a.removeEventListener("pointermove", this._onMSPointerMove), a.removeEventListener("pointerup", this._onMSPointerUp), 
            a.removeEventListener("pointerover", this._onMSPointerOver), a.removeEventListener("pointerout", this._onMSPointerOut), 
            window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal), window.removeEventListener("pointerup", this._onMSPointerUpGlobal);
        }
    }, c.MSPointer.prototype.constructor = c.MSPointer, c.DeviceButton = function(a, b) {
        this.parent = a, this.game = a.game, this.event = null, this.isDown = !1, this.isUp = !0, 
        this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, 
        this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = b, this.onDown = new c.Signal(), 
        this.onUp = new c.Signal(), this.onFloat = new c.Signal();
    }, c.DeviceButton.prototype = {
        start: function(a, b) {
            this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, 
            this.duration = 0, this.repeats = 0, this.event = a, this.value = b, a && (this.altKey = a.altKey, 
            this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onDown.dispatch(this, b));
        },
        stop: function(a, b) {
            this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, 
            this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, 
            this.ctrlKey = a.ctrlKey), this.onUp.dispatch(this, b));
        },
        padFloat: function(a) {
            this.value = a, this.onFloat.dispatch(this, a);
        },
        justPressed: function(a) {
            return a = a || 250, this.isDown && this.timeDown + a > this.game.time.time;
        },
        justReleased: function(a) {
            return a = a || 250, this.isUp && this.timeUp + a > this.game.time.time;
        },
        reset: function() {
            this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.duration = 0, 
            this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1;
        },
        destroy: function() {
            this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, 
            this.game = null;
        }
    }, c.DeviceButton.prototype.constructor = c.DeviceButton, Object.defineProperty(c.DeviceButton.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown;
        }
    }), c.Pointer = function(a, b) {
        this.game = a, this.id = b, this.type = c.POINTER, this.exists = !0, this.identifier = 0, 
        this.pointerId = null, this.target = null, this.button = null, this.leftButton = new c.DeviceButton(this, c.Pointer.LEFT_BUTTON), 
        this.middleButton = new c.DeviceButton(this, c.Pointer.MIDDLE_BUTTON), this.rightButton = new c.DeviceButton(this, c.Pointer.RIGHT_BUTTON), 
        this.backButton = new c.DeviceButton(this, c.Pointer.BACK_BUTTON), this.forwardButton = new c.DeviceButton(this, c.Pointer.FORWARD_BUTTON), 
        this.eraserButton = new c.DeviceButton(this, c.Pointer.ERASER_BUTTON), this._holdSent = !1, 
        this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, 
        this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, 
        this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, 
        this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === b, this.isDown = !1, 
        this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, 
        this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.active = !1, 
        this.dirty = !1, this.position = new c.Point(), this.positionDown = new c.Point(), 
        this.positionUp = new c.Point(), this.circle = new c.Circle(0, 0, 44), this._clickTrampolines = null, 
        this._trampolineTargetObject = null;
    }, c.Pointer.NO_BUTTON = 0, c.Pointer.LEFT_BUTTON = 1, c.Pointer.RIGHT_BUTTON = 2, 
    c.Pointer.MIDDLE_BUTTON = 4, c.Pointer.BACK_BUTTON = 8, c.Pointer.FORWARD_BUTTON = 16, 
    c.Pointer.ERASER_BUTTON = 32, c.Pointer.prototype = {
        resetButtons: function() {
            this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), 
            this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset());
        },
        processButtonsDown: function(a, b) {
            c.Pointer.LEFT_BUTTON & a && this.leftButton.start(b), c.Pointer.RIGHT_BUTTON & a && this.rightButton.start(b), 
            c.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(b), c.Pointer.BACK_BUTTON & a && this.backButton.start(b), 
            c.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(b), c.Pointer.ERASER_BUTTON & a && this.eraserButton.start(b);
        },
        processButtonsUp: function(a, b) {
            a === c.Mouse.LEFT_BUTTON && this.leftButton.stop(b), a === c.Mouse.RIGHT_BUTTON && this.rightButton.stop(b), 
            a === c.Mouse.MIDDLE_BUTTON && this.middleButton.stop(b), a === c.Mouse.BACK_BUTTON && this.backButton.stop(b), 
            a === c.Mouse.FORWARD_BUTTON && this.forwardButton.stop(b), 5 === a && this.eraserButton.stop(b);
        },
        updateButtons: function(a) {
            this.button = a.button;
            var b = "down" === a.type.toLowerCase().substr(-4);
            void 0 !== a.buttons ? b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a) : b ? this.leftButton.start(a) : (this.leftButton.stop(a), 
            this.rightButton.stop(a)), a.ctrlKey && this.leftButton.isDown && this.rightButton.start(a), 
            this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, 
            this.isDown = !0);
        },
        start: function(a) {
            return a.pointerId && (this.pointerId = a.pointerId), this.identifier = a.identifier, 
            this.target = a.target, this.isMouse ? this.updateButtons(a) : (this.isDown = !0, 
            this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], 
            this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, 
            this.timeDown = this.game.time.time, this._holdSent = !1, this.move(a, !0), this.positionDown.setTo(this.x, this.y), 
            (this.game.input.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.totalActivePointers) && (this.game.input.x = this.x, 
            this.game.input.y = this.y, this.game.input.position.setTo(this.x, this.y), this.game.input.onDown.dispatch(this, a), 
            this.game.input.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, 
            null !== this.targetObject && this.targetObject._touchedHandler(this), this;
        },
        update: function() {
            this.active && (this.dirty && (this.game.input.interactiveItems.total > 0 && this.processInteractiveObjects(!1), 
            this.dirty = !1), this._holdSent === !1 && this.duration >= this.game.input.holdRate && ((this.game.input.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.totalActivePointers) && this.game.input.onHold.dispatch(this), 
            this._holdSent = !0), this.game.input.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + this.game.input.recordRate, 
            this._history.push({
                x: this.position.x,
                y: this.position.y
            }), this._history.length > this.game.input.recordLimit && this._history.shift()));
        },
        move: function(a, b) {
            var d = this.game.input;
            if (!d.pollLocked) {
                if (void 0 === b && (b = !1), void 0 !== a.button && (this.button = a.button), b && this.isMouse && this.updateButtons(a), 
                this.clientX = a.clientX, this.clientY = a.clientY, this.pageX = a.pageX, this.pageY = a.pageY, 
                this.screenX = a.screenX, this.screenY = a.screenY, this.isMouse && d.mouse.locked && !b && (this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0, 
                this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0, this.movementX += this.rawMovementX, 
                this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x, 
                this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y, this.position.setTo(this.x, this.y), 
                this.circle.x = this.x, this.circle.y = this.y, (d.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) && (d.activePointer = this, 
                d.x = this.x, d.y = this.y, d.position.setTo(d.x, d.y), d.circle.x = d.x, d.circle.y = d.y), 
                this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                for (var e = d.moveCallbacks.length; e--; ) d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, b);
                return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : d.interactiveItems.total > 0 && this.processInteractiveObjects(b), 
                this;
            }
        },
        processInteractiveObjects: function(a) {
            for (var b = Number.MAX_VALUE, c = -1, d = null, e = this.game.input.interactiveItems.first; e; ) e.checked = !1, 
            e.validForInput(c, b, !1) && (e.checked = !0, (a && e.checkPointerDown(this, !0) || !a && e.checkPointerOver(this, !0)) && (b = e.sprite.renderOrderID, 
            c = e.priorityID, d = e)), e = this.game.input.interactiveItems.next;
            for (var e = this.game.input.interactiveItems.first; e; ) !e.checked && e.validForInput(c, b, !0) && (a && e.checkPointerDown(this, !1) || !a && e.checkPointerOver(this, !1)) && (b = e.sprite.renderOrderID, 
            c = e.priorityID, d = e), e = this.game.input.interactiveItems.next;
            return null === d ? this.targetObject && (this.targetObject._pointerOutHandler(this), 
            this.targetObject = null) : null === this.targetObject ? (this.targetObject = d, 
            d._pointerOverHandler(this)) : this.targetObject === d ? d.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this), 
            this.targetObject = d, this.targetObject._pointerOverHandler(this)), null !== this.targetObject;
        },
        leave: function(a) {
            this.withinGame = !1, this.move(a, !1);
        },
        stop: function(a) {
            return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time, 
            (this.game.input.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.totalActivePointers) && (this.game.input.onUp.dispatch(this, a), 
            this.duration >= 0 && this.duration <= this.game.input.tapRate && (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate ? this.game.input.onTap.dispatch(this, !0) : this.game.input.onTap.dispatch(this, !1), 
            this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(a) : (this.isDown = !1, 
            this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY), 
            this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), 
            this.isMouse === !1 && this.game.input.currentPointers--, this.game.input.interactiveItems.callAll("_releasedHandler", this), 
            this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, 
            this);
        },
        justPressed: function(a) {
            return a = a || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + a > this.game.time.time;
        },
        justReleased: function(a) {
            return a = a || this.game.input.justReleasedRate, this.isUp && this.timeUp + a > this.game.time.time;
        },
        addClickTrampoline: function(a, b, c, d) {
            if (this.isDown) {
                for (var e = this._clickTrampolines = this._clickTrampolines || [], f = 0; f < e.length; f++) if (e[f].name === a) {
                    e.splice(f, 1);
                    break;
                }
                e.push({
                    name: a,
                    targetObject: this.targetObject,
                    callback: b,
                    callbackContext: c,
                    callbackArgs: d
                });
            }
        },
        processClickTrampolines: function() {
            var a = this._clickTrampolines;
            if (a) {
                for (var b = 0; b < a.length; b++) {
                    var c = a[b];
                    c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs);
                }
                this._clickTrampolines = null, this._trampolineTargetObject = null;
            }
        },
        reset: function() {
            this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, 
            this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, 
            this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), 
            this.targetObject = null;
        },
        resetMovement: function() {
            this.movementX = 0, this.movementY = 0;
        }
    }, c.Pointer.prototype.constructor = c.Pointer, Object.defineProperty(c.Pointer.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown;
        }
    }), Object.defineProperty(c.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x;
        }
    }), Object.defineProperty(c.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y;
        }
    }), c.Touch = function(a) {
        this.game = a, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, 
        this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, 
        this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, 
        this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, 
        this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, 
        this._onTouchMove = null;
    }, c.Touch.prototype = {
        start: function() {
            if (null === this._onTouchStart) {
                var a = this;
                this.game.device.touch && (this._onTouchStart = function(b) {
                    return a.onTouchStart(b);
                }, this._onTouchMove = function(b) {
                    return a.onTouchMove(b);
                }, this._onTouchEnd = function(b) {
                    return a.onTouchEnd(b);
                }, this._onTouchEnter = function(b) {
                    return a.onTouchEnter(b);
                }, this._onTouchLeave = function(b) {
                    return a.onTouchLeave(b);
                }, this._onTouchCancel = function(b) {
                    return a.onTouchCancel(b);
                }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), 
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), 
                this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), 
                this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)));
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(a) {
                a.preventDefault();
            }, document.addEventListener("touchmove", this._documentTouchMove, !1);
        },
        addTouchLockCallback: function(a, b) {
            this.touchLockCallbacks.push({
                callback: a,
                context: b
            });
        },
        removeTouchLockCallback: function(a, b) {
            for (var c = this.touchLockCallbacks.length; c--; ) if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) return this.touchLockCallbacks.splice(c, 1), 
            !0;
            return !1;
        },
        onTouchStart: function(a) {
            for (var b = this.touchLockCallbacks.length; b--; ) this.touchLockCallbacks[b].callback.call(this.touchLockCallbacks[b].context, this, a) && this.touchLockCallbacks.splice(b, 1);
            if (this.event = a, this.game.input.enabled && this.enabled) {
                this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a), 
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b]);
            }
        },
        onTouchCancel: function(a) {
            if (this.event = a, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a), 
            this.game.input.enabled && this.enabled) {
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b]);
            }
        },
        onTouchEnter: function(a) {
            this.event = a, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a), 
            this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault();
        },
        onTouchLeave: function(a) {
            this.event = a, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a), 
            this.preventDefault && a.preventDefault();
        },
        onTouchMove: function(a) {
            this.event = a, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a), 
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b]);
        },
        onTouchEnd: function(a) {
            this.event = a, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a), 
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b]);
        },
        stop: function() {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), 
            this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), 
            this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), 
            this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel));
        }
    }, c.Touch.prototype.constructor = c.Touch, c.InputHandler = function(a) {
        this.sprite = a, this.game = a.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, 
        this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, 
        this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, 
        this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, 
        this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, 
        this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.consumePointerEvent = !1, 
        this.scaleLayer = !1, this.dragOffset = new c.Point(), this.dragFromCenter = !1, 
        this.dragStartPoint = new c.Point(), this.snapPoint = new c.Point(), this._dragPoint = new c.Point(), 
        this._dragPhase = !1, this._wasEnabled = !1, this._tempPoint = new c.Point(), this._pointerData = [], 
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: !1,
            isUp: !1,
            isOver: !1,
            isOut: !1,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: !1
        });
    }, c.InputHandler.prototype = {
        start: function(a, b) {
            if (a = a || 0, void 0 === b && (b = !1), this.enabled === !1) {
                this.game.input.interactiveItems.add(this), this.useHandCursor = b, this.priorityID = a;
                for (var d = 0; 10 > d; d++) this._pointerData[d] = {
                    id: d,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                };
                this.snapOffset = new c.Point(), this.enabled = !0, this._wasEnabled = !0;
            }
            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), 
            this.flagged = !1, this.sprite;
        },
        addedToGroup: function() {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start();
        },
        removedFromGroup: function() {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1);
        },
        reset: function() {
            this.enabled = !1, this.flagged = !1;
            for (var a = 0; 10 > a; a++) this._pointerData[a] = {
                id: a,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            };
        },
        stop: function() {
            this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this));
        },
        destroy: function() {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", 
            this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), 
            this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, 
            this.sprite = null);
        },
        validForInput: function(a, b, c) {
            return void 0 === c && (c = !0), 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID ? !1 : (c || !this.pixelPerfectClick && !this.pixelPerfectOver) && (this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID < b) ? !0 : !1;
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function(a) {
            return a = a || 0, this._pointerData[a].x;
        },
        pointerY: function(a) {
            return a = a || 0, this._pointerData[a].y;
        },
        pointerDown: function(a) {
            return a = a || 0, this._pointerData[a].isDown;
        },
        pointerUp: function(a) {
            return a = a || 0, this._pointerData[a].isUp;
        },
        pointerTimeDown: function(a) {
            return a = a || 0, this._pointerData[a].timeDown;
        },
        pointerTimeUp: function(a) {
            return a = a || 0, this._pointerData[a].timeUp;
        },
        pointerOver: function(a) {
            if (this.enabled) {
                if (void 0 !== a) return this._pointerData[a].isOver;
                for (var b = 0; 10 > b; b++) if (this._pointerData[b].isOver) return !0;
            }
            return !1;
        },
        pointerOut: function(a) {
            if (this.enabled) {
                if (void 0 !== a) return this._pointerData[a].isOut;
                for (var b = 0; 10 > b; b++) if (this._pointerData[b].isOut) return !0;
            }
            return !1;
        },
        pointerTimeOver: function(a) {
            return a = a || 0, this._pointerData[a].timeOver;
        },
        pointerTimeOut: function(a) {
            return a = a || 0, this._pointerData[a].timeOut;
        },
        pointerDragged: function(a) {
            return a = a || 0, this._pointerData[a].isDragged;
        },
        checkPointerDown: function(a, b) {
            return a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, a, this._tempPoint) ? (void 0 === b && (b = !1), 
            !b && this.pixelPerfectClick ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1;
        },
        checkPointerOver: function(a, b) {
            return this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, a, this._tempPoint) ? (void 0 === b && (b = !1), 
            !b && this.pixelPerfectOver ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1;
        },
        checkPixel: function(a, b, c) {
            if (this.sprite.texture.baseTexture.source) {
                if (null === a && null === b) {
                    this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
                    var a = this._tempPoint.x, b = this._tempPoint.y;
                }
                if (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 
                0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y), 
                a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.sprite.texture.trim && (a -= this.sprite.texture.trim.x, 
                b -= this.sprite.texture.trim.y, a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom)) return this._dx = a, 
                this._dy = b, !1;
                this._dx = a, this._dy = b, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
                var d = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (d.data[3] >= this.pixelPerfectAlpha) return !0;
            }
            return !1;
        },
        update: function(a) {
            return null !== this.sprite && void 0 !== this.sprite.parent ? this.enabled && this.sprite.visible && this.sprite.parent.visible ? this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x, 
            this._pointerData[a.id].y = a.y - this.sprite.y, !0) : (this._pointerOutHandler(a), 
            !1) : void 0 : (this._pointerOutHandler(a), !1) : void 0;
        },
        _pointerOverHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                (b.isOver === !1 || a.dirty) && (b.isOver = !0, b.isOut = !1, b.timeOver = this.game.time.time, 
                b.x = a.x - this.sprite.x, b.y = a.y - this.sprite.y, this.useHandCursor && b.isDragged === !1 && (this.game.canvas.style.cursor = "pointer", 
                this._setHandCursor = !0), this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a));
            }
        },
        _pointerOutHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                b.isOver = !1, b.isOut = !0, b.timeOut = this.game.time.time, this.useHandCursor && b.isDragged === !1 && (this.game.canvas.style.cursor = "default", 
                this._setHandCursor = !1), this.sprite && this.sprite.events && this.sprite.events.onInputOut$dispatch(this.sprite, a);
            }
        },
        _touchedHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                if (!b.isDown && b.isOver) {
                    if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) return;
                    b.isDown = !0, b.isUp = !1, b.timeDown = this.game.time.time, this.sprite && this.sprite.events && this.sprite.events.onInputDown$dispatch(this.sprite, a), 
                    a.dirty = !0, this.draggable && this.isDragged === !1 && this.startDrag(a), this.bringToTop && this.sprite.bringToTop();
                }
                return this.consumePointerEvent;
            }
        },
        _releasedHandler: function(a) {
            if (null !== this.sprite) {
                var b = this._pointerData[a.id];
                if (b.isDown && a.isUp) {
                    b.isDown = !1, b.isUp = !0, b.timeUp = this.game.time.time, b.downDuration = b.timeUp - b.timeDown;
                    var c = this.checkPointerOver(a);
                    this.sprite && this.sprite.events && (this.sprite.events.onInputUp$dispatch(this.sprite, a, c), 
                    c && (c = this.checkPointerOver(a))), b.isOver = c, !c && this.useHandCursor && (this.game.canvas.style.cursor = "default", 
                    this._setHandCursor = !1), a.dirty = !0, this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a);
                }
            }
        },
        updateDrag: function(a) {
            if (a.isUp) return this.stopDrag(a), !1;
            var b = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x, c = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
            return this.sprite.fixedToCamera ? (this.allowHorizontalDrag && (this.sprite.cameraOffset.x = b), 
            this.allowVerticalDrag && (this.sprite.cameraOffset.y = c), this.boundsRect && this.checkBoundsRect(), 
            this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, 
            this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y))) : (this.allowHorizontalDrag && (this.sprite.x = b), 
            this.allowVerticalDrag && (this.sprite.y = c), this.boundsRect && this.checkBoundsRect(), 
            this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, 
            this.snapPoint.set(this.sprite.x, this.sprite.y))), this.sprite.events.onDragUpdate.dispatch(this.sprite, a, b, c, this.snapPoint), 
            !0;
        },
        justOver: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isOver && this.overDuration(a) < b;
        },
        justOut: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b;
        },
        justPressed: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isDown && this.downDuration(a) < b;
        },
        justReleased: function(a, b) {
            return a = a || 0, b = b || 500, this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b;
        },
        overDuration: function(a) {
            return a = a || 0, this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1;
        },
        downDuration: function(a) {
            return a = a || 0, this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1;
        },
        enableDrag: function(a, b, d, e, f, g) {
            void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === d && (d = !1), void 0 === e && (e = 255), 
            void 0 === f && (f = null), void 0 === g && (g = null), this._dragPoint = new c.Point(), 
            this.draggable = !0, this.bringToTop = b, this.dragOffset = new c.Point(), this.dragFromCenter = a, 
            this.pixelPerfectClick = d, this.pixelPerfectAlpha = e, f && (this.boundsRect = f), 
            g && (this.boundsSprite = g);
        },
        disableDrag: function() {
            if (this._pointerData) for (var a = 0; 10 > a; a++) this._pointerData[a].isDragged = !1;
            this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1;
        },
        startDrag: function(a) {
            var b = this.sprite.x, c = this.sprite.y;
            if (this.isDragged = !0, this._draggedPointerID = a.id, this._pointerData[a.id].isDragged = !0, 
            this.sprite.fixedToCamera) this.dragFromCenter ? (this.sprite.centerOn(a.x, a.y), 
            this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y)) : this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y); else {
                if (this.dragFromCenter) {
                    var d = this.sprite.getBounds();
                    this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX), this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY);
                }
                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y));
            }
            this.updateDrag(a), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), 
            this.dragStartPoint.set(b, c), this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c);
        },
        globalToLocalX: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.x, a *= this.game.scale.grid.scaleFluidInversed.x), 
            a;
        },
        globalToLocalY: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.y, a *= this.game.scale.grid.scaleFluidInversed.y), 
            a;
        },
        stopDrag: function(a) {
            this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[a.id].isDragged = !1, 
            this._dragPhase = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, 
            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), 
            this.sprite.events.onDragStop$dispatch(this.sprite, a), this.checkPointerOver(a) === !1 && this._pointerOutHandler(a);
        },
        setDragLock: function(a, b) {
            void 0 === a && (a = !0), void 0 === b && (b = !0), this.allowHorizontalDrag = a, 
            this.allowVerticalDrag = b;
        },
        enableSnap: function(a, b, c, d, e, f) {
            void 0 === c && (c = !0), void 0 === d && (d = !1), void 0 === e && (e = 0), void 0 === f && (f = 0), 
            this.snapX = a, this.snapY = b, this.snapOffsetX = e, this.snapOffsetY = f, this.snapOnDrag = c, 
            this.snapOnRelease = d;
        },
        disableSnap: function() {
            this.snapOnDrag = !1, this.snapOnRelease = !1;
        },
        checkBoundsRect: function() {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), 
            this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), 
            this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)));
        },
        checkBoundsSprite: function() {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), 
            this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), 
            this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)));
        }
    }, c.InputHandler.prototype.constructor = c.InputHandler, c.Gamepad = function(a) {
        this.game = a, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, 
        this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 != navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, 
        this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, 
        this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, 
        this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, 
        this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [ new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this) ];
    }, c.Gamepad.prototype = {
        addCallbacks: function(a, b) {
            "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, 
            this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, 
            this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, 
            this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, 
            this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, 
            this.callbackContext = a);
        },
        start: function() {
            if (!this._active) {
                this._active = !0;
                var a = this;
                this._onGamepadConnected = function(b) {
                    return a.onGamepadConnected(b);
                }, this._onGamepadDisconnected = function(b) {
                    return a.onGamepadDisconnected(b);
                }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1);
            }
        },
        onGamepadConnected: function(a) {
            var b = a.gamepad;
            this._rawPads.push(b), this._gamepads[b.index].connect(b);
        },
        onGamepadDisconnected: function(a) {
            var b = a.gamepad;
            for (var c in this._rawPads) this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
            this._gamepads[b.index].disconnect();
        },
        update: function() {
            this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), 
            this.pad4.pollStatus();
        },
        _pollGamepads: function() {
            if (navigator.getGamepads) var a = navigator.getGamepads(); else if (navigator.webkitGetGamepads) var a = navigator.webkitGetGamepads(); else if (navigator.webkitGamepads) var a = navigator.webkitGamepads();
            if (a) {
                this._rawPads = [];
                for (var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = !0, 
                this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 !== c); c++) ;
                if (b) {
                    for (var d, e = {
                        rawIndices: {},
                        padIndices: {}
                    }, f = 0; f < this._gamepads.length; f++) if (d = this._gamepads[f], d.connected) for (var g = 0; g < this._rawPads.length; g++) this._rawPads[g].index === d.index && (e.rawIndices[d.index] = !0, 
                    e.padIndices[f] = !0);
                    for (var h = 0; h < this._gamepads.length; h++) if (d = this._gamepads[h], !e.padIndices[h]) {
                        this._rawPads.length < 1 && d.disconnect();
                        for (var i = 0; i < this._rawPads.length && !e.padIndices[h]; i++) {
                            var j = this._rawPads[i];
                            if (j) {
                                if (e.rawIndices[j.index]) {
                                    d.disconnect();
                                    continue;
                                }
                                d.connect(j), e.rawIndices[j.index] = !0, e.padIndices[h] = !0;
                            } else d.disconnect();
                        }
                    }
                }
            }
        },
        setDeadZones: function(a) {
            for (var b = 0; b < this._gamepads.length; b++) this._gamepads[b].deadZone = a;
        },
        stop: function() {
            this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), 
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function() {
            this.update();
            for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].reset();
        },
        justPressed: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++) if (this._gamepads[c].justPressed(a, b) === !0) return !0;
            return !1;
        },
        justReleased: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++) if (this._gamepads[c].justReleased(a, b) === !0) return !0;
            return !1;
        },
        isDown: function(a) {
            for (var b = 0; b < this._gamepads.length; b++) if (this._gamepads[b].isDown(a) === !0) return !0;
            return !1;
        },
        destroy: function() {
            this.stop();
            for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].destroy();
        }
    }, c.Gamepad.prototype.constructor = c.Gamepad, Object.defineProperty(c.Gamepad.prototype, "active", {
        get: function() {
            return this._active;
        }
    }), Object.defineProperty(c.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable;
        }
    }), Object.defineProperty(c.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length;
        }
    }), Object.defineProperty(c.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0];
        }
    }), Object.defineProperty(c.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1];
        }
    }), Object.defineProperty(c.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2];
        }
    }), Object.defineProperty(c.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3];
        }
    }), c.Gamepad.BUTTON_0 = 0, c.Gamepad.BUTTON_1 = 1, c.Gamepad.BUTTON_2 = 2, c.Gamepad.BUTTON_3 = 3, 
    c.Gamepad.BUTTON_4 = 4, c.Gamepad.BUTTON_5 = 5, c.Gamepad.BUTTON_6 = 6, c.Gamepad.BUTTON_7 = 7, 
    c.Gamepad.BUTTON_8 = 8, c.Gamepad.BUTTON_9 = 9, c.Gamepad.BUTTON_10 = 10, c.Gamepad.BUTTON_11 = 11, 
    c.Gamepad.BUTTON_12 = 12, c.Gamepad.BUTTON_13 = 13, c.Gamepad.BUTTON_14 = 14, c.Gamepad.BUTTON_15 = 15, 
    c.Gamepad.AXIS_0 = 0, c.Gamepad.AXIS_1 = 1, c.Gamepad.AXIS_2 = 2, c.Gamepad.AXIS_3 = 3, 
    c.Gamepad.AXIS_4 = 4, c.Gamepad.AXIS_5 = 5, c.Gamepad.AXIS_6 = 6, c.Gamepad.AXIS_7 = 7, 
    c.Gamepad.AXIS_8 = 8, c.Gamepad.AXIS_9 = 9, c.Gamepad.XBOX360_A = 0, c.Gamepad.XBOX360_B = 1, 
    c.Gamepad.XBOX360_X = 2, c.Gamepad.XBOX360_Y = 3, c.Gamepad.XBOX360_LEFT_BUMPER = 4, 
    c.Gamepad.XBOX360_RIGHT_BUMPER = 5, c.Gamepad.XBOX360_LEFT_TRIGGER = 6, c.Gamepad.XBOX360_RIGHT_TRIGGER = 7, 
    c.Gamepad.XBOX360_BACK = 8, c.Gamepad.XBOX360_START = 9, c.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, 
    c.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, c.Gamepad.XBOX360_DPAD_LEFT = 14, c.Gamepad.XBOX360_DPAD_RIGHT = 15, 
    c.Gamepad.XBOX360_DPAD_UP = 12, c.Gamepad.XBOX360_DPAD_DOWN = 13, c.Gamepad.XBOX360_STICK_LEFT_X = 0, 
    c.Gamepad.XBOX360_STICK_LEFT_Y = 1, c.Gamepad.XBOX360_STICK_RIGHT_X = 2, c.Gamepad.XBOX360_STICK_RIGHT_Y = 3, 
    c.Gamepad.PS3XC_X = 0, c.Gamepad.PS3XC_CIRCLE = 1, c.Gamepad.PS3XC_SQUARE = 2, c.Gamepad.PS3XC_TRIANGLE = 3, 
    c.Gamepad.PS3XC_L1 = 4, c.Gamepad.PS3XC_R1 = 5, c.Gamepad.PS3XC_L2 = 6, c.Gamepad.PS3XC_R2 = 7, 
    c.Gamepad.PS3XC_SELECT = 8, c.Gamepad.PS3XC_START = 9, c.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, 
    c.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, c.Gamepad.PS3XC_DPAD_UP = 12, c.Gamepad.PS3XC_DPAD_DOWN = 13, 
    c.Gamepad.PS3XC_DPAD_LEFT = 14, c.Gamepad.PS3XC_DPAD_RIGHT = 15, c.Gamepad.PS3XC_STICK_LEFT_X = 0, 
    c.Gamepad.PS3XC_STICK_LEFT_Y = 1, c.Gamepad.PS3XC_STICK_RIGHT_X = 2, c.Gamepad.PS3XC_STICK_RIGHT_Y = 3, 
    c.SinglePad = function(a, b) {
        this.game = a, this.index = null, this.connected = !1, this.callbackContext = this, 
        this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, 
        this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, 
        this.deadZone = .26, this._padParent = b, this._rawPad = null, this._prevTimestamp = null, 
        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0;
    }, c.SinglePad.prototype = {
        addCallbacks: function(a, b) {
            "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, 
            this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, 
            this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, 
            this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, 
            this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback);
        },
        getButton: function(a) {
            return this._buttons[a] ? this._buttons[a] : null;
        },
        pollStatus: function() {
            if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                for (var a = 0; a < this._buttonsLen; a++) {
                    var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
                    b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b));
                }
                for (var c = 0; c < this._axesLen; c++) {
                    var d = this._rawPad.axes[c];
                    d > 0 && d > this.deadZone || 0 > d && d < -this.deadZone ? this.processAxisChange(c, d) : this.processAxisChange(c, 0);
                }
                this._prevTimestamp = this._rawPad.timestamp;
            }
        },
        connect: function(a) {
            var b = !this.connected;
            this.connected = !0, this.index = a.index, this._rawPad = a, this._buttons = [], 
            this._buttonsLen = a.buttons.length, this._axes = [], this._axesLen = a.axes.length;
            for (var d = 0; d < this._axesLen; d++) this._axes[d] = a.axes[d];
            for (var e in a.buttons) e = parseInt(e, 10), this._buttons[e] = new c.DeviceButton(this, e);
            b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), 
            b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext);
        },
        disconnect: function() {
            var a = this.connected, b = this.index;
            this.connected = !1, this.index = null, this._rawPad = void 0;
            for (var c = 0; c < this._buttonsLen; c++) this._buttons[c].destroy();
            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b), 
            a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext);
        },
        destroy: function() {
            this._rawPad = void 0;
            for (var a = 0; a < this._buttonsLen; a++) this._buttons[a].destroy();
            this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, 
            this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, 
            this.onAxisCallback = null, this.onFloatCallback = null;
        },
        processAxisChange: function(a, b) {
            this._axes[a] !== b && (this._axes[a] = b, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b), 
            this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b));
        },
        processButtonDown: function(a, b) {
            this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index), 
            this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].start(null, b);
        },
        processButtonUp: function(a, b) {
            this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index), 
            this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].stop(null, b);
        },
        processButtonFloat: function(a, b) {
            this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index), 
            this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].padFloat(b);
        },
        axis: function(a) {
            return this._axes[a] ? this._axes[a] : !1;
        },
        isDown: function(a) {
            return this._buttons[a] ? this._buttons[a].isDown : !1;
        },
        isUp: function(a) {
            return this._buttons[a] ? this._buttons[a].isUp : !1;
        },
        justReleased: function(a, b) {
            return this._buttons[a] ? this._buttons[a].justReleased(b) : void 0;
        },
        justPressed: function(a, b) {
            return this._buttons[a] ? this._buttons[a].justPressed(b) : void 0;
        },
        buttonValue: function(a) {
            return this._buttons[a] ? this._buttons[a].value : null;
        },
        reset: function() {
            for (var a = 0; a < this._axes.length; a++) this._axes[a] = 0;
        }
    }, c.SinglePad.prototype.constructor = c.SinglePad, c.Key = function(a, b) {
        this.game = a, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, 
        this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, 
        this.timeUp = -2500, this.repeats = 0, this.keyCode = b, this.onDown = new c.Signal(), 
        this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new c.Signal(), 
        this._justDown = !1, this._justUp = !1;
    }, c.Key.prototype = {
        update: function() {
            this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, 
            this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this));
        },
        processKeyDown: function(a) {
            this._enabled && (this.event = a, this.isDown || (this.altKey = a.altKey, this.ctrlKey = a.ctrlKey, 
            this.shiftKey = a.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, 
            this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)));
        },
        processKeyUp: function(a) {
            this._enabled && (this.event = a, this.isUp || (this.isDown = !1, this.isUp = !0, 
            this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, 
            this._justUp = !0, this.onUp.dispatch(this)));
        },
        reset: function(a) {
            void 0 === a && (a = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, 
            this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, a && (this.onDown.removeAll(), 
            this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null);
        },
        downDuration: function(a) {
            return void 0 === a && (a = 50), this.isDown && this.duration < a;
        },
        upDuration: function(a) {
            return void 0 === a && (a = 50), !this.isDown && this.game.time.time - this.timeUp < a;
        }
    }, Object.defineProperty(c.Key.prototype, "justDown", {
        get: function() {
            var a = this._justDown;
            return this._justDown = !1, a;
        }
    }), Object.defineProperty(c.Key.prototype, "justUp", {
        get: function() {
            var a = this._justUp;
            return this._justUp = !1, a;
        }
    }), Object.defineProperty(c.Key.prototype, "enabled", {
        get: function() {
            return this._enabled;
        },
        set: function(a) {
            a = !!a, a !== this._enabled && (a || this.reset(!1), this._enabled = a);
        }
    }), c.Key.prototype.constructor = c.Key, c.Keyboard = function(a) {
        this.game = a, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, 
        this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, 
        this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, 
        this._onKeyUp = null, this._i = 0, this._k = 0;
    }, c.Keyboard.prototype = {
        addCallbacks: function(a, b, c, d) {
            this.callbackContext = a, "undefined" != typeof b && (this.onDownCallback = b), 
            "undefined" != typeof c && (this.onUpCallback = c), "undefined" != typeof d && (this.onPressCallback = d);
        },
        addKey: function(a) {
            return this._keys[a] || (this._keys[a] = new c.Key(this.game, a), this.addKeyCapture(a)), 
            this._keys[a];
        },
        addKeys: function(a) {
            var b = {};
            for (var c in a) b[c] = this.addKey(a[c]);
            return b;
        },
        removeKey: function(a) {
            this._keys[a] && (this._keys[a] = null, this.removeKeyCapture(a));
        },
        createCursorKeys: function() {
            return this.addKeys({
                up: c.Keyboard.UP,
                down: c.Keyboard.DOWN,
                left: c.Keyboard.LEFT,
                right: c.Keyboard.RIGHT
            });
        },
        start: function() {
            if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                var a = this;
                this._onKeyDown = function(b) {
                    return a.processKeyDown(b);
                }, this._onKeyUp = function(b) {
                    return a.processKeyUp(b);
                }, this._onKeyPress = function(b) {
                    return a.processKeyPress(b);
                }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), 
                window.addEventListener("keypress", this._onKeyPress, !1);
            }
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), 
            window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, 
            this._onKeyUp = null, this._onKeyPress = null;
        },
        destroy: function() {
            this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0;
        },
        addKeyCapture: function(a) {
            if ("object" == typeof a) for (var b in a) this._capture[a[b]] = !0; else this._capture[a] = !0;
        },
        removeKeyCapture: function(a) {
            delete this._capture[a];
        },
        clearCaptures: function() {
            this._capture = {};
        },
        update: function() {
            for (this._i = this._keys.length; this._i--; ) this._keys[this._i] && this._keys[this._i].update();
        },
        processKeyDown: function(a) {
            this.event = a, this.game.input.enabled && this.enabled && (this._capture[a.keyCode] && a.preventDefault(), 
            this._keys[a.keyCode] || (this._keys[a.keyCode] = new c.Key(this.game, a.keyCode)), 
            this._keys[a.keyCode].processKeyDown(a), this._k = a.keyCode, this.onDownCallback && this.onDownCallback.call(this.callbackContext, a));
        },
        processKeyPress: function(a) {
            this.pressEvent = a, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a);
        },
        processKeyUp: function(a) {
            this.event = a, this.game.input.enabled && this.enabled && (this._capture[a.keyCode] && a.preventDefault(), 
            this._keys[a.keyCode] || (this._keys[a.keyCode] = new c.Key(this.game, a.keyCode)), 
            this._keys[a.keyCode].processKeyUp(a), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a));
        },
        reset: function(a) {
            void 0 === a && (a = !0), this.event = null;
            for (var b = this._keys.length; b--; ) this._keys[b] && this._keys[b].reset(a);
        },
        downDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].downDuration(b) : null;
        },
        upDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].upDuration(b) : null;
        },
        isDown: function(a) {
            return this._keys[a] ? this._keys[a].isDown : null;
        }
    }, Object.defineProperty(c.Keyboard.prototype, "lastChar", {
        get: function() {
            return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode);
        }
    }), Object.defineProperty(c.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k];
        }
    }), c.Keyboard.prototype.constructor = c.Keyboard, c.Keyboard.A = "A".charCodeAt(0), 
    c.Keyboard.B = "B".charCodeAt(0), c.Keyboard.C = "C".charCodeAt(0), c.Keyboard.D = "D".charCodeAt(0), 
    c.Keyboard.E = "E".charCodeAt(0), c.Keyboard.F = "F".charCodeAt(0), c.Keyboard.G = "G".charCodeAt(0), 
    c.Keyboard.H = "H".charCodeAt(0), c.Keyboard.I = "I".charCodeAt(0), c.Keyboard.J = "J".charCodeAt(0), 
    c.Keyboard.K = "K".charCodeAt(0), c.Keyboard.L = "L".charCodeAt(0), c.Keyboard.M = "M".charCodeAt(0), 
    c.Keyboard.N = "N".charCodeAt(0), c.Keyboard.O = "O".charCodeAt(0), c.Keyboard.P = "P".charCodeAt(0), 
    c.Keyboard.Q = "Q".charCodeAt(0), c.Keyboard.R = "R".charCodeAt(0), c.Keyboard.S = "S".charCodeAt(0), 
    c.Keyboard.T = "T".charCodeAt(0), c.Keyboard.U = "U".charCodeAt(0), c.Keyboard.V = "V".charCodeAt(0), 
    c.Keyboard.W = "W".charCodeAt(0), c.Keyboard.X = "X".charCodeAt(0), c.Keyboard.Y = "Y".charCodeAt(0), 
    c.Keyboard.Z = "Z".charCodeAt(0), c.Keyboard.ZERO = "0".charCodeAt(0), c.Keyboard.ONE = "1".charCodeAt(0), 
    c.Keyboard.TWO = "2".charCodeAt(0), c.Keyboard.THREE = "3".charCodeAt(0), c.Keyboard.FOUR = "4".charCodeAt(0), 
    c.Keyboard.FIVE = "5".charCodeAt(0), c.Keyboard.SIX = "6".charCodeAt(0), c.Keyboard.SEVEN = "7".charCodeAt(0), 
    c.Keyboard.EIGHT = "8".charCodeAt(0), c.Keyboard.NINE = "9".charCodeAt(0), c.Keyboard.NUMPAD_0 = 96, 
    c.Keyboard.NUMPAD_1 = 97, c.Keyboard.NUMPAD_2 = 98, c.Keyboard.NUMPAD_3 = 99, c.Keyboard.NUMPAD_4 = 100, 
    c.Keyboard.NUMPAD_5 = 101, c.Keyboard.NUMPAD_6 = 102, c.Keyboard.NUMPAD_7 = 103, 
    c.Keyboard.NUMPAD_8 = 104, c.Keyboard.NUMPAD_9 = 105, c.Keyboard.NUMPAD_MULTIPLY = 106, 
    c.Keyboard.NUMPAD_ADD = 107, c.Keyboard.NUMPAD_ENTER = 108, c.Keyboard.NUMPAD_SUBTRACT = 109, 
    c.Keyboard.NUMPAD_DECIMAL = 110, c.Keyboard.NUMPAD_DIVIDE = 111, c.Keyboard.F1 = 112, 
    c.Keyboard.F2 = 113, c.Keyboard.F3 = 114, c.Keyboard.F4 = 115, c.Keyboard.F5 = 116, 
    c.Keyboard.F6 = 117, c.Keyboard.F7 = 118, c.Keyboard.F8 = 119, c.Keyboard.F9 = 120, 
    c.Keyboard.F10 = 121, c.Keyboard.F11 = 122, c.Keyboard.F12 = 123, c.Keyboard.F13 = 124, 
    c.Keyboard.F14 = 125, c.Keyboard.F15 = 126, c.Keyboard.COLON = 186, c.Keyboard.EQUALS = 187, 
    c.Keyboard.COMMA = 188, c.Keyboard.UNDERSCORE = 189, c.Keyboard.PERIOD = 190, c.Keyboard.QUESTION_MARK = 191, 
    c.Keyboard.TILDE = 192, c.Keyboard.OPEN_BRACKET = 219, c.Keyboard.BACKWARD_SLASH = 220, 
    c.Keyboard.CLOSED_BRACKET = 221, c.Keyboard.QUOTES = 222, c.Keyboard.BACKSPACE = 8, 
    c.Keyboard.TAB = 9, c.Keyboard.CLEAR = 12, c.Keyboard.ENTER = 13, c.Keyboard.SHIFT = 16, 
    c.Keyboard.CONTROL = 17, c.Keyboard.ALT = 18, c.Keyboard.CAPS_LOCK = 20, c.Keyboard.ESC = 27, 
    c.Keyboard.SPACEBAR = 32, c.Keyboard.PAGE_UP = 33, c.Keyboard.PAGE_DOWN = 34, c.Keyboard.END = 35, 
    c.Keyboard.HOME = 36, c.Keyboard.LEFT = 37, c.Keyboard.UP = 38, c.Keyboard.RIGHT = 39, 
    c.Keyboard.DOWN = 40, c.Keyboard.PLUS = 43, c.Keyboard.MINUS = 44, c.Keyboard.INSERT = 45, 
    c.Keyboard.DELETE = 46, c.Keyboard.HELP = 47, c.Keyboard.NUM_LOCK = 144, c.Component = function() {}, 
    c.Component.Angle = function() {}, c.Component.Angle.prototype = {
        angle: {
            get: function() {
                return c.Math.wrapAngle(c.Math.radToDeg(this.rotation));
            },
            set: function(a) {
                this.rotation = c.Math.degToRad(c.Math.wrapAngle(a));
            }
        }
    }, c.Component.Animation = function() {}, c.Component.Animation.prototype = {
        play: function(a, b, c, d) {
            return this.animations ? this.animations.play(a, b, c, d) : void 0;
        }
    }, c.Component.AutoCull = function() {}, c.Component.AutoCull.prototype = {
        autoCull: !1,
        inCamera: {
            get: function() {
                return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), 
                this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), 
                this.game.world.camera.view.intersects(this._bounds);
            }
        }
    }, c.Component.Bounds = function() {}, c.Component.Bounds.prototype = {
        offsetX: {
            get: function() {
                return this.anchor.x * this.width;
            }
        },
        offsetY: {
            get: function() {
                return this.anchor.y * this.height;
            }
        },
        left: {
            get: function() {
                return this.x - this.offsetX;
            }
        },
        right: {
            get: function() {
                return this.x + this.width - this.offsetX;
            }
        },
        top: {
            get: function() {
                return this.y - this.offsetY;
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height - this.offsetY;
            }
        }
    }, c.Component.BringToTop = function() {}, c.Component.BringToTop.prototype.bringToTop = function() {
        return this.parent && this.parent.bringToTop(this), this;
    }, c.Component.BringToTop.prototype.sendToBack = function() {
        return this.parent && this.parent.sendToBack(this), this;
    }, c.Component.BringToTop.prototype.moveUp = function() {
        return this.parent && this.parent.moveUp(this), this;
    }, c.Component.BringToTop.prototype.moveDown = function() {
        return this.parent && this.parent.moveDown(this), this;
    }, c.Component.Core = function() {}, c.Component.Core.install = function(a) {
        c.Utils.mixinPrototype(this, c.Component.Core.prototype), this.components = {};
        for (var b = 0; b < a.length; b++) {
            var d = a[b], e = !1;
            "Destroy" === d && (e = !0), c.Utils.mixinPrototype(this, c.Component[d].prototype, e), 
            this.components[d] = !0;
        }
    }, c.Component.Core.init = function(a, b, d, e, f) {
        this.game = a, this.key = e, this.position.set(b, d), this.world = new c.Point(b, d), 
        this.previousPosition = new c.Point(b, d), this.events = new c.Events(this), this._bounds = new c.Rectangle(), 
        this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new c.AnimationManager(this)), 
        this.components.LoadTexture && null !== e && this.loadTexture(e, f), this.components.FixedToCamera && (this.cameraOffset = new c.Point(b, d));
    }, c.Component.Core.preUpdate = function() {
        if (this.pendingDestroy) return void this.destroy();
        if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, 
        !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), 
        this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.texture && (this.texture.requiresReTint = !1), 
        this.animations && this.animations.update(), this.body && this.body.preUpdate();
        for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
        return !0;
    }, c.Component.Core.prototype = {
        game: null,
        name: "",
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
            get: function() {
                return this._exists;
            },
            set: function(a) {
                a ? (this._exists = !0, this.body && this.body.type === c.Physics.P2JS && this.body.addToWorld(), 
                this.visible = !0) : (this._exists = !1, this.body && this.body.type === c.Physics.P2JS && this.body.removeFromWorld(), 
                this.visible = !1);
            }
        },
        update: function() {},
        postUpdate: function() {
            this.customRender && this.key.render(), this.components.PhysicsBody && c.Component.PhysicsBody.postUpdate.call(this), 
            this.components.FixedToCamera && c.Component.FixedToCamera.postUpdate.call(this);
            for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
        }
    }, c.Component.Crop = function() {}, c.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function(a, b) {
            void 0 === b && (b = !1), a ? (b && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : this.cropRect = b && null === this.cropRect ? new c.Rectangle(a.x, a.y, a.width, a.height) : a, 
            this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame());
        },
        updateCrop: function() {
            if (this.cropRect) {
                this._crop = c.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, 
                this._crop.y += this._frame.y;
                var a = Math.max(this._frame.x, this._crop.x), b = Math.max(this._frame.y, this._crop.y), d = Math.min(this._frame.right, this._crop.right) - a, e = Math.min(this._frame.bottom, this._crop.bottom) - b;
                this.texture.crop.x = a, this.texture.crop.y = b, this.texture.crop.width = d, this.texture.crop.height = e, 
                this.texture.frame.width = Math.min(d, this.cropRect.width), this.texture.frame.height = Math.min(e, this.cropRect.height), 
                this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, 
                this.texture._updateUvs();
            }
        }
    }, c.Component.Delta = function() {}, c.Component.Delta.prototype = {
        deltaX: {
            get: function() {
                return this.world.x - this.previousPosition.x;
            }
        },
        deltaY: {
            get: function() {
                return this.world.y - this.previousPosition.y;
            }
        },
        deltaZ: {
            get: function() {
                return this.rotation - this.previousRotation;
            }
        }
    }, c.Component.Destroy = function() {}, c.Component.Destroy.prototype = {
        destroyPhase: !1,
        destroy: function(a) {
            if (null !== this.game && !this.destroyPhase) {
                void 0 === a && (a = !0), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), 
                this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this)), 
                this.input && this.input.destroy(), this.animations && this.animations.destroy(), 
                this.body && this.body.destroy(), this.events && this.events.destroy();
                var b = this.children.length;
                if (a) for (;b--; ) this.children[b].destroy(a); else for (;b--; ) this.removeChild(this.children[b]);
                this._crop && (this._crop = null), this._frame && (this._frame = null), c.Video && this.key instanceof c.Video && this.key.onChangeSource.remove(this.resizeFrame, this), 
                c.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, 
                this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.renderable = !1, 
                this.transformCallback = null, this.transformCallbackContext = null, this.hitArea = null, 
                this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, 
                this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), 
                this.destroyPhase = !1, this.pendingDestroy = !1;
            }
        }
    }, c.Events = function(a) {
        this.parent = a;
    }, c.Events.prototype = {
        destroy: function() {
            this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), 
            this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), 
            this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), 
            this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), 
            this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), 
            this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), 
            this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), 
            this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), 
            this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose();
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    }, c.Events.prototype.constructor = c.Events;
    for (var e in c.Events.prototype) c.Events.prototype.hasOwnProperty(e) && 0 === e.indexOf("on") && null === c.Events.prototype[e] && !function(a, b) {
        "use strict";
        Object.defineProperty(c.Events.prototype, a, {
            get: function() {
                return this[b] || (this[b] = new c.Signal());
            }
        }), c.Events.prototype[a + "$dispatch"] = function() {
            return this[b] ? this[b].dispatch.apply(this[b], arguments) : null;
        };
    }(e, "_" + e);
    c.Component.FixedToCamera = function() {}, c.Component.FixedToCamera.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, 
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
    }, c.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1,
        fixedToCamera: {
            get: function() {
                return this._fixedToCamera;
            },
            set: function(a) {
                a ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1;
            }
        },
        cameraOffset: new c.Point()
    }, c.Component.Health = function() {}, c.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function(a) {
            return this.alive && (this.health -= a, this.health <= 0 && this.kill()), this;
        },
        heal: function(a) {
            return this.alive && (this.health += a, this.health > this.maxHealth && (this.health = this.maxHealth)), 
            this;
        }
    }, c.Component.InCamera = function() {}, c.Component.InCamera.prototype = {
        inCamera: {
            get: function() {
                return this.game.world.camera.view.intersects(this._bounds);
            }
        }
    }, c.Component.InputEnabled = function() {}, c.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
            get: function() {
                return this.input && this.input.enabled;
            },
            set: function(a) {
                a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop();
            }
        }
    }, c.Component.InWorld = function() {}, c.Component.InWorld.preUpdate = function() {
        if ((this.autoCull || this.checkWorldBounds) && (this._bounds.copyFrom(this.getBounds()), 
        this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, 
        this.autoCull && (this.game.world.camera.view.intersects(this._bounds) ? (this.renderable = !0, 
        this.game.world.camera.totalInView++) : this.renderable = !1), this.checkWorldBounds)) if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, 
        this.events.onEnterBounds$dispatch(this); else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, 
        this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), 
        !1;
        return !0;
    }, c.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
            get: function() {
                return this.game.world.bounds.intersects(this.getBounds());
            }
        }
    }, c.Component.LifeSpan = function() {}, c.Component.LifeSpan.preUpdate = function() {
        return this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) ? (this.kill(), 
        !1) : !0;
    }, c.Component.LifeSpan.prototype = {
        alive: !0,
        lifespan: 0,
        revive: function(a) {
            return void 0 === a && (a = 1), this.alive = !0, this.exists = !0, this.visible = !0, 
            "number" == typeof this.health && (this.health = a), this.events && this.events.onRevived$dispatch(this), 
            this;
        },
        kill: function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), 
            this;
        }
    }, c.Component.LoadTexture = function() {}, c.Component.LoadTexture.prototype = {
        customRender: !1,
        _frame: null,
        loadTexture: function(a, b, d) {
            b = b || 0, (d || void 0 === d) && this.animations && this.animations.stop(), this.key = a, 
            this.customRender = !1;
            var e = this.game.cache, f = !0, g = !this.texture.baseTexture.scaleMode;
            if (c.RenderTexture && a instanceof c.RenderTexture) this.key = a.key, this.setTexture(a); else if (c.BitmapData && a instanceof c.BitmapData) this.customRender = !0, 
            this.setTexture(a.texture), e.hasFrameData(a.key, c.Cache.BITMAPDATA) && (f = !this.animations.loadFrameData(e.getFrameData(a.key, c.Cache.BITMAPDATA), b)); else if (c.Video && a instanceof c.Video) {
                this.customRender = !0;
                var h = a.texture.valid;
                this.setTexture(a.texture), this.setFrame(a.texture.frame.clone()), a.onChangeSource.add(this.resizeFrame, this), 
                this.texture.valid = h;
            } else if (a instanceof PIXI.Texture) this.setTexture(a); else {
                var i = e.getImage(a, !0);
                this.key = i.key, this.setTexture(new PIXI.Texture(i.base)), f = !this.animations.loadFrameData(i.frameData, b);
            }
            f && (this._frame = c.Rectangle.clone(this.texture.frame)), g || (this.texture.baseTexture.scaleMode = 1);
        },
        setFrame: function(a) {
            this._frame = a, this.texture.frame.x = a.x, this.texture.frame.y = a.y, this.texture.frame.width = a.width, 
            this.texture.frame.height = a.height, this.texture.crop.x = a.x, this.texture.crop.y = a.y, 
            this.texture.crop.width = a.width, this.texture.crop.height = a.height, a.trimmed ? (this.texture.trim ? (this.texture.trim.x = a.spriteSourceSizeX, 
            this.texture.trim.y = a.spriteSourceSizeY, this.texture.trim.width = a.sourceSizeW, 
            this.texture.trim.height = a.sourceSizeH) : this.texture.trim = {
                x: a.spriteSourceSizeX,
                y: a.spriteSourceSizeY,
                width: a.sourceSizeW,
                height: a.sourceSizeH
            }, this.texture.width = a.sourceSizeW, this.texture.height = a.sourceSizeH, this.texture.frame.width = a.sourceSizeW, 
            this.texture.frame.height = a.sourceSizeH) : !a.trimmed && this.texture.trim && (this.texture.trim = null), 
            this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), 
            this.tilingTexture && (this.refreshTexture = !0);
        },
        resizeFrame: function(a, b, c) {
            this.texture.frame.resize(b, c), this.texture.setFrame(this.texture.frame);
        },
        resetFrame: function() {
            this._frame && this.setFrame(this._frame);
        },
        frame: {
            get: function() {
                return this.animations.frame;
            },
            set: function(a) {
                this.animations.frame = a;
            }
        },
        frameName: {
            get: function() {
                return this.animations.frameName;
            },
            set: function(a) {
                this.animations.frameName = a;
            }
        }
    }, c.Component.Overlap = function() {}, c.Component.Overlap.prototype = {
        overlap: function(a) {
            return c.Rectangle.intersects(this.getBounds(), a.getBounds());
        }
    }, c.Component.PhysicsBody = function() {}, c.Component.PhysicsBody.preUpdate = function() {
        return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), 
        this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), 
        this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, 
        !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, 
        this._exists && this.parent.exists ? !0 : (this.renderOrderID = -1, !1));
    }, c.Component.PhysicsBody.postUpdate = function() {
        this.exists && this.body && this.body.postUpdate();
    }, c.Component.PhysicsBody.prototype = {
        body: null,
        x: {
            get: function() {
                return this.position.x;
            },
            set: function(a) {
                this.position.x = a, this.body && !this.body.dirty && (this.body._reset = !0);
            }
        },
        y: {
            get: function() {
                return this.position.y;
            },
            set: function(a) {
                this.position.y = a, this.body && !this.body.dirty && (this.body._reset = !0);
            }
        }
    }, c.Component.Reset = function() {}, c.Component.Reset.prototype.reset = function(a, b, c) {
        return void 0 === c && (c = 1), this.world.set(a, b), this.position.set(a, b), this.fresh = !0, 
        this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), 
        this.components.LifeSpan && (this.alive = !0, this.health = c), this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1), 
        this;
    }, c.Component.ScaleMinMax = function() {}, c.Component.ScaleMinMax.prototype = {
        transformCallback: this.checkTransform,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function(a) {
            this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x), a.d < this.scaleMin.y && (a.d = this.scaleMin.y)), 
            this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x), a.d > this.scaleMax.y && (a.d = this.scaleMax.y));
        },
        setScaleMinMax: function(a, b, d, e) {
            void 0 === b ? b = d = e = a : void 0 === d && (d = e = b, b = a), null === a ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(a, b) : this.scaleMin = new c.Point(a, b), 
            null === d ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(d, e) : this.scaleMax = new c.Point(d, e);
        }
    }, c.Component.Smoothed = function() {}, c.Component.Smoothed.prototype = {
        smoothed: {
            get: function() {
                return !this.texture.baseTexture.scaleMode;
            },
            set: function(a) {
                a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1);
            }
        }
    }, c.GameObjectFactory = function(a) {
        this.game = a, this.world = this.game.world;
    }, c.GameObjectFactory.prototype = {
        existing: function(a) {
            return this.world.add(a);
        },
        image: function(a, b, d, e, f) {
            return void 0 === f && (f = this.world), f.add(new c.Image(this.game, a, b, d, e));
        },
        sprite: function(a, b, c, d, e) {
            return void 0 === e && (e = this.world), e.create(a, b, c, d);
        },
        creature: function(a, b, d, e, f) {
            void 0 === f && (f = this.world);
            var g = new c.Creature(this.game, a, b, d, e);
            return f.add(g), g;
        },
        tween: function(a) {
            return this.game.tweens.create(a);
        },
        group: function(a, b, d, e, f) {
            return new c.Group(this.game, a, b, d, e, f);
        },
        physicsGroup: function(a, b, d, e) {
            return new c.Group(this.game, b, d, e, !0, a);
        },
        spriteBatch: function(a, b, d) {
            return void 0 === a && (a = null), void 0 === b && (b = "group"), void 0 === d && (d = !1), 
            new c.SpriteBatch(this.game, a, b, d);
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a);
        },
        tileSprite: function(a, b, d, e, f, g, h) {
            return void 0 === h && (h = this.world), h.add(new c.TileSprite(this.game, a, b, d, e, f, g));
        },
        rope: function(a, b, d, e, f, g) {
            return void 0 === g && (g = this.world), g.add(new c.Rope(this.game, a, b, d, e, f));
        },
        text: function(a, b, d, e, f) {
            return void 0 === f && (f = this.world), f.add(new c.Text(this.game, a, b, d, e));
        },
        button: function(a, b, d, e, f, g, h, i, j, k) {
            return void 0 === k && (k = this.world), k.add(new c.Button(this.game, a, b, d, e, f, g, h, i, j));
        },
        graphics: function(a, b, d) {
            return void 0 === d && (d = this.world), d.add(new c.Graphics(this.game, a, b));
        },
        emitter: function(a, b, d) {
            return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game, a, b, d));
        },
        retroFont: function(a, b, d, e, f, g, h, i, j) {
            return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function(a, b, d, e, f, g) {
            return void 0 === g && (g = this.world), g.add(new c.BitmapText(this.game, a, b, d, e, f));
        },
        tilemap: function(a, b, d, e, f) {
            return new c.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function(a, b, d, e) {
            (void 0 === d || "" === d) && (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
            var f = new c.RenderTexture(this.game, a, b, d);
            return e && this.game.cache.addRenderTexture(d, f), f;
        },
        video: function(a, b) {
            return new c.Video(this.game, a, b);
        },
        bitmapData: function(a, b, d, e) {
            void 0 === e && (e = !1), (void 0 === d || "" === d) && (d = this.game.rnd.uuid());
            var f = new c.BitmapData(this.game, d, a, b);
            return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function(a) {
            var b = Array.prototype.splice.call(arguments, 1), a = new c.Filter[a](this.game);
            return a.init.apply(a, b), a;
        },
        plugin: function(a) {
            return this.game.plugins.add(a);
        }
    }, c.GameObjectFactory.prototype.constructor = c.GameObjectFactory, c.GameObjectCreator = function(a) {
        this.game = a, this.world = this.game.world;
    }, c.GameObjectCreator.prototype = {
        image: function(a, b, d, e) {
            return new c.Image(this.game, a, b, d, e);
        },
        sprite: function(a, b, d, e) {
            return new c.Sprite(this.game, a, b, d, e);
        },
        tween: function(a) {
            return new c.Tween(a, this.game, this.game.tweens);
        },
        group: function(a, b, d, e, f) {
            return new c.Group(this.game, a, b, d, e, f);
        },
        spriteBatch: function(a, b, d) {
            return void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d);
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a);
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d);
        },
        tileSprite: function(a, b, d, e, f, g) {
            return new c.TileSprite(this.game, a, b, d, e, f, g);
        },
        rope: function(a, b, d, e, f) {
            return new c.Rope(this.game, a, b, d, e, f);
        },
        text: function(a, b, d, e) {
            return new c.Text(this.game, a, b, d, e);
        },
        button: function(a, b, d, e, f, g, h, i, j) {
            return new c.Button(this.game, a, b, d, e, f, g, h, i, j);
        },
        graphics: function(a, b) {
            return new c.Graphics(this.game, a, b);
        },
        emitter: function(a, b, d) {
            return new c.Particles.Arcade.Emitter(this.game, a, b, d);
        },
        retroFont: function(a, b, d, e, f, g, h, i, j) {
            return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function(a, b, d, e, f, g) {
            return new c.BitmapText(this.game, a, b, d, e, f, g);
        },
        tilemap: function(a, b, d, e, f) {
            return new c.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function(a, b, d, e) {
            (void 0 === d || "" === d) && (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
            var f = new c.RenderTexture(this.game, a, b, d);
            return e && this.game.cache.addRenderTexture(d, f), f;
        },
        bitmapData: function(a, b, d, e) {
            void 0 === e && (e = !1), (void 0 === d || "" === d) && (d = this.game.rnd.uuid());
            var f = new c.BitmapData(this.game, d, a, b);
            return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function(a) {
            var b = Array.prototype.splice.call(arguments, 1), a = new c.Filter[a](this.game);
            return a.init.apply(a, b), a;
        }
    }, c.GameObjectCreator.prototype.constructor = c.GameObjectCreator, c.Sprite = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.SPRITE, this.physicsType = c.SPRITE, 
        PIXI.Sprite.call(this, PIXI.TextureCache.__default), c.Component.Core.init.call(this, a, b, d, e, f);
    }, c.Sprite.prototype = Object.create(PIXI.Sprite.prototype), c.Sprite.prototype.constructor = c.Sprite, 
    c.Component.Core.install.call(c.Sprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]), 
    c.Sprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Sprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.Sprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Sprite.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.Sprite.prototype.preUpdate = function() {
        return this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.Image = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.IMAGE, PIXI.Sprite.call(this, PIXI.TextureCache.__default), 
        c.Component.Core.init.call(this, a, b, d, e, f);
    }, c.Image.prototype = Object.create(PIXI.Sprite.prototype), c.Image.prototype.constructor = c.Image, 
    c.Component.Core.install.call(c.Image.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "Smoothed" ]), 
    c.Image.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Image.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.Image.prototype.preUpdate = function() {
        return this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.TileSprite = function(a, b, d, e, f, g, h) {
        b = b || 0, d = d || 0, e = e || 256, f = f || 256, g = g || null, h = h || null, 
        this.type = c.TILESPRITE, this.physicsType = c.SPRITE, this._scroll = new c.Point();
        var i = a.cache.getImage("__default", !0);
        PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f), c.Component.Core.init.call(this, a, b, d, g, h);
    }, c.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), c.TileSprite.prototype.constructor = c.TileSprite, 
    c.Component.Core.install.call(c.TileSprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed" ]), 
    c.TileSprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.TileSprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.TileSprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.TileSprite.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.TileSprite.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
        this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.TileSprite.prototype.autoScroll = function(a, b) {
        this._scroll.set(a, b);
    }, c.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    }, c.TileSprite.prototype.destroy = function(a) {
        c.Component.Destroy.prototype.destroy.call(this, a), PIXI.TilingSprite.prototype.destroy.call(this);
    }, c.TileSprite.prototype.reset = function(a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, 
        this.tilePosition.y = 0, this;
    }, c.Rope = function(a, b, d, e, f, g) {
        this.points = [], this.points = g, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, 
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.ROPE, this._scroll = new c.Point(), 
        PIXI.Rope.call(this, PIXI.TextureCache.__default, this.points), c.Component.Core.init.call(this, a, b, d, e, f);
    }, c.Rope.prototype = Object.create(PIXI.Rope.prototype), c.Rope.prototype.constructor = c.Rope, 
    c.Component.Core.install.call(c.Rope.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]), 
    c.Rope.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Rope.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.Rope.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Rope.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.Rope.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
        this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.Rope.prototype.update = function() {
        this._hasUpdateAnimation && this.updateAnimation.call(this);
    }, c.Rope.prototype.reset = function(a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, 
        this.tilePosition.y = 0, this;
    }, Object.defineProperty(c.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(a) {
            a && "function" == typeof a ? (this._hasUpdateAnimation = !0, this._updateAnimation = a) : (this._hasUpdateAnimation = !1, 
            this._updateAnimation = null);
        }
    }), Object.defineProperty(c.Rope.prototype, "segments", {
        get: function() {
            for (var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++) a = 4 * k, 
            b = this.vertices[a] * this.scale.x, d = this.vertices[a + 1] * this.scale.y, e = this.vertices[a + 4] * this.scale.x, 
            f = this.vertices[a + 3] * this.scale.y, g = c.Math.difference(b, e), h = c.Math.difference(d, f), 
            b += this.world.x, d += this.world.y, i = new c.Rectangle(b, d, g, h), j.push(i);
            return j;
        }
    }), c.Button = function(a, b, d, e, f, g, h, i, j, k) {
        b = b || 0, d = d || 0, e = e || null, f = f || null, g = g || this, c.Image.call(this, a, b, d, e, i), 
        this.type = c.BUTTON, this.physicsType = c.SPRITE, this._onOverFrame = null, this._onOutFrame = null, 
        this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, 
        this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", 
        this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new c.Signal(), 
        this.onInputOut = new c.Signal(), this.onInputDown = new c.Signal(), this.onInputUp = new c.Signal(), 
        this.onOverMouseOnly = !1, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, 
        this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(h, i, j, k), 
        null !== f && this.onInputUp.add(f, g), this.events.onInputOver.add(this.onInputOverHandler, this), 
        this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), 
        this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
    }, c.Button.prototype = Object.create(c.Image.prototype), c.Button.prototype.constructor = c.Button;
    var f = "Over", g = "Out", h = "Down", i = "Up";
    c.Button.prototype.clearFrames = function() {
        this.setFrames(null, null, null, null);
    }, c.Button.prototype.removedFromWorld = function() {
        this.inputEnabled = !1;
    }, c.Button.prototype.setStateFrame = function(a, b, c) {
        var d = "_on" + a + "Frame";
        null !== b ? (this[d] = b, c && this.changeStateFrame(a)) : this[d] = null;
    }, c.Button.prototype.changeStateFrame = function(a) {
        if (this.freezeFrames) return !1;
        var b = "_on" + a + "Frame", c = this[b];
        return "string" == typeof c ? (this.frameName = c, !0) : "number" == typeof c ? (this.frame = c, 
        !0) : !1;
    }, c.Button.prototype.setFrames = function(a, b, c, d) {
        this.setStateFrame(f, a, this.input.pointerOver()), this.setStateFrame(g, b, !this.input.pointerOver()), 
        this.setStateFrame(h, c, this.input.pointerDown()), this.setStateFrame(i, d, this.input.pointerUp());
    }, c.Button.prototype.setStateSound = function(a, b, d) {
        var e = "on" + a + "Sound", f = "on" + a + "SoundMarker";
        b instanceof c.Sound || b instanceof c.AudioSprite ? (this[e] = b, this[f] = "string" == typeof d ? d : "") : (this[e] = null, 
        this[f] = "");
    }, c.Button.prototype.playStateSound = function(a) {
        var b = "on" + a + "Sound", c = this[b];
        if (c) {
            var d = "on" + a + "SoundMarker", e = this[d];
            return c.play(e), !0;
        }
        return !1;
    }, c.Button.prototype.setSounds = function(a, b, c, d, e, j, k, l) {
        this.setStateSound(f, a, b), this.setStateSound(g, e, j), this.setStateSound(h, c, d), 
        this.setStateSound(i, k, l);
    }, c.Button.prototype.setOverSound = function(a, b) {
        this.setStateSound(f, a, b);
    }, c.Button.prototype.setOutSound = function(a, b) {
        this.setStateSound(g, a, b);
    }, c.Button.prototype.setDownSound = function(a, b) {
        this.setStateSound(h, a, b);
    }, c.Button.prototype.setUpSound = function(a, b) {
        this.setStateSound(i, a, b);
    }, c.Button.prototype.onInputOverHandler = function(a, b) {
        b.justReleased() || (this.changeStateFrame(f), (!this.onOverMouseOnly || b.isMouse) && (this.playStateSound(f), 
        this.onInputOver && this.onInputOver.dispatch(this, b)));
    }, c.Button.prototype.onInputOutHandler = function(a, b) {
        this.changeStateFrame(g), this.playStateSound(g), this.onInputOut && this.onInputOut.dispatch(this, b);
    }, c.Button.prototype.onInputDownHandler = function(a, b) {
        this.changeStateFrame(h), this.playStateSound(h), this.onInputDown && this.onInputDown.dispatch(this, b);
    }, c.Button.prototype.onInputUpHandler = function(a, b, c) {
        if (this.playStateSound(i), this.onInputUp && this.onInputUp.dispatch(this, b, c), 
        !this.freezeFrames) if (this.forceOut) this.changeStateFrame(g); else {
            var d = this.changeStateFrame(i);
            d || this.changeStateFrame(c ? f : g);
        }
    }, c.SpriteBatch = function(a, b, d, e) {
        (void 0 === b || null === b) && (b = a.world), PIXI.SpriteBatch.call(this), c.Group.call(this, a, b, d, e), 
        this.type = c.SPRITEBATCH;
    }, c.SpriteBatch.prototype = c.Utils.extend(!0, c.SpriteBatch.prototype, c.Group.prototype, PIXI.SpriteBatch.prototype), 
    c.SpriteBatch.prototype.constructor = c.SpriteBatch, c.Particle = function(a, b, d, e, f) {
        c.Sprite.call(this, a, b, d, e, f), this.autoScale = !1, this.scaleData = null, 
        this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0;
    }, c.Particle.prototype = Object.create(c.Sprite.prototype), c.Particle.prototype.constructor = c.Particle, 
    c.Particle.prototype.update = function() {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), 
        this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1);
    }, c.Particle.prototype.onEmit = function() {}, c.Particle.prototype.setAlphaData = function(a) {
        this.alphaData = a, this._a = a.length - 1, this.alpha = this.alphaData[this._a].v, 
        this.autoAlpha = !0;
    }, c.Particle.prototype.setScaleData = function(a) {
        this.scaleData = a, this._s = a.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), 
        this.autoScale = !0;
    }, c.Particle.prototype.reset = function(a, b, d) {
        return c.Component.Reset.prototype.reset.call(this, a, b, d), this.alpha = 1, this.scale.set(1), 
        this.autoScale = !1, this.autoAlpha = !1, this;
    }, c.BitmapData = function(a, b, d, e) {
        (void 0 === d || 0 === d) && (d = 256), (void 0 === e || 0 === e) && (e = 256), 
        this.game = a, this.key = b, this.width = d, this.height = e, this.canvas = PIXI.CanvasPool.create(this, d, e), 
        this.context = this.canvas.getContext("2d", {
            alpha: !0
        }), this.ctx = this.context, this.imageData = this.context.getImageData(0, 0, d, e), 
        this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, 
        this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, 
        this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), 
        this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), 
        this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), 
        this.textureFrame = new c.Frame(0, 0, 0, d, e, "bitmapData"), this.texture.frame = this.textureFrame, 
        this.type = c.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, 
        this._image = null, this._pos = new c.Point(), this._size = new c.Point(), this._scale = new c.Point(), 
        this._rotate = 0, this._alpha = {
            prev: 1,
            current: 1
        }, this._anchor = new c.Point(), this._tempR = 0, this._tempG = 0, this._tempB = 0, 
        this._circle = new c.Circle(), this._swapCanvas = PIXI.CanvasPool.create(this, d, e);
    }, c.BitmapData.prototype = {
        move: function(a, b) {
            return 0 !== a && this.moveH(a), 0 !== b && this.moveV(b), this;
        },
        moveH: function(a) {
            var b = this._swapCanvas, c = b.getContext("2d"), d = this.height, e = this.canvas;
            if (c.clearRect(0, 0, this.width, this.height), 0 > a) {
                a = Math.abs(a);
                var f = this.width - a;
                c.drawImage(e, 0, 0, a, d, f, 0, a, d), c.drawImage(e, a, 0, f, d, 0, 0, f, d);
            } else {
                var f = this.width - a;
                c.drawImage(e, f, 0, a, d, 0, 0, a, d), c.drawImage(e, 0, 0, f, d, a, 0, f, d);
            }
            return this.clear(), this.copy(this._swapCanvas);
        },
        moveV: function(a) {
            var b = this._swapCanvas, c = b.getContext("2d"), d = this.width, e = this.canvas;
            if (c.clearRect(0, 0, this.width, this.height), 0 > a) {
                a = Math.abs(a);
                var f = this.height - a;
                c.drawImage(e, 0, 0, d, a, 0, f, d, a), c.drawImage(e, 0, a, d, f, 0, 0, d, f);
            } else {
                var f = this.height - a;
                c.drawImage(e, 0, f, d, a, 0, 0, d, a), c.drawImage(e, 0, 0, d, f, 0, a, d, f);
            }
            return this.clear(), this.copy(this._swapCanvas);
        },
        add: function(a) {
            if (Array.isArray(a)) for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this); else a.loadTexture(this);
            return this;
        },
        load: function(a) {
            return "string" == typeof a && (a = this.game.cache.getImage(a)), a ? (this.resize(a.width, a.height), 
            this.cls(), this.draw(a), this.update(), this) : void 0;
        },
        clear: function(a, b, c, d) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.width), 
            void 0 === d && (d = this.height), this.context.clearRect(a, b, c, d), this.dirty = !0, 
            this;
        },
        fill: function(a, b, c, d) {
            return void 0 === d && (d = 1), this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")", 
            this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this;
        },
        generateTexture: function(a) {
            var b = new Image();
            b.src = this.canvas.toDataURL("image/png");
            var c = this.game.cache.addImage(a, "", b);
            return new PIXI.Texture(c.base);
        },
        resize: function(a, b) {
            return (a !== this.width || b !== this.height) && (this.width = a, this.height = b, 
            this.canvas.width = a, this.canvas.height = b, this._swapCanvas.width = a, this._swapCanvas.height = b, 
            this.baseTexture.width = a, this.baseTexture.height = b, this.textureFrame.width = a, 
            this.textureFrame.height = b, this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, 
            this.texture.crop.height = b, this.update(), this.dirty = !0), this;
        },
        update: function(a, b, c, d) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = Math.max(1, this.width)), 
            void 0 === d && (d = Math.max(1, this.height)), this.imageData = this.context.getImageData(a, b, c, d), 
            this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, 
            this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), 
            this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, 
            this;
        },
        processPixelRGB: function(a, b, d, e, f, g) {
            void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = this.width), 
            void 0 === g && (g = this.height);
            for (var h = d + f, i = e + g, j = c.Color.createColor(), k = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, l = !1, m = e; i > m; m++) for (var n = d; h > n; n++) c.Color.unpackPixel(this.getPixel32(n, m), j), 
            k = a.call(b, j, n, m), k !== !1 && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1), 
            l = !0);
            return l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), 
            this;
        },
        processPixel: function(a, b, c, d, e, f) {
            void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = this.width), 
            void 0 === f && (f = this.height);
            for (var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; h > l; l++) for (var m = c; g > m; m++) i = this.getPixel32(m, l), 
            j = a.call(b, i, m, l), j !== i && (this.pixels[l * this.width + m] = j, k = !0);
            return k && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), 
            this;
        },
        replaceRGB: function(a, b, d, e, f, g, h, i, j) {
            var k = 0, l = 0, m = this.width, n = this.height, o = c.Color.packPixel(a, b, d, e);
            void 0 !== j && j instanceof c.Rectangle && (k = j.x, l = j.y, m = j.width, n = j.height);
            for (var p = 0; n > p; p++) for (var q = 0; m > q; q++) this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
        },
        setHSL: function(a, b, d, e) {
            if ((void 0 === a || null === a) && (a = !1), (void 0 === b || null === b) && (b = !1), 
            (void 0 === d || null === d) && (d = !1), a || b || d) {
                void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                for (var f = c.Color.createColor(), g = e.y; g < e.bottom; g++) for (var h = e.x; h < e.right; h++) c.Color.unpackPixel(this.getPixel32(h, g), f, !0), 
                a && (f.h = a), b && (f.s = b), d && (f.l = d), c.Color.HSLtoRGB(f.h, f.s, f.l, f), 
                this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
            }
        },
        shiftHSL: function(a, b, d, e) {
            if ((void 0 === a || null === a) && (a = !1), (void 0 === b || null === b) && (b = !1), 
            (void 0 === d || null === d) && (d = !1), a || b || d) {
                void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                for (var f = c.Color.createColor(), g = e.y; g < e.bottom; g++) for (var h = e.x; h < e.right; h++) c.Color.unpackPixel(this.getPixel32(h, g), f, !0), 
                a && (f.h = this.game.math.wrap(f.h + a, 0, 1)), b && (f.s = this.game.math.limitValue(f.s + b, 0, 1)), 
                d && (f.l = this.game.math.limitValue(f.l + d, 0, 1)), c.Color.HSLtoRGB(f.h, f.s, f.l, f), 
                this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this;
            }
        },
        setPixel32: function(a, b, d, e, f, g, h) {
            return void 0 === h && (h = !0), a >= 0 && a <= this.width && b >= 0 && b <= this.height && (this.pixels[b * this.width + a] = c.Device.LITTLE_ENDIAN ? g << 24 | f << 16 | e << 8 | d : d << 24 | e << 16 | f << 8 | g, 
            h && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this;
        },
        setPixel: function(a, b, c, d, e, f) {
            return this.setPixel32(a, b, c, d, e, 255, f);
        },
        getPixel: function(a, b, d) {
            d || (d = c.Color.createColor());
            var e = ~~(a + b * this.width);
            return e *= 4, d.r = this.data[e], d.g = this.data[++e], d.b = this.data[++e], d.a = this.data[++e], 
            d;
        },
        getPixel32: function(a, b) {
            return a >= 0 && a <= this.width && b >= 0 && b <= this.height ? this.pixels[b * this.width + a] : void 0;
        },
        getPixelRGB: function(a, b, d, e, f) {
            return c.Color.unpackPixel(this.getPixel32(a, b), d, e, f);
        },
        getPixels: function(a) {
            return this.context.getImageData(a.x, a.y, a.width, a.height);
        },
        getFirstPixel: function(a) {
            void 0 === a && (a = 0);
            var b = c.Color.createColor(), d = 0, e = 0, f = 1, g = !1;
            1 === a ? (f = -1, e = this.height) : 3 === a && (f = -1, d = this.width);
            do c.Color.unpackPixel(this.getPixel32(d, e), b), 0 === a || 1 === a ? (d++, d === this.width && (d = 0, 
            e += f, (e >= this.height || 0 >= e) && (g = !0))) : (2 === a || 3 === a) && (e++, 
            e === this.height && (e = 0, d += f, (d >= this.width || 0 >= d) && (g = !0))); while (0 === b.a && !g);
            return b.x = d, b.y = e, b;
        },
        getBounds: function(a) {
            return void 0 === a && (a = new c.Rectangle()), a.x = this.getFirstPixel(2).x, a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y, 
            a.width = this.getFirstPixel(3).x - a.x + 1, a.height = this.getFirstPixel(1).y - a.y + 1, 
            a);
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1, f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        copy: function(a, b, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
            if ((void 0 === a || null === a) && (a = this), this._image = a, a instanceof c.Sprite || a instanceof c.Image || a instanceof c.Text || a instanceof PIXI.Sprite) this._pos.set(a.texture.crop.x, a.texture.crop.y), 
            this._size.set(a.texture.crop.width, a.texture.crop.height), this._scale.set(a.scale.x, a.scale.y), 
            this._anchor.set(a.anchor.x, a.anchor.y), this._rotate = a.rotation, this._alpha.current = a.alpha, 
            this._image = a.texture.baseTexture.source, (void 0 === g || null === g) && (g = a.x), 
            (void 0 === h || null === h) && (h = a.y), a.texture.trim && (g += a.texture.trim.x - a.anchor.x * a.texture.trim.width, 
            h += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, 
            a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture); else {
                if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, 
                this._alpha.current = 1, a instanceof c.BitmapData) this._image = a.canvas; else if ("string" == typeof a) {
                    if (a = this.game.cache.getImage(a), null === a) return;
                    this._image = a;
                }
                this._size.set(this._image.width, this._image.height);
            }
            if ((void 0 === b || null === b) && (b = 0), (void 0 === d || null === d) && (d = 0), 
            e && (this._size.x = e), f && (this._size.y = f), (void 0 === g || null === g) && (g = b), 
            (void 0 === h || null === h) && (h = d), (void 0 === i || null === i) && (i = this._size.x), 
            (void 0 === j || null === j) && (j = this._size.y), "number" == typeof k && (this._rotate = k), 
            "number" == typeof l && (this._anchor.x = l), "number" == typeof m && (this._anchor.y = m), 
            "number" == typeof n && (this._scale.x = n), "number" == typeof o && (this._scale.y = o), 
            "number" == typeof p && (this._alpha.current = p), void 0 === q && (q = null), void 0 === r && (r = !1), 
            !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                var s = this.context;
                return this._alpha.prev = s.globalAlpha, s.save(), s.globalAlpha = this._alpha.current, 
                q && (this.op = q), r && (g |= 0, h |= 0), s.translate(g, h), s.scale(this._scale.x, this._scale.y), 
                s.rotate(this._rotate), s.drawImage(this._image, this._pos.x + b, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j), 
                s.restore(), s.globalAlpha = this._alpha.prev, this.dirty = !0, this;
            }
        },
        copyRect: function(a, b, c, d, e, f, g) {
            return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g);
        },
        draw: function(a, b, c, d, e, f, g) {
            return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g);
        },
        drawGroup: function(a, b, c) {
            return a.total > 0 && a.forEachExists(this.copy, this, null, null, null, null, null, null, null, null, null, null, null, null, null, null, b, c), 
            this;
        },
        drawFull: function(a, b, d) {
            if (a.worldVisible === !1 || 0 === a.worldAlpha || a.hasOwnProperty("exists") && a.exists === !1) return this;
            if (a.type !== c.GROUP && a.type !== c.EMITTER && a.type !== c.BITMAPTEXT) if (a.type === c.GRAPHICS) {
                var e = a.getBounds();
                this.ctx.save(), this.ctx.translate(e.x, e.y), PIXI.CanvasGraphics.renderGraphics(a, this.ctx), 
                this.ctx.restore();
            } else this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, b, d);
            if (a.children) for (var f = 0; f < a.children.length; f++) this.drawFull(a.children[f], b, d);
            return this;
        },
        shadow: function(a, b, c, d) {
            var e = this.context;
            void 0 === a || null === a ? e.shadowColor = "rgba(0,0,0,0)" : (e.shadowColor = a, 
            e.shadowBlur = b || 5, e.shadowOffsetX = c || 10, e.shadowOffsetY = d || 10);
        },
        alphaMask: function(a, b, c, d) {
            return void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(), 
            void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(), 
            this;
        },
        extract: function(a, b, c, d, e, f, g, h, i) {
            return void 0 === e && (e = 255), void 0 === f && (f = !1), void 0 === g && (g = b), 
            void 0 === h && (h = c), void 0 === i && (i = d), f && a.resize(this.width, this.height), 
            this.processPixelRGB(function(f, j, k) {
                return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1), 
                !1;
            }, this), a.context.putImageData(a.imageData, 0, 0), a.dirty = !0, a;
        },
        rect: function(a, b, c, d, e) {
            return "undefined" != typeof e && (this.context.fillStyle = e), this.context.fillRect(a, b, c, d), 
            this;
        },
        text: function(a, b, c, d, e, f) {
            void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = "14px Courier"), 
            void 0 === e && (e = "rgb(255,255,255)"), void 0 === f && (f = !0);
            var g = this.context, h = g.font;
            g.font = d, f && (g.fillStyle = "rgb(0,0,0)", g.fillText(a, b + 1, c + 1)), g.fillStyle = e, 
            g.fillText(a, b, c), g.font = h;
        },
        circle: function(a, b, c, d) {
            var e = this.context;
            return void 0 !== d && (e.fillStyle = d), e.beginPath(), e.arc(a, b, c, 0, 2 * Math.PI, !1), 
            e.closePath(), e.fill(), this;
        },
        line: function(a, b, c, d, e, f) {
            void 0 === e && (e = "#fff"), void 0 === f && (f = 1);
            var g = this.context;
            return g.beginPath(), g.moveTo(a, b), g.lineTo(c, d), g.lineWidth = f, g.strokeStyle = e, 
            g.stroke(), g.closePath(), this;
        },
        textureLine: function(a, b, d) {
            if (void 0 === d && (d = "repeat-x"), "string" != typeof b || (b = this.game.cache.getImage(b))) {
                var e = a.length;
                "no-repeat" === d && e > b.width && (e = b.width);
                var f = this.context;
                return f.fillStyle = f.createPattern(b, d), this._circle = new c.Circle(a.start.x, a.start.y, b.height), 
                this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos), f.save(), 
                f.translate(this._pos.x, this._pos.y), f.rotate(a.angle), f.fillRect(0, 0, e, b.height), 
                f.restore(), this.dirty = !0, this;
            }
        },
        render: function() {
            return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), 
            this;
        },
        destroy: function() {
            PIXI.CanvasPool.remove(this);
        },
        blendReset: function() {
            return this.op = "source-over", this;
        },
        blendSourceOver: function() {
            return this.op = "source-over", this;
        },
        blendSourceIn: function() {
            return this.op = "source-in", this;
        },
        blendSourceOut: function() {
            return this.op = "source-out", this;
        },
        blendSourceAtop: function() {
            return this.op = "source-atop", this;
        },
        blendDestinationOver: function() {
            return this.op = "destination-over", this;
        },
        blendDestinationIn: function() {
            return this.op = "destination-in", this;
        },
        blendDestinationOut: function() {
            return this.op = "destination-out", this;
        },
        blendDestinationAtop: function() {
            return this.op = "destination-atop", this;
        },
        blendXor: function() {
            return this.op = "xor", this;
        },
        blendAdd: function() {
            return this.op = "lighter", this;
        },
        blendMultiply: function() {
            return this.op = "multiply", this;
        },
        blendScreen: function() {
            return this.op = "screen", this;
        },
        blendOverlay: function() {
            return this.op = "overlay", this;
        },
        blendDarken: function() {
            return this.op = "darken", this;
        },
        blendLighten: function() {
            return this.op = "lighten", this;
        },
        blendColorDodge: function() {
            return this.op = "color-dodge", this;
        },
        blendColorBurn: function() {
            return this.op = "color-burn", this;
        },
        blendHardLight: function() {
            return this.op = "hard-light", this;
        },
        blendSoftLight: function() {
            return this.op = "soft-light", this;
        },
        blendDifference: function() {
            return this.op = "difference", this;
        },
        blendExclusion: function() {
            return this.op = "exclusion", this;
        },
        blendHue: function() {
            return this.op = "hue", this;
        },
        blendSaturation: function() {
            return this.op = "saturation", this;
        },
        blendColor: function() {
            return this.op = "color", this;
        },
        blendLuminosity: function() {
            return this.op = "luminosity", this;
        }
    }, Object.defineProperty(c.BitmapData.prototype, "smoothed", {
        get: function() {
            c.Canvas.getSmoothingEnabled(this.context);
        },
        set: function(a) {
            c.Canvas.setSmoothingEnabled(this.context, a);
        }
    }), Object.defineProperty(c.BitmapData.prototype, "op", {
        get: function() {
            return this.context.globalCompositeOperation;
        },
        set: function(a) {
            this.context.globalCompositeOperation = a;
        }
    }), c.BitmapData.getTransform = function(a, b, c, d, e, f) {
        return "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), "number" != typeof c && (c = 1), 
        "number" != typeof d && (d = 1), "number" != typeof e && (e = 0), "number" != typeof f && (f = 0), 
        {
            sx: c,
            sy: d,
            scaleX: c,
            scaleY: d,
            skewX: e,
            skewY: f,
            translateX: a,
            translateY: b,
            tx: a,
            ty: b
        };
    }, c.BitmapData.prototype.constructor = c.BitmapData, PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, 
        this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, 
        this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], 
        this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), 
        this.dirty = !0, this.webGLDirty = !1, this.cachedSpriteDirty = !1;
    }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
    PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(a, b, c) {
        return this.lineWidth = a || 0, this.lineColor = b || 0, this.lineAlpha = void 0 === c ? 1 : c, 
        this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, 
        this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), 
        this;
    }, PIXI.Graphics.prototype.moveTo = function(a, b) {
        return this.drawShape(new PIXI.Polygon([ a, b ])), this;
    }, PIXI.Graphics.prototype.lineTo = function(a, b) {
        return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(a, b), 
        this.dirty = !0, this;
    }, PIXI.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
        var e, f, g = 20, h = this.currentPath.shape.points;
        0 === h.length && this.moveTo(0, 0);
        for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; g >= l; ++l) k = l / g, 
        e = i + (a - i) * k, f = j + (b - j) * k, h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
        return this.dirty = !0, this;
    }, PIXI.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
        for (var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; l >= q; ++q) p = q / l, 
        g = 1 - p, h = g * g, i = h * g, j = p * p, k = j * p, m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f);
        return this.dirty = !0, this;
    }, PIXI.Graphics.prototype.arcTo = function(a, b, c, d, e) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
        var f = this.currentPath.shape.points, g = f[f.length - 2], h = f[f.length - 1], i = h - b, j = g - a, k = d - b, l = c - a, m = Math.abs(i * l - j * k);
        if (1e-8 > m || 0 === e) (f[f.length - 2] !== a || f[f.length - 1] !== b) && f.push(a, b); else {
            var n = i * i + j * j, o = k * k + l * l, p = i * k + j * l, q = e * Math.sqrt(n) / m, r = e * Math.sqrt(o) / m, s = q * p / n, t = r * p / o, u = q * l + r * j, v = q * k + r * i, w = j * (r + s), x = i * (r + s), y = l * (q + t), z = k * (q + t), A = Math.atan2(x - v, w - u), B = Math.atan2(z - v, y - u);
            this.arc(u + a, v + b, e, A, B, j * k > l * i);
        }
        return this.dirty = !0, this;
    }, PIXI.Graphics.prototype.arc = function(a, b, c, d, e, f) {
        if (d === e) return this;
        void 0 === f && (f = !1), !f && d >= e ? e += 2 * Math.PI : f && e >= d && (d += 2 * Math.PI);
        var g = f ? -1 * (d - e) : e - d, h = 40 * Math.ceil(Math.abs(g) / (2 * Math.PI));
        if (0 === g) return this;
        var i = a + Math.cos(d) * c, j = b + Math.sin(d) * c;
        f && this.filling ? this.moveTo(a, b) : this.moveTo(i, j);
        for (var k = this.currentPath.shape.points, l = g / (2 * h), m = 2 * l, n = Math.cos(l), o = Math.sin(l), p = h - 1, q = p % 1 / p, r = 0; p >= r; r++) {
            var s = r + q * r, t = l + d + m * s, u = Math.cos(t), v = -Math.sin(t);
            k.push((n * u + o * v) * c + a, (n * -v + o * u) * c + b);
        }
        return this.dirty = !0, this;
    }, PIXI.Graphics.prototype.beginFill = function(a, b) {
        return this.filling = !0, this.fillColor = a || 0, this.fillAlpha = void 0 === b ? 1 : b, 
        this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, 
        this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), 
        this;
    }, PIXI.Graphics.prototype.endFill = function() {
        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this;
    }, PIXI.Graphics.prototype.drawRect = function(a, b, c, d) {
        return this.drawShape(new PIXI.Rectangle(a, b, c, d)), this;
    }, PIXI.Graphics.prototype.drawRoundedRect = function(a, b, c, d, e) {
        return this.drawShape(new PIXI.RoundedRectangle(a, b, c, d, e)), this;
    }, PIXI.Graphics.prototype.drawCircle = function(a, b, c) {
        return this.drawShape(new PIXI.Circle(a, b, c)), this;
    }, PIXI.Graphics.prototype.drawEllipse = function(a, b, c, d) {
        return this.drawShape(new PIXI.Ellipse(a, b, c, d)), this;
    }, PIXI.Graphics.prototype.drawPolygon = function(a) {
        (a instanceof c.Polygon || a instanceof PIXI.Polygon) && (a = a.points);
        var b = a;
        if (!Array.isArray(b)) {
            b = new Array(arguments.length);
            for (var d = 0; d < b.length; ++d) b[d] = arguments[d];
        }
        return this.drawShape(new c.Polygon(b)), this;
    }, PIXI.Graphics.prototype.clear = function() {
        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this.clearDirty = !0, 
        this.graphicsData = [], this;
    }, PIXI.Graphics.prototype.generateTexture = function(a, b) {
        a = a || 1;
        var c = this.getBounds(), d = new PIXI.CanvasBuffer(c.width * a, c.height * a), e = PIXI.Texture.fromCanvas(d.canvas, b);
        return e.baseTexture.resolution = a, d.context.scale(a, a), d.context.translate(-c.x, -c.y), 
        PIXI.CanvasGraphics.renderGraphics(this, d.context), e;
    }, PIXI.Graphics.prototype._renderWebGL = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
            this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
            if (a.spriteBatch.stop(), a.blendModeManager.setBlendMode(this.blendMode), this._mask && a.maskManager.pushMask(this._mask, a), 
            this._filters && a.filterManager.pushFilter(this._filterBlock), this.blendMode !== a.spriteBatch.currentBlendMode) {
                a.spriteBatch.currentBlendMode = this.blendMode;
                var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
                a.spriteBatch.gl.blendFunc(b[0], b[1]);
            }
            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, a), 
            this.children.length) {
                a.spriteBatch.start();
                for (var c = 0; c < this.children.length; c++) this.children[c]._renderWebGL(a);
                a.spriteBatch.stop();
            }
            this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), 
            a.drawCount++, a.spriteBatch.start();
        }
    }, PIXI.Graphics.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
            if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), 
            this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
            this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
            var b = a.context, c = this.worldTransform;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]), 
            this._mask && a.maskManager.pushMask(this._mask, a);
            var d = a.resolution;
            b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, c.tx * d, c.ty * d), PIXI.CanvasGraphics.renderGraphics(this, b);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, PIXI.Graphics.prototype.getBounds = function(a) {
        if (!this._currentBounds) {
            if (!this.renderable) return PIXI.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, 
            this.dirty = !1);
            var b = this._localBounds, c = b.x, d = b.width + b.x, e = b.y, f = b.height + b.y, g = a || this.worldTransform, h = g.a, i = g.b, j = g.c, k = g.d, l = g.tx, m = g.ty, n = h * d + j * f + l, o = k * f + i * d + m, p = h * c + j * f + l, q = k * f + i * c + m, r = h * c + j * e + l, s = k * e + i * c + m, t = h * d + j * e + l, u = k * e + i * d + m, v = n, w = o, x = n, y = o;
            x = x > p ? p : x, x = x > r ? r : x, x = x > t ? t : x, y = y > q ? q : y, y = y > s ? s : y, 
            y = y > u ? u : y, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = q > w ? q : w, 
            w = s > w ? s : w, w = u > w ? u : w, this._bounds.x = x, this._bounds.width = v - x, 
            this._bounds.y = y, this._bounds.height = w - y, this._currentBounds = this._bounds;
        }
        return this._currentBounds;
    }, PIXI.Graphics.prototype.containsPoint = function(a) {
        this.worldTransform.applyInverse(a, tempPoint);
        for (var b = this.graphicsData, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d.fill && d.shape && d.shape.contains(tempPoint.x, tempPoint.y)) return !0;
        }
        return !1;
    }, PIXI.Graphics.prototype.updateLocalBounds = function() {
        var a = 1 / 0, b = -1 / 0, d = 1 / 0, e = -1 / 0;
        if (this.graphicsData.length) for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
            var m = this.graphicsData[l], n = m.type, o = m.lineWidth;
            if (f = m.shape, n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC) h = f.x - o / 2, 
            i = f.y - o / 2, j = f.width + o, k = f.height + o, a = a > h ? h : a, b = h + j > b ? h + j : b, 
            d = d > i ? i : d, e = i + k > e ? i + k : e; else if (n === PIXI.Graphics.CIRC) h = f.x, 
            i = f.y, j = f.radius + o / 2, k = f.radius + o / 2, a = a > h - j ? h - j : a, 
            b = h + j > b ? h + j : b, d = d > i - k ? i - k : d, e = i + k > e ? i + k : e; else if (n === PIXI.Graphics.ELIP) h = f.x, 
            i = f.y, j = f.width + o / 2, k = f.height + o / 2, a = a > h - j ? h - j : a, b = h + j > b ? h + j : b, 
            d = d > i - k ? i - k : d, e = i + k > e ? i + k : e; else {
                g = f.points;
                for (var p = 0; p < g.length; p++) g[p] instanceof c.Point ? (h = g[p].x, i = g[p].y) : (h = g[p], 
                i = g[p + 1], p < g.length - 1 && p++), a = a > h - o ? h - o : a, b = h + o > b ? h + o : b, 
                d = d > i - o ? i - o : d, e = i + o > e ? i + o : e;
            }
        } else a = 0, b = 0, d = 0, e = 0;
        var q = this.boundsPadding;
        this._localBounds.x = a - q, this._localBounds.width = b - a + 2 * q, this._localBounds.y = d - q, 
        this._localBounds.height = e - d + 2 * q;
    }, PIXI.Graphics.prototype._generateCachedSprite = function() {
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height); else {
            var b = new PIXI.CanvasBuffer(a.width, a.height), c = PIXI.Texture.fromCanvas(b.canvas);
            this._cachedSprite = new PIXI.Sprite(c), this._cachedSprite.buffer = b, this._cachedSprite.worldTransform = this.worldTransform;
        }
        this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), 
        this._cachedSprite.buffer.context.translate(-a.x, -a.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), 
        this._cachedSprite.alpha = this.alpha;
    }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
        var a = this._cachedSprite, b = a.texture, c = a.buffer.canvas;
        b.baseTexture.width = c.width, b.baseTexture.height = c.height, b.crop.width = b.frame.width = c.width, 
        b.crop.height = b.frame.height = c.height, a._width = c.width, a._height = c.height, 
        b.baseTexture.dirty();
    }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null;
    }, PIXI.Graphics.prototype.drawShape = function(a) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), 
        this.currentPath = null, a instanceof c.Polygon && (a = a.clone(), a.flatten());
        var b = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
        return this.graphicsData.push(b), b.type === PIXI.Graphics.POLY && (b.shape.closed = this.filling, 
        this.currentPath = b), this.dirty = !0, b;
    }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(a) {
            this._cacheAsBitmap = a, this._cacheAsBitmap ? this._generateCachedSprite() : (this.destroyCachedSprite(), 
            this.dirty = !0);
        }
    }), PIXI.GraphicsData = function(a, b, c, d, e, f, g) {
        this.lineWidth = a, this.lineColor = b, this.lineAlpha = c, this._lineTint = b, 
        this.fillColor = d, this.fillAlpha = e, this._fillTint = d, this.fill = f, this.shape = g, 
        this.type = g.type;
    }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
    }, c.Graphics = function(a, b, d) {
        void 0 === b && (b = 0), void 0 === d && (d = 0), this.type = c.GRAPHICS, this.physicsType = c.SPRITE, 
        PIXI.Graphics.call(this), c.Component.Core.init.call(this, a, b, d, "", null);
    }, c.Graphics.prototype = Object.create(PIXI.Graphics.prototype), c.Graphics.prototype.constructor = c.Graphics, 
    c.Component.Core.install.call(c.Graphics.prototype, [ "Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset" ]), 
    c.Graphics.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Graphics.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.Graphics.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Graphics.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.Graphics.prototype.preUpdate = function() {
        return this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.Graphics.prototype.destroy = function(a) {
        this.clear(), c.Component.Destroy.prototype.destroy.call(this, a);
    }, c.Graphics.prototype.drawTriangle = function(a, b) {
        void 0 === b && (b = !1);
        var d = new c.Polygon(a);
        if (b) {
            var e = new c.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y), f = new c.Point(a[1].x - a[0].x, a[1].y - a[0].y), g = new c.Point(a[1].x - a[2].x, a[1].y - a[2].y), h = g.cross(f);
            e.dot(h) > 0 && this.drawPolygon(d);
        } else this.drawPolygon(d);
    }, c.Graphics.prototype.drawTriangles = function(a, b, d) {
        void 0 === d && (d = !1);
        var e, f = new c.Point(), g = new c.Point(), h = new c.Point(), i = [];
        if (b) if (a[0] instanceof c.Point) for (e = 0; e < b.length / 3; e++) i.push(a[b[3 * e]]), 
        i.push(a[b[3 * e + 1]]), i.push(a[b[3 * e + 2]]), 3 === i.length && (this.drawTriangle(i, d), 
        i = []); else for (e = 0; e < b.length; e++) f.x = a[2 * b[e]], f.y = a[2 * b[e] + 1], 
        i.push(f.copyTo({})), 3 === i.length && (this.drawTriangle(i, d), i = []); else if (a[0] instanceof c.Point) for (e = 0; e < a.length / 3; e++) this.drawTriangle([ a[3 * e], a[3 * e + 1], a[3 * e + 2] ], d); else for (e = 0; e < a.length / 6; e++) f.x = a[6 * e + 0], 
        f.y = a[6 * e + 1], g.x = a[6 * e + 2], g.y = a[6 * e + 3], h.x = a[6 * e + 4], 
        h.y = a[6 * e + 5], this.drawTriangle([ f, g, h ], d);
    }, c.RenderTexture = function(a, b, d, e, f, g) {
        void 0 === e && (e = ""), void 0 === f && (f = c.scaleModes.DEFAULT), void 0 === g && (g = 1), 
        this.game = a, this.key = e, this.type = c.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix(), 
        PIXI.RenderTexture.call(this, b, d, this.game.renderer, f, g), this.render = c.RenderTexture.prototype.render;
    }, c.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), c.RenderTexture.prototype.constructor = c.RenderTexture, 
    c.RenderTexture.prototype.renderXY = function(a, b, c, d) {
        a.updateTransform(), this._tempMatrix.copyFrom(a.worldTransform), this._tempMatrix.tx = b, 
        this._tempMatrix.ty = c, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d);
    }, c.RenderTexture.prototype.renderRawXY = function(a, b, c, d) {
        this._tempMatrix.identity().translate(b, c), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d);
    }, c.RenderTexture.prototype.render = function(a, b, c) {
        this._tempMatrix.copyFrom(void 0 === b || null === b ? a.worldTransform : b), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, c) : this.renderCanvas(a, this._tempMatrix, c);
    }, c.Text = function(a, b, d, e, f) {
        b = b || 0, d = d || 0, e = void 0 === e || null === e ? "" : e.toString(), f = f || {}, 
        this.type = c.TEXT, this.physicsType = c.SPRITE, this.padding = new c.Point(), this.textBounds = null, 
        this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), 
        this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], 
        this.autoRound = !1, this._res = a.renderer.resolution, this._text = e, this._fontComponents = null, 
        this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, c.Sprite.call(this, a, b, d, PIXI.Texture.fromCanvas(this.canvas)), 
        this.setStyle(f), "" !== e && this.updateText();
    }, c.Text.prototype = Object.create(c.Sprite.prototype), c.Text.prototype.constructor = c.Text, 
    c.Text.prototype.preUpdate = function() {
        return this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.Text.prototype.update = function() {}, c.Text.prototype.destroy = function(a) {
        this.texture.destroy(!0), PIXI.CanvasPool.remove(this), c.Component.Destroy.prototype.destroy.call(this, a);
    }, c.Text.prototype.setShadow = function(a, b, c, d, e, f) {
        return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = "rgba(0, 0, 0, 1)"), 
        void 0 === d && (d = 0), void 0 === e && (e = !0), void 0 === f && (f = !0), this.style.shadowOffsetX = a, 
        this.style.shadowOffsetY = b, this.style.shadowColor = c, this.style.shadowBlur = d, 
        this.style.shadowStroke = e, this.style.shadowFill = f, this.dirty = !0, this;
    }, c.Text.prototype.setStyle = function(a) {
        a = a || {}, a.font = a.font || "bold 20pt Arial", a.backgroundColor = a.backgroundColor || null, 
        a.fill = a.fill || "black", a.align = a.align || "left", a.boundsAlignH = a.boundsAlignH || "left", 
        a.boundsAlignV = a.boundsAlignV || "top", a.stroke = a.stroke || "black", a.strokeThickness = a.strokeThickness || 0, 
        a.wordWrap = a.wordWrap || !1, a.wordWrapWidth = a.wordWrapWidth || 100, a.shadowOffsetX = a.shadowOffsetX || 0, 
        a.shadowOffsetY = a.shadowOffsetY || 0, a.shadowColor = a.shadowColor || "rgba(0,0,0,0)", 
        a.shadowBlur = a.shadowBlur || 0, a.tabs = a.tabs || 0;
        var b = this.fontToComponents(a.font);
        return a.fontStyle && (b.fontStyle = a.fontStyle), a.fontVariant && (b.fontVariant = a.fontVariant), 
        a.fontWeight && (b.fontWeight = a.fontWeight), a.fontSize && ("number" == typeof a.fontSize && (a.fontSize = a.fontSize + "px"), 
        b.fontSize = a.fontSize), this._fontComponents = b, a.font = this.componentsToFont(this._fontComponents), 
        this.style = a, this.dirty = !0, this;
    }, c.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
        var a = this.text;
        this.style.wordWrap && (a = this.runWordWrap(this.text));
        for (var b = a.split(/(?:\r\n|\r|\n)/), c = this.style.tabs, d = [], e = 0, f = this.determineFontProperties(this.style.font), g = 0; g < b.length; g++) {
            if (0 === c) var h = this.context.measureText(b[g]).width + this.style.strokeThickness + this.padding.x; else {
                var i = b[g].split(/(?:\t)/), h = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(c)) for (var j = 0, k = 0; k < i.length; k++) {
                    var l = Math.ceil(this.context.measureText(i[k]).width);
                    k > 0 && (j += c[k - 1]), h = j + l;
                } else for (var k = 0; k < i.length; k++) {
                    h += Math.ceil(this.context.measureText(i[k]).width);
                    var m = this.game.math.snapToCeil(h, c) - h;
                    h += m;
                }
            }
            d[g] = Math.ceil(h), e = Math.max(e, d[g]);
        }
        var n = e + this.style.strokeThickness;
        this.canvas.width = n * this._res;
        var o = f.fontSize + this.style.strokeThickness + this.padding.y, p = o * b.length, q = this._lineSpacing;
        if (0 > q && Math.abs(q) > o && (q = -o), 0 !== q) {
            var m = q * (b.length - 1);
            p += m;
        }
        this.canvas.height = p * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
        this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, 
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, 
        this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, 
        this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, 
        this.context.lineCap = "round", this.context.lineJoin = "round";
        var r, s;
        for (this._charCount = 0, g = 0; g < b.length; g++) r = this.style.strokeThickness / 2, 
        s = this.style.strokeThickness / 2 + g * o + f.ascent, g > 0 && (s += q * g), "right" === this.style.align ? r += e - d[g] : "center" === this.style.align && (r += (e - d[g]) / 2), 
        this.autoRound && (r = Math.round(r), s = Math.round(s)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(b[g], r, s) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 
        0 === c ? this.context.strokeText(b[g], r, s) : this.renderTabLine(b[g], r, s, !1)), 
        this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[g], r, s) : this.renderTabLine(b[g], r, s, !0)));
        this.updateTexture();
    }, c.Text.prototype.renderTabLine = function(a, b, c, d) {
        var e = a.split(/(?:\t)/), f = this.style.tabs, g = 0;
        if (Array.isArray(f)) for (var h = 0, i = 0; i < e.length; i++) i > 0 && (h += f[i - 1]), 
        g = b + h, d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c); else for (var i = 0; i < e.length; i++) {
            var j = Math.ceil(this.context.measureText(e[i]).width);
            g = this.game.math.snapToCeil(b, f), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c), 
            b = g + j;
        }
    }, c.Text.prototype.updateShadow = function(a) {
        a ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, 
        this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, 
        this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0);
    }, c.Text.prototype.updateLine = function(a, b, c) {
        for (var d = 0; d < a.length; d++) {
            var e = a[d];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var f = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]), 
                this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]), 
                this.context.font = this.componentsToFont(f);
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), 
            this.updateShadow(this.style.shadowStroke), this.context.strokeText(e, b, c)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), 
            this.updateShadow(this.style.shadowFill), this.context.fillText(e, b, c)), b += this.context.measureText(e).width, 
            this._charCount++;
        }
    }, c.Text.prototype.clearColors = function() {
        return this.colors = [], this.strokeColors = [], this.dirty = !0, this;
    }, c.Text.prototype.clearFontValues = function() {
        return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this;
    }, c.Text.prototype.addColor = function(a, b) {
        return this.colors[b] = a, this.dirty = !0, this;
    }, c.Text.prototype.addStrokeColor = function(a, b) {
        return this.strokeColors[b] = a, this.dirty = !0, this;
    }, c.Text.prototype.addFontStyle = function(a, b) {
        return this.fontStyles[b] = a, this.dirty = !0, this;
    }, c.Text.prototype.addFontWeight = function(a, b) {
        return this.fontWeights[b] = a, this.dirty = !0, this;
    }, c.Text.prototype.runWordWrap = function(a) {
        for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
            for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
                var h = this.context.measureText(f[g]).width, i = h + this.context.measureText(" ").width;
                i > e ? (g > 0 && (b += "\n"), b += f[g] + " ", e = this.style.wordWrapWidth - h) : (e -= i, 
                b += f[g] + " ");
            }
            d < c.length - 1 && (b += "\n");
        }
        return b;
    }, c.Text.prototype.updateFont = function(a) {
        var b = this.componentsToFont(a);
        this.style.font !== b && (this.style.font = b, this.dirty = !0, this.parent && this.updateTransform());
    }, c.Text.prototype.fontToComponents = function(a) {
        var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        return b ? {
            font: a,
            fontStyle: b[1] || "normal",
            fontVariant: b[2] || "normal",
            fontWeight: b[3] || "normal",
            fontSize: b[4] || "medium",
            fontFamily: b[5]
        } : (console.warn("Phaser.Text - unparsable CSS font: " + a), {
            font: a
        });
    }, c.Text.prototype.componentsToFont = function(a) {
        var b, c = [];
        return b = a.fontStyle, b && "normal" !== b && c.push(b), b = a.fontVariant, b && "normal" !== b && c.push(b), 
        b = a.fontWeight, b && "normal" !== b && c.push(b), b = a.fontSize, b && "medium" !== b && c.push(b), 
        b = a.fontFamily, b && c.push(b), c.length || c.push(a.font), c.join(" ");
    }, c.Text.prototype.setText = function(a) {
        return this.text = a.toString() || "", this.dirty = !0, this;
    }, c.Text.prototype.parseList = function(a) {
        if (!Array.isArray(a)) return this;
        for (var b = "", c = 0; c < a.length; c++) Array.isArray(a[c]) ? (b += a[c].join("	"), 
        c < a.length - 1 && (b += "\n")) : (b += a[c], c < a.length - 1 && (b += "	"));
        return this.text = b, this.dirty = !0, this;
    }, c.Text.prototype.setTextBounds = function(a, b, d, e) {
        return void 0 === a ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(a, b, d, e) : this.textBounds = new c.Rectangle(a, b, d, e), 
        this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)), this.updateTexture(), 
        this;
    }, c.Text.prototype.updateTexture = function() {
        var a = this.texture.baseTexture, b = this.texture.crop, c = this.texture.frame, d = this.canvas.width, e = this.canvas.height;
        if (a.width = d, a.height = e, b.width = d, b.height = e, c.width = d, c.height = e, 
        this.texture.width = d, this.texture.height = e, this._width = d, this._height = e, 
        this.textBounds) {
            var f = this.textBounds.x, g = this.textBounds.y;
            "right" === this.style.boundsAlignH ? f += this.textBounds.width - this.canvas.width : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / 2), 
            "bottom" === this.style.boundsAlignV ? g += this.textBounds.height - this.canvas.height : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / 2), 
            this.pivot.x = -f, this.pivot.y = -g;
        }
        this.renderable = 0 !== d && 0 !== e, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty();
    }, c.Text.prototype._renderWebGL = function(a) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, a);
    }, c.Text.prototype._renderCanvas = function(a) {
        this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, a);
    }, c.Text.prototype.determineFontProperties = function(a) {
        var b = c.Text.fontPropertiesCache[a];
        if (!b) {
            b = {};
            var d = c.Text.fontPropertiesCanvas, e = c.Text.fontPropertiesContext;
            e.font = a;
            var f = Math.ceil(e.measureText("|MÉq").width), g = Math.ceil(e.measureText("|MÉq").width), h = 2 * g;
            if (g = 1.4 * g | 0, d.width = f, d.height = h, e.fillStyle = "#f00", e.fillRect(0, 0, f, h), 
            e.font = a, e.textBaseline = "alphabetic", e.fillStyle = "#000", e.fillText("|MÉq", 0, g), 
            !e.getImageData(0, 0, f, h)) return b.ascent = g, b.descent = g + 6, b.fontSize = b.ascent + b.descent, 
            c.Text.fontPropertiesCache[a] = b, b;
            var i, j, k = e.getImageData(0, 0, f, h).data, l = k.length, m = 4 * f, n = 0, o = !1;
            for (i = 0; g > i; i++) {
                for (j = 0; m > j; j += 4) if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n += m;
            }
            for (b.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--) {
                for (j = 0; m > j; j += 4) if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n -= m;
            }
            b.descent = i - g, b.descent += 6, b.fontSize = b.ascent + b.descent, c.Text.fontPropertiesCache[a] = b;
        }
        return b;
    }, c.Text.prototype.getBounds = function(a) {
        return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, a);
    }, Object.defineProperty(c.Text.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "", this.dirty = !0, this.parent && this.updateTransform());
        }
    }), Object.defineProperty(c.Text.prototype, "cssFont", {
        get: function() {
            return this.componentsToFont(this._fontComponents);
        },
        set: function(a) {
            a = a || "bold 20pt Arial", this._fontComponents = this.fontToComponents(a), this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "font", {
        get: function() {
            return this._fontComponents.fontFamily;
        },
        set: function(a) {
            a = a || "Arial", a = a.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"), 
            this._fontComponents.fontFamily = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "fontSize", {
        get: function() {
            var a = this._fontComponents.fontSize;
            return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a;
        },
        set: function(a) {
            a = a || "0", "number" == typeof a && (a += "px"), this._fontComponents.fontSize = a, 
            this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontComponents.fontWeight || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontWeight = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "fontStyle", {
        get: function() {
            return this._fontComponents.fontStyle || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontStyle = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "fontVariant", {
        get: function() {
            return this._fontComponents.fontVariant || "normal";
        },
        set: function(a) {
            a = a || "normal", this._fontComponents.fontVariant = a, this.updateFont(this._fontComponents);
        }
    }), Object.defineProperty(c.Text.prototype, "fill", {
        get: function() {
            return this.style.fill;
        },
        set: function(a) {
            a !== this.style.fill && (this.style.fill = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "align", {
        get: function() {
            return this.style.align;
        },
        set: function(a) {
            a !== this.style.align && (this.style.align = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "resolution", {
        get: function() {
            return this._res;
        },
        set: function(a) {
            a !== this._res && (this._res = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "tabs", {
        get: function() {
            return this.style.tabs;
        },
        set: function(a) {
            a !== this.style.tabs && (this.style.tabs = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "boundsAlignH", {
        get: function() {
            return this.style.boundsAlignH;
        },
        set: function(a) {
            a !== this.style.boundsAlignH && (this.style.boundsAlignH = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "boundsAlignV", {
        get: function() {
            return this.style.boundsAlignV;
        },
        set: function(a) {
            a !== this.style.boundsAlignV && (this.style.boundsAlignV = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke;
        },
        set: function(a) {
            a !== this.style.stroke && (this.style.stroke = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness;
        },
        set: function(a) {
            a !== this.style.strokeThickness && (this.style.strokeThickness = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap;
        },
        set: function(a) {
            a !== this.style.wordWrap && (this.style.wordWrap = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth;
        },
        set: function(a) {
            a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing;
        },
        set: function(a) {
            a !== this._lineSpacing && (this._lineSpacing = parseFloat(a), this.dirty = !0, 
            this.parent && this.updateTransform());
        }
    }), Object.defineProperty(c.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX;
        },
        set: function(a) {
            a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY;
        },
        set: function(a) {
            a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor;
        },
        set: function(a) {
            a !== this.style.shadowColor && (this.style.shadowColor = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur;
        },
        set: function(a) {
            a !== this.style.shadowBlur && (this.style.shadowBlur = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "shadowStroke", {
        get: function() {
            return this.style.shadowStroke;
        },
        set: function(a) {
            a !== this.style.shadowStroke && (this.style.shadowStroke = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "shadowFill", {
        get: function() {
            return this.style.shadowFill;
        },
        set: function(a) {
            a !== this.style.shadowFill && (this.style.shadowFill = a, this.dirty = !0);
        }
    }), Object.defineProperty(c.Text.prototype, "width", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width;
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(c.Text.prototype, "height", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height;
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), c.Text.fontPropertiesCache = {}, c.Text.fontPropertiesCanvas = PIXI.CanvasPool.create(c.Text.fontPropertiesCanvas), 
    c.Text.fontPropertiesContext = c.Text.fontPropertiesCanvas.getContext("2d"), c.BitmapText = function(a, b, d, e, f, g, h) {
        b = b || 0, d = d || 0, e = e || "", f = f || "", g = g || 32, h = h || "left", 
        PIXI.DisplayObjectContainer.call(this), this.type = c.BITMAPTEXT, this.physicsType = c.SPRITE, 
        this.textWidth = 0, this.textHeight = 0, this.anchor = new c.Point(), this._prevAnchor = new c.Point(), 
        this._glyphs = [], this._maxWidth = 0, this._text = f, this._data = a.cache.getBitmapFont(e), 
        this._font = e, this._fontSize = g, this._align = h, this._tint = 16777215, this.updateText(), 
        this.dirty = !1, c.Component.Core.init.call(this, a, b, d, "", null);
    }, c.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), 
    c.BitmapText.prototype.constructor = c.BitmapText, c.Component.Core.install.call(c.BitmapText.prototype, [ "Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset" ]), 
    c.BitmapText.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.BitmapText.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.BitmapText.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.BitmapText.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.BitmapText.prototype.preUpdate = function() {
        return this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.BitmapText.prototype.postUpdate = function() {
        c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), 
        this.body && this.body.type === c.Physics.ARCADE && (this.textWidth !== this.body.sourceWidth || this.textHeight !== this.body.sourceHeight) && this.body.setSize(this.textWidth, this.textHeight);
    }, c.BitmapText.prototype.setText = function(a) {
        this.text = a;
    }, c.BitmapText.prototype.scanLine = function(a, b, c) {
        for (var d = 0, e = 0, f = -1, g = null, h = this._maxWidth > 0 ? this._maxWidth : null, i = [], j = 0; j < c.length; j++) {
            var k = j === c.length - 1 ? !0 : !1;
            if (/(?:\r\n|\r|\n)/.test(c.charAt(j))) return {
                width: e,
                text: c.substr(0, j),
                end: k,
                chars: i
            };
            var l = c.charCodeAt(j), m = a.chars[l], n = 0;
            if (m) {
                var o = g && m.kerning[g] ? m.kerning[g] : 0;
                if (f = /(\s)/.test(c.charAt(j)) ? j : f, n = (o + m.texture.width + m.xOffset) * b, 
                h && e + n >= h && f > -1) return {
                    width: e,
                    text: c.substr(0, j - (j - f)),
                    end: k,
                    chars: i
                };
                e += m.xAdvance * b, i.push(d + m.xOffset * b), d += m.xAdvance * b, g = l;
            }
        }
        return {
            width: e,
            text: c,
            end: k,
            chars: i
        };
    }, c.BitmapText.prototype.updateText = function() {
        var a = this._data.font;
        if (a) {
            var b = this.text, c = this._fontSize / a.size, d = [], e = 0;
            this.textWidth = 0;
            do {
                var f = this.scanLine(a, c, b);
                f.y = e, d.push(f), f.width > this.textWidth && (this.textWidth = f.width), e += a.lineHeight * c, 
                b = b.substr(f.text.length + 1);
            } while (f.end === !1);
            this.textHeight = e;
            for (var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++) {
                var f = d[k];
                "right" === this._align ? h = this.textWidth - f.width : "center" === this._align && (h = (this.textWidth - f.width) / 2);
                for (var l = 0; l < f.text.length; l++) {
                    var m = f.text.charCodeAt(l), n = a.chars[m], o = this._glyphs[g];
                    o ? o.texture = n.texture : (o = new PIXI.Sprite(n.texture), o.name = f.text[l], 
                    this._glyphs.push(o)), o.position.x = f.chars[l] + h - i, o.position.y = f.y + n.yOffset * c - j, 
                    o.scale.set(c), o.tint = this.tint, o.texture.requiresReTint = !0, o.parent || this.addChild(o), 
                    g++;
                }
            }
            for (k = g; k < this._glyphs.length; k++) this.removeChild(this._glyphs[k]);
        }
    }, c.BitmapText.prototype.purgeGlyphs = function() {
        for (var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++) this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]);
        return this._glyphs = [], this._glyphs = b, this.updateText(), a - b.length;
    }, c.BitmapText.prototype.updateTransform = function() {
        (this.dirty || !this.anchor.equals(this._prevAnchor)) && (this.updateText(), this.dirty = !1, 
        this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    }, Object.defineProperty(c.BitmapText.prototype, "align", {
        get: function() {
            return this._align;
        },
        set: function(a) {
            a === this._align || "left" !== a && "center" !== a && "right" !== a || (this._align = a, 
            this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint;
        },
        set: function(a) {
            a !== this._tint && (this._tint = a, this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(a) {
            a !== this._font && (this._font = a.trim(), this._data = this.game.cache.getBitmapFont(this._font), 
            this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(a) {
            a = parseInt(a, 10), a !== this._fontSize && a > 0 && (this._fontSize = a, this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "", this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "maxWidth", {
        get: function() {
            return this._maxWidth;
        },
        set: function(a) {
            a !== this._maxWidth && (this._maxWidth = a, this.updateText());
        }
    }), Object.defineProperty(c.BitmapText.prototype, "smoothed", {
        get: function() {
            return !this._data.base.scaleMode;
        },
        set: function(a) {
            this._data.base.scaleMode = a ? 0 : 1;
        }
    }), c.RetroFont = function(a, b, d, e, f, g, h, i, j, k) {
        if (!a.cache.checkImageKey(b)) return !1;
        (void 0 === g || null === g) && (g = a.cache.getImage(b).width / d), this.characterWidth = d, 
        this.characterHeight = e, this.characterSpacingX = h || 0, this.characterSpacingY = i || 0, 
        this.characterPerRow = g, this.offsetX = j || 0, this.offsetY = k || 0, this.align = "left", 
        this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, 
        this.fixedWidth = 0, this.fontSet = a.cache.getImage(b), this._text = "", this.grabData = [], 
        this.frameData = new c.FrameData();
        for (var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++) {
            var p = this.frameData.addFrame(new c.Frame(o, l, m, this.characterWidth, this.characterHeight));
            this.grabData[f.charCodeAt(o)] = p.index, n++, n === this.characterPerRow ? (n = 0, 
            l = this.offsetX, m += this.characterHeight + this.characterSpacingY) : l += this.characterWidth + this.characterSpacingX;
        }
        a.cache.updateFrameData(b, this.frameData), this.stamp = new c.Image(a, 0, 0, b, 0), 
        c.RenderTexture.call(this, a, 100, 100, "", c.scaleModes.NEAREST), this.type = c.RETROFONT;
    }, c.RetroFont.prototype = Object.create(c.RenderTexture.prototype), c.RetroFont.prototype.constructor = c.RetroFont, 
    c.RetroFont.ALIGN_LEFT = "left", c.RetroFont.ALIGN_RIGHT = "right", c.RetroFont.ALIGN_CENTER = "center", 
    c.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", 
    c.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", 
    c.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", c.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", 
    c.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", c.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", 
    c.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", c.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", 
    c.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", c.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 
    c.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", c.RetroFont.prototype.setFixedWidth = function(a, b) {
        void 0 === b && (b = "left"), this.fixedWidth = a, this.align = b;
    }, c.RetroFont.prototype.setText = function(a, b, c, d, e, f) {
        this.multiLine = b || !1, this.customSpacingX = c || 0, this.customSpacingY = d || 0, 
        this.align = e || "left", this.autoUpperCase = f ? !1 : !0, a.length > 0 && (this.text = a);
    }, c.RetroFont.prototype.buildRetroFontText = function() {
        var a = 0, b = 0;
        if (this.clear(), this.multiLine) {
            var d = this._text.split("\n");
            this.fixedWidth > 0 ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
            for (var e = 0; e < d.length; e++) a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - d[e].length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2, 
            a += this.customSpacingX / 2), 0 > a && (a = 0), this.pasteLine(d[e], a, b, this.customSpacingX), 
            b += this.characterHeight + this.customSpacingY;
        } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), 
        a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, 
        a += this.customSpacingX / 2), 0 > a && (a = 0), this.pasteLine(this._text, a, 0, this.customSpacingX);
        this.requiresReTint = !0;
    }, c.RetroFont.prototype.pasteLine = function(a, b, c, d) {
        for (var e = 0; e < a.length; e++) if (" " === a.charAt(e)) b += this.characterWidth + d; else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)], 
        this.renderXY(this.stamp, b, c, !1), b += this.characterWidth + d, b > this.width)) break;
    }, c.RetroFont.prototype.getLongestLine = function() {
        var a = 0;
        if (this._text.length > 0) for (var b = this._text.split("\n"), c = 0; c < b.length; c++) b[c].length > a && (a = b[c].length);
        return a;
    }, c.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
        for (var b = "", c = 0; c < this._text.length; c++) {
            var d = this._text[c], e = d.charCodeAt(0);
            (this.grabData[e] >= 0 || !a && "\n" === d) && (b = b.concat(d));
        }
        return b;
    }, c.RetroFont.prototype.updateOffset = function(a, b) {
        if (this.offsetX !== a || this.offsetY !== b) {
            for (var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--; ) e[f].x += c, 
            e[f].y += d;
            this.buildRetroFontText();
        }
    }, Object.defineProperty(c.RetroFont.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(a) {
            var b;
            b = this.autoUpperCase ? a.toUpperCase() : a, b !== this._text && (this._text = b, 
            this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText());
        }
    }), Object.defineProperty(c.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed;
        },
        set: function(a) {
            this.stamp.smoothed = a, this.buildRetroFontText();
        }
    }), c.Rope = function(a, b, d, e, f, g) {
        this.points = [], this.points = g, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, 
        b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.ROPE, this._scroll = new c.Point(), 
        PIXI.Rope.call(this, PIXI.TextureCache.__default, this.points), c.Component.Core.init.call(this, a, b, d, e, f);
    }, c.Rope.prototype = Object.create(PIXI.Rope.prototype), c.Rope.prototype.constructor = c.Rope, 
    c.Component.Core.install.call(c.Rope.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed" ]), 
    c.Rope.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Rope.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.Rope.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Rope.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.Rope.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
        this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.Rope.prototype.update = function() {
        this._hasUpdateAnimation && this.updateAnimation.call(this);
    }, c.Rope.prototype.reset = function(a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, 
        this.tilePosition.y = 0, this;
    }, Object.defineProperty(c.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(a) {
            a && "function" == typeof a ? (this._hasUpdateAnimation = !0, this._updateAnimation = a) : (this._hasUpdateAnimation = !1, 
            this._updateAnimation = null);
        }
    }), Object.defineProperty(c.Rope.prototype, "segments", {
        get: function() {
            for (var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++) a = 4 * k, 
            b = this.vertices[a] * this.scale.x, d = this.vertices[a + 1] * this.scale.y, e = this.vertices[a + 4] * this.scale.x, 
            f = this.vertices[a + 3] * this.scale.y, g = c.Math.difference(b, e), h = c.Math.difference(d, f), 
            b += this.world.x, d += this.world.y, i = new c.Rectangle(b, d, g, h), j.push(i);
            return j;
        }
    }), c.TileSprite = function(a, b, d, e, f, g, h) {
        b = b || 0, d = d || 0, e = e || 256, f = f || 256, g = g || null, h = h || null, 
        this.type = c.TILESPRITE, this.physicsType = c.SPRITE, this._scroll = new c.Point();
        var i = a.cache.getImage("__default", !0);
        PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f), c.Component.Core.init.call(this, a, b, d, g, h);
    }, c.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), c.TileSprite.prototype.constructor = c.TileSprite, 
    c.Component.Core.install.call(c.TileSprite.prototype, [ "Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed" ]), 
    c.TileSprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.TileSprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, 
    c.TileSprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.TileSprite.prototype.preUpdateCore = c.Component.Core.preUpdate, 
    c.TileSprite.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), 
        this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld() ? this.preUpdateCore() : !1;
    }, c.TileSprite.prototype.autoScroll = function(a, b) {
        this._scroll.set(a, b);
    }, c.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    }, c.TileSprite.prototype.destroy = function(a) {
        c.Component.Destroy.prototype.destroy.call(this, a), PIXI.TilingSprite.prototype.destroy.call(this);
    }, c.TileSprite.prototype.reset = function(a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, 
        this.tilePosition.y = 0, this;
    }, c.Device = function() {
        this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, 
        this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, 
        this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, 
        this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, 
        this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, 
        this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, 
        this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, 
        this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, 
        this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, 
        this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.mobileSafari = !1, 
        this.midori = !1, this.opera = !1, this.safari = !1, this.webApp = !1, this.silk = !1, 
        this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, 
        this.wav = !1, this.m4a = !1, this.webm = !1, this.oggVideo = !1, this.h264Video = !1, 
        this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, 
        this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, 
        this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", 
        this.cancelFullscreen = "", this.fullscreenKeyboard = !1;
    }, c.Device = new c.Device(), c.Device.onInitialized = new c.Signal(), c.Device.whenReady = function(a, b, c) {
        var d = this._readyCheck;
        if (this.deviceReadyAt || !d) a.call(b, this); else if (d._monitor || c) d._queue = d._queue || [], 
        d._queue.push([ a, b ]); else {
            d._monitor = d.bind(this), d._queue = d._queue || [], d._queue.push([ a, b ]);
            var e = "undefined" != typeof window.cordova, f = navigator.isCocoonJS;
            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(d._monitor, 0) : e && !f ? document.addEventListener("deviceready", d._monitor, !1) : (document.addEventListener("DOMContentLoaded", d._monitor, !1), 
            window.addEventListener("load", d._monitor, !1));
        }
    }, c.Device._readyCheck = function() {
        var a = this._readyCheck;
        if (document.body) {
            if (!this.deviceReadyAt) {
                this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", a._monitor), 
                document.removeEventListener("DOMContentLoaded", a._monitor), window.removeEventListener("load", a._monitor), 
                this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                for (var b; b = a._queue.shift(); ) {
                    var c = b[0], d = b[1];
                    c.call(d, this);
                }
                this._readyCheck = null, this._initialize = null, this.onInitialized = null;
            }
        } else window.setTimeout(a._monitor, 20);
    }, c.Device._initialize = function() {
        function a() {
            var a = navigator.userAgent;
            /Playstation Vita/.test(a) ? l.vita = !0 : /Kindle/.test(a) || /\bKF[A-Z][A-Z]+/.test(a) || /Silk.*Mobile Safari/.test(a) ? l.kindle = !0 : /Android/.test(a) ? l.android = !0 : /CrOS/.test(a) ? l.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? l.iOS = !0 : /Linux/.test(a) ? l.linux = !0 : /Mac OS/.test(a) ? l.macOS = !0 : /Windows/.test(a) && (l.windows = !0), 
            (/Windows Phone/i.test(a) || /IEMobile/i.test(a)) && (l.android = !1, l.iOS = !1, 
            l.macOS = !1, l.windows = !0, l.windowsPhone = !0);
            var b = /Silk/.test(a);
            (l.windows || l.macOS || l.linux && !b || l.chromeOS) && (l.desktop = !0), (l.windowsPhone || /Windows NT/i.test(a) && /Touch/i.test(a)) && (l.desktop = !1);
        }
        function b() {
            l.canvas = !!window.CanvasRenderingContext2D || l.cocoonJS;
            try {
                l.localStorage = !!localStorage.getItem;
            } catch (a) {
                l.localStorage = !1;
            }
            l.file = !!(window.File && window.FileReader && window.FileList && window.Blob), 
            l.fileSystem = !!window.requestFileSystem, l.webGL = function() {
                try {
                    var a = document.createElement("canvas");
                    return a.screencanvas = !1, !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
                } catch (b) {
                    return !1;
                }
            }(), l.webGL = !!l.webGL, l.worker = !!window.Worker, l.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, 
            l.quirksMode = "CSS1Compat" === document.compatMode ? !1 : !0, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, 
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, l.getUserMedia = l.getUserMedia && !!navigator.getUserMedia && !!window.URL, 
            l.firefox && l.firefoxVersion < 21 && (l.getUserMedia = !1), !l.iOS && (l.ie || l.firefox || l.chrome) && (l.canvasBitBltShift = !0), 
            (l.safari || l.mobileSafari) && (l.canvasBitBltShift = !1);
        }
        function c() {
            ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (l.touch = !0), 
            (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (l.mspointer = !0), 
            l.cocoonJS || ("onwheel" in window || l.ie && "WheelEvent" in window ? l.wheelEvent = "wheel" : "onmousewheel" in window ? l.wheelEvent = "mousewheel" : l.firefox && "MouseScrollEvent" in window && (l.wheelEvent = "DOMMouseScroll"));
        }
        function d() {
            for (var a = [ "requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen" ], b = document.createElement("div"), c = 0; c < a.length; c++) if (b[a[c]]) {
                l.fullscreen = !0, l.requestFullscreen = a[c];
                break;
            }
            var d = [ "cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen" ];
            if (l.fullscreen) for (var c = 0; c < d.length; c++) if (document[d[c]]) {
                l.cancelFullscreen = d[c];
                break;
            }
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (l.fullscreenKeyboard = !0);
        }
        function e() {
            var a = navigator.userAgent;
            if (/Arora/.test(a) ? l.arora = !0 : /Chrome\/(\d+)/.test(a) && !l.windowsPhone ? (l.chrome = !0, 
            l.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(a) ? l.epiphany = !0 : /Firefox\D+(\d+)/.test(a) ? (l.firefox = !0, 
            l.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(a) && l.iOS ? l.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (l.ie = !0, 
            l.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? l.midori = !0 : /Opera/.test(a) ? l.opera = !0 : /Safari/.test(a) && !l.windowsPhone ? l.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && (l.ie = !0, 
            l.trident = !0, l.tridentVersion = parseInt(RegExp.$1, 10), l.ieVersion = parseInt(RegExp.$3, 10)), 
            /Silk/.test(a) && (l.silk = !0), navigator.standalone && (l.webApp = !0), "undefined" != typeof window.cordova && (l.cordova = !0), 
            "undefined" != typeof process && "undefined" != typeof require && (l.node = !0), 
            l.node && "object" == typeof process.versions && (l.nodeWebkit = !!process.versions["node-webkit"], 
            l.electron = !!process.versions.electron), navigator.isCocoonJS && (l.cocoonJS = !0), 
            l.cocoonJS) try {
                l.cocoonJSApp = "undefined" != typeof CocoonJS;
            } catch (b) {
                l.cocoonJSApp = !1;
            }
            "undefined" != typeof window.ejecta && (l.ejecta = !0), /Crosswalk/.test(a) && (l.crosswalk = !0);
        }
        function f() {
            var a = document.createElement("video"), b = !1;
            try {
                (b = !!a.canPlayType) && (a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (l.oggVideo = !0), 
                a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.h264Video = !0, 
                l.mp4Video = !0), a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (l.webmVideo = !0), 
                a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (l.vp9Video = !0), 
                a.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.hlsVideo = !0));
            } catch (c) {}
        }
        function g() {
            l.audioData = !!window.Audio, l.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
            var a = document.createElement("audio"), b = !1;
            try {
                (b = !!a.canPlayType) && (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (l.ogg = !0), 
                (a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || a.canPlayType("audio/opus;").replace(/^no$/, "")) && (l.opus = !0), 
                a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (l.mp3 = !0), a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (l.wav = !0), 
                (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) && (l.m4a = !0), 
                a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (l.webm = !0));
            } catch (c) {}
        }
        function h() {
            l.pixelRatio = window.devicePixelRatio || 1, l.iPhone = -1 != navigator.userAgent.toLowerCase().indexOf("iphone"), 
            l.iPhone4 = 2 == l.pixelRatio && l.iPhone, l.iPad = -1 != navigator.userAgent.toLowerCase().indexOf("ipad"), 
            l.typedArray = "undefined" != typeof Int8Array ? !0 : !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (l.littleEndian = i(), 
            l.LITTLE_ENDIAN = l.littleEndian), l.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== l.littleEndian && j(), 
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, 
            navigator.vibrate && (l.vibration = !0);
        }
        function i() {
            var a = new ArrayBuffer(4), b = new Uint8Array(a), c = new Uint32Array(a);
            return b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 == c[0] ? !0 : 2712847316 == c[0] ? !1 : null;
        }
        function j() {
            if (void 0 === Uint8ClampedArray) return !1;
            var a = PIXI.CanvasPool.create(this, 1, 1), b = a.getContext("2d");
            if (!b) return !1;
            var c = b.createImageData(1, 1);
            return PIXI.CanvasPool.remove(this), c.data instanceof Uint8ClampedArray;
        }
        function k() {
            var a, b = document.createElement("p"), c = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(b, null);
            for (var d in c) void 0 !== b.style[d] && (b.style[d] = "translate3d(1px,1px,1px)", 
            a = window.getComputedStyle(b).getPropertyValue(c[d]));
            document.body.removeChild(b), l.css3D = void 0 !== a && a.length > 0 && "none" !== a;
        }
        var l = this;
        a(), g(), f(), e(), k(), h(), b(), d(), c();
    }, c.Device.canPlayAudio = function(a) {
        return "mp3" === a && this.mp3 ? !0 : "ogg" === a && (this.ogg || this.opus) ? !0 : "m4a" === a && this.m4a ? !0 : "opus" === a && this.opus ? !0 : "wav" === a && this.wav ? !0 : "webm" === a && this.webm ? !0 : !1;
    }, c.Device.canPlayVideo = function(a) {
        return "webm" === a && (this.webmVideo || this.vp9Video) ? !0 : "mp4" === a && (this.mp4Video || this.h264Video) ? !0 : "ogg" !== a && "ogv" !== a || !this.oggVideo ? "mpeg" === a && this.hlsVideo ? !0 : !1 : !0;
    }, c.Device.isConsoleOpen = function() {
        return window.console && window.console.firebug ? !0 : window.console && (console.profile(), 
        console.profileEnd(), console.clear && console.clear(), console.profiles) ? console.profiles.length > 0 : !1;
    }, c.Device.isAndroidStockBrowser = function() {
        var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return a && a[1] < 537;
    }, c.DOM = {
        getOffset: function(a, b) {
            b = b || new c.Point();
            var d = a.getBoundingClientRect(), e = c.DOM.scrollY, f = c.DOM.scrollX, g = document.documentElement.clientTop, h = document.documentElement.clientLeft;
            return b.x = d.left + f - h, b.y = d.top + e - g, b;
        },
        getBounds: function(a, b) {
            return void 0 === b && (b = 0), a = a && !a.nodeType ? a[0] : a, a && 1 === a.nodeType ? this.calibrate(a.getBoundingClientRect(), b) : !1;
        },
        calibrate: function(a, b) {
            b = +b || 0;
            var c = {
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            return c.width = (c.right = a.right + b) - (c.left = a.left - b), c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b), 
            c;
        },
        getAspectRatio: function(a) {
            a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
            var b = a.width, c = a.height;
            return "function" == typeof b && (b = b.call(a)), "function" == typeof c && (c = c.call(a)), 
            b / c;
        },
        inLayoutViewport: function(a, b) {
            var c = this.getBounds(a, b);
            return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height;
        },
        getScreenOrientation: function(a) {
            var b = window.screen, c = b.orientation || b.mozOrientation || b.msOrientation;
            if (c && "string" == typeof c.type) return c.type;
            if ("string" == typeof c) return c;
            var d = "portrait-primary", e = "landscape-primary";
            if ("screen" === a) return b.height > b.width ? d : e;
            if ("viewport" === a) return this.visualBounds.height > this.visualBounds.width ? d : e;
            if ("window.orientation" === a && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? d : e;
            if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) return d;
                if (window.matchMedia("(orientation: landscape)").matches) return e;
            }
            return this.visualBounds.height > this.visualBounds.width ? d : e;
        },
        visualBounds: new c.Rectangle(),
        layoutBounds: new c.Rectangle(),
        documentBounds: new c.Rectangle()
    }, c.Device.whenReady(function(a) {
        var b = window && "pageXOffset" in window ? function() {
            return window.pageXOffset;
        } : function() {
            return document.documentElement.scrollLeft;
        }, d = window && "pageYOffset" in window ? function() {
            return window.pageYOffset;
        } : function() {
            return document.documentElement.scrollTop;
        };
        Object.defineProperty(c.DOM, "scrollX", {
            get: b
        }), Object.defineProperty(c.DOM, "scrollY", {
            get: d
        }), Object.defineProperty(c.DOM.visualBounds, "x", {
            get: b
        }), Object.defineProperty(c.DOM.visualBounds, "y", {
            get: d
        }), Object.defineProperty(c.DOM.layoutBounds, "x", {
            value: 0
        }), Object.defineProperty(c.DOM.layoutBounds, "y", {
            value: 0
        });
        var e = a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
        if (e) {
            var f = function() {
                return Math.max(window.innerWidth, document.documentElement.clientWidth);
            }, g = function() {
                return Math.max(window.innerHeight, document.documentElement.clientHeight);
            };
            Object.defineProperty(c.DOM.visualBounds, "width", {
                get: f
            }), Object.defineProperty(c.DOM.visualBounds, "height", {
                get: g
            }), Object.defineProperty(c.DOM.layoutBounds, "width", {
                get: f
            }), Object.defineProperty(c.DOM.layoutBounds, "height", {
                get: g
            });
        } else Object.defineProperty(c.DOM.visualBounds, "width", {
            get: function() {
                return window.innerWidth;
            }
        }), Object.defineProperty(c.DOM.visualBounds, "height", {
            get: function() {
                return window.innerHeight;
            }
        }), Object.defineProperty(c.DOM.layoutBounds, "width", {
            get: function() {
                var a = document.documentElement.clientWidth, b = window.innerWidth;
                return b > a ? b : a;
            }
        }), Object.defineProperty(c.DOM.layoutBounds, "height", {
            get: function() {
                var a = document.documentElement.clientHeight, b = window.innerHeight;
                return b > a ? b : a;
            }
        });
        Object.defineProperty(c.DOM.documentBounds, "x", {
            value: 0
        }), Object.defineProperty(c.DOM.documentBounds, "y", {
            value: 0
        }), Object.defineProperty(c.DOM.documentBounds, "width", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth);
            }
        }), Object.defineProperty(c.DOM.documentBounds, "height", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight);
            }
        });
    }, null, !0), c.Canvas = {
        create: function(a, b, c, d, e) {
            if (b = b || 256, c = c || 256, void 0 === e) var f = PIXI.CanvasPool.create(a, b, c); else var f = document.createElement("canvas");
            return "string" == typeof d && "" !== d && (f.id = d), f.width = b, f.height = c, 
            f.style.display = "block", f;
        },
        setBackgroundColor: function(a, b) {
            return b = b || "rgb(0,0,0)", a.style.backgroundColor = b, a;
        },
        setTouchAction: function(a, b) {
            return b = b || "none", a.style.msTouchAction = b, a.style["ms-touch-action"] = b, 
            a.style["touch-action"] = b, a;
        },
        setUserSelect: function(a, b) {
            return b = b || "none", a.style["-webkit-touch-callout"] = b, a.style["-webkit-user-select"] = b, 
            a.style["-khtml-user-select"] = b, a.style["-moz-user-select"] = b, a.style["-ms-user-select"] = b, 
            a.style["user-select"] = b, a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", 
            a;
        },
        addToDOM: function(a, b, c) {
            var d;
            return void 0 === c && (c = !0), b && ("string" == typeof b ? d = document.getElementById(b) : "object" == typeof b && 1 === b.nodeType && (d = b)), 
            d || (d = document.body), c && d.style && (d.style.overflow = "hidden"), d.appendChild(a), 
            a;
        },
        removeFromDOM: function(a) {
            a.parentNode && a.parentNode.removeChild(a);
        },
        setTransform: function(a, b, c, d, e, f, g) {
            return a.setTransform(d, f, g, e, b, c), a;
        },
        setSmoothingEnabled: function(a, b) {
            var c = [ "i", "mozI", "oI", "webkitI", "msI" ];
            for (var d in c) {
                var e = c[d] + "mageSmoothingEnabled";
                if (e in a) return a[e] = b, a;
            }
            return a;
        },
        getSmoothingEnabled: function(a) {
            return a.imageSmoothingEnabled || a.mozImageSmoothingEnabled || a.oImageSmoothingEnabled || a.webkitImageSmoothingEnabled || a.msImageSmoothingEnabled;
        },
        setImageRenderingCrisp: function(a) {
            return a.style["image-rendering"] = "optimizeSpeed", a.style["image-rendering"] = "crisp-edges", 
            a.style["image-rendering"] = "-moz-crisp-edges", a.style["image-rendering"] = "-webkit-optimize-contrast", 
            a.style["image-rendering"] = "optimize-contrast", a.style["image-rendering"] = "pixelated", 
            a.style.msInterpolationMode = "nearest-neighbor", a;
        },
        setImageRenderingBicubic: function(a) {
            return a.style["image-rendering"] = "auto", a.style.msInterpolationMode = "bicubic", 
            a;
        }
    }, c.RequestAnimationFrame = function(a, b) {
        void 0 === b && (b = !1), this.game = a, this.isRunning = !1, this.forceSetTimeOut = b;
        for (var c = [ "ms", "moz", "webkit", "o" ], d = 0; d < c.length && !window.requestAnimationFrame; d++) window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"], 
        window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"];
        this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null;
    }, c.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = !0;
            var a = this;
            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, 
            this._onLoop = function() {
                return a.updateSetTimeout();
            }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, 
            this._onLoop = function(b) {
                return a.updateRAF(b);
            }, this._timeOutID = window.requestAnimationFrame(this._onLoop));
        },
        updateRAF: function(a) {
            this.game.update(Math.floor(a)), this._timeOutID = window.requestAnimationFrame(this._onLoop);
        },
        updateSetTimeout: function() {
            this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
        },
        stop: function() {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), 
            this.isRunning = !1;
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut;
        },
        isRAF: function() {
            return this._isSetTimeOut === !1;
        }
    }, c.RequestAnimationFrame.prototype.constructor = c.RequestAnimationFrame, c.Math = {
        PI2: 2 * Math.PI,
        fuzzyEqual: function(a, b, c) {
            return void 0 === c && (c = 1e-4), Math.abs(a - b) < c;
        },
        fuzzyLessThan: function(a, b, c) {
            return void 0 === c && (c = 1e-4), b + c > a;
        },
        fuzzyGreaterThan: function(a, b, c) {
            return void 0 === c && (c = 1e-4), a > b - c;
        },
        fuzzyCeil: function(a, b) {
            return void 0 === b && (b = 1e-4), Math.ceil(a - b);
        },
        fuzzyFloor: function(a, b) {
            return void 0 === b && (b = 1e-4), Math.floor(a + b);
        },
        average: function() {
            for (var a = 0, b = 0; b < arguments.length; b++) a += +arguments[b];
            return a / arguments.length;
        },
        shear: function(a) {
            return a % 1;
        },
        snapTo: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.round(a / b), 
            c + a);
        },
        snapToFloor: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.floor(a / b), 
            c + a);
        },
        snapToCeil: function(a, b, c) {
            return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.ceil(a / b), 
            c + a);
        },
        roundTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.round(a * d) / d;
        },
        floorTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.floor(a * d) / d;
        },
        ceilTo: function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.ceil(a * d) / d;
        },
        angleBetween: function(a, b, c, d) {
            return Math.atan2(d - b, c - a);
        },
        angleBetweenY: function(a, b, c, d) {
            return Math.atan2(c - a, d - b);
        },
        angleBetweenPoints: function(a, b) {
            return Math.atan2(b.y - a.y, b.x - a.x);
        },
        angleBetweenPointsY: function(a, b) {
            return Math.atan2(b.x - a.x, b.y - a.y);
        },
        reverseAngle: function(a) {
            return this.normalizeAngle(a + Math.PI, !0);
        },
        normalizeAngle: function(a) {
            return a %= 2 * Math.PI, a >= 0 ? a : a + 2 * Math.PI;
        },
        maxAdd: function(a, b, c) {
            return Math.min(a + b, c);
        },
        minSub: function(a, b, c) {
            return Math.max(a - b, c);
        },
        wrap: function(a, b, c) {
            var d = c - b;
            if (0 >= d) return 0;
            var e = (a - b) % d;
            return 0 > e && (e += d), e + b;
        },
        wrapValue: function(a, b, c) {
            var d;
            return a = Math.abs(a), b = Math.abs(b), c = Math.abs(c), d = (a + b) % c;
        },
        isOdd: function(a) {
            return !!(1 & a);
        },
        isEven: function(a) {
            return !(1 & a);
        },
        min: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0]; else var a = arguments;
            for (var b = 1, c = 0, d = a.length; d > b; b++) a[b] < a[c] && (c = b);
            return a[c];
        },
        max: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0]; else var a = arguments;
            for (var b = 1, c = 0, d = a.length; d > b; b++) a[b] > a[c] && (c = b);
            return a[c];
        },
        minProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1]; else var b = arguments.slice(1);
            for (var c = 1, d = 0, e = b.length; e > c; c++) b[c][a] < b[d][a] && (d = c);
            return b[d][a];
        },
        maxProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1]; else var b = arguments.slice(1);
            for (var c = 1, d = 0, e = b.length; e > c; c++) b[c][a] > b[d][a] && (d = c);
            return b[d][a];
        },
        wrapAngle: function(a, b) {
            return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180);
        },
        linearInterpolation: function(a, b) {
            var c = a.length - 1, d = c * b, e = Math.floor(d);
            return 0 > b ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e);
        },
        bezierInterpolation: function(a, b) {
            for (var c = 0, d = a.length - 1, e = 0; d >= e; e++) c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
            return c;
        },
        catmullRomInterpolation: function(a, b) {
            var c = a.length - 1, d = c * b, e = Math.floor(d);
            return a[0] === a[c] ? (0 > b && (e = Math.floor(d = c * (1 + b))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : 0 > b ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[e + 1 > c ? c : e + 1], a[e + 2 > c ? c : e + 2], d - e);
        },
        linear: function(a, b, c) {
            return (b - a) * c + a;
        },
        bernstein: function(a, b) {
            return this.factorial(a) / this.factorial(b) / this.factorial(a - b);
        },
        factorial: function(a) {
            if (0 === a) return 1;
            for (var b = a; --a; ) b *= a;
            return b;
        },
        catmullRom: function(a, b, c, d, e) {
            var f = .5 * (c - a), g = .5 * (d - b), h = e * e, i = e * h;
            return (2 * b - 2 * c + f + g) * i + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b;
        },
        difference: function(a, b) {
            return Math.abs(a - b);
        },
        roundAwayFromZero: function(a) {
            return a > 0 ? Math.ceil(a) : Math.floor(a);
        },
        sinCosGenerator: function(a, b, c, d) {
            void 0 === b && (b = 1), void 0 === c && (c = 1), void 0 === d && (d = 1);
            for (var e = b, f = c, g = d * Math.PI / a, h = [], i = [], j = 0; a > j; j++) f -= e * g, 
            e += f * g, h[j] = f, i[j] = e;
            return {
                sin: i,
                cos: h,
                length: a
            };
        },
        distance: function(a, b, c, d) {
            var e = a - c, f = b - d;
            return Math.sqrt(e * e + f * f);
        },
        distanceSq: function(a, b, c, d) {
            var e = a - c, f = b - d;
            return e * e + f * f;
        },
        distancePow: function(a, b, c, d, e) {
            return void 0 === e && (e = 2), Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e));
        },
        clamp: function(a, b, c) {
            return b > a ? b : a > c ? c : a;
        },
        clampBottom: function(a, b) {
            return b > a ? b : a;
        },
        within: function(a, b, c) {
            return Math.abs(a - b) <= c;
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b);
        },
        smoothstep: function(a, b, c) {
            return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * (3 - 2 * a);
        },
        smootherstep: function(a, b, c) {
            return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * a * (a * (6 * a - 15) + 10);
        },
        sign: function(a) {
            return 0 > a ? -1 : a > 0 ? 1 : 0;
        },
        percent: function(a, b, c) {
            return void 0 === c && (c = 0), a > b || c > b ? 1 : c > a || c > a ? 0 : (a - c) / b;
        }
    };
    var j = Math.PI / 180, k = 180 / Math.PI;
    return c.Math.degToRad = function(a) {
        return a * j;
    }, c.Math.radToDeg = function(a) {
        return a * k;
    }, c.RandomDataGenerator = function(a) {
        void 0 === a && (a = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.sow(a);
    }, c.RandomDataGenerator.prototype = {
        rnd: function() {
            var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
            return this.c = 0 | a, this.s0 = this.s1, this.s1 = this.s2, this.s2 = a - this.c, 
            this.s2;
        },
        sow: function(a) {
            if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), 
            this.c = 1, a) for (var b = 0; b < a.length && null != a[b]; b++) {
                var c = a[b];
                this.s0 -= this.hash(c), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(c), this.s1 += ~~(this.s1 < 0), 
                this.s2 -= this.hash(c), this.s2 += ~~(this.s2 < 0);
            }
        },
        hash: function(a) {
            var b, c, d;
            for (d = 4022871197, a = a.toString(), c = 0; c < a.length; c++) d += a.charCodeAt(c), 
            b = .02519603282416938 * d, d = b >>> 0, b -= d, b *= d, d = b >>> 0, b -= d, d += 4294967296 * b;
            return 2.3283064365386963e-10 * (d >>> 0);
        },
        integer: function() {
            return 4294967296 * this.rnd.apply(this);
        },
        frac: function() {
            return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0);
        },
        real: function() {
            return this.integer() + this.frac();
        },
        integerInRange: function(a, b) {
            return Math.floor(this.realInRange(0, b - a + 1) + a);
        },
        between: function(a, b) {
            return this.integerInRange(a, b);
        },
        realInRange: function(a, b) {
            return this.frac() * (b - a) + a;
        },
        normal: function() {
            return 1 - 2 * this.frac();
        },
        uuid: function() {
            var a = "", b = "";
            for (b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-") ;
            return b;
        },
        pick: function(a) {
            return a[this.integerInRange(0, a.length - 1)];
        },
        weightedPick: function(a) {
            return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + .5)];
        },
        timestamp: function(a, b) {
            return this.realInRange(a || 9466848e5, b || 1577862e6);
        },
        angle: function() {
            return this.integerInRange(-180, 180);
        }
    }, c.RandomDataGenerator.prototype.constructor = c.RandomDataGenerator, c.QuadTree = function(a, b, c, d, e, f, g) {
        this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], 
        this.nodes = [], this._empty = [], this.reset(a, b, c, d, e, f, g);
    }, c.QuadTree.prototype = {
        reset: function(a, b, c, d, e, f, g) {
            this.maxObjects = e || 10, this.maxLevels = f || 4, this.level = g || 0, this.bounds = {
                x: Math.round(a),
                y: Math.round(b),
                width: c,
                height: d,
                subWidth: Math.floor(c / 2),
                subHeight: Math.floor(d / 2),
                right: Math.round(a) + Math.floor(c / 2),
                bottom: Math.round(b) + Math.floor(d / 2)
            }, this.objects.length = 0, this.nodes.length = 0;
        },
        populate: function(a) {
            a.forEach(this.populateHandler, this, !0);
        },
        populateHandler: function(a) {
            a.body && a.exists && this.insert(a.body);
        },
        split: function() {
            this.nodes[0] = new c.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
            this.nodes[1] = new c.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
            this.nodes[2] = new c.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), 
            this.nodes[3] = new c.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        },
        insert: function(a) {
            var b, c = 0;
            if (null != this.nodes[0] && (b = this.getIndex(a), -1 !== b)) return void this.nodes[b].insert(a);
            if (this.objects.push(a), this.objects.length > this.maxObjects && this.level < this.maxLevels) for (null == this.nodes[0] && this.split(); c < this.objects.length; ) b = this.getIndex(this.objects[c]), 
            -1 !== b ? this.nodes[b].insert(this.objects.splice(c, 1)[0]) : c++;
        },
        getIndex: function(a) {
            var b = -1;
            return a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3)), 
            b;
        },
        retrieve: function(a) {
            if (a instanceof c.Rectangle) var b = this.objects, d = this.getIndex(a); else {
                if (!a.body) return this._empty;
                var b = this.objects, d = this.getIndex(a.body);
            }
            return this.nodes[0] && (-1 !== d ? b = b.concat(this.nodes[d].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), 
            b = b.concat(this.nodes[1].retrieve(a)), b = b.concat(this.nodes[2].retrieve(a)), 
            b = b.concat(this.nodes[3].retrieve(a)))), b;
        },
        clear: function() {
            this.objects.length = 0;
            for (var a = this.nodes.length; a--; ) this.nodes[a].clear(), this.nodes.splice(a, 1);
            this.nodes.length = 0;
        }
    }, c.QuadTree.prototype.constructor = c.QuadTree, c.Net = function(a) {
        this.game = a;
    }, c.Net.prototype = {
        getHostName: function() {
            return window.location && window.location.hostname ? window.location.hostname : null;
        },
        checkDomainName: function(a) {
            return -1 !== window.location.hostname.indexOf(a);
        },
        updateQueryString: function(a, b, c, d) {
            void 0 === c && (c = !1), (void 0 === d || "" === d) && (d = window.location.href);
            var e = "", f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
            if (f.test(d)) e = "undefined" != typeof b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, ""); else if ("undefined" != typeof b && null !== b) {
                var g = -1 !== d.indexOf("?") ? "&" : "?", h = d.split("#");
                d = h[0] + g + a + "=" + b, h[1] && (d += "#" + h[1]), e = d;
            } else e = d;
            return c ? void (window.location.href = e) : e;
        },
        getQueryString: function(a) {
            void 0 === a && (a = "");
            var b = {}, c = location.search.substring(1).split("&");
            for (var d in c) {
                var e = c[d].split("=");
                if (e.length > 1) {
                    if (a && a == this.decodeURI(e[0])) return this.decodeURI(e[1]);
                    b[this.decodeURI(e[0])] = this.decodeURI(e[1]);
                }
            }
            return b;
        },
        decodeURI: function(a) {
            return decodeURIComponent(a.replace(/\+/g, " "));
        }
    }, c.Net.prototype.constructor = c.Net, c.TweenManager = function(a) {
        this.game = a, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
            Power0: c.Easing.Power0,
            Power1: c.Easing.Power1,
            Power2: c.Easing.Power2,
            Power3: c.Easing.Power3,
            Power4: c.Easing.Power4,
            Linear: c.Easing.Linear.None,
            Quad: c.Easing.Quadratic.Out,
            Cubic: c.Easing.Cubic.Out,
            Quart: c.Easing.Quartic.Out,
            Quint: c.Easing.Quintic.Out,
            Sine: c.Easing.Sinusoidal.Out,
            Expo: c.Easing.Exponential.Out,
            Circ: c.Easing.Circular.Out,
            Elastic: c.Easing.Elastic.Out,
            Back: c.Easing.Back.Out,
            Bounce: c.Easing.Bounce.Out,
            "Quad.easeIn": c.Easing.Quadratic.In,
            "Cubic.easeIn": c.Easing.Cubic.In,
            "Quart.easeIn": c.Easing.Quartic.In,
            "Quint.easeIn": c.Easing.Quintic.In,
            "Sine.easeIn": c.Easing.Sinusoidal.In,
            "Expo.easeIn": c.Easing.Exponential.In,
            "Circ.easeIn": c.Easing.Circular.In,
            "Elastic.easeIn": c.Easing.Elastic.In,
            "Back.easeIn": c.Easing.Back.In,
            "Bounce.easeIn": c.Easing.Bounce.In,
            "Quad.easeOut": c.Easing.Quadratic.Out,
            "Cubic.easeOut": c.Easing.Cubic.Out,
            "Quart.easeOut": c.Easing.Quartic.Out,
            "Quint.easeOut": c.Easing.Quintic.Out,
            "Sine.easeOut": c.Easing.Sinusoidal.Out,
            "Expo.easeOut": c.Easing.Exponential.Out,
            "Circ.easeOut": c.Easing.Circular.Out,
            "Elastic.easeOut": c.Easing.Elastic.Out,
            "Back.easeOut": c.Easing.Back.Out,
            "Bounce.easeOut": c.Easing.Bounce.Out,
            "Quad.easeInOut": c.Easing.Quadratic.InOut,
            "Cubic.easeInOut": c.Easing.Cubic.InOut,
            "Quart.easeInOut": c.Easing.Quartic.InOut,
            "Quint.easeInOut": c.Easing.Quintic.InOut,
            "Sine.easeInOut": c.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": c.Easing.Exponential.InOut,
            "Circ.easeInOut": c.Easing.Circular.InOut,
            "Elastic.easeInOut": c.Easing.Elastic.InOut,
            "Back.easeInOut": c.Easing.Back.InOut,
            "Bounce.easeInOut": c.Easing.Bounce.InOut
        }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this);
    }, c.TweenManager.prototype = {
        getAll: function() {
            return this._tweens;
        },
        removeAll: function() {
            for (var a = 0; a < this._tweens.length; a++) this._tweens[a].pendingDelete = !0;
            this._add = [];
        },
        removeFrom: function(a, b) {
            void 0 === b && (b = !0);
            var d, e;
            if (Array.isArray(a)) for (d = 0, e = a.length; e > d; d++) this.removeFrom(a[d]); else if (a.type === c.GROUP && b) for (var d = 0, e = a.children.length; e > d; d++) this.removeFrom(a.children[d]); else {
                for (d = 0, e = this._tweens.length; e > d; d++) a === this._tweens[d].target && this.remove(this._tweens[d]);
                for (d = 0, e = this._add.length; e > d; d++) a === this._add[d].target && this.remove(this._add[d]);
            }
        },
        add: function(a) {
            a._manager = this, this._add.push(a);
        },
        create: function(a) {
            return new c.Tween(a, this.game, this);
        },
        remove: function(a) {
            var b = this._tweens.indexOf(a);
            -1 !== b ? this._tweens[b].pendingDelete = !0 : (b = this._add.indexOf(a), -1 !== b && (this._add[b].pendingDelete = !0));
        },
        update: function() {
            var a = this._add.length, b = this._tweens.length;
            if (0 === b && 0 === a) return !1;
            for (var c = 0; b > c; ) this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1), 
            b--);
            return a > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), 
            !0;
        },
        isTweening: function(a) {
            return this._tweens.some(function(b) {
                return b.target === a;
            });
        },
        _pauseAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._pause();
        },
        _resumeAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._resume();
        },
        pauseAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].pause();
        },
        resumeAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].resume(!0);
        }
    }, c.TweenManager.prototype.constructor = c.TweenManager, c.Tween = function(a, b, d) {
        this.game = b, this.target = a, this.manager = d, this.timeline = [], this.reverse = !1, 
        this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new c.Signal(), 
        this.onLoop = new c.Signal(), this.onRepeat = new c.Signal(), this.onChildComplete = new c.Signal(), 
        this.onComplete = new c.Signal(), this.isRunning = !1, this.current = 0, this.properties = {}, 
        this.chainedTween = null, this.isPaused = !1, this.frameBased = d.frameBased, this._onUpdateCallback = null, 
        this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, 
        this._hasStarted = !1;
    }, c.Tween.prototype = {
        to: function(a, b, d, e, f, g, h) {
            return (void 0 === b || 0 >= b) && (b = 1e3), (void 0 === d || null === d) && (d = c.Easing.Default), 
            void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), 
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), 
            this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), 
            this) : (this.timeline.push(new c.TweenData(this).to(a, b, d, f, g, h)), e && this.start(), 
            this);
        },
        from: function(a, b, d, e, f, g, h) {
            return void 0 === b && (b = 1e3), (void 0 === d || null === d) && (d = c.Easing.Default), 
            void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), 
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), 
            this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), 
            this) : (this.timeline.push(new c.TweenData(this).from(a, b, d, f, g, h)), e && this.start(), 
            this);
        },
        start: function(a) {
            if (void 0 === a && (a = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
            for (var b = 0; b < this.timeline.length; b++) for (var c in this.timeline[b].vEnd) this.properties[c] = this.target[c] || 0, 
            Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
            for (var b = 0; b < this.timeline.length; b++) this.timeline[b].loadValues();
            return this.manager.add(this), this.isRunning = !0, (0 > a || a > this.timeline.length - 1) && (a = 0), 
            this.current = a, this.timeline[this.current].start(), this;
        },
        stop: function(a) {
            return void 0 === a && (a = !1), this.isRunning = !1, this._onUpdateCallback = null, 
            this._onUpdateCallbackContext = null, a && (this.onComplete.dispatch(this.target, this), 
            this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this;
        },
        updateTweenData: function(a, b, c) {
            if (0 === this.timeline.length) return this;
            if (void 0 === c && (c = 0), -1 === c) for (var d = 0; d < this.timeline.length; d++) this.timeline[d][a] = b; else this.timeline[c][a] = b;
            return this;
        },
        delay: function(a, b) {
            return this.updateTweenData("delay", a, b);
        },
        repeat: function(a, b, c) {
            return void 0 === b && (b = 0), this.updateTweenData("repeatCounter", a, c), this.updateTweenData("repeatDelay", b, c);
        },
        repeatDelay: function(a, b) {
            return this.updateTweenData("repeatDelay", a, b);
        },
        yoyo: function(a, b, c) {
            return void 0 === b && (b = 0), this.updateTweenData("yoyo", a, c), this.updateTweenData("yoyoDelay", b, c);
        },
        yoyoDelay: function(a, b) {
            return this.updateTweenData("yoyoDelay", a, b);
        },
        easing: function(a, b) {
            return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]), 
            this.updateTweenData("easingFunction", a, b);
        },
        interpolation: function(a, b, d) {
            return void 0 === b && (b = c.Math), this.updateTweenData("interpolationFunction", a, d), 
            this.updateTweenData("interpolationContext", b, d);
        },
        repeatAll: function(a) {
            return void 0 === a && (a = 0), this.repeatCounter = a, this;
        },
        chain: function() {
            for (var a = arguments.length; a--; ) a > 0 ? arguments[a - 1].chainedTween = arguments[a] : this.chainedTween = arguments[a];
            return this;
        },
        loop: function(a) {
            return void 0 === a && (a = !0), a ? this.repeatAll(-1) : this.repeatCounter = 0, 
            this;
        },
        onUpdateCallback: function(a, b) {
            return this._onUpdateCallback = a, this._onUpdateCallbackContext = b, this;
        },
        pause: function() {
            this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time;
        },
        _pause: function() {
            this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time);
        },
        resume: function() {
            if (this.isPaused) {
                this.isPaused = !1, this._codePaused = !1;
                for (var a = 0; a < this.timeline.length; a++) this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime);
            }
        },
        _resume: function() {
            this._codePaused || this.resume();
        },
        update: function(a) {
            if (this.pendingDelete) return !1;
            if (this.isPaused) return !0;
            var b = this.timeline[this.current].update(a);
            if (b === c.TweenData.PENDING) return !0;
            if (b === c.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), 
            this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), 
            this.isRunning;
            if (b === c.TweenData.LOOPED) return this.onLoop.dispatch(this.target, this), !0;
            if (b === c.TweenData.COMPLETE) {
                var d = !1;
                return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, 
                d = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, 
                d = !0)), d ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), 
                this.onRepeat.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, 
                this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), 
                !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this.chainedTween && this.chainedTween.start(), 
                !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), 
                !0);
            }
        },
        generateData: function(a, b) {
            if (null === this.game || null === this.target) return null;
            void 0 === a && (a = 60), void 0 === b && (b = []);
            for (var c = 0; c < this.timeline.length; c++) for (var d in this.timeline[c].vEnd) this.properties[d] = this.target[d] || 0, 
            Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
            for (var c = 0; c < this.timeline.length; c++) this.timeline[c].loadValues();
            for (var c = 0; c < this.timeline.length; c++) b = b.concat(this.timeline[c].generateData(a));
            return b;
        }
    }, Object.defineProperty(c.Tween.prototype, "totalDuration", {
        get: function() {
            for (var a = 0, b = 0; b < this.timeline.length; b++) a += this.timeline[b].duration;
            return a;
        }
    }), c.Tween.prototype.constructor = c.Tween, c.TweenData = function(a) {
        this.parent = a, this.game = a.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, 
        this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, 
        this.repeatDelay = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, 
        this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = c.Easing.Default, 
        this.interpolationFunction = c.Math.linearInterpolation, this.interpolationContext = c.Math, 
        this.isRunning = !1, this.isFrom = !1;
    }, c.TweenData.PENDING = 0, c.TweenData.RUNNING = 1, c.TweenData.LOOPED = 2, c.TweenData.COMPLETE = 3, 
    c.TweenData.prototype = {
        to: function(a, b, c, d, e, f) {
            return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, 
            this.repeatCounter = e, this.yoyo = f, this.isFrom = !1, this;
        },
        from: function(a, b, c, d, e, f) {
            return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, 
            this.repeatCounter = e, this.yoyo = f, this.isFrom = !0, this;
        },
        start: function() {
            if (this.startTime = this.game.time.time + this.delay, this.dt = this.parent.reverse ? this.duration : 0, 
            this.isRunning = this.delay > 0 ? !1 : !0, this.isFrom) for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], 
            this.vEnd[a] = this.vStartCache[a], this.parent.target[a] = this.vStart[a];
            return this.value = 0, this.yoyoCounter = 0, this;
        },
        loadValues: function() {
            for (var a in this.parent.properties) {
                if (this.vStart[a] = this.parent.properties[a], Array.isArray(this.vEnd[a])) {
                    if (0 === this.vEnd[a].length) continue;
                    0 === this.percent && (this.vEnd[a] = [ this.vStart[a] ].concat(this.vEnd[a]));
                }
                "undefined" != typeof this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)), 
                this.parent.properties[a] = this.vEnd[a]) : this.vEnd[a] = this.vStart[a], this.vStartCache[a] = this.vStart[a], 
                this.vEndCache[a] = this.vEnd[a];
            }
            return this;
        },
        update: function(a) {
            if (this.isRunning) {
                if (a < this.startTime) return c.TweenData.RUNNING;
            } else {
                if (!(a >= this.startTime)) return c.TweenData.PENDING;
                this.isRunning = !0;
            }
            var b = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
            this.parent.reverse ? (this.dt -= b * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += b * this.parent.timeScale, 
            this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, 
            this.value = this.easingFunction(this.percent);
            for (var d in this.vEnd) {
                var e = this.vStart[d], f = this.vEnd[d];
                this.parent.target[d] = Array.isArray(f) ? this.interpolationFunction.call(this.interpolationContext, f, this.value) : e + (f - e) * this.value;
            }
            return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : c.TweenData.RUNNING;
        },
        generateData: function(a) {
            this.dt = this.parent.reverse ? this.duration : 0;
            var b = [], c = !1, d = 1 / a * 1e3;
            do {
                this.parent.reverse ? (this.dt -= d, this.dt = Math.max(this.dt, 0)) : (this.dt += d, 
                this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, 
                this.value = this.easingFunction(this.percent);
                var e = {};
                for (var f in this.vEnd) {
                    var g = this.vStart[f], h = this.vEnd[f];
                    e[f] = Array.isArray(h) ? this.interpolationFunction(h, this.value) : g + (h - g) * this.value;
                }
                b.push(e), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (c = !0);
            } while (!c);
            if (this.yoyo) {
                var i = b.slice();
                i.reverse(), b = b.concat(i);
            }
            return b;
        },
        repeat: function() {
            if (this.yoyo) {
                if (this.inReverse && 0 === this.repeatCounter) return c.TweenData.COMPLETE;
                this.inReverse = !this.inReverse;
            } else if (0 === this.repeatCounter) return c.TweenData.COMPLETE;
            if (this.inReverse) for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], 
            this.vEnd[a] = this.vStartCache[a]; else {
                for (var a in this.vStartCache) this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                this.repeatCounter > 0 && this.repeatCounter--;
            }
            return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), 
            this.dt = this.parent.reverse ? this.duration : 0, c.TweenData.LOOPED;
        }
    }, c.TweenData.prototype.constructor = c.TweenData, c.Easing = {
        Linear: {
            None: function(a) {
                return a;
            }
        },
        Quadratic: {
            In: function(a) {
                return a * a;
            },
            Out: function(a) {
                return a * (2 - a);
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1);
            }
        },
        Cubic: {
            In: function(a) {
                return a * a * a;
            },
            Out: function(a) {
                return --a * a * a + 1;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2);
            }
        },
        Quartic: {
            In: function(a) {
                return a * a * a * a;
            },
            Out: function(a) {
                return 1 - --a * a * a * a;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2);
            }
        },
        Quintic: {
            In: function(a) {
                return a * a * a * a * a;
            },
            Out: function(a) {
                return --a * a * a * a * a + 1;
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2);
            }
        },
        Sinusoidal: {
            In: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2);
            },
            Out: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2);
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : .5 * (1 - Math.cos(Math.PI * a));
            }
        },
        Exponential: {
            In: function(a) {
                return 0 === a ? 0 : Math.pow(1024, a - 1);
            },
            Out: function(a) {
                return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2);
            }
        },
        Circular: {
            In: function(a) {
                return 1 - Math.sqrt(1 - a * a);
            },
            Out: function(a) {
                return Math.sqrt(1 - --a * a);
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
            }
        },
        Elastic: {
            In: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), 
                -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d)));
            },
            Out: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), 
                c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / d) + 1);
            },
            InOut: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), 
                (a *= 2) < 1 ? -.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) * .5 + 1);
            }
        },
        Back: {
            In: function(a) {
                var b = 1.70158;
                return a * a * ((b + 1) * a - b);
            },
            Out: function(a) {
                var b = 1.70158;
                return --a * a * ((b + 1) * a + b) + 1;
            },
            InOut: function(a) {
                var b = 2.5949095;
                return (a *= 2) < 1 ? .5 * a * a * ((b + 1) * a - b) : .5 * ((a -= 2) * a * ((b + 1) * a + b) + 2);
            }
        },
        Bounce: {
            In: function(a) {
                return 1 - c.Easing.Bounce.Out(1 - a);
            },
            Out: function(a) {
                return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375;
            },
            InOut: function(a) {
                return .5 > a ? .5 * c.Easing.Bounce.In(2 * a) : .5 * c.Easing.Bounce.Out(2 * a - 1) + .5;
            }
        }
    }, c.Easing.Default = c.Easing.Linear.None, c.Easing.Power0 = c.Easing.Linear.None, 
    c.Easing.Power1 = c.Easing.Quadratic.Out, c.Easing.Power2 = c.Easing.Cubic.Out, 
    c.Easing.Power3 = c.Easing.Quartic.Out, c.Easing.Power4 = c.Easing.Quintic.Out, 
    c.Time = function(a) {
        this.game = a, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, 
        this.elapsedMS = 0, this.physicsElapsed = 0, this.physicsElapsedMS = 0, this.desiredFps = 60, 
        this.suggestedFps = null, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, 
        this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, 
        this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new c.Timer(this.game, !1), 
        this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, 
        this._pauseStarted = 0, this._justResumed = !1, this._timers = [];
    }, c.Time.prototype = {
        boot: function() {
            this._started = Date.now(), this.time = Date.now(), this.events.start();
        },
        add: function(a) {
            return this._timers.push(a), a;
        },
        create: function(a) {
            void 0 === a && (a = !0);
            var b = new c.Timer(this.game, a);
            return this._timers.push(b), b;
        },
        removeAll: function() {
            for (var a = 0; a < this._timers.length; a++) this._timers[a].destroy();
            this._timers = [], this.events.removeAll();
        },
        update: function(a) {
            this.game.raf._isSetTimeOut ? this.updateSetTimeout(a) : this.updateRAF(a), this.advancedTiming && this.updateAdvancedTiming(), 
            this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers());
        },
        updateSetTimeout: function(a) {
            var b = this.time;
            this.time = a, this.elapsedMS = this.time - b, this.prevTime = this.now, this.now = a, 
            this.elapsed = this.now - this.prevTime, this.timeToCall = Math.floor(Math.max(0, 1e3 / this.desiredFps - (this.timeCallExpected - a))), 
            this.timeCallExpected = a + this.timeToCall, this.physicsElapsed = 1 / this.desiredFps, 
            this.physicsElapsedMS = 1e3 * this.physicsElapsed;
        },
        updateRAF: function(a) {
            var b = this.time;
            this.time = Date.now(), this.elapsedMS = this.time - b, this.prevTime = this.now, 
            this.now = a, this.elapsed = this.now - this.prevTime, this.physicsElapsed = 1 / this.desiredFps, 
            this.physicsElapsedMS = 1e3 * this.physicsElapsed;
        },
        updateTimers: function() {
            for (var a = 0, b = this._timers.length; b > a; ) this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1), 
            b--);
        },
        updateAdvancedTiming: function() {
            this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this.desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), 
            this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), 
            this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), 
            this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), 
            this._timeLastSecond = this.now, this.frames = 0);
        },
        gamePaused: function() {
            this._pauseStarted = Date.now(), this.events.pause();
            for (var a = this._timers.length; a--; ) this._timers[a]._pause();
        },
        gameResumed: function() {
            this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
            for (var a = this._timers.length; a--; ) this._timers[a]._resume();
        },
        totalElapsedSeconds: function() {
            return .001 * (this.time - this._started);
        },
        elapsedSince: function(a) {
            return this.time - a;
        },
        elapsedSecondsSince: function(a) {
            return .001 * (this.time - a);
        },
        reset: function() {
            this._started = this.time, this.removeAll();
        }
    }, c.Time.prototype.constructor = c.Time, c.Timer = function(a, b) {
        void 0 === b && (b = !0), this.game = a, this.running = !1, this.autoDestroy = b, 
        this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new c.Signal(), 
        this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, 
        this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), 
        this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0;
    }, c.Timer.MINUTE = 6e4, c.Timer.SECOND = 1e3, c.Timer.HALF = 500, c.Timer.QUARTER = 250, 
    c.Timer.prototype = {
        create: function(a, b, d, e, f, g) {
            a = Math.round(a);
            var h = a;
            h += 0 === this._now ? this.game.time.time : this._now;
            var i = new c.TimerEvent(this, a, h, d, b, e, f, g);
            return this.events.push(i), this.order(), this.expired = !1, i;
        },
        add: function(a, b, c) {
            return this.create(a, !1, 0, b, c, Array.prototype.splice.call(arguments, 3));
        },
        repeat: function(a, b, c, d) {
            return this.create(a, !1, b, c, d, Array.prototype.splice.call(arguments, 4));
        },
        loop: function(a, b, c) {
            return this.create(a, !0, 0, b, c, Array.prototype.splice.call(arguments, 3));
        },
        start: function(a) {
            if (!this.running) {
                this._started = this.game.time.time + (a || 0), this.running = !0;
                for (var b = 0; b < this.events.length; b++) this.events[b].tick = this.events[b].delay + this._started;
            }
        },
        stop: function(a) {
            this.running = !1, void 0 === a && (a = !0), a && (this.events.length = 0);
        },
        remove: function(a) {
            for (var b = 0; b < this.events.length; b++) if (this.events[b] === a) return this.events[b].pendingDelete = !0, 
            !0;
            return !1;
        },
        order: function() {
            this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick);
        },
        sortHandler: function(a, b) {
            return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
        },
        clearPendingEvents: function() {
            for (this._i = this.events.length; this._i--; ) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length, this._i = 0;
        },
        update: function(a) {
            if (this.paused) return !0;
            if (this.elapsed = a - this._now, this._now = a, this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed), 
            this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                for (;this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete; ) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), 
                this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, 
                this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, 
                this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, 
                this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), 
                this._i++;
                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this));
            }
            return this.expired && this.autoDestroy ? !1 : !0;
        },
        pause: function() {
            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, 
            this.paused = !0));
        },
        _pause: function() {
            !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0);
        },
        adjustEvents: function(a) {
            for (var b = 0; b < this.events.length; b++) if (!this.events[b].pendingDelete) {
                var c = this.events[b].tick - a;
                0 > c && (c = 0), this.events[b].tick = this._now + c;
            }
            var d = this.nextTick - a;
            this.nextTick = 0 > d ? this._now : this._now + d;
        },
        resume: function() {
            if (this.paused) {
                var a = this.game.time.time;
                this._pauseTotal += a - this._now, this._now = a, this.adjustEvents(this._pauseStarted), 
                this.paused = !1, this._codePaused = !1;
            }
        },
        _resume: function() {
            this._codePaused || this.resume();
        },
        removeAll: function() {
            this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0;
        },
        destroy: function() {
            this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, 
            this._i = 0;
        }
    }, Object.defineProperty(c.Timer.prototype, "next", {
        get: function() {
            return this.nextTick;
        }
    }), Object.defineProperty(c.Timer.prototype, "duration", {
        get: function() {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
        }
    }), Object.defineProperty(c.Timer.prototype, "length", {
        get: function() {
            return this.events.length;
        }
    }), Object.defineProperty(c.Timer.prototype, "ms", {
        get: function() {
            return this.running ? this._now - this._started - this._pauseTotal : 0;
        }
    }), Object.defineProperty(c.Timer.prototype, "seconds", {
        get: function() {
            return this.running ? .001 * this.ms : 0;
        }
    }), c.Timer.prototype.constructor = c.Timer, c.TimerEvent = function(a, b, c, d, e, f, g, h) {
        this.timer = a, this.delay = b, this.tick = c, this.repeatCount = d - 1, this.loop = e, 
        this.callback = f, this.callbackContext = g, this.args = h, this.pendingDelete = !1;
    }, c.TimerEvent.prototype.constructor = c.TimerEvent, c.AnimationManager = function(a) {
        this.sprite = a, this.game = a.game, this.currentFrame = null, this.currentAnim = null, 
        this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, 
        this._outputFrames = [];
    }, c.AnimationManager.prototype = {
        loadFrameData: function(a, b) {
            if (void 0 === a) return !1;
            if (this.isLoaded) for (var c in this._anims) this._anims[c].updateFrameData(a);
            return this._frameData = a, void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, 
            this.isLoaded = !0, !0;
        },
        copyFrameData: function(a, b) {
            if (this._frameData = a.clone(), this.isLoaded) for (var c in this._anims) this._anims[c].updateFrameData(this._frameData);
            return void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, 
            this.isLoaded = !0, !0;
        },
        add: function(a, b, d, e, f) {
            return b = b || [], d = d || 60, void 0 === e && (e = !1), void 0 === f && (f = b && "number" == typeof b[0] ? !0 : !1), 
            this._outputFrames = [], this._frameData.getFrameIndexes(b, f, this._outputFrames), 
            this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e), 
            this.currentAnim = this._anims[a], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), 
            this._anims[a];
        },
        validateFrames: function(a, b) {
            void 0 === b && (b = !0);
            for (var c = 0; c < a.length; c++) if (b === !0) {
                if (a[c] > this._frameData.total) return !1;
            } else if (this._frameData.checkFrameName(a[c]) === !1) return !1;
            return !0;
        },
        play: function(a, b, c, d) {
            return this._anims[a] ? this.currentAnim === this._anims[a] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, 
            this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), 
            this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, 
            this.currentAnim.play(b, c, d)) : void 0;
        },
        stop: function(a, b) {
            void 0 === b && (b = !1), "string" == typeof a ? this._anims[a] && (this.currentAnim = this._anims[a], 
            this.currentAnim.stop(b)) : this.currentAnim && this.currentAnim.stop(b);
        },
        update: function() {
            return this.updateIfVisible && !this.sprite.visible ? !1 : this.currentAnim && this.currentAnim.update() ? (this.currentFrame = this.currentAnim.currentFrame, 
            !0) : !1;
        },
        next: function(a) {
            this.currentAnim && (this.currentAnim.next(a), this.currentFrame = this.currentAnim.currentFrame);
        },
        previous: function(a) {
            this.currentAnim && (this.currentAnim.previous(a), this.currentFrame = this.currentAnim.currentFrame);
        },
        getAnimation: function(a) {
            return "string" == typeof a && this._anims[a] ? this._anims[a] : null;
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
        },
        destroy: function() {
            var a = null;
            for (var a in this._anims) this._anims.hasOwnProperty(a) && this._anims[a].destroy();
            this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, 
            this.currentFrame = null, this.sprite = null, this.game = null;
        }
    }, c.AnimationManager.prototype.constructor = c.AnimationManager, Object.defineProperty(c.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData;
        }
    }), Object.defineProperty(c.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total;
        }
    }), Object.defineProperty(c.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused;
        },
        set: function(a) {
            this.currentAnim.paused = a;
        }
    }), Object.defineProperty(c.AnimationManager.prototype, "name", {
        get: function() {
            return this.currentAnim ? this.currentAnim.name : void 0;
        }
    }), Object.defineProperty(c.AnimationManager.prototype, "frame", {
        get: function() {
            return this.currentFrame ? this.currentFrame.index : void 0;
        },
        set: function(a) {
            "number" == typeof a && this._frameData && null !== this._frameData.getFrame(a) && (this.currentFrame = this._frameData.getFrame(a), 
            this.currentFrame && this.sprite.setFrame(this.currentFrame));
        }
    }), Object.defineProperty(c.AnimationManager.prototype, "frameName", {
        get: function() {
            return this.currentFrame ? this.currentFrame.name : void 0;
        },
        set: function(a) {
            "string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a) ? (this.currentFrame = this._frameData.getFrameByName(a), 
            this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + a);
        }
    }), c.Animation = function(a, b, d, e, f, g, h) {
        void 0 === h && (h = !1), this.game = a, this._parent = b, this._frameData = e, 
        this.name = d, this._frames = [], this._frames = this._frames.concat(f), this.delay = 1e3 / g, 
        this.loop = h, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, 
        this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, 
        this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
        this.onStart = new c.Signal(), this.onUpdate = null, this.onComplete = new c.Signal(), 
        this.onLoop = new c.Signal(), this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this);
    }, c.Animation.prototype = {
        play: function(a, b, c) {
            return "number" == typeof a && (this.delay = 1e3 / a), "boolean" == typeof b && (this.loop = b), 
            "undefined" != typeof c && (this.killOnComplete = c), this.isPlaying = !0, this.isFinished = !1, 
            this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, 
            this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.updateCurrentFrame(!1, !0), 
            this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), 
            this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, 
            this;
        },
        restart: function() {
            this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, 
            this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, 
            this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
            this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, 
            this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this);
        },
        setFrame: function(a, b) {
            var c;
            if (void 0 === b && (b = !1), "string" == typeof a) for (var d = 0; d < this._frames.length; d++) this._frameData.getFrame(this._frames[d]).name === a && (c = d); else if ("number" == typeof a) if (b) c = a; else for (var d = 0; d < this._frames.length; d++) this._frames[d] === c && (c = d);
            c && (this._frameIndex = c - 1, this._timeNextFrame = this.game.time.time, this.update());
        },
        stop: function(a, b) {
            void 0 === a && (a = !1), void 0 === b && (b = !1), this.isPlaying = !1, this.isFinished = !0, 
            this.paused = !1, a && (this.currentFrame = this._frameData.getFrame(this._frames[0]), 
            this._parent.setFrame(this.currentFrame)), b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), 
            this.onComplete.dispatch(this._parent, this));
        },
        onPause: function() {
            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time);
        },
        onResume: function() {
            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff);
        },
        update: function() {
            return this.isPaused ? !1 : this.isPlaying && this.game.time.time >= this._timeNextFrame ? (this._frameSkip = 1, 
            this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, 
            this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), 
            this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), 
            this._frameIndex += this._frameSkip, this._frameIndex >= this._frames.length ? this.loop ? (this._frameIndex %= this._frames.length, 
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), 
            this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), 
            this.onLoop.dispatch(this._parent, this), this.onUpdate ? (this.onUpdate.dispatch(this, this.currentFrame), 
            !!this._frameData) : !0) : (this.complete(), !1) : this.updateCurrentFrame(!0)) : !1;
        },
        updateCurrentFrame: function(a, b) {
            if (void 0 === b && (b = !1), !this._frameData) return !1;
            var c = this.currentFrame.index;
            return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
            this.currentFrame && (b || !b && c !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), 
            this.onUpdate && a ? (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData) : !0;
        },
        next: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex + a;
            b >= this._frames.length && (this.loop ? b %= this._frames.length : b = this._frames.length - 1), 
            b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0));
        },
        previous: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex - a;
            0 > b && (this.loop ? b = this._frames.length + b : b++), b !== this._frameIndex && (this._frameIndex = b, 
            this.updateCurrentFrame(!0));
        },
        updateFrameData: function(a) {
            this._frameData = a, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
        },
        destroy: function() {
            this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), 
            this.game = null, this._parent = null, this._frames = null, this._frameData = null, 
            this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), 
            this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose());
        },
        complete: function() {
            this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), 
            this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), 
            this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill();
        }
    }, c.Animation.prototype.constructor = c.Animation, Object.defineProperty(c.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused;
        },
        set: function(a) {
            this.isPaused = a, a ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay);
        }
    }), Object.defineProperty(c.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length;
        }
    }), Object.defineProperty(c.Animation.prototype, "frame", {
        get: function() {
            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
        },
        set: function(a) {
            this.currentFrame = this._frameData.getFrame(this._frames[a]), null !== this.currentFrame && (this._frameIndex = a, 
            this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
        }
    }), Object.defineProperty(c.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1e3 / this.delay);
        },
        set: function(a) {
            a >= 1 && (this.delay = 1e3 / a);
        }
    }), Object.defineProperty(c.Animation.prototype, "enableUpdate", {
        get: function() {
            return null !== this.onUpdate;
        },
        set: function(a) {
            a && null === this.onUpdate ? this.onUpdate = new c.Signal() : a || null === this.onUpdate || (this.onUpdate.dispose(), 
            this.onUpdate = null);
        }
    }), c.Animation.generateFrameNames = function(a, b, d, e, f) {
        void 0 === e && (e = "");
        var g = [], h = "";
        if (d > b) for (var i = b; d >= i; i++) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), 
        h = a + h + e, g.push(h); else for (var i = b; i >= d; i--) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), 
        h = a + h + e, g.push(h);
        return g;
    }, c.Frame = function(a, b, d, e, f, g) {
        this.index = a, this.x = b, this.y = d, this.width = e, this.height = f, this.name = g, 
        this.centerX = Math.floor(e / 2), this.centerY = Math.floor(f / 2), this.distance = c.Math.distance(0, 0, e, f), 
        this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = e, 
        this.sourceSizeH = f, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, 
        this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height;
    }, c.Frame.prototype = {
        resize: function(a, b) {
            this.width = a, this.height = b, this.centerX = Math.floor(a / 2), this.centerY = Math.floor(b / 2), 
            this.distance = c.Math.distance(0, 0, a, b), this.sourceSizeW = a, this.sourceSizeH = b, 
            this.right = this.x + a, this.bottom = this.y + b;
        },
        setTrim: function(a, b, c, d, e, f, g) {
            this.trimmed = a, a && (this.sourceSizeW = b, this.sourceSizeH = c, this.centerX = Math.floor(b / 2), 
            this.centerY = Math.floor(c / 2), this.spriteSourceSizeX = d, this.spriteSourceSizeY = e, 
            this.spriteSourceSizeW = f, this.spriteSourceSizeH = g);
        },
        clone: function() {
            var a = new c.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
            for (var b in this) this.hasOwnProperty(b) && (a[b] = this[b]);
            return a;
        },
        getRect: function(a) {
            return void 0 === a ? a = new c.Rectangle(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), 
            a;
        }
    }, c.Frame.prototype.constructor = c.Frame, c.FrameData = function() {
        this._frames = [], this._frameNames = [];
    }, c.FrameData.prototype = {
        addFrame: function(a) {
            return a.index = this._frames.length, this._frames.push(a), "" !== a.name && (this._frameNames[a.name] = a.index), 
            a;
        },
        getFrame: function(a) {
            return a >= this._frames.length && (a = 0), this._frames[a];
        },
        getFrameByName: function(a) {
            return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null;
        },
        checkFrameName: function(a) {
            return null == this._frameNames[a] ? !1 : !0;
        },
        clone: function() {
            for (var a = new c.FrameData(), b = 0; b < this._frames.length; b++) a._frames.push(this._frames[b].clone());
            for (var d in this._frameNames) this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]);
            return a;
        },
        getFrameRange: function(a, b, c) {
            void 0 === c && (c = []);
            for (var d = a; b >= d; d++) c.push(this._frames[d]);
            return c;
        },
        getFrames: function(a, b, c) {
            if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length) for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d]); else for (var d = 0; d < a.length; d++) c.push(b ? this.getFrame(a[d]) : this.getFrameByName(a[d]));
            return c;
        },
        getFrameIndexes: function(a, b, c) {
            if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length) for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d].index); else for (var d = 0; d < a.length; d++) b ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
            return c;
        }
    }, c.FrameData.prototype.constructor = c.FrameData, Object.defineProperty(c.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length;
        }
    }), c.AnimationParser = {
        spriteSheet: function(a, b, d, e, f, g, h) {
            var i = b;
            if ("string" == typeof b && (i = a.cache.getImage(b)), null === i) return null;
            var j = i.width, k = i.height;
            0 >= d && (d = Math.floor(-j / Math.min(-1, d))), 0 >= e && (e = Math.floor(-k / Math.min(-1, e)));
            var l = Math.floor((j - g) / (d + h)), m = Math.floor((k - g) / (e + h)), n = l * m;
            if (-1 !== f && (n = f), 0 === j || 0 === k || d > j || e > k || 0 === n) return console.warn("Phaser.AnimationParser.spriteSheet: '" + b + "'s width/height zero or width/height < given frameWidth/frameHeight"), 
            null;
            for (var o = new c.FrameData(), p = g, q = g, r = 0; n > r; r++) o.addFrame(new c.Frame(r, p, q, d, e, "")), 
            p += d + h, p + d > j && (p = g, q += e + h);
            return o;
        },
        JSONData: function(a, b) {
            if (!b.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), 
            void console.log(b);
            for (var d, e = new c.FrameData(), f = b.frames, g = 0; g < f.length; g++) d = e.addFrame(new c.Frame(g, f[g].frame.x, f[g].frame.y, f[g].frame.w, f[g].frame.h, f[g].filename)), 
            f[g].trimmed && d.setTrim(f[g].trimmed, f[g].sourceSize.w, f[g].sourceSize.h, f[g].spriteSourceSize.x, f[g].spriteSourceSize.y, f[g].spriteSourceSize.w, f[g].spriteSourceSize.h);
            return e;
        },
        JSONDataHash: function(a, b) {
            if (!b.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), 
            void console.log(b);
            var d, e = new c.FrameData(), f = b.frames, g = 0;
            for (var h in f) d = e.addFrame(new c.Frame(g, f[h].frame.x, f[h].frame.y, f[h].frame.w, f[h].frame.h, h)), 
            f[h].trimmed && d.setTrim(f[h].trimmed, f[h].sourceSize.w, f[h].sourceSize.h, f[h].spriteSourceSize.x, f[h].spriteSourceSize.y, f[h].spriteSourceSize.w, f[h].spriteSourceSize.h), 
            g++;
            return e;
        },
        XMLData: function(a, b) {
            if (!b.getElementsByTagName("TextureAtlas")) return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
            for (var d, e, f, g, h, i, j, k, l, m, n, o = new c.FrameData(), p = b.getElementsByTagName("SubTexture"), q = 0; q < p.length; q++) f = p[q].attributes, 
            e = f.name.value, g = parseInt(f.x.value, 10), h = parseInt(f.y.value, 10), i = parseInt(f.width.value, 10), 
            j = parseInt(f.height.value, 10), k = null, l = null, f.frameX && (k = Math.abs(parseInt(f.frameX.value, 10)), 
            l = Math.abs(parseInt(f.frameY.value, 10)), m = parseInt(f.frameWidth.value, 10), 
            n = parseInt(f.frameHeight.value, 10)), d = o.addFrame(new c.Frame(q, g, h, i, j, e)), 
            (null !== k || null !== l) && d.setTrim(!0, i, j, k, l, m, n);
            return o;
        }
    }, c.Cache = function(a) {
        this.game = a, this.autoResolveURL = !1, this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {}
        }, this._urlMap = {}, this._urlResolver = new Image(), this._urlTemp = null, this.onSoundUnlock = new c.Signal(), 
        this._cacheMap = [], this._cacheMap[c.Cache.CANVAS] = this._cache.canvas, this._cacheMap[c.Cache.IMAGE] = this._cache.image, 
        this._cacheMap[c.Cache.TEXTURE] = this._cache.texture, this._cacheMap[c.Cache.SOUND] = this._cache.sound, 
        this._cacheMap[c.Cache.TEXT] = this._cache.text, this._cacheMap[c.Cache.PHYSICS] = this._cache.physics, 
        this._cacheMap[c.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[c.Cache.BINARY] = this._cache.binary, 
        this._cacheMap[c.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[c.Cache.BITMAPFONT] = this._cache.bitmapFont, 
        this._cacheMap[c.Cache.JSON] = this._cache.json, this._cacheMap[c.Cache.XML] = this._cache.xml, 
        this._cacheMap[c.Cache.VIDEO] = this._cache.video, this._cacheMap[c.Cache.SHADER] = this._cache.shader, 
        this._cacheMap[c.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), 
        this.addMissingImage();
    }, c.Cache.CANVAS = 1, c.Cache.IMAGE = 2, c.Cache.TEXTURE = 3, c.Cache.SOUND = 4, 
    c.Cache.TEXT = 5, c.Cache.PHYSICS = 6, c.Cache.TILEMAP = 7, c.Cache.BINARY = 8, 
    c.Cache.BITMAPDATA = 9, c.Cache.BITMAPFONT = 10, c.Cache.JSON = 11, c.Cache.XML = 12, 
    c.Cache.VIDEO = 13, c.Cache.SHADER = 14, c.Cache.RENDER_TEXTURE = 15, c.Cache.prototype = {
        addCanvas: function(a, b, c) {
            void 0 === c && (c = b.getContext("2d")), this._cache.canvas[a] = {
                canvas: b,
                context: c
            };
        },
        addImage: function(a, b, d) {
            this.checkImageKey(a) && this.removeImage(a);
            var e = {
                key: a,
                url: b,
                data: d,
                base: new PIXI.BaseTexture(d),
                frame: new c.Frame(0, 0, 0, d.width, d.height, a),
                frameData: new c.FrameData()
            };
            return e.frameData.addFrame(new c.Frame(0, 0, 0, d.width, d.height, b)), this._cache.image[a] = e, 
            this._resolveURL(b, e), e;
        },
        addDefaultImage: function() {
            var a = new Image();
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            var b = this.addImage("__default", null, a);
            PIXI.TextureCache.__default = new PIXI.Texture(b.base);
        },
        addMissingImage: function() {
            var a = new Image();
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            var b = this.addImage("__missing", null, a);
            PIXI.TextureCache.__missing = new PIXI.Texture(b.base);
        },
        addSound: function(a, b, c, d, e) {
            void 0 === d && (d = !0, e = !1), void 0 === e && (d = !1, e = !0);
            var f = !1;
            e && (f = !0), this._cache.sound[a] = {
                url: b,
                data: c,
                isDecoding: !1,
                decoded: f,
                webAudio: d,
                audioTag: e,
                locked: this.game.sound.touchLocked
            }, this._resolveURL(b, this._cache.sound[a]);
        },
        addText: function(a, b, c) {
            this._cache.text[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.text[a]);
        },
        addPhysicsData: function(a, b, c, d) {
            this._cache.physics[a] = {
                url: b,
                data: c,
                format: d
            }, this._resolveURL(b, this._cache.physics[a]);
        },
        addTilemap: function(a, b, c, d) {
            this._cache.tilemap[a] = {
                url: b,
                data: c,
                format: d
            }, this._resolveURL(b, this._cache.tilemap[a]);
        },
        addBinary: function(a, b) {
            this._cache.binary[a] = b;
        },
        addBitmapData: function(a, b, d) {
            return b.key = a, void 0 === d && (d = new c.FrameData(), d.addFrame(b.textureFrame)), 
            this._cache.bitmapData[a] = {
                data: b,
                frameData: d
            }, b;
        },
        addBitmapFont: function(a, b, d, e, f, g, h) {
            var i = {
                url: b,
                data: d,
                font: null,
                base: new PIXI.BaseTexture(d)
            };
            i.font = "json" === f ? c.LoaderParser.jsonBitmapFont(e, i.base, g, h) : c.LoaderParser.xmlBitmapFont(e, i.base, g, h), 
            this._cache.bitmapFont[a] = i, this._resolveURL(b, i);
        },
        addJSON: function(a, b, c) {
            this._cache.json[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.json[a]);
        },
        addXML: function(a, b, c) {
            this._cache.xml[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.xml[a]);
        },
        addVideo: function(a, b, c, d) {
            this._cache.video[a] = {
                url: b,
                data: c,
                isBlob: d,
                locked: !0
            }, this._resolveURL(b, this._cache.video[a]);
        },
        addShader: function(a, b, c) {
            this._cache.shader[a] = {
                url: b,
                data: c
            }, this._resolveURL(b, this._cache.shader[a]);
        },
        addRenderTexture: function(a, b) {
            this._cache.renderTexture[a] = {
                texture: b,
                frame: new c.Frame(0, 0, 0, b.width, b.height, "", "")
            };
        },
        addSpriteSheet: function(a, b, d, e, f, g, h, i) {
            void 0 === g && (g = -1), void 0 === h && (h = 0), void 0 === i && (i = 0);
            var j = {
                key: a,
                url: b,
                data: d,
                frameWidth: e,
                frameHeight: f,
                margin: h,
                spacing: i,
                base: new PIXI.BaseTexture(d),
                frameData: c.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i)
            };
            this._cache.image[a] = j, this._resolveURL(b, j);
        },
        addTextureAtlas: function(a, b, d, e, f) {
            var g = {
                key: a,
                url: b,
                data: d,
                base: new PIXI.BaseTexture(d)
            };
            g.frameData = f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? c.AnimationParser.XMLData(this.game, e, a) : Array.isArray(e.frames) ? c.AnimationParser.JSONData(this.game, e, a) : c.AnimationParser.JSONDataHash(this.game, e, a), 
            this._cache.image[a] = g, this._resolveURL(b, g);
        },
        reloadSound: function(a) {
            var b = this, c = this.getSound(a);
            c && (c.data.src = c.url, c.data.addEventListener("canplaythrough", function() {
                return b.reloadSoundComplete(a);
            }, !1), c.data.load());
        },
        reloadSoundComplete: function(a) {
            var b = this.getSound(a);
            b && (b.locked = !1, this.onSoundUnlock.dispatch(a));
        },
        updateSound: function(a, b, c) {
            var d = this.getSound(a);
            d && (d[b] = c);
        },
        decodedSound: function(a, b) {
            var c = this.getSound(a);
            c.data = b, c.decoded = !0, c.isDecoding = !1;
        },
        isSoundDecoded: function(a) {
            var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
            return b ? b.decoded : void 0;
        },
        isSoundReady: function(a) {
            var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
            return b ? b.decoded && !this.game.sound.touchLocked : void 0;
        },
        checkKey: function(a, b) {
            return this._cacheMap[a][b] ? !0 : !1;
        },
        checkURL: function(a) {
            return this._urlMap[this._resolveURL(a)] ? !0 : !1;
        },
        checkCanvasKey: function(a) {
            return this.checkKey(c.Cache.CANVAS, a);
        },
        checkImageKey: function(a) {
            return this.checkKey(c.Cache.IMAGE, a);
        },
        checkTextureKey: function(a) {
            return this.checkKey(c.Cache.TEXTURE, a);
        },
        checkSoundKey: function(a) {
            return this.checkKey(c.Cache.SOUND, a);
        },
        checkTextKey: function(a) {
            return this.checkKey(c.Cache.TEXT, a);
        },
        checkPhysicsKey: function(a) {
            return this.checkKey(c.Cache.PHYSICS, a);
        },
        checkTilemapKey: function(a) {
            return this.checkKey(c.Cache.TILEMAP, a);
        },
        checkBinaryKey: function(a) {
            return this.checkKey(c.Cache.BINARY, a);
        },
        checkBitmapDataKey: function(a) {
            return this.checkKey(c.Cache.BITMAPDATA, a);
        },
        checkBitmapFontKey: function(a) {
            return this.checkKey(c.Cache.BITMAPFONT, a);
        },
        checkJSONKey: function(a) {
            return this.checkKey(c.Cache.JSON, a);
        },
        checkXMLKey: function(a) {
            return this.checkKey(c.Cache.XML, a);
        },
        checkVideoKey: function(a) {
            return this.checkKey(c.Cache.VIDEO, a);
        },
        checkShaderKey: function(a) {
            return this.checkKey(c.Cache.SHADER, a);
        },
        checkRenderTextureKey: function(a) {
            return this.checkKey(c.Cache.RENDER_TEXTURE, a);
        },
        getItem: function(a, b, c, d) {
            return this.checkKey(b, a) ? void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : (c && console.warn("Phaser.Cache." + c + ': Key "' + a + '" not found in Cache.'), 
            null);
        },
        getCanvas: function(a) {
            return this.getItem(a, c.Cache.CANVAS, "getCanvas", "canvas");
        },
        getImage: function(a, b) {
            (void 0 === a || null === a) && (a = "__default"), void 0 === b && (b = !1);
            var d = this.getItem(a, c.Cache.IMAGE, "getImage");
            return null === d && (d = this.getItem("__missing", c.Cache.IMAGE, "getImage")), 
            b ? d : d.data;
        },
        getTextureFrame: function(a) {
            return this.getItem(a, c.Cache.TEXTURE, "getTextureFrame", "frame");
        },
        getSound: function(a) {
            return this.getItem(a, c.Cache.SOUND, "getSound");
        },
        getSoundData: function(a) {
            return this.getItem(a, c.Cache.SOUND, "getSoundData", "data");
        },
        getText: function(a) {
            return this.getItem(a, c.Cache.TEXT, "getText", "data");
        },
        getPhysicsData: function(a, b, d) {
            var e = this.getItem(a, c.Cache.PHYSICS, "getPhysicsData", "data");
            if (null === e || void 0 === b || null === b) return e;
            if (e[b]) {
                var f = e[b];
                if (!f || !d) return f;
                for (var g in f) if (g = f[g], g.fixtureKey === d) return g;
                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + d + " in " + a + '"');
            } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + a + " / " + b + '"');
            return null;
        },
        getTilemapData: function(a) {
            return this.getItem(a, c.Cache.TILEMAP, "getTilemapData");
        },
        getBinary: function(a) {
            return this.getItem(a, c.Cache.BINARY, "getBinary");
        },
        getBitmapData: function(a) {
            return this.getItem(a, c.Cache.BITMAPDATA, "getBitmapData", "data");
        },
        getBitmapFont: function(a) {
            return this.getItem(a, c.Cache.BITMAPFONT, "getBitmapFont");
        },
        getJSON: function(a, b) {
            var d = this.getItem(a, c.Cache.JSON, "getJSON", "data");
            return d ? b ? c.Utils.extend(!0, d) : d : null;
        },
        getXML: function(a) {
            return this.getItem(a, c.Cache.XML, "getXML", "data");
        },
        getVideo: function(a) {
            return this.getItem(a, c.Cache.VIDEO, "getVideo");
        },
        getShader: function(a) {
            return this.getItem(a, c.Cache.SHADER, "getShader", "data");
        },
        getRenderTexture: function(a) {
            return this.getItem(a, c.Cache.RENDER_TEXTURE, "getRenderTexture");
        },
        getBaseTexture: function(a, b) {
            return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getBaseTexture", "base");
        },
        getFrame: function(a, b) {
            return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrame", "frame");
        },
        getFrameCount: function(a, b) {
            var c = this.getFrameData(a, b);
            return c ? c.total : 0;
        },
        getFrameData: function(a, b) {
            return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrameData", "frameData");
        },
        hasFrameData: function(a, b) {
            return void 0 === b && (b = c.Cache.IMAGE), null !== this.getItem(a, b, "", "frameData");
        },
        updateFrameData: function(a, b, d) {
            void 0 === d && (d = c.Cache.IMAGE), this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = b);
        },
        getFrameByIndex: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrame(b) : null;
        },
        getFrameByName: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrameByName(b) : null;
        },
        getPixiTexture: function(a) {
            if (PIXI.TextureCache[a]) return PIXI.TextureCache[a];
            var b = this.getPixiBaseTexture(a);
            return b ? new PIXI.Texture(b) : null;
        },
        getPixiBaseTexture: function(a) {
            if (PIXI.BaseTextureCache[a]) return PIXI.BaseTextureCache[a];
            var b = this.getItem(a, c.Cache.IMAGE, "getPixiBaseTexture");
            return null !== b ? b.base : null;
        },
        getURL: function(a) {
            var a = this._resolveURL(a);
            return a ? this._urlMap[a] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + a + '" or Cache.autoResolveURL was false'), 
            null);
        },
        getKeys: function(a) {
            void 0 === a && (a = c.Cache.IMAGE);
            var b = [];
            if (this._cacheMap[a]) for (var d in this._cacheMap[a]) "__default" !== d && "__missing" !== d && b.push(d);
            return b;
        },
        removeCanvas: function(a) {
            delete this._cache.canvas[a];
        },
        removeImage: function(a, b) {
            void 0 === b && (b = !0);
            var c = this.getImage(a, !0);
            b && c.base && c.base.destroy(), delete this._cache.image[a];
        },
        removeSound: function(a) {
            delete this._cache.sound[a];
        },
        removeText: function(a) {
            delete this._cache.text[a];
        },
        removePhysics: function(a) {
            delete this._cache.physics[a];
        },
        removeTilemap: function(a) {
            delete this._cache.tilemap[a];
        },
        removeBinary: function(a) {
            delete this._cache.binary[a];
        },
        removeBitmapData: function(a) {
            delete this._cache.bitmapData[a];
        },
        removeBitmapFont: function(a) {
            delete this._cache.bitmapFont[a];
        },
        removeJSON: function(a) {
            delete this._cache.json[a];
        },
        removeXML: function(a) {
            delete this._cache.xml[a];
        },
        removeVideo: function(a) {
            delete this._cache.video[a];
        },
        removeShader: function(a) {
            delete this._cache.shader[a];
        },
        removeRenderTexture: function(a) {
            delete this._cache.renderTexture[a];
        },
        removeSpriteSheet: function(a) {
            delete this._cache.spriteSheet[a];
        },
        removeTextureAtlas: function(a) {
            delete this._cache.atlas[a];
        },
        clearGLTextures: function() {
            for (var a in this.cache.image) this.cache.image[a].base._glTextures = [];
        },
        _resolveURL: function(a, b) {
            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a, 
            this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", b && (this._urlMap[this._urlTemp] = b), 
            this._urlTemp) : null;
        },
        destroy: function() {
            for (var a = 0; a < this._cacheMap.length; a++) {
                var b = this._cacheMap[a];
                for (var c in b) "__default" !== c && "__missing" !== c && (b[c].destroy && b[c].destroy(), 
                delete b[c]);
            }
            this._urlMap = null, this._urlResolver = null, this._urlTemp = null;
        }
    }, c.Cache.prototype.constructor = c.Cache, c.Loader = function(a) {
        this.game = a, this.cache = a.cache, this.resetLocked = !1, this.isLoading = !1, 
        this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", 
        this.path = "", this.onLoadStart = new c.Signal(), this.onLoadComplete = new c.Signal(), 
        this.onPackComplete = new c.Signal(), this.onFileStart = new c.Signal(), this.onFileComplete = new c.Signal(), 
        this.onFileError = new c.Signal(), this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, 
        this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, 
        this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, 
        this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0;
    }, c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, c.Loader.TEXTURE_ATLAS_JSON_HASH = 1, 
    c.Loader.TEXTURE_ATLAS_XML_STARLING = 2, c.Loader.PHYSICS_LIME_CORONA_JSON = 3, 
    c.Loader.PHYSICS_PHASER_JSON = 4, c.Loader.prototype = {
        setPreloadSprite: function(a, b) {
            b = b || 0, this.preloadSprite = {
                sprite: a,
                direction: b,
                width: a.width,
                height: a.height,
                rect: null
            }, this.preloadSprite.rect = 0 === b ? new c.Rectangle(0, 0, 1, a.height) : new c.Rectangle(0, 0, a.width, 1), 
            a.crop(this.preloadSprite.rect), a.visible = !0;
        },
        resize: function() {
            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height);
        },
        checkKeyExists: function(a, b) {
            return this.getAssetIndex(a, b) > -1;
        },
        getAssetIndex: function(a, b) {
            for (var c = -1, d = 0; d < this._fileList.length; d++) {
                var e = this._fileList[d];
                if (e.type === a && e.key === b && (c = d, !e.loaded && !e.loading)) break;
            }
            return c;
        },
        getAsset: function(a, b) {
            var c = this.getAssetIndex(a, b);
            return c > -1 ? {
                index: c,
                file: this._fileList[c]
            } : !1;
        },
        reset: function(a, b) {
            void 0 === b && (b = !1), this.resetLocked || (a && (this.preloadSprite = null), 
            this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, 
            this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, 
            this._loadedPackCount = 0, this._loadedFileCount = 0, b && (this.onLoadStart.removeAll(), 
            this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), 
            this.onFileComplete.removeAll(), this.onFileError.removeAll()));
        },
        addToFileList: function(a, b, c, d, e, f) {
            if (void 0 === e && (e = !1), void 0 === b || "" === b) return console.warn("Phaser.Loader: Invalid or no key given of type " + a), 
            this;
            if (void 0 === c || null === c) {
                if (!f) return console.warn("Phaser.Loader: No URL given for file type: " + a + " key: " + b), 
                this;
                c = b + f;
            }
            var g = {
                type: a,
                key: b,
                path: this.path,
                url: c,
                syncPoint: this._withSyncPointDepth > 0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (d) for (var h in d) g[h] = d[h];
            var i = this.getAssetIndex(a, b);
            if (e && i > -1) {
                var j = this._fileList[i];
                j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : this._fileList[i] = g;
            } else -1 === i && (this._fileList.push(g), this._totalFileCount++);
            return this;
        },
        replaceInFileList: function(a, b, c, d) {
            return this.addToFileList(a, b, c, d, !0);
        },
        pack: function(a, b, c, d) {
            if (void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null), 
            !b && !c) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), 
            this;
            var e = {
                type: "packfile",
                key: a,
                url: b,
                path: this.path,
                syncPoint: !0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1,
                callbackContext: d
            };
            c && ("string" == typeof c && (c = JSON.parse(c)), e.data = c || {}, e.loaded = !0);
            for (var f = 0; f < this._fileList.length + 1; f++) {
                var g = this._fileList[f];
                if (!g || !g.loaded && !g.loading && "packfile" !== g.type) {
                    this._fileList.splice(f, 1, e), this._totalPackCount++;
                    break;
                }
            }
            return this;
        },
        image: function(a, b, c) {
            return this.addToFileList("image", a, b, void 0, c, ".png");
        },
        images: function(a, b) {
            if (Array.isArray(b)) for (var c = 0; c < a.length; c++) this.image(a[c], b[c]); else for (var c = 0; c < a.length; c++) this.image(a[c]);
            return this;
        },
        text: function(a, b, c) {
            return this.addToFileList("text", a, b, void 0, c, ".txt");
        },
        json: function(a, b, c) {
            return this.addToFileList("json", a, b, void 0, c, ".json");
        },
        shader: function(a, b, c) {
            return this.addToFileList("shader", a, b, void 0, c, ".frag");
        },
        xml: function(a, b, c) {
            return this.addToFileList("xml", a, b, void 0, c, ".xml");
        },
        script: function(a, b, c, d) {
            return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = this), this.addToFileList("script", a, b, {
                syncPoint: !0,
                callback: c,
                callbackContext: d
            }, !1, ".js");
        },
        binary: function(a, b, c, d) {
            return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = c), this.addToFileList("binary", a, b, {
                callback: c,
                callbackContext: d
            }, !1, ".bin");
        },
        spritesheet: function(a, b, c, d, e, f, g) {
            return void 0 === e && (e = -1), void 0 === f && (f = 0), void 0 === g && (g = 0), 
            this.addToFileList("spritesheet", a, b, {
                frameWidth: c,
                frameHeight: d,
                frameMax: e,
                margin: f,
                spacing: g
            }, !1, ".png");
        },
        audio: function(a, b, c) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = !0), "string" == typeof b && (b = [ b ]), 
            this.addToFileList("audio", a, b, {
                buffer: null,
                autoDecode: c
            }));
        },
        audiosprite: function(a, b, c, d, e) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = null), void 0 === d && (d = null), 
            void 0 === e && (e = !0), this.audio(a, b, e), c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)), 
            this.cache.addJSON(a + "-audioatlas", "", d)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), 
            this);
        },
        video: function(a, b, c, d) {
            return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"), 
            void 0 === d && (d = !1), "string" == typeof b && (b = [ b ]), this.addToFileList("video", a, b, {
                buffer: null,
                asBlob: d,
                loadEvent: c
            });
        },
        tilemap: function(a, b, d, e) {
            if (void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Tilemap.CSV), 
            b || d || (b = e === c.Tilemap.CSV ? a + ".csv" : a + ".json"), d) {
                switch (e) {
                  case c.Tilemap.CSV:
                    break;

                  case c.Tilemap.TILED_JSON:
                    "string" == typeof d && (d = JSON.parse(d));
                }
                this.cache.addTilemap(a, null, d, e);
            } else this.addToFileList("tilemap", a, b, {
                format: e
            });
            return this;
        },
        physics: function(a, b, d, e) {
            return void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Physics.LIME_CORONA_JSON), 
            b || d || (b = a + ".json"), d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, {
                format: e
            }), this;
        },
        bitmapFont: function(a, b, c, d, e, f) {
            if ((void 0 === b || null === b) && (b = a + ".png"), void 0 === c && (c = null), 
            void 0 === d && (d = null), void 0 === e && (e = 0), void 0 === f && (f = 0), c) this.addToFileList("bitmapfont", a, b, {
                atlasURL: c,
                xSpacing: e,
                ySpacing: f
            }); else if ("string" == typeof d) {
                var g, h;
                try {
                    g = JSON.parse(d);
                } catch (i) {
                    h = this.parseXml(d);
                }
                if (!h && !g) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                this.addToFileList("bitmapfont", a, b, {
                    atlasURL: null,
                    atlasData: g || h,
                    atlasType: g ? "json" : "xml",
                    xSpacing: e,
                    ySpacing: f
                });
            }
            return this;
        },
        atlasJSONArray: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function(a, b, d, e) {
            return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function(a, b, d, e) {
            return void 0 === d && (d = null), void 0 === e && (e = null), d || e || (d = a + ".xml"), 
            this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function(a, b, d, e, f) {
            if ((void 0 === b || null === b) && (b = a + ".png"), void 0 === d && (d = null), 
            void 0 === e && (e = null), void 0 === f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY), 
            d || e || (d = f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"), 
            d) this.addToFileList("textureatlas", a, b, {
                atlasURL: d,
                format: f
            }); else {
                switch (f) {
                  case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    "string" == typeof e && (e = JSON.parse(e));
                    break;

                  case c.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if ("string" == typeof e) {
                        var g = this.parseXml(e);
                        if (!g) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        e = g;
                    }
                }
                this.addToFileList("textureatlas", a, b, {
                    atlasURL: null,
                    atlasData: e,
                    format: f
                });
            }
            return this;
        },
        withSyncPoint: function(a, b) {
            this._withSyncPointDepth++;
            try {
                a.call(b || this, this);
            } finally {
                this._withSyncPointDepth--;
            }
            return this;
        },
        addSyncPoint: function(a, b) {
            var c = this.getAsset(a, b);
            return c && (c.file.syncPoint = !0), this;
        },
        removeFile: function(a, b) {
            var c = this.getAsset(a, b);
            c && (c.loaded || c.loading || this._fileList.splice(c.index, 1));
        },
        removeAll: function() {
            this._fileList.length = 0, this._flightQueue.length = 0;
        },
        start: function() {
            this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), 
            this.processLoadQueue());
        },
        processLoadQueue: function() {
            if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), 
            void this.finishedLoading(!0);
            for (var a = 0; a < this._flightQueue.length; a++) {
                var b = this._flightQueue[a];
                (b.loaded || b.error) && (this._flightQueue.splice(a, 1), a--, b.loading = !1, b.requestUrl = null, 
                b.requestObject = null, b.error && this.onFileError.dispatch(b.key, b), "packfile" !== b.type ? (this._loadedFileCount++, 
                this.onFileComplete.dispatch(this.progress, b.key, !b.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === b.type && b.error && (this._loadedPackCount++, 
                this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)));
            }
            for (var d = !1, e = this.enableParallel ? c.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, a = this._processingHead; a < this._fileList.length; a++) {
                var b = this._fileList[a];
                if ("packfile" === b.type && !b.error && b.loaded && a === this._processingHead && (this.processPack(b), 
                this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)), 
                b.loaded || b.error ? a === this._processingHead && (this._processingHead = a + 1) : !b.loading && this._flightQueue.length < e && ("packfile" !== b.type || b.data ? d || (this._fileLoadStarted || (this._fileLoadStarted = !0, 
                this.onLoadStart.dispatch()), this._flightQueue.push(b), b.loading = !0, this.onFileStart.dispatch(this.progress, b.key, b.url), 
                this.loadFile(b)) : (this._flightQueue.push(b), b.loading = !0, this.loadFile(b))), 
                !b.loaded && b.syncPoint && (d = !0), this._flightQueue.length >= e || d && this._loadedPackCount === this._totalPackCount) break;
            }
            if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading(); else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var f = this;
                setTimeout(function() {
                    f.finishedLoading(!0);
                }, 2e3);
            }
        },
        finishedLoading: function(a) {
            this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, a || this._fileLoadStarted || (this._fileLoadStarted = !0, 
            this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.reset(), this.game.state.loadComplete());
        },
        asyncComplete: function(a, b) {
            void 0 === b && (b = ""), a.loaded = !0, a.error = !!b, b && (a.errorMessage = b, 
            console.warn("Phaser.Loader - " + a.type + "[" + a.key + "]: " + b)), this.processLoadQueue();
        },
        processPack: function(a) {
            var b = a.data[a.key];
            if (!b) return void console.warn("Phaser.Loader - " + a.key + ": pack has data, but not for pack key");
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                switch (e.type) {
                  case "image":
                    this.image(e.key, e.url, e.overwrite);
                    break;

                  case "text":
                    this.text(e.key, e.url, e.overwrite);
                    break;

                  case "json":
                    this.json(e.key, e.url, e.overwrite);
                    break;

                  case "xml":
                    this.xml(e.key, e.url, e.overwrite);
                    break;

                  case "script":
                    this.script(e.key, e.url, e.callback, a.callbackContext || this);
                    break;

                  case "binary":
                    this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                    break;

                  case "spritesheet":
                    this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                    break;

                  case "video":
                    this.video(e.key, e.urls);
                    break;

                  case "audio":
                    this.audio(e.key, e.urls, e.autoDecode);
                    break;

                  case "audiosprite":
                    this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                    break;

                  case "tilemap":
                    this.tilemap(e.key, e.url, e.data, c.Tilemap[e.format]);
                    break;

                  case "physics":
                    this.physics(e.key, e.url, e.data, c.Loader[e.format]);
                    break;

                  case "bitmapFont":
                    this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                    break;

                  case "atlasJSONArray":
                    this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;

                  case "atlasJSONHash":
                    this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;

                  case "atlasXML":
                    this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;

                  case "atlas":
                    this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, c.Loader[e.format]);
                    break;

                  case "shader":
                    this.shader(e.key, e.url, e.overwrite);
                }
            }
        },
        transformUrl: function(a, b) {
            return a ? "http" === a.substr(0, 4) || "//" === a.substr(0, 2) ? a : this.baseURL + b.path + a : !1;
        },
        loadFile: function(a) {
            switch (a.type) {
              case "packfile":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                break;

              case "image":
              case "spritesheet":
              case "textureatlas":
              case "bitmapfont":
                this.loadImageTag(a);
                break;

              case "audio":
                a.url = this.getAudioURL(a.url), a.url ? this.game.sound.usingWebAudio ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(a) : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
                break;

              case "video":
                a.url = this.getVideoURL(a.url), a.url ? a.asBlob ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.loadVideoTag(a) : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
                break;

              case "json":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
                break;

              case "xml":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
                break;

              case "tilemap":
                a.format === c.Tilemap.TILED_JSON ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete) : a.format === c.Tilemap.CSV ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete) : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
                break;

              case "text":
              case "script":
              case "shader":
              case "physics":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                break;

              case "binary":
                this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
            }
        },
        loadImageTag: function(a) {
            var b = this;
            a.data = new Image(), a.data.name = a.key, this.crossOrigin && (a.data.crossOrigin = this.crossOrigin), 
            a.data.onload = function() {
                a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileComplete(a));
            }, a.data.onerror = function() {
                a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileError(a));
            }, a.data.src = this.transformUrl(a.url, a), a.data.complete && a.data.width && a.data.height && (a.data.onload = null, 
            a.data.onerror = null, this.fileComplete(a));
        },
        loadVideoTag: function(a) {
            var b = this;
            a.data = document.createElement("video"), a.data.name = a.key, a.data.controls = !1, 
            a.data.autoplay = !1;
            var d = function() {
                a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !0, 
                c.GAMES[b.game.id].load.fileComplete(a);
            };
            a.data.onerror = function() {
                a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !1, 
                b.fileError(a);
            }, a.data.addEventListener(a.loadEvent, d, !1), a.data.src = this.transformUrl(a.url, a), 
            a.data.load();
        },
        loadAudioTag: function(a) {
            var b = this;
            if (this.game.sound.touchLocked) a.data = new Audio(), a.data.name = a.key, a.data.preload = "auto", 
            a.data.src = this.transformUrl(a.url, a), this.fileComplete(a); else {
                a.data = new Audio(), a.data.name = a.key;
                var d = function() {
                    a.data.removeEventListener("canplaythrough", d, !1), a.data.onerror = null, c.GAMES[b.game.id].load.fileComplete(a);
                };
                a.data.onerror = function() {
                    a.data.removeEventListener("canplaythrough", d, !1), a.data.onerror = null, b.fileError(a);
                }, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), a.data.addEventListener("canplaythrough", d, !1), 
                a.data.load();
            }
        },
        xhrLoad: function(a, b, c, d, e) {
            if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(a, b, c, d, e);
            var f = new XMLHttpRequest();
            f.open("GET", b, !0), f.responseType = c, e = e || this.fileError;
            var g = this;
            f.onload = function() {
                try {
                    return d.call(g, a, f);
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception");
                }
            }, f.onerror = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception");
                }
            }, a.requestObject = f, a.requestUrl = b, f.send();
        },
        xhrLoadWithXDR: function(a, b, c, d, e) {
            this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0, 
            console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
            var f = new window.XDomainRequest();
            f.open("GET", b, !0), f.responseType = c, f.timeout = 3e3, e = e || this.fileError;
            var g = this;
            f.onerror = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, f.ontimeout = function() {
                try {
                    return e.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, f.onprogress = function() {}, f.onload = function() {
                try {
                    return d.call(g, a, f);
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception");
                }
            }, a.requestObject = f, a.requestUrl = b, setTimeout(function() {
                f.send();
            }, 0);
        },
        getVideoURL: function(a) {
            for (var b = 0; b < a.length; b++) {
                var c, d = a[b];
                if (d.uri) d = d.uri, c = d.type; else {
                    if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                    d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                    var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                    c = e.toLowerCase();
                }
                if (this.game.device.canPlayVideo(c)) return a[b];
            }
            return null;
        },
        getAudioURL: function(a) {
            if (this.game.sound.noAudio) return null;
            for (var b = 0; b < a.length; b++) {
                var c, d = a[b];
                if (d.uri) d = d.uri, c = d.type; else {
                    if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                    d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                    var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                    c = e.toLowerCase();
                }
                if (this.game.device.canPlayAudio(c)) return a[b];
            }
            return null;
        },
        fileError: function(a, b, c) {
            var d = a.requestUrl || this.transformUrl(a.url, a), e = "error loading asset from URL " + d;
            !c && b && (c = b.status), c && (e = e + " (" + c + ")"), this.asyncComplete(a, e);
        },
        fileComplete: function(a, b) {
            var d = !0;
            switch (a.type) {
              case "packfile":
                var e = JSON.parse(b.responseText);
                a.data = e || {};
                break;

              case "image":
                this.cache.addImage(a.key, a.url, a.data);
                break;

              case "spritesheet":
                this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
                break;

              case "textureatlas":
                if (null == a.atlasURL) this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format); else if (d = !1, 
                a.format == c.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format == c.Loader.TEXTURE_ATLAS_JSON_HASH) this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete); else {
                    if (a.format != c.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                    this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete);
                }
                break;

              case "bitmapfont":
                a.atlasURL ? (d = !1, this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function(a, b) {
                    var c;
                    try {
                        c = JSON.parse(b.responseText);
                    } catch (d) {}
                    c ? (a.atlasType = "json", this.jsonLoadComplete(a, b)) : (a.atlasType = "xml", 
                    this.xmlLoadComplete(a, b));
                })) : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
                break;

              case "video":
                if (a.asBlob) try {
                    a.data = new Blob([ new Uint8Array(b.response) ]);
                } catch (f) {
                    throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key);
                }
                this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
                break;

              case "audio":
                this.game.sound.usingWebAudio ? (a.data = b.response, this.cache.addSound(a.key, a.url, a.data, !0, !1), 
                a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
                break;

              case "text":
                a.data = b.responseText, this.cache.addText(a.key, a.url, a.data);
                break;

              case "shader":
                a.data = b.responseText, this.cache.addShader(a.key, a.url, a.data);
                break;

              case "physics":
                var e = JSON.parse(b.responseText);
                this.cache.addPhysicsData(a.key, a.url, e, a.format);
                break;

              case "script":
                a.data = document.createElement("script"), a.data.language = "javascript", a.data.type = "text/javascript", 
                a.data.defer = !1, a.data.text = b.responseText, document.head.appendChild(a.data), 
                a.callback && (a.data = a.callback.call(a.callbackContext, a.key, b.responseText));
                break;

              case "binary":
                a.data = a.callback ? a.callback.call(a.callbackContext, a.key, b.response) : b.response, 
                this.cache.addBinary(a.key, a.data);
            }
            d && this.asyncComplete(a);
        },
        jsonLoadComplete: function(a, b) {
            var c = JSON.parse(b.responseText);
            "tilemap" === a.type ? this.cache.addTilemap(a.key, a.url, c, a.format) : "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing) : "json" === a.type ? this.cache.addJSON(a.key, a.url, c) : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format), 
            this.asyncComplete(a);
        },
        csvLoadComplete: function(a, b) {
            var c = b.responseText;
            this.cache.addTilemap(a.key, a.url, c, a.format), this.asyncComplete(a);
        },
        xmlLoadComplete: function(a, b) {
            var c = b.responseText, d = this.parseXml(c);
            if (!d) {
                var e = b.responseType || b.contentType;
                return console.warn("Phaser.Loader - " + a.key + ": invalid XML (" + e + ")"), void this.asyncComplete(a, "invalid XML");
            }
            "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing) : "textureatlas" === a.type ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format) : "xml" === a.type && this.cache.addXML(a.key, a.url, d), 
            this.asyncComplete(a);
        },
        parseXml: function(a) {
            var b;
            try {
                if (window.DOMParser) {
                    var c = new DOMParser();
                    b = c.parseFromString(a, "text/xml");
                } else b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a);
            } catch (d) {
                b = null;
            }
            return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null;
        },
        updateProgress: function() {
            this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), 
            this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null);
        },
        totalLoadedFiles: function() {
            return this._loadedFileCount;
        },
        totalQueuedFiles: function() {
            return this._totalFileCount - this._loadedFileCount;
        },
        totalLoadedPacks: function() {
            return this._totalPackCount;
        },
        totalQueuedPacks: function() {
            return this._totalPackCount - this._loadedPackCount;
        }
    }, Object.defineProperty(c.Loader.prototype, "progressFloat", {
        get: function() {
            var a = this._loadedFileCount / this._totalFileCount * 100;
            return c.Math.clamp(a || 0, 0, 100);
        }
    }), Object.defineProperty(c.Loader.prototype, "progress", {
        get: function() {
            return Math.round(this.progressFloat);
        }
    }), c.Loader.prototype.constructor = c.Loader, c.LoaderParser = {
        bitmapFont: function(a, b, c, d) {
            return this.xmlBitmapFont(a, b, c, d);
        },
        xmlBitmapFont: function(a, b, c, d) {
            var e = {}, f = a.getElementsByTagName("info")[0], g = a.getElementsByTagName("common")[0];
            e.font = f.getAttribute("face"), e.size = parseInt(f.getAttribute("size"), 10), 
            e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d, e.chars = {};
            for (var h = a.getElementsByTagName("char"), i = 0; i < h.length; i++) {
                var j = parseInt(h[i].getAttribute("id"), 10);
                e.chars[j] = {
                    x: parseInt(h[i].getAttribute("x"), 10),
                    y: parseInt(h[i].getAttribute("y"), 10),
                    width: parseInt(h[i].getAttribute("width"), 10),
                    height: parseInt(h[i].getAttribute("height"), 10),
                    xOffset: parseInt(h[i].getAttribute("xoffset"), 10),
                    yOffset: parseInt(h[i].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c,
                    kerning: {}
                };
            }
            var k = a.getElementsByTagName("kerning");
            for (i = 0; i < k.length; i++) {
                var l = parseInt(k[i].getAttribute("first"), 10), m = parseInt(k[i].getAttribute("second"), 10), n = parseInt(k[i].getAttribute("amount"), 10);
                e.chars[m].kerning[l] = n;
            }
            return this.finalizeBitmapFont(b, e);
        },
        jsonBitmapFont: function(a, b, c, d) {
            var e = {
                font: a.font.info._face,
                size: parseInt(a.font.info._size, 10),
                lineHeight: parseInt(a.font.common._lineHeight, 10) + d,
                chars: {}
            };
            return a.font.chars["char"].forEach(function(a) {
                var b = parseInt(a._id, 10);
                e.chars[b] = {
                    x: parseInt(a._x, 10),
                    y: parseInt(a._y, 10),
                    width: parseInt(a._width, 10),
                    height: parseInt(a._height, 10),
                    xOffset: parseInt(a._xoffset, 10),
                    yOffset: parseInt(a._yoffset, 10),
                    xAdvance: parseInt(a._xadvance, 10) + c,
                    kerning: {}
                };
            }), a.font.kernings && a.font.kernings.kerning && a.font.kernings.kerning.forEach(function(a) {
                e.chars[a._second].kerning[a._first] = parseInt(a._amount, 10);
            }), this.finalizeBitmapFont(b, e);
        },
        finalizeBitmapFont: function(a, b) {
            return Object.keys(b.chars).forEach(function(d) {
                var e = b.chars[d];
                e.texture = new PIXI.Texture(a, new c.Rectangle(e.x, e.y, e.width, e.height));
            }), b;
        }
    }, c.AudioSprite = function(a, b) {
        this.game = a, this.key = b, this.config = this.game.cache.getJSON(b + "-audioatlas"), 
        this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
        for (var c in this.config.spritemap) {
            var d = this.config.spritemap[c], e = this.game.add.sound(this.key);
            e.addMarker(c, d.start, d.end - d.start, null, d.loop), this.sounds[c] = e;
        }
        this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), 
        this.autoplay = this.sounds[this.autoplayKey]);
    }, c.AudioSprite.prototype = {
        play: function(a, b) {
            return void 0 === b && (b = 1), this.sounds[a].play(a, null, b);
        },
        stop: function(a) {
            if (a) this.sounds[a].stop(); else for (var b in this.sounds) this.sounds[b].stop();
        },
        get: function(a) {
            return this.sounds[a];
        }
    }, c.AudioSprite.prototype.constructor = c.AudioSprite, c.Sound = function(a, b, d, e, f) {
        void 0 === d && (d = 1), void 0 === e && (e = !1), void 0 === f && (f = a.sound.connectToMaster), 
        this.game = a, this.name = b, this.key = b, this.loop = e, this.volume = d, this.markers = {}, 
        this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, 
        this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, 
        this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, 
        this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, 
        this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, 
        this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, 
        this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, 
        this.masterGainNode = this.game.sound.masterGain, this.gainNode = void 0 === this.context.createGain ? this.context.createGainNode() : this.context.createGain(), 
        this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), 
        this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), 
        this.onDecoded = new c.Signal(), this.onPlay = new c.Signal(), this.onPause = new c.Signal(), 
        this.onResume = new c.Signal(), this.onLoop = new c.Signal(), this.onStop = new c.Signal(), 
        this.onMute = new c.Signal(), this.onMarkerComplete = new c.Signal(), this.onFadeComplete = new c.Signal(), 
        this._volume = d, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, 
        this._tempVolume = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, 
        this._onDecodedEventDispatched = !1;
    }, c.Sound.prototype = {
        soundHasUnlocked: function(a) {
            a === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration);
        },
        addMarker: function(a, b, c, d, e) {
            (void 0 === d || null === d) && (d = 1), void 0 === e && (e = !1), this.markers[a] = {
                name: a,
                start: b,
                stop: b + c,
                volume: d,
                duration: c,
                durationMS: 1e3 * c,
                loop: e
            };
        },
        removeMarker: function(a) {
            delete this.markers[a];
        },
        onEndedHandler: function() {
            this.isPlaying = !1, this.stop();
        },
        update: function() {
            return this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), 
            this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, 
            this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), 
            void (this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, 
            this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), 
            "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time) : (this.onMarkerComplete.dispatch(this.currentMarker, this), 
            this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), 
            this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop())))) : void this.destroy();
        },
        loopFull: function(a) {
            this.play(null, 0, a, !0);
        },
        play: function(a, b, c, d, e) {
            if ((void 0 === a || a === !1 || null === a) && (a = ""), void 0 === e && (e = !0), 
            this.isPlaying && !this.allowMultiple && !e && !this.override) return this;
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) if (this.usingWebAudio) if (this._sound.disconnect(this.externalNode ? this.externalNode : this.gainNode), 
            void 0 === this._sound.stop) this._sound.noteOff(0); else try {
                this._sound.stop(0);
            } catch (f) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
            if ("" === a && Object.keys(this.markers).length > 0) return this;
            if ("" !== a) {
                if (this.currentMarker = a, !this.markers[a]) return this;
                this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, 
                this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, 
                "undefined" != typeof c && (this.volume = c), "undefined" != typeof d && (this.loop = d), 
                this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, 
                this._tempLoop = this.loop;
            } else b = b || 0, void 0 === c && (c = this._volume), void 0 === d && (d = this.loop), 
            this.position = b, this.volume = c, this.loop = d, this.duration = 0, this.durationMS = 0, 
            this._tempMarker = a, this._tempPosition = b, this._tempVolume = c, this._tempLoop = d;
            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), 
            this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), 
            this._sound.buffer = this._buffer, this.loop && "" === a && (this._sound.loop = !0), 
            this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)), 
            this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, 
            this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), 
            this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, 
            this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, 
            this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), 
            this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), 
            this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, 
            this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, 
            this._sound.muted = this._muted, this._sound.volume = this._muted ? 0 : this._volume, 
            this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, 
            this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, 
            this;
        },
        restart: function(a, b, c, d) {
            a = a || "", b = b || 0, c = c || 1, void 0 === d && (d = !1), this.play(a, b, c, d, !0);
        },
        pause: function() {
            this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, 
            this.pausedTime = this.game.time.time, this.onPause.dispatch(this), this.stop());
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var a = this.position + this.pausedPosition / 1e3;
                    this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, 
                    this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this.loop && (this._sound.loop = !0), 
                    this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                    var b = this.duration - this.pausedPosition / 1e3;
                    void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a) : this._sound.start(0, a, b);
                } else this._sound.play();
                this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, 
                this.onResume.dispatch(this);
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) if (this.usingWebAudio) if (this._sound.disconnect(this.externalNode ? this.externalNode : this.gainNode), 
            void 0 === this._sound.stop) this._sound.noteOff(0); else try {
                this._sound.stop(0);
            } catch (a) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
            this.pendingPlayback = !1, this.isPlaying = !1;
            var b = this.currentMarker;
            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), 
            this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.paused || this.onStop.dispatch(this, b);
        },
        fadeIn: function(a, b, c) {
            void 0 === b && (b = !1), void 0 === c && (c = this.currentMarker), this.paused || (this.play(c, 0, 0, b), 
            this.fadeTo(a, 1));
        },
        fadeOut: function(a) {
            this.fadeTo(a, 0);
        },
        fadeTo: function(a, b) {
            if (this.isPlaying && !this.paused && b !== this.volume) {
                if (void 0 === a && (a = 1e3), void 0 === b) return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                this.fadeTween = this.game.add.tween(this).to({
                    volume: b
                }, a, c.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this);
            }
        },
        fadeComplete: function() {
            this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop();
        },
        destroy: function(a) {
            void 0 === a && (a = !0), this.stop(), a ? this.game.sound.remove(this) : (this.markers = {}, 
            this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), 
            this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), 
            this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose());
        }
    }, c.Sound.prototype.constructor = c.Sound, Object.defineProperty(c.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding;
        }
    }), Object.defineProperty(c.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key);
        }
    }), Object.defineProperty(c.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute;
        },
        set: function(a) {
            a = a || !1, a !== this._muted && (a ? (this._muted = !0, this._muteVolume = this._tempVolume, 
            this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, 
            this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), 
            this.onMute.dispatch(this));
        }
    }), Object.defineProperty(c.Sound.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(a) {
            return this.game.device.firefox && this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)), 
            this._muted ? void (this._muteVolume = a) : (this._tempVolume = a, this._volume = a, 
            void (this.usingWebAudio ? this.gainNode.gain.value = a : this.usingAudioTag && this._sound && (this._sound.volume = a)));
        }
    }), c.SoundManager = function(a) {
        this.game = a, this.onSoundDecode = new c.Signal(), this.onVolumeChange = new c.Signal(), 
        this.onMute = new c.Signal(), this.onUnMute = new c.Signal(), this.context = null, 
        this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, 
        this.touchLocked = !1, this.channels = 32, this._codeMuted = !1, this._muted = !1, 
        this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new c.ArraySet(), 
        this._watching = !1, this._watchCallback = null, this._watchContext = null;
    }, c.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), 
            window.PhaserGlobal) {
                if (window.PhaserGlobal.disableAudio === !0) return this.noAudio = !0, void (this.touchLocked = !1);
                if (window.PhaserGlobal.disableWebAudio === !0) return this.usingAudioTag = !0, 
                void (this.touchLocked = !1);
            }
            if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext; else if (window.AudioContext) try {
                this.context = new window.AudioContext();
            } catch (a) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1;
            } else if (window.webkitAudioContext) try {
                this.context = new window.webkitAudioContext();
            } catch (a) {
                this.context = null, this.usingWebAudio = !1, this.touchLocked = !1;
            }
            if (null === this.context) {
                if (void 0 === window.Audio) return void (this.noAudio = !0);
                this.usingAudioTag = !0;
            } else this.usingWebAudio = !0, this.masterGain = void 0 === this.context.createGain ? this.context.createGainNode() : this.context.createGain(), 
            this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
            this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock();
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0;
        },
        unlock: function() {
            if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
            if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null; else if (this.usingWebAudio) {
                var a = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = a, 
                this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0);
            }
            return !0;
        },
        stopAll: function() {
            if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop();
        },
        pauseAll: function() {
            if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause();
        },
        resumeAll: function() {
            if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume();
        },
        decode: function(a, b) {
            b = b || null;
            var c = this.game.cache.getSoundData(a);
            if (c && this.game.cache.isSoundDecoded(a) === !1) {
                this.game.cache.updateSound(a, "isDecoding", !0);
                var d = this;
                try {
                    this.context.decodeAudioData(c, function(c) {
                        c && (d.game.cache.decodedSound(a, c), d.onSoundDecode.dispatch(a, b));
                    });
                } catch (e) {}
            }
        },
        setDecodedCallback: function(a, b, d) {
            "string" == typeof a && (a = [ a ]), this._watchList.reset();
            for (var e = 0; e < a.length; e++) a[e] instanceof c.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
            0 === this._watchList.total ? (this._watching = !1, b.call(d)) : (this._watching = !0, 
            this._watchCallback = b, this._watchContext = d);
        },
        update: function() {
            if (!this.noAudio) {
                !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, 
                this._unlockSource = null);
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update();
                if (this._watching) {
                    for (var b = this._watchList.first; b; ) this.game.cache.isSoundDecoded(b) && this._watchList.remove(b), 
                    b = this._watchList.next;
                    0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext));
                }
            }
        },
        add: function(a, b, d, e) {
            void 0 === b && (b = 1), void 0 === d && (d = !1), void 0 === e && (e = this.connectToMaster);
            var f = new c.Sound(this.game, a, b, d, e);
            return this._sounds.push(f), f;
        },
        addSprite: function(a) {
            var b = new c.AudioSprite(this.game, a);
            return b;
        },
        remove: function(a) {
            for (var b = this._sounds.length; b--; ) if (this._sounds[b] === a) return this._sounds[b].destroy(!1), 
            this._sounds.splice(b, 1), !0;
            return !1;
        },
        removeByKey: function(a) {
            for (var b = this._sounds.length, c = 0; b--; ) this._sounds[b].key === a && (this._sounds[b].destroy(!1), 
            this._sounds.splice(b, 1), c++);
            return c;
        },
        play: function(a, b, c) {
            if (!this.noAudio) {
                var d = this.add(a, b, c);
                return d.play(), d;
            }
        },
        setMute: function() {
            if (!this._muted) {
                this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, 
                this.masterGain.gain.value = 0);
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
                this.onMute.dispatch();
            }
        },
        unsetMute: function() {
            if (this._muted && !this._codeMuted) {
                this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
                this.onUnMute.dispatch();
            }
        },
        destroy: function() {
            this.stopAll();
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].destroy();
            this._sounds = [], this.onSoundDecode.dispose(), this.context && window.PhaserGlobal && (window.PhaserGlobal.audioContext = this.context);
        }
    }, c.SoundManager.prototype.constructor = c.SoundManager, Object.defineProperty(c.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(a) {
            if (a = a || !1) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute();
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute();
            }
        }
    }), Object.defineProperty(c.SoundManager.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(a) {
            if (0 > a ? a = 0 : a > 1 && (a = 1), this._volume !== a) {
                if (this._volume = a, this.usingWebAudio) this.masterGain.gain.value = a; else for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && (this._sounds[b].volume = this._sounds[b].volume * a);
                this.onVolumeChange.dispatch(a);
            }
        }
    }), c.Utils.Debug = function(a) {
        this.game = a, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, 
        this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, 
        this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1;
    }, c.Utils.Debug.prototype = {
        boot: function() {
            this.game.renderType === c.CANVAS ? this.context = this.game.context : (this.bmd = this.game.make.bitmapData(this.game.width, this.game.height), 
            this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), 
            this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"));
        },
        preUpdate: function() {
            this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), 
            this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1);
        },
        reset: function() {
            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), 
            this.sprite && this.bmd.clear();
        },
        start: function(a, b, c, d) {
            "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), c = c || "rgb(255,255,255)", 
            void 0 === d && (d = 0), this.currentX = a, this.currentY = b, this.currentColor = c, 
            this.columnWidth = d, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), 
            this.context.strokeStyle = c, this.context.fillStyle = c, this.context.font = this.font, 
            this.context.globalAlpha = this.currentAlpha;
        },
        stop: function() {
            this.context.restore();
        },
        line: function() {
            for (var a = this.currentX, b = 0; b < arguments.length; b++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", 
            this.context.fillText(arguments[b], a + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), 
            this.context.fillText(arguments[b], a, this.currentY), a += this.columnWidth;
            this.currentY += this.lineHeight;
        },
        soundInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked), 
            this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback), 
            this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding), this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying), 
            this.line("Time: " + a.currentTime), this.line("Volume: " + a.volume + " Muted: " + a.mute), 
            this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag), "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"), 
            this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), 
            this.line("Position: " + a.position)), this.stop();
        },
        cameraInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Camera (" + a.width + " x " + a.height + ")"), this.line("X: " + a.x + " Y: " + a.y), 
            a.bounds && this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height), 
            this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height), 
            this.line("Total in view: " + a.totalInView), this.stop();
        },
        timer: function(a, b, c, d) {
            this.start(b, c, d), this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"), 
            this.line("Next Tick: " + a.next + " Duration: " + a.duration), this.line("Paused: " + a.paused + " Length: " + a.length), 
            this.stop();
        },
        pointer: function(a, b, c, d, e) {
            null != a && (void 0 === b && (b = !1), c = c || "rgba(0,255,0,0.5)", d = d || "rgba(255,0,0,0.5)", 
            (b !== !0 || a.isUp !== !0) && (this.start(a.x, a.y - 100, e), this.context.beginPath(), 
            this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), this.context.fillStyle = a.active ? c : d, 
            this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), 
            this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), 
            this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " + a.worldY), 
            this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame), this.line("Duration: " + a.duration + " ms"), 
            this.line("is Down: " + a.isDown + " is Up: " + a.isUp), this.stop()));
        },
        spriteInputInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sprite Input: (" + a.width + " x " + a.height + ")"), 
            this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)), 
            this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)), 
            this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)), 
            this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()), 
            this.stop();
        },
        key: function(a, b, c, d) {
            this.start(b, c, d, 150), this.line("Key:", a.keyCode, "isDown:", a.isDown), this.line("justDown:", a.justDown, "justUp:", a.justUp), 
            this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)), 
            this.stop();
        },
        inputInfo: function(a, b, c) {
            this.start(a, b, c), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), 
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), 
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), 
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), 
            this.stop();
        },
        spriteBounds: function(a, b, c) {
            var d = a.getBounds();
            d.x += this.game.camera.x, d.y += this.game.camera.y, this.rectangle(d, b, c);
        },
        ropeSegments: function(a, b, c) {
            var d = a.segments, e = this;
            d.forEach(function(a) {
                e.rectangle(a, b, c);
            }, this);
        },
        spriteInfo: function(a, b, c, d) {
            this.start(b, c, d), this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y), 
            this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)), this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)), 
            this.line("visible: " + a.visible + " in camera: " + a.inCamera), this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)), 
            this.stop();
        },
        spriteCoords: function(a, b, c, d) {
            this.start(b, c, d, 100), a.name && this.line(a.name), this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)), 
            this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)), 
            this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)), this.stop();
        },
        lineInfo: function(a, b, c, d) {
            this.start(b, c, d, 80), this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)), 
            this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)), this.line("length:", a.length.toFixed(2), "angle:", a.angle), 
            this.stop();
        },
        pixel: function(a, b, c, d) {
            d = d || 2, this.start(), this.context.fillStyle = c, this.context.fillRect(a, b, d, d), 
            this.stop();
        },
        geom: function(a, b, d, e) {
            void 0 === d && (d = !0), void 0 === e && (e = 0), b = b || "rgba(0,255,0,0.4)", 
            this.start(), this.context.fillStyle = b, this.context.strokeStyle = b, a instanceof c.Rectangle || 1 === e ? d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : a instanceof c.Circle || 2 === e ? (this.context.beginPath(), 
            this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), 
            this.context.closePath(), d ? this.context.fill() : this.context.stroke()) : a instanceof c.Point || 3 === e ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4) : (a instanceof c.Line || 4 === e) && (this.context.lineWidth = 1, 
            this.context.beginPath(), this.context.moveTo(a.start.x + .5 - this.game.camera.x, a.start.y + .5 - this.game.camera.y), 
            this.context.lineTo(a.end.x + .5 - this.game.camera.x, a.end.y + .5 - this.game.camera.y), 
            this.context.closePath(), this.context.stroke()), this.stop();
        },
        rectangle: function(a, b, c) {
            void 0 === c && (c = !0), b = b || "rgba(0, 255, 0, 0.4)", this.start(), c ? (this.context.fillStyle = b, 
            this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.strokeStyle = b, 
            this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)), 
            this.stop();
        },
        text: function(a, b, c, d, e) {
            d = d || "rgb(255,255,255)", e = e || "16px Courier", this.start(), this.context.font = e, 
            this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, b + 1, c + 1)), 
            this.context.fillStyle = d, this.context.fillText(a, b, c), this.stop();
        },
        quadTree: function(a, b) {
            b = b || "rgba(255,0,0,0.3)", this.start();
            var c = a.bounds;
            if (0 === a.nodes.length) {
                this.context.strokeStyle = b, this.context.strokeRect(c.x, c.y, c.width, c.height), 
                this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"), 
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var d = 0; d < a.objects.length; d++) this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height);
            } else for (var d = 0; d < a.nodes.length; d++) this.quadTree(a.nodes[d]);
            this.stop();
        },
        body: function(a, b, d) {
            a.body && (this.start(), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.NINJA ? c.Physics.Ninja.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.BOX2D && c.Physics.Box2D.renderBody(this.context, a.body, b), 
            this.stop());
        },
        bodyInfo: function(a, b, d, e) {
            a.body && (this.start(b, d, e, 210), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === c.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body), 
            this.stop());
        },
        box2dWorld: function() {
            this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), 
            this.game.physics.box2d.renderDebugDraw(this.context), this.stop();
        },
        box2dBody: function(a, b) {
            this.start(), c.Physics.Box2D.renderBody(this.context, a, b), this.stop();
        },
        destroy: function() {
            PIXI.CanvasPool.remove(this);
        }
    }, c.Utils.Debug.prototype.constructor = c.Utils.Debug, c.ArraySet = function(a) {
        this.position = 0, this.list = a || [];
    }, c.ArraySet.prototype = {
        add: function(a) {
            return this.exists(a) || this.list.push(a), a;
        },
        getIndex: function(a) {
            return this.list.indexOf(a);
        },
        getByKey: function(a, b) {
            for (var c = this.list.length; c--; ) if (this.list[c][a] === b) return this.list[c];
            return null;
        },
        exists: function(a) {
            return this.list.indexOf(a) > -1;
        },
        reset: function() {
            this.list.length = 0;
        },
        remove: function(a) {
            var b = this.list.indexOf(a);
            return b > -1 ? (this.list.splice(b, 1), a) : void 0;
        },
        setAll: function(a, b) {
            for (var c = this.list.length; c--; ) this.list[c] && (this.list[c][a] = b);
        },
        callAll: function(a) {
            for (var b = Array.prototype.splice.call(arguments, 1), c = this.list.length; c--; ) this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b);
        },
        removeAll: function(a) {
            void 0 === a && (a = !1);
            for (var b = this.list.length; b--; ) if (this.list[b]) {
                var c = this.remove(this.list[b]);
                a && c.destroy();
            }
            this.position = 0, this.list = [];
        }
    }, Object.defineProperty(c.ArraySet.prototype, "total", {
        get: function() {
            return this.list.length;
        }
    }), Object.defineProperty(c.ArraySet.prototype, "first", {
        get: function() {
            return this.position = 0, this.list.length > 0 ? this.list[0] : null;
        }
    }), Object.defineProperty(c.ArraySet.prototype, "next", {
        get: function() {
            return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        }
    }), c.ArraySet.prototype.constructor = c.ArraySet, c.ArrayUtils = {
        getRandomItem: function(a, b, c) {
            if (null === a) return null;
            void 0 === b && (b = 0), void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            return void 0 === a[d] ? null : a[d];
        },
        removeRandomItem: function(a, b, c) {
            if (null == a) return null;
            void 0 === b && (b = 0), void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            if (d < a.length) {
                var e = a.splice(d, 1);
                return void 0 === e[0] ? null : e[0];
            }
            return null;
        },
        shuffle: function(a) {
            for (var b = a.length - 1; b > 0; b--) {
                var c = Math.floor(Math.random() * (b + 1)), d = a[b];
                a[b] = a[c], a[c] = d;
            }
            return a;
        },
        transposeMatrix: function(a) {
            for (var b = a.length, c = a[0].length, d = new Array(c), e = 0; c > e; e++) {
                d[e] = new Array(b);
                for (var f = b - 1; f > -1; f--) d[e][f] = a[f][e];
            }
            return d;
        },
        rotateMatrix: function(a, b) {
            if ("string" != typeof b && (b = (b % 360 + 360) % 360), 90 === b || -270 === b || "rotateLeft" === b) a = c.ArrayUtils.transposeMatrix(a), 
            a = a.reverse(); else if (-90 === b || 270 === b || "rotateRight" === b) a = a.reverse(), 
            a = c.ArrayUtils.transposeMatrix(a); else if (180 === Math.abs(b) || "rotate180" === b) {
                for (var d = 0; d < a.length; d++) a[d].reverse();
                a = a.reverse();
            }
            return a;
        },
        findClosest: function(a, b) {
            if (!b.length) return 0 / 0;
            if (1 === b.length || a < b[0]) return b[0];
            for (var c = 1; b[c] < a; ) c++;
            var d = b[c - 1], e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
            return a - d >= e - a ? e : d;
        },
        rotate: function(a) {
            var b = a.shift();
            return a.push(b), b;
        },
        numberArray: function(a, b) {
            for (var c = [], d = a; b >= d; d++) c.push(d);
            return c;
        },
        numberArrayStep: function(a, b, d) {
            (void 0 === a || null === a) && (a = 0), (void 0 === b || null === b) && (b = a, 
            a = 0), void 0 === d && (d = 1);
            for (var e = [], f = Math.max(c.Math.roundAwayFromZero((b - a) / (d || 1)), 0), g = 0; f > g; g++) e.push(a), 
            a += d;
            return e;
        }
    }, c.Color = {
        packPixel: function(a, b, d, e) {
            return c.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | b << 8 | a) >>> 0 : (a << 24 | b << 16 | d << 8 | e) >>> 0;
        },
        unpackPixel: function(a, b, d, e) {
            return (void 0 === b || null === b) && (b = c.Color.createColor()), (void 0 === d || null === d) && (d = !1), 
            (void 0 === e || null === e) && (e = !1), c.Device.LITTLE_ENDIAN ? (b.a = (4278190080 & a) >>> 24, 
            b.b = (16711680 & a) >>> 16, b.g = (65280 & a) >>> 8, b.r = 255 & a) : (b.r = (4278190080 & a) >>> 24, 
            b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a), b.color = a, 
            b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")", d && c.Color.RGBtoHSL(b.r, b.g, b.b, b), 
            e && c.Color.RGBtoHSV(b.r, b.g, b.b, b), b;
        },
        fromRGBA: function(a, b) {
            return b || (b = c.Color.createColor()), b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, 
            b.b = (65280 & a) >>> 8, b.a = 255 & a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")", 
            b;
        },
        toRGBA: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d;
        },
        RGBtoHSL: function(a, b, d, e) {
            e || (e = c.Color.createColor(a, b, d, 1)), a /= 255, b /= 255, d /= 255;
            var f = Math.min(a, b, d), g = Math.max(a, b, d);
            if (e.h = 0, e.s = 0, e.l = (g + f) / 2, g !== f) {
                var h = g - f;
                e.s = e.l > .5 ? h / (2 - g - f) : h / (g + f), g === a ? e.h = (b - d) / h + (d > b ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), 
                e.h /= 6;
            }
            return e;
        },
        HSLtoRGB: function(a, b, d, e) {
            if (e ? (e.r = d, e.g = d, e.b = d) : e = c.Color.createColor(d, d, d), 0 !== b) {
                var f = .5 > d ? d * (1 + b) : d + b - d * b, g = 2 * d - f;
                e.r = c.Color.hueToColor(g, f, a + 1 / 3), e.g = c.Color.hueToColor(g, f, a), e.b = c.Color.hueToColor(g, f, a - 1 / 3);
            }
            return e.r = Math.floor(255 * e.r | 0), e.g = Math.floor(255 * e.g | 0), e.b = Math.floor(255 * e.b | 0), 
            c.Color.updateColor(e), e;
        },
        RGBtoHSV: function(a, b, d, e) {
            e || (e = c.Color.createColor(a, b, d, 255)), a /= 255, b /= 255, d /= 255;
            var f = Math.min(a, b, d), g = Math.max(a, b, d), h = g - f;
            return e.h = 0, e.s = 0 === g ? 0 : h / g, e.v = g, g !== f && (g === a ? e.h = (b - d) / h + (d > b ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), 
            e.h /= 6), e;
        },
        HSVtoRGB: function(a, b, d, e) {
            void 0 === e && (e = c.Color.createColor(0, 0, 0, 1, a, b, 0, d));
            var f, g, h, i = Math.floor(6 * a), j = 6 * a - i, k = d * (1 - b), l = d * (1 - j * b), m = d * (1 - (1 - j) * b);
            switch (i % 6) {
              case 0:
                f = d, g = m, h = k;
                break;

              case 1:
                f = l, g = d, h = k;
                break;

              case 2:
                f = k, g = d, h = m;
                break;

              case 3:
                f = k, g = l, h = d;
                break;

              case 4:
                f = m, g = k, h = d;
                break;

              case 5:
                f = d, g = k, h = l;
            }
            return e.r = Math.floor(255 * f), e.g = Math.floor(255 * g), e.b = Math.floor(255 * h), 
            c.Color.updateColor(e), e;
        },
        hueToColor: function(a, b, c) {
            return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + (b - a) * (2 / 3 - c) * 6 : a;
        },
        createColor: function(a, b, d, e, f, g, h, i) {
            var j = {
                r: a || 0,
                g: b || 0,
                b: d || 0,
                a: e || 1,
                h: f || 0,
                s: g || 0,
                l: h || 0,
                v: i || 0,
                color: 0,
                color32: 0,
                rgba: ""
            };
            return c.Color.updateColor(j);
        },
        updateColor: function(a) {
            return a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")", 
            a.color = c.Color.getColor(a.r, a.g, a.b), a.color32 = c.Color.getColor32(a.a, a.r, a.g, a.b), 
            a;
        },
        getColor32: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d;
        },
        getColor: function(a, b, c) {
            return a << 16 | b << 8 | c;
        },
        RGBtoString: function(a, b, d, e, f) {
            return void 0 === e && (e = 255), void 0 === f && (f = "#"), "#" === f ? "#" + ((1 << 24) + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c.Color.componentToHex(e) + c.Color.componentToHex(a) + c.Color.componentToHex(b) + c.Color.componentToHex(d);
        },
        hexToRGB: function(a) {
            var b = c.Color.hexToColor(a);
            return b ? c.Color.getColor32(b.a, b.r, b.g, b.b) : void 0;
        },
        hexToColor: function(a, b) {
            a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) {
                return b + b + c + c + d + d;
            });
            var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
            if (d) {
                var e = parseInt(d[1], 16), f = parseInt(d[2], 16), g = parseInt(d[3], 16);
                b ? (b.r = e, b.g = f, b.b = g) : b = c.Color.createColor(e, f, g);
            }
            return b;
        },
        webToColor: function(a, b) {
            b || (b = c.Color.createColor());
            var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
            return d && (b.r = parseInt(d[1], 10), b.g = parseInt(d[2], 10), b.b = parseInt(d[3], 10), 
            b.a = void 0 !== d[4] ? parseFloat(d[4]) : 1, c.Color.updateColor(b)), b;
        },
        valueToColor: function(a, b) {
            if (b || (b = c.Color.createColor()), "string" == typeof a) return 0 === a.indexOf("rgb") ? c.Color.webToColor(a, b) : (b.a = 1, 
            c.Color.hexToColor(a, b));
            if ("number" == typeof a) {
                var d = c.Color.getRGB(a);
                return b.r = d.r, b.g = d.g, b.b = d.b, b.a = d.a / 255, b;
            }
            return b;
        },
        componentToHex: function(a) {
            var b = a.toString(16);
            return 1 == b.length ? "0" + b : b;
        },
        HSVColorWheel: function(a, b) {
            void 0 === a && (a = 1), void 0 === b && (b = 1);
            for (var d = [], e = 0; 359 >= e; e++) d.push(c.Color.HSVtoRGB(e / 359, a, b));
            return d;
        },
        HSLColorWheel: function(a, b) {
            void 0 === a && (a = .5), void 0 === b && (b = .5);
            for (var d = [], e = 0; 359 >= e; e++) d.push(c.Color.HSLtoRGB(e / 359, a, b));
            return d;
        },
        interpolateColor: function(a, b, d, e, f) {
            void 0 === f && (f = 255);
            var g = c.Color.getRGB(a), h = c.Color.getRGB(b), i = (h.red - g.red) * e / d + g.red, j = (h.green - g.green) * e / d + g.green, k = (h.blue - g.blue) * e / d + g.blue;
            return c.Color.getColor32(f, i, j, k);
        },
        interpolateColorWithRGB: function(a, b, d, e, f, g) {
            var h = c.Color.getRGB(a), i = (b - h.red) * g / f + h.red, j = (d - h.green) * g / f + h.green, k = (e - h.blue) * g / f + h.blue;
            return c.Color.getColor(i, j, k);
        },
        interpolateRGB: function(a, b, d, e, f, g, h, i) {
            var j = (e - a) * i / h + a, k = (f - b) * i / h + b, l = (g - d) * i / h + d;
            return c.Color.getColor(j, k, l);
        },
        getRandomColor: function(a, b, d) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 255), void 0 === d && (d = 255), 
            b > 255 || a > b) return c.Color.getColor(255, 255, 255);
            var e = a + Math.round(Math.random() * (b - a)), f = a + Math.round(Math.random() * (b - a)), g = a + Math.round(Math.random() * (b - a));
            return c.Color.getColor32(d, e, f, g);
        },
        getRGB: function(a) {
            return a > 16777215 ? {
                alpha: a >>> 24,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: a >>> 24,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            } : {
                alpha: 255,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: 255,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            };
        },
        getWebRGB: function(a) {
            if ("object" == typeof a) return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
            var b = c.Color.getRGB(a);
            return "rgba(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + "," + (b.a / 255).toString() + ")";
        },
        getAlpha: function(a) {
            return a >>> 24;
        },
        getAlphaFloat: function(a) {
            return (a >>> 24) / 255;
        },
        getRed: function(a) {
            return a >> 16 & 255;
        },
        getGreen: function(a) {
            return a >> 8 & 255;
        },
        getBlue: function(a) {
            return 255 & a;
        },
        blendNormal: function(a) {
            return a;
        },
        blendLighten: function(a, b) {
            return b > a ? b : a;
        },
        blendDarken: function(a, b) {
            return b > a ? a : b;
        },
        blendMultiply: function(a, b) {
            return a * b / 255;
        },
        blendAverage: function(a, b) {
            return (a + b) / 2;
        },
        blendAdd: function(a, b) {
            return Math.min(255, a + b);
        },
        blendSubtract: function(a, b) {
            return Math.max(0, a + b - 255);
        },
        blendDifference: function(a, b) {
            return Math.abs(a - b);
        },
        blendNegation: function(a, b) {
            return 255 - Math.abs(255 - a - b);
        },
        blendScreen: function(a, b) {
            return 255 - ((255 - a) * (255 - b) >> 8);
        },
        blendExclusion: function(a, b) {
            return a + b - 2 * a * b / 255;
        },
        blendOverlay: function(a, b) {
            return 128 > b ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255;
        },
        blendSoftLight: function(a, b) {
            return 128 > b ? 2 * ((a >> 1) + 64) * (b / 255) : 255 - 2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255;
        },
        blendHardLight: function(a, b) {
            return c.Color.blendOverlay(b, a);
        },
        blendColorDodge: function(a, b) {
            return 255 === b ? b : Math.min(255, (a << 8) / (255 - b));
        },
        blendColorBurn: function(a, b) {
            return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b);
        },
        blendLinearDodge: function(a, b) {
            return c.Color.blendAdd(a, b);
        },
        blendLinearBurn: function(a, b) {
            return c.Color.blendSubtract(a, b);
        },
        blendLinearLight: function(a, b) {
            return 128 > b ? c.Color.blendLinearBurn(a, 2 * b) : c.Color.blendLinearDodge(a, 2 * (b - 128));
        },
        blendVividLight: function(a, b) {
            return 128 > b ? c.Color.blendColorBurn(a, 2 * b) : c.Color.blendColorDodge(a, 2 * (b - 128));
        },
        blendPinLight: function(a, b) {
            return 128 > b ? c.Color.blendDarken(a, 2 * b) : c.Color.blendLighten(a, 2 * (b - 128));
        },
        blendHardMix: function(a, b) {
            return c.Color.blendVividLight(a, b) < 128 ? 0 : 255;
        },
        blendReflect: function(a, b) {
            return 255 === b ? b : Math.min(255, a * a / (255 - b));
        },
        blendGlow: function(a, b) {
            return c.Color.blendReflect(b, a);
        },
        blendPhoenix: function(a, b) {
            return Math.min(a, b) - Math.max(a, b) + 255;
        }
    }, c.LinkedList = function() {
        this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0;
    }, c.LinkedList.prototype = {
        add: function(a) {
            return 0 === this.total && null === this.first && null === this.last ? (this.first = a, 
            this.last = a, this.next = a, a.prev = this, this.total++, a) : (this.last.next = a, 
            a.prev = this.last, this.last = a, this.total++, a);
        },
        reset: function() {
            this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0;
        },
        remove: function(a) {
            return 1 === this.total ? (this.reset(), void (a.next = a.prev = null)) : (a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev), 
            a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), a.next = a.prev = null, 
            null === this.first && (this.last = null), void this.total--);
        },
        callAll: function(a) {
            if (this.first && this.last) {
                var b = this.first;
                do b && b[a] && b[a].call(b), b = b.next; while (b != this.last.next);
            }
        }
    }, c.LinkedList.prototype.constructor = c.LinkedList, c.Physics = function(a, b) {
        b = b || {}, this.game = a, this.config = b, this.arcade = null, this.p2 = null, 
        this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, 
        this.parseConfig();
    }, c.Physics.ARCADE = 0, c.Physics.P2JS = 1, c.Physics.NINJA = 2, c.Physics.BOX2D = 3, 
    c.Physics.CHIPMUNK = 4, c.Physics.MATTERJS = 5, c.Physics.prototype = {
        parseConfig: function() {
            this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !c.Physics.hasOwnProperty("Arcade") || (this.arcade = new c.Physics.Arcade(this.game)), 
            this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && c.Physics.hasOwnProperty("Ninja") && (this.ninja = new c.Physics.Ninja(this.game)), 
            this.config.hasOwnProperty("p2") && this.config.p2 === !0 && c.Physics.hasOwnProperty("P2") && (this.p2 = new c.Physics.P2(this.game, this.config)), 
            this.config.hasOwnProperty("box2d") && this.config.box2d === !0 && c.Physics.hasOwnProperty("BOX2D") && (this.box2d = new c.Physics.BOX2D(this.game, this.config)), 
            this.config.hasOwnProperty("matter") && this.config.matter === !0 && c.Physics.hasOwnProperty("Matter") && (this.matter = new c.Physics.Matter(this.game, this.config));
        },
        startSystem: function(a) {
            a === c.Physics.ARCADE ? this.arcade = new c.Physics.Arcade(this.game) : a === c.Physics.P2JS ? null === this.p2 ? this.p2 = new c.Physics.P2(this.game, this.config) : this.p2.reset() : a === c.Physics.NINJA ? this.ninja = new c.Physics.Ninja(this.game) : a === c.Physics.BOX2D ? null === this.box2d ? this.box2d = new c.Physics.Box2D(this.game, this.config) : this.box2d.reset() : a === c.Physics.MATTERJS && (null === this.matter ? this.matter = new c.Physics.Matter(this.game, this.config) : this.matter.reset());
        },
        enable: function(a, b, d) {
            void 0 === b && (b = c.Physics.ARCADE), void 0 === d && (d = !1), b === c.Physics.ARCADE ? this.arcade.enable(a) : b === c.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : b === c.Physics.NINJA && this.ninja ? this.ninja.enableAABB(a) : b === c.Physics.BOX2D && this.box2d ? this.box2d.enable(a) : b === c.Physics.MATTERJS && this.matter && this.matter.enable(a);
        },
        preUpdate: function() {
            this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate();
        },
        update: function() {
            this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update();
        },
        setBoundsToWorld: function() {
            this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), 
            this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), 
            this.matter && this.matter.setBoundsToWorld();
        },
        clear: function() {
            this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear();
        },
        reset: function() {
            this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset();
        },
        destroy: function() {
            this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), 
            this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null;
        }
    }, c.Physics.prototype.constructor = c.Physics, c.Physics.Arcade = function(a) {
        this.game = a, this.gravity = new c.Point(), this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height), 
        this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, 
        this.sortDirection = c.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, 
        this.quadTree = new c.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
        this._total = 0, this.setBoundsToWorld();
    }, c.Physics.Arcade.prototype.constructor = c.Physics.Arcade, c.Physics.Arcade.SORT_NONE = 0, 
    c.Physics.Arcade.LEFT_RIGHT = 1, c.Physics.Arcade.RIGHT_LEFT = 2, c.Physics.Arcade.TOP_BOTTOM = 3, 
    c.Physics.Arcade.BOTTOM_TOP = 4, c.Physics.Arcade.prototype = {
        setBounds: function(a, b, c, d) {
            this.bounds.setTo(a, b, c, d);
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds);
        },
        enable: function(a, b) {
            void 0 === b && (b = !0);
            var d = 1;
            if (Array.isArray(a)) for (d = a.length; d--; ) a[d] instanceof c.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), 
            b && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0)); else a instanceof c.Group ? this.enable(a.children, b) : (this.enableBody(a), 
            b && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0));
        },
        enableBody: function(a) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.Arcade.Body(a), 
            a.parent && a.parent instanceof c.Group && a.parent.addToHash(a));
        },
        updateMotion: function(a) {
            var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
            a.angularVelocity += b, a.rotation += a.angularVelocity * this.game.time.physicsElapsed, 
            a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x), 
            a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y);
        },
        computeVelocity: function(a, b, c, d, e, f) {
            return void 0 === f && (f = 1e4), 1 === a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed), 
            d ? c += d * this.game.time.physicsElapsed : e && (e *= this.game.time.physicsElapsed, 
            c - e > 0 ? c -= e : 0 > c + e ? c += e : c = 0), c > f ? c = f : -f > c && (c = -f), 
            c;
        },
        overlap: function(a, b, c, d, e) {
            if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !0); else if (Array.isArray(a) && !Array.isArray(b)) for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !0); else if (Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < a.length; f++) for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !0); else this.collideHandler(a, b, c, d, e, !0);
            return this._total > 0;
        },
        collide: function(a, b, c, d, e) {
            if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !1); else if (Array.isArray(a) && !Array.isArray(b)) for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !1); else if (Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < a.length; f++) for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !1); else this.collideHandler(a, b, c, d, e, !1);
            return this._total > 0;
        },
        sortLeftRight: function(a, b) {
            return a.body && b.body ? a.body.x - b.body.x : 0;
        },
        sortRightLeft: function(a, b) {
            return a.body && b.body ? b.body.x - a.body.x : 0;
        },
        sortTopBottom: function(a, b) {
            return a.body && b.body ? a.body.y - b.body.y : 0;
        },
        sortBottomTop: function(a, b) {
            return a.body && b.body ? b.body.y - a.body.y : 0;
        },
        sort: function(a, b) {
            null !== a.physicsSortDirection ? b = a.physicsSortDirection : void 0 === b && (b = this.sortDirection), 
            b === c.Physics.Arcade.LEFT_RIGHT ? a.hash.sort(this.sortLeftRight) : b === c.Physics.Arcade.RIGHT_LEFT ? a.hash.sort(this.sortRightLeft) : b === c.Physics.Arcade.TOP_BOTTOM ? a.hash.sort(this.sortTopBottom) : b === c.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop);
        },
        collideHandler: function(a, b, d, e, f, g) {
            return void 0 === b && a.physicsType === c.GROUP ? (this.sort(a), void this.collideGroupVsSelf(a, d, e, f, g)) : void (a && b && a.exists && b.exists && (this.sortDirection !== c.Physics.Arcade.SORT_NONE && (a.physicsType === c.GROUP && this.sort(a), 
            b.physicsType === c.GROUP && this.sort(b)), a.physicsType === c.SPRITE ? b.physicsType === c.SPRITE ? this.collideSpriteVsSprite(a, b, d, e, f, g) : b.physicsType === c.GROUP ? this.collideSpriteVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.GROUP ? b.physicsType === c.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, g) : b.physicsType === c.GROUP ? this.collideGroupVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.TILEMAPLAYER && (b.physicsType === c.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f, g) : b.physicsType === c.GROUP && this.collideGroupVsTilemapLayer(b, a, d, e, f, g))));
        },
        collideSpriteVsSprite: function(a, b, c, d, e, f) {
            return a.body && b.body ? (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), 
            this._total++), !0) : !1;
        },
        collideSpriteVsGroup: function(a, b, d, e, f, g) {
            if (0 !== b.length && a.body) {
                var h;
                if (this.skipQuadTree || a.body.skipQuadTree) {
                    for (var i = 0; i < b.hash.length; i++) if (b.hash[i] && b.hash[i].exists && b.hash[i].body) {
                        if (h = b.hash[i].body, this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) {
                            if (a.body.right < h.x) break;
                            if (h.right < a.body.x) continue;
                        } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                            if (a.body.x > h.right) break;
                            if (h.x > a.body.right) continue;
                        } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                            if (a.body.bottom < h.y) break;
                            if (h.bottom < a.body.y) continue;
                        } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                            if (a.body.y > h.bottom) break;
                            if (h.y > a.body.bottom) continue;
                        }
                        this.collideSpriteVsSprite(a, b.hash[i], d, e, f, g);
                    }
                } else {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
                    this.quadTree.populate(b);
                    for (var j = this.quadTree.retrieve(a), i = 0; i < j.length; i++) this.separate(a.body, j[i], e, f, g) && (d && d.call(f, a, j[i].sprite), 
                    this._total++);
                }
            }
        },
        collideGroupVsSelf: function(a, b, d, e, f) {
            if (0 !== a.length) for (var g = 0; g < a.hash.length; g++) if (a.hash[g] && a.hash[g].exists && a.hash[g].body) for (var h = a.hash[g], i = g + 1; i < a.hash.length; i++) if (a.hash[i] && a.hash[i].exists && a.hash[i].body) {
                var j = a.hash[i];
                if (this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) {
                    if (h.body.right < j.body.x) break;
                    if (j.body.right < h.body.x) continue;
                } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                    if (h.body.x > j.body.right) continue;
                    if (j.body.x > h.body.right) break;
                } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                    if (h.body.bottom < j.body.y) continue;
                    if (j.body.bottom < h.body.y) break;
                } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                    if (h.body.y > j.body.bottom) continue;
                    if (j.body.y > h.body.bottom) break;
                }
                this.collideSpriteVsSprite(h, j, b, d, e, f);
            }
        },
        collideGroupVsGroup: function(a, b, d, e, f, g) {
            if (0 !== a.length && 0 !== b.length) for (var h = 0; h < a.children.length; h++) a.children[h].exists && (a.children[h].physicsType === c.GROUP ? this.collideGroupVsGroup(a.children[h], b, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], b, d, e, f, g));
        },
        separate: function(a, b, c, d, e) {
            if (!a.enable || !b.enable || !this.intersects(a, b)) return !1;
            if (c && c.call(d, a.sprite, b.sprite) === !1) return !1;
            var f = !1;
            return f = this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? this.separateX(a, b, e) || this.separateY(a, b, e) : this.separateY(a, b, e) || this.separateX(a, b, e), 
            e ? !0 : f;
        },
        intersects: function(a, b) {
            return a.right <= b.position.x ? !1 : a.bottom <= b.position.y ? !1 : a.position.x >= b.right ? !1 : a.position.y >= b.bottom ? !1 : !0;
        },
        separateX: function(a, b, c) {
            if (a.immovable && b.immovable) return !1;
            var d = 0;
            if (this.intersects(a, b)) {
                var e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
                if (0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0, b.embedded = !0) : a.deltaX() > b.deltaX() ? (d = a.right - b.x, 
                d > e || a.checkCollision.right === !1 || b.checkCollision.left === !1 ? d = 0 : (a.touching.none = !1, 
                a.touching.right = !0, b.touching.none = !1, b.touching.left = !0)) : a.deltaX() < b.deltaX() && (d = a.x - b.width - b.x, 
                -d > e || a.checkCollision.left === !1 || b.checkCollision.right === !1 ? d = 0 : (a.touching.none = !1, 
                a.touching.left = !0, b.touching.none = !1, b.touching.right = !0)), a.overlapX = d, 
                b.overlapX = d, 0 !== d) {
                    if (c || a.customSeparateX || b.customSeparateX) return !0;
                    var f = a.velocity.x, g = b.velocity.x;
                    if (a.immovable || b.immovable) a.immovable ? b.immovable || (b.x += d, b.velocity.x = f - g * b.bounce.x, 
                    a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : (a.x = a.x - d, a.velocity.x = g - f * a.bounce.x, 
                    b.moves && (a.y += (b.y - b.prev.y) * b.friction.y)); else {
                        d *= .5, a.x = a.x - d, b.x += d;
                        var h = Math.sqrt(g * g * b.mass / a.mass) * (g > 0 ? 1 : -1), i = Math.sqrt(f * f * a.mass / b.mass) * (f > 0 ? 1 : -1), j = .5 * (h + i);
                        h -= j, i -= j, a.velocity.x = j + h * a.bounce.x, b.velocity.x = j + i * b.bounce.x;
                    }
                    return !0;
                }
            }
            return !1;
        },
        separateY: function(a, b, c) {
            if (a.immovable && b.immovable) return !1;
            var d = 0;
            if (this.intersects(a, b)) {
                var e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
                if (0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0, b.embedded = !0) : a.deltaY() > b.deltaY() ? (d = a.bottom - b.y, 
                d > e || a.checkCollision.down === !1 || b.checkCollision.up === !1 ? d = 0 : (a.touching.none = !1, 
                a.touching.down = !0, b.touching.none = !1, b.touching.up = !0)) : a.deltaY() < b.deltaY() && (d = a.y - b.bottom, 
                -d > e || a.checkCollision.up === !1 || b.checkCollision.down === !1 ? d = 0 : (a.touching.none = !1, 
                a.touching.up = !0, b.touching.none = !1, b.touching.down = !0)), a.overlapY = d, 
                b.overlapY = d, 0 !== d) {
                    if (c || a.customSeparateY || b.customSeparateY) return !0;
                    var f = a.velocity.y, g = b.velocity.y;
                    if (a.immovable || b.immovable) a.immovable ? b.immovable || (b.y += d, b.velocity.y = f - g * b.bounce.y, 
                    a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : (a.y = a.y - d, a.velocity.y = g - f * a.bounce.y, 
                    b.moves && (a.x += (b.x - b.prev.x) * b.friction.x)); else {
                        d *= .5, a.y = a.y - d, b.y += d;
                        var h = Math.sqrt(g * g * b.mass / a.mass) * (g > 0 ? 1 : -1), i = Math.sqrt(f * f * a.mass / b.mass) * (f > 0 ? 1 : -1), j = .5 * (h + i);
                        h -= j, i -= j, a.velocity.y = j + h * a.bounce.y, b.velocity.y = j + i * b.bounce.y;
                    }
                    return !0;
                }
            }
            return !1;
        },
        getObjectsUnderPointer: function(a, b, c, d) {
            return 0 !== b.length && a.exists ? this.getObjectsAtLocation(a.x, a.y, b, c, d, a) : void 0;
        },
        getObjectsAtLocation: function(a, b, d, e, f, g) {
            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), 
            this.quadTree.populate(d);
            for (var h = new c.Rectangle(a, b, 1, 1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++) j[k].hitTest(a, b) && (e && e.call(f, g, j[k].sprite), 
            i.push(j[k].sprite));
            return i;
        },
        moveToObject: function(a, b, c, d) {
            void 0 === c && (c = 60), void 0 === d && (d = 0);
            var e = Math.atan2(b.y - a.y, b.x - a.x);
            return d > 0 && (c = this.distanceBetween(a, b) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * c, 
            a.body.velocity.y = Math.sin(e) * c, e;
        },
        moveToPointer: function(a, b, c, d) {
            void 0 === b && (b = 60), c = c || this.game.input.activePointer, void 0 === d && (d = 0);
            var e = this.angleToPointer(a, c);
            return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * b, 
            a.body.velocity.y = Math.sin(e) * b, e;
        },
        moveToXY: function(a, b, c, d, e) {
            void 0 === d && (d = 60), void 0 === e && (e = 0);
            var f = Math.atan2(c - a.y, b - a.x);
            return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1e3)), a.body.velocity.x = Math.cos(f) * d, 
            a.body.velocity.y = Math.sin(f) * d, f;
        },
        velocityFromAngle: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c.Point(), d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b);
        },
        velocityFromRotation: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c.Point(), d.setTo(Math.cos(a) * b, Math.sin(a) * b);
        },
        accelerationFromRotation: function(a, b, d) {
            return void 0 === b && (b = 60), d = d || new c.Point(), d.setTo(Math.cos(a) * b, Math.sin(a) * b);
        },
        accelerateToObject: function(a, b, c, d, e) {
            void 0 === c && (c = 60), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3);
            var f = this.angleBetween(a, b);
            return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), 
            f;
        },
        accelerateToPointer: function(a, b, c, d, e) {
            void 0 === c && (c = 60), void 0 === b && (b = this.game.input.activePointer), void 0 === d && (d = 1e3), 
            void 0 === e && (e = 1e3);
            var f = this.angleToPointer(a, b);
            return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), 
            f;
        },
        accelerateToXY: function(a, b, c, d, e, f) {
            void 0 === d && (d = 60), void 0 === e && (e = 1e3), void 0 === f && (f = 1e3);
            var g = this.angleToXY(a, b, c);
            return a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d), a.body.maxVelocity.setTo(e, f), 
            g;
        },
        distanceBetween: function(a, b) {
            var c = a.x - b.x, d = a.y - b.y;
            return Math.sqrt(c * c + d * d);
        },
        distanceToXY: function(a, b, c) {
            var d = a.x - b, e = a.y - c;
            return Math.sqrt(d * d + e * e);
        },
        distanceToPointer: function(a, b) {
            b = b || this.game.input.activePointer;
            var c = a.x - b.worldX, d = a.y - b.worldY;
            return Math.sqrt(c * c + d * d);
        },
        angleBetween: function(a, b) {
            var c = b.x - a.x, d = b.y - a.y;
            return Math.atan2(d, c);
        },
        angleToXY: function(a, b, c) {
            var d = b - a.x, e = c - a.y;
            return Math.atan2(e, d);
        },
        angleToPointer: function(a, b) {
            b = b || this.game.input.activePointer;
            var c = b.worldX - a.x, d = b.worldY - a.y;
            return Math.atan2(d, c);
        }
    }, c.Physics.Arcade.Body = function(a) {
        this.sprite = a, this.game = a.game, this.type = c.Physics.ARCADE, this.enable = !0, 
        this.offset = new c.Point(), this.position = new c.Point(a.x, a.y), this.prev = new c.Point(this.position.x, this.position.y), 
        this.allowRotation = !0, this.rotation = a.rotation, this.preRotation = a.rotation, 
        this.width = a.width, this.height = a.height, this.sourceWidth = a.width, this.sourceHeight = a.height, 
        a.texture && (this.sourceWidth = a.texture.frame.width, this.sourceHeight = a.texture.frame.height), 
        this.halfWidth = Math.abs(a.width / 2), this.halfHeight = Math.abs(a.height / 2), 
        this.center = new c.Point(a.x + this.halfWidth, a.y + this.halfHeight), this.velocity = new c.Point(), 
        this.newVelocity = new c.Point(0, 0), this.deltaMax = new c.Point(0, 0), this.acceleration = new c.Point(), 
        this.drag = new c.Point(), this.allowGravity = !0, this.gravity = new c.Point(0, 0), 
        this.bounce = new c.Point(), this.maxVelocity = new c.Point(1e4, 1e4), this.friction = new c.Point(1, 0), 
        this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, 
        this.mass = 1, this.angle = 0, this.speed = 0, this.facing = c.NONE, this.immovable = !1, 
        this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, 
        this.overlapY = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
            none: !1,
            any: !0,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        }, this.touching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.blocked = {
            up: !1,
            down: !1,
            left: !1,
            right: !1
        }, this.tilePadding = new c.Point(), this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, 
        this._reset = !0, this._sx = a.scale.x, this._sy = a.scale.y, this._dx = 0, this._dy = 0;
    }, c.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            if (this.syncBounds) {
                var a = this.sprite.getBounds();
                a.ceilAll(), (a.width !== this.width || a.height !== this.height) && (this.width = a.width, 
                this.height = a.height, this._reset = !0);
            } else {
                var b = Math.abs(this.sprite.scale.x), c = Math.abs(this.sprite.scale.y);
                (b !== this._sx || c !== this._sy) && (this.width = this.sourceWidth * b, this.height = this.sourceHeight * c, 
                this._sx = b, this._sy = c, this._reset = !0);
            }
            this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), 
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight));
        },
        preUpdate: function() {
            this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, 
            this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, 
            this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, 
            this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, 
            this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, 
            this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x, 
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y, 
            this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, 
            this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), 
            this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), 
            this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, (this.position.x !== this.prev.x || this.position.y !== this.prev.y) && (this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), 
            this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.collideWorldBounds && this.checkWorldBounds()), 
            this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1);
        },
        postUpdate: function() {
            this.enable && this.dirty && (this.dirty = !1, this.deltaX() < 0 ? this.facing = c.LEFT : this.deltaX() > 0 && (this.facing = c.RIGHT), 
            this.deltaY() < 0 ? this.facing = c.UP : this.deltaY() > 0 && (this.facing = c.DOWN), 
            this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 
            0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), 
            this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), 
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), 
            this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, 
            this.prev.y = this.position.y);
        },
        destroy: function() {
            this.sprite.parent && this.sprite.parent instanceof c.Group && this.sprite.parent.removeFromHash(this.sprite), 
            this.sprite.body = null, this.sprite = null;
        },
        checkWorldBounds: function() {
            var a = this.position, b = this.game.physics.arcade.bounds, c = this.game.physics.arcade.checkCollision;
            a.x < b.x && c.left ? (a.x = b.x, this.velocity.x *= -this.bounce.x, this.blocked.left = !0) : this.right > b.right && c.right && (a.x = b.right - this.width, 
            this.velocity.x *= -this.bounce.x, this.blocked.right = !0), a.y < b.y && c.up ? (a.y = b.y, 
            this.velocity.y *= -this.bounce.y, this.blocked.up = !0) : this.bottom > b.bottom && c.down && (a.y = b.bottom - this.height, 
            this.velocity.y *= -this.bounce.y, this.blocked.down = !0);
        },
        setSize: function(a, b, c, d) {
            void 0 === c && (c = this.offset.x), void 0 === d && (d = this.offset.y), this.sourceWidth = a, 
            this.sourceHeight = b, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, 
            this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), 
            this.offset.setTo(c, d), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        reset: function(a, b) {
            this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, 
            this.angularAcceleration = 0, this.position.x = a - this.sprite.anchor.x * this.width + this.offset.x, 
            this.position.y = b - this.sprite.anchor.y * this.height + this.offset.y, this.prev.x = this.position.x, 
            this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, 
            this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        hitTest: function(a, b) {
            return c.Rectangle.contains(this, a, b);
        },
        onFloor: function() {
            return this.blocked.down;
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function() {
            return this.position.x - this.prev.x;
        },
        deltaY: function() {
            return this.position.y - this.prev.y;
        },
        deltaZ: function() {
            return this.rotation - this.preRotation;
        }
    }, Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height;
        }
    }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width;
        }
    }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(a) {
            this.position.x = a;
        }
    }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(a) {
            this.position.y = a;
        }
    }), c.Physics.Arcade.Body.render = function(a, b, c, d) {
        void 0 === d && (d = !0), c = c || "rgba(0,255,0,0.4)", d ? (a.fillStyle = c, a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height)) : (a.strokeStyle = c, 
        a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height));
    }, c.Physics.Arcade.Body.renderBodyInfo = function(a, b) {
        a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height), 
        a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)), 
        a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)), 
        a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)), 
        a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down), 
        a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down);
    }, c.Physics.Arcade.Body.prototype.constructor = c.Physics.Arcade.Body, c.Physics.Arcade.TilemapCollision = function() {}, 
    c.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function(a, b, c, d, e, f) {
            if (a.body) {
                var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
                if (0 !== g.length) for (var h = 0; h < g.length; h++) d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], f) && (this._total++, 
                c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], f) && (this._total++, 
                c && c.call(e, a, g[h]));
            }
        },
        collideGroupVsTilemapLayer: function(a, b, c, d, e, f) {
            if (0 !== a.length) for (var g = 0; g < a.children.length; g++) a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f);
        },
        separateTile: function(a, b, c, d) {
            if (!b.enable) return !1;
            if (!c.intersects(b.position.x, b.position.y, b.right, b.bottom)) return !1;
            if (d) return !0;
            if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) return !1;
            if (c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) return !1;
            if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) return !1;
            var e = 0, f = 0, g = 0, h = 1;
            if (b.deltaAbsX() > b.deltaAbsY() ? g = -1 : b.deltaAbsX() < b.deltaAbsY() && (h = -1), 
            0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom) && (g = Math.min(Math.abs(b.position.x - c.right), Math.abs(b.right - c.left)), 
            h = Math.min(Math.abs(b.position.y - c.bottom), Math.abs(b.bottom - c.top))), h > g) {
                if ((c.faceLeft || c.faceRight) && (e = this.tileCheckX(b, c), 0 !== e && !c.intersects(b.position.x, b.position.y, b.right, b.bottom))) return !0;
                (c.faceTop || c.faceBottom) && (f = this.tileCheckY(b, c));
            } else {
                if ((c.faceTop || c.faceBottom) && (f = this.tileCheckY(b, c), 0 !== f && !c.intersects(b.position.x, b.position.y, b.right, b.bottom))) return !0;
                (c.faceLeft || c.faceRight) && (e = this.tileCheckX(b, c));
            }
            return 0 !== e || 0 !== f;
        },
        tileCheckX: function(a, b) {
            var c = 0;
            return a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left ? b.faceRight && a.x < b.right && (c = a.x - b.right, 
            c < -this.TILE_BIAS && (c = 0)) : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right > b.left && (c = a.right - b.left, 
            c > this.TILE_BIAS && (c = 0)), 0 !== c && (a.customSeparateX ? a.overlapX = c : this.processTileSeparationX(a, c)), 
            c;
        },
        tileCheckY: function(a, b) {
            var c = 0;
            return a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up ? b.faceBottom && a.y < b.bottom && (c = a.y - b.bottom, 
            c < -this.TILE_BIAS && (c = 0)) : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom > b.top && (c = a.bottom - b.top, 
            c > this.TILE_BIAS && (c = 0)), 0 !== c && (a.customSeparateY ? a.overlapY = c : this.processTileSeparationY(a, c)), 
            c;
        },
        processTileSeparationX: function(a, b) {
            0 > b ? a.blocked.left = !0 : b > 0 && (a.blocked.right = !0), a.position.x -= b, 
            a.velocity.x = 0 === a.bounce.x ? 0 : -a.velocity.x * a.bounce.x;
        },
        processTileSeparationY: function(a, b) {
            0 > b ? a.blocked.up = !0 : b > 0 && (a.blocked.down = !0), a.position.y -= b, a.velocity.y = 0 === a.bounce.y ? 0 : -a.velocity.y * a.bounce.y;
        }
    }, c.Utils.mixinPrototype(c.Physics.Arcade.prototype, c.Physics.Arcade.TilemapCollision.prototype), 
    p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, c.Physics.P2 = function(a, b) {
        this.game = a, void 0 === b ? b = {
            gravity: [ 0, 0 ],
            broadphase: new p2.SAPBroadphase()
        } : (b.hasOwnProperty("gravity") || (b.gravity = [ 0, 0 ]), b.hasOwnProperty("broadphase") || (b.broadphase = new p2.SAPBroadphase())), 
        this.config = b, this.world = new p2.World(this.config), this.frameRate = 1 / 60, 
        this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new c.Physics.P2.InversePointProxy(this, this.world.gravity), 
        this.walls = {
            left: null,
            right: null,
            top: null,
            bottom: null
        }, this.onBodyAdded = new c.Signal(), this.onBodyRemoved = new c.Signal(), this.onSpringAdded = new c.Signal(), 
        this.onSpringRemoved = new c.Signal(), this.onConstraintAdded = new c.Signal(), 
        this.onConstraintRemoved = new c.Signal(), this.onContactMaterialAdded = new c.Signal(), 
        this.onContactMaterialRemoved = new c.Signal(), this.postBroadphaseCallback = null, 
        this.callbackContext = null, this.onBeginContact = new c.Signal(), this.onEndContact = new c.Signal(), 
        b.hasOwnProperty("mpx") && b.hasOwnProperty("pxm") && b.hasOwnProperty("mpxi") && b.hasOwnProperty("pxmi") && (this.mpx = b.mpx, 
        this.mpxi = b.mpxi, this.pxm = b.pxm, this.pxmi = b.pxmi), this.world.on("beginContact", this.beginContactHandler, this), 
        this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], 
        this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), 
        this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], 
        this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, 
        this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1);
    }, c.Physics.P2.prototype = {
        removeBodyNextStep: function(a) {
            this._toRemove.push(a);
        },
        preUpdate: function() {
            for (var a = this._toRemove.length; a--; ) this.removeBody(this._toRemove[a]);
            this._toRemove.length = 0;
        },
        enable: function(a, b, d) {
            void 0 === b && (b = !1), void 0 === d && (d = !0);
            var e = 1;
            if (Array.isArray(a)) for (e = a.length; e--; ) a[e] instanceof c.Group ? this.enable(a[e].children, b, d) : (this.enableBody(a[e], b), 
            d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], b, !0)); else a instanceof c.Group ? this.enable(a.children, b, d) : (this.enableBody(a, b), 
            d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, b, !0));
        },
        enableBody: function(a, b) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.P2.Body(this.game, a, a.x, a.y, 1), 
            a.body.debug = b, "undefined" != typeof a.anchor && a.anchor.set(.5));
        },
        setImpactEvents: function(a) {
            a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this);
        },
        setPostBroadphaseCallback: function(a, b) {
            this.postBroadphaseCallback = a, this.callbackContext = b, null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        },
        postBroadphaseHandler: function(a) {
            if (this.postBroadphaseCallback && 0 !== a.pairs.length) for (var b = a.pairs.length - 2; b >= 0; b -= 2) a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2);
        },
        impactHandler: function(a) {
            if (a.bodyA.parent && a.bodyB.parent) {
                var b = a.bodyA.parent, c = a.bodyB.parent;
                b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB), 
                c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA), 
                b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB), 
                c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA);
            }
        },
        beginContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), 
            a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), 
            a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations));
        },
        endContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB), 
            a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB), 
            a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA));
        },
        setBoundsToWorld: function(a, b, c, d, e) {
            this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e);
        },
        setWorldMaterial: function(a, b, c, d, e) {
            void 0 === b && (b = !0), void 0 === c && (c = !0), void 0 === d && (d = !0), void 0 === e && (e = !0), 
            b && this.walls.left && (this.walls.left.shapes[0].material = a), c && this.walls.right && (this.walls.right.shapes[0].material = a), 
            d && this.walls.top && (this.walls.top.shapes[0].material = a), e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a);
        },
        updateBoundsCollisionGroup: function(a) {
            var b = this.everythingCollisionGroup.mask;
            void 0 === a && (b = this.boundsCollisionGroup.mask), this.walls.left && (this.walls.left.shapes[0].collisionGroup = b), 
            this.walls.right && (this.walls.right.shapes[0].collisionGroup = b), this.walls.top && (this.walls.top.shapes[0].collisionGroup = b), 
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b);
        },
        setBounds: function(a, b, c, d, e, f, g, h, i) {
            void 0 === e && (e = this._boundsLeft), void 0 === f && (f = this._boundsRight), 
            void 0 === g && (g = this._boundsTop), void 0 === h && (h = this._boundsBottom), 
            void 0 === i && (i = this._boundsOwnGroup), this.walls.left && this.world.removeBody(this.walls.left), 
            this.walls.right && this.world.removeBody(this.walls.right), this.walls.top && this.world.removeBody(this.walls.top), 
            this.walls.bottom && this.world.removeBody(this.walls.bottom), e && (this.walls.left = new p2.Body({
                mass: 0,
                position: [ this.pxmi(a), this.pxmi(b) ],
                angle: 1.5707963267948966
            }), this.walls.left.addShape(new p2.Plane()), i && (this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), 
            this.world.addBody(this.walls.left)), f && (this.walls.right = new p2.Body({
                mass: 0,
                position: [ this.pxmi(a + c), this.pxmi(b) ],
                angle: -1.5707963267948966
            }), this.walls.right.addShape(new p2.Plane()), i && (this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), 
            this.world.addBody(this.walls.right)), g && (this.walls.top = new p2.Body({
                mass: 0,
                position: [ this.pxmi(a), this.pxmi(b) ],
                angle: -3.141592653589793
            }), this.walls.top.addShape(new p2.Plane()), i && (this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), 
            this.world.addBody(this.walls.top)), h && (this.walls.bottom = new p2.Body({
                mass: 0,
                position: [ this.pxmi(a), this.pxmi(b + d) ]
            }), this.walls.bottom.addShape(new p2.Plane()), i && (this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), 
            this.world.addBody(this.walls.bottom)), this._boundsLeft = e, this._boundsRight = f, 
            this._boundsTop = g, this._boundsBottom = h, this._boundsOwnGroup = i;
        },
        pause: function() {
            this.paused = !0;
        },
        resume: function() {
            this.paused = !1;
        },
        update: function() {
            this.paused || this.world.step(this.useElapsedTime ? this.game.time.physicsElapsed : this.frameRate);
        },
        reset: function() {
            this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), 
            this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), 
            this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, 
            this.setBoundsToWorld(!0, !0, !0, !0, !1);
        },
        clear: function() {
            this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
            for (var a = this.world.constraints, b = a.length - 1; b >= 0; b--) this.world.removeConstraint(a[b]);
            for (var c = this.world.bodies, b = c.length - 1; b >= 0; b--) this.world.removeBody(c[b]);
            for (var d = this.world.springs, b = d.length - 1; b >= 0; b--) this.world.removeSpring(d[b]);
            for (var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--) this.world.removeContactMaterial(e[b]);
            this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), 
            this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, 
            this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [];
        },
        destroy: function() {
            this.clear(), this.game = null;
        },
        addBody: function(a) {
            return a.data.world ? !1 : (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), 
            !0);
        },
        removeBody: function(a) {
            return a.data.world == this.world && (this.world.removeBody(a.data), this.onBodyRemoved.dispatch(a)), 
            a;
        },
        addSpring: function(a) {
            return this.world.addSpring(a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? a.data : a), 
            this.onSpringAdded.dispatch(a), a;
        },
        removeSpring: function(a) {
            return this.world.removeSpring(a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? a.data : a), 
            this.onSpringRemoved.dispatch(a), a;
        },
        createDistanceConstraint: function(a, b, d, e, f, g) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.DistanceConstraint(this, a, b, d, e, f, g)) : void console.warn("Cannot create Constraint, invalid body objects given");
        },
        createGearConstraint: function(a, b, d, e) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.GearConstraint(this, a, b, d, e)) : void console.warn("Cannot create Constraint, invalid body objects given");
        },
        createRevoluteConstraint: function(a, b, d, e, f, g) {
            return a = this.getBody(a), d = this.getBody(d), a && d ? this.addConstraint(new c.Physics.P2.RevoluteConstraint(this, a, b, d, e, f, g)) : void console.warn("Cannot create Constraint, invalid body objects given");
        },
        createLockConstraint: function(a, b, d, e, f) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.LockConstraint(this, a, b, d, e, f)) : void console.warn("Cannot create Constraint, invalid body objects given");
        },
        createPrismaticConstraint: function(a, b, d, e, f, g, h) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addConstraint(new c.Physics.P2.PrismaticConstraint(this, a, b, d, e, f, g, h)) : void console.warn("Cannot create Constraint, invalid body objects given");
        },
        addConstraint: function(a) {
            return this.world.addConstraint(a), this.onConstraintAdded.dispatch(a), a;
        },
        removeConstraint: function(a) {
            return this.world.removeConstraint(a), this.onConstraintRemoved.dispatch(a), a;
        },
        addContactMaterial: function(a) {
            return this.world.addContactMaterial(a), this.onContactMaterialAdded.dispatch(a), 
            a;
        },
        removeContactMaterial: function(a) {
            return this.world.removeContactMaterial(a), this.onContactMaterialRemoved.dispatch(a), 
            a;
        },
        getContactMaterial: function(a, b) {
            return this.world.getContactMaterial(a, b);
        },
        setMaterial: function(a, b) {
            for (var c = b.length; c--; ) b[c].setMaterial(a);
        },
        createMaterial: function(a, b) {
            a = a || "";
            var d = new c.Physics.P2.Material(a);
            return this.materials.push(d), "undefined" != typeof b && b.setMaterial(d), d;
        },
        createContactMaterial: function(a, b, d) {
            void 0 === a && (a = this.createMaterial()), void 0 === b && (b = this.createMaterial());
            var e = new c.Physics.P2.ContactMaterial(a, b, d);
            return this.addContactMaterial(e);
        },
        getBodies: function() {
            for (var a = [], b = this.world.bodies.length; b--; ) a.push(this.world.bodies[b].parent);
            return a;
        },
        getBody: function(a) {
            return a instanceof p2.Body ? a : a instanceof c.Physics.P2.Body ? a.data : a.body && a.body.type === c.Physics.P2JS ? a.body.data : null;
        },
        getSprings: function() {
            for (var a = [], b = this.world.springs.length; b--; ) a.push(this.world.springs[b].parent);
            return a;
        },
        getConstraints: function() {
            for (var a = [], b = this.world.constraints.length; b--; ) a.push(this.world.constraints[b]);
            return a;
        },
        hitTest: function(a, b, d, e) {
            void 0 === b && (b = this.world.bodies), void 0 === d && (d = 5), void 0 === e && (e = !1);
            for (var f = [ this.pxmi(a.x), this.pxmi(a.y) ], g = [], h = b.length; h--; ) b[h] instanceof c.Physics.P2.Body && (!e || b[h].data.type !== p2.Body.STATIC) ? g.push(b[h].data) : b[h] instanceof p2.Body && b[h].parent && (!e || b[h].type !== p2.Body.STATIC) ? g.push(b[h]) : b[h] instanceof c.Sprite && b[h].hasOwnProperty("body") && (!e || b[h].body.data.type !== p2.Body.STATIC) && g.push(b[h].body.data);
            return this.world.hitTest(f, g, d);
        },
        toJSON: function() {
            return this.world.toJSON();
        },
        createCollisionGroup: function(a) {
            var b = Math.pow(2, this._collisionGroupID);
            this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | b), 
            this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | b), 
            this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | b), 
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | b), 
            this._collisionGroupID++;
            var d = new c.Physics.P2.CollisionGroup(b);
            return this.collisionGroups.push(d), a && this.setCollisionGroup(a, d), d;
        },
        setCollisionGroup: function(a, b) {
            if (a instanceof c.Group) for (var d = 0; d < a.total; d++) a.children[d].body && a.children[d].body.type === c.Physics.P2JS && a.children[d].body.setCollisionGroup(b); else a.body.setCollisionGroup(b);
        },
        createSpring: function(a, b, d, e, f, g, h, i, j) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addSpring(new c.Physics.P2.Spring(this, a, b, d, e, f, g, h, i, j)) : void console.warn("Cannot create Spring, invalid body objects given");
        },
        createRotationalSpring: function(a, b, d, e, f) {
            return a = this.getBody(a), b = this.getBody(b), a && b ? this.addSpring(new c.Physics.P2.RotationalSpring(this, a, b, d, e, f)) : void console.warn("Cannot create Rotational Spring, invalid body objects given");
        },
        createBody: function(a, b, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new c.Physics.P2.Body(this.game, null, a, b, d);
            if (g) {
                var i = h.addPolygon(f, g);
                if (!i) return !1;
            }
            return e && this.world.addBody(h.data), h;
        },
        createParticle: function(a, b, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new c.Physics.P2.Body(this.game, null, a, b, d);
            if (g) {
                var i = h.addPolygon(f, g);
                if (!i) return !1;
            }
            return e && this.world.addBody(h.data), h;
        },
        convertCollisionObjects: function(a, b, c) {
            void 0 === c && (c = !0);
            for (var d = [], e = 0, f = a.collision[b].length; f > e; e++) {
                var g = a.collision[b][e], h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
                h && d.push(h);
            }
            return d;
        },
        clearTilemapLayerBodies: function(a, b) {
            b = a.getLayer(b);
            for (var c = a.layers[b].bodies.length; c--; ) a.layers[b].bodies[c].destroy();
            a.layers[b].bodies.length = 0;
        },
        convertTilemap: function(a, b, c, d) {
            b = a.getLayer(b), void 0 === c && (c = !0), void 0 === d && (d = !0), this.clearTilemapLayerBodies(a, b);
            for (var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; i > h; h++) {
                e = 0;
                for (var j = 0, k = a.layers[b].width; k > j; j++) {
                    var l = a.layers[b].data[h][j];
                    if (l && l.index > -1 && l.collides) if (d) {
                        var m = a.getTileRight(b, j, h);
                        if (0 === e && (f = l.x * l.width, g = l.y * l.height, e = l.width), m && m.collides) e += l.width; else {
                            var n = this.createBody(f, g, 0, !1);
                            n.addRectangle(e, l.height, e / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n), 
                            e = 0;
                        }
                    } else {
                        var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                        n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0), c && this.addBody(n), 
                        a.layers[b].bodies.push(n);
                    }
                }
            }
            return a.layers[b].bodies;
        },
        mpx: function(a) {
            return a *= 20;
        },
        pxm: function(a) {
            return .05 * a;
        },
        mpxi: function(a) {
            return a *= -20;
        },
        pxmi: function(a) {
            return a * -.05;
        }
    }, Object.defineProperty(c.Physics.P2.prototype, "friction", {
        get: function() {
            return this.world.defaultContactMaterial.friction;
        },
        set: function(a) {
            this.world.defaultContactMaterial.friction = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "restitution", {
        get: function() {
            return this.world.defaultContactMaterial.restitution;
        },
        set: function(a) {
            this.world.defaultContactMaterial.restitution = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "contactMaterial", {
        get: function() {
            return this.world.defaultContactMaterial;
        },
        set: function(a) {
            this.world.defaultContactMaterial = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "applySpringForces", {
        get: function() {
            return this.world.applySpringForces;
        },
        set: function(a) {
            this.world.applySpringForces = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "applyDamping", {
        get: function() {
            return this.world.applyDamping;
        },
        set: function(a) {
            this.world.applyDamping = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "applyGravity", {
        get: function() {
            return this.world.applyGravity;
        },
        set: function(a) {
            this.world.applyGravity = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "solveConstraints", {
        get: function() {
            return this.world.solveConstraints;
        },
        set: function(a) {
            this.world.solveConstraints = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "time", {
        get: function() {
            return this.world.time;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "emitImpactEvent", {
        get: function() {
            return this.world.emitImpactEvent;
        },
        set: function(a) {
            this.world.emitImpactEvent = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "sleepMode", {
        get: function() {
            return this.world.sleepMode;
        },
        set: function(a) {
            this.world.sleepMode = a;
        }
    }), Object.defineProperty(c.Physics.P2.prototype, "total", {
        get: function() {
            return this.world.bodies.length;
        }
    }), c.Physics.P2.FixtureList = function(a) {
        Array.isArray(a) || (a = [ a ]), this.rawList = a, this.init(), this.parse(this.rawList);
    }, c.Physics.P2.FixtureList.prototype = {
        init: function() {
            this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = [];
        },
        setCategory: function(a, b) {
            var c = function(b) {
                b.collisionGroup = a;
            };
            this.getFixtures(b).forEach(c);
        },
        setMask: function(a, b) {
            var c = function(b) {
                b.collisionMask = a;
            };
            this.getFixtures(b).forEach(c);
        },
        setSensor: function(a, b) {
            var c = function(b) {
                b.sensor = a;
            };
            this.getFixtures(b).forEach(c);
        },
        setMaterial: function(a, b) {
            var c = function(b) {
                b.material = a;
            };
            this.getFixtures(b).forEach(c);
        },
        getFixtures: function(a) {
            var b = [];
            if (a) {
                a instanceof Array || (a = [ a ]);
                var c = this;
                return a.forEach(function(a) {
                    c.namedFixtures[a] && b.push(c.namedFixtures[a]);
                }), this.flatten(b);
            }
            return this.allFixtures;
        },
        getFixtureByKey: function(a) {
            return this.namedFixtures[a];
        },
        getGroup: function(a) {
            return this.groupedFixtures[a];
        },
        parse: function() {
            var a, b, c, d;
            c = this.rawList, d = [];
            for (a in c) b = c[a], isNaN(a - 0) ? this.namedFixtures[a] = this.flatten(b) : (this.groupedFixtures[a] = this.groupedFixtures[a] || [], 
            this.groupedFixtures[a] = this.groupedFixtures[a].concat(b)), d.push(this.allFixtures = this.flatten(this.groupedFixtures));
        },
        flatten: function(a) {
            var b, c;
            return b = [], c = arguments.callee, a.forEach(function(a) {
                return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [ a ]);
            }), b;
        }
    }, c.Physics.P2.PointProxy = function(a, b) {
        this.world = a, this.destination = b;
    }, c.Physics.P2.PointProxy.prototype.constructor = c.Physics.P2.PointProxy, Object.defineProperty(c.Physics.P2.PointProxy.prototype, "x", {
        get: function() {
            return this.world.mpx(this.destination[0]);
        },
        set: function(a) {
            this.destination[0] = this.world.pxm(a);
        }
    }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "y", {
        get: function() {
            return this.world.mpx(this.destination[1]);
        },
        set: function(a) {
            this.destination[1] = this.world.pxm(a);
        }
    }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(a) {
            this.destination[0] = a;
        }
    }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(a) {
            this.destination[1] = a;
        }
    }), c.Physics.P2.InversePointProxy = function(a, b) {
        this.world = a, this.destination = b;
    }, c.Physics.P2.InversePointProxy.prototype.constructor = c.Physics.P2.InversePointProxy, 
    Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.destination[0]);
        },
        set: function(a) {
            this.destination[0] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.destination[1]);
        },
        set: function(a) {
            this.destination[1] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0];
        },
        set: function(a) {
            this.destination[0] = -a;
        }
    }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "my", {
        get: function() {
            return this.destination[1];
        },
        set: function(a) {
            this.destination[1] = -a;
        }
    }), c.Physics.P2.Body = function(a, b, d, e, f) {
        b = b || null, d = d || 0, e = e || 0, void 0 === f && (f = 1), this.game = a, this.world = a.physics.p2, 
        this.sprite = b, this.type = c.Physics.P2JS, this.offset = new c.Point(), this.data = new p2.Body({
            position: [ this.world.pxmi(d), this.world.pxmi(e) ],
            mass: f
        }), this.data.parent = this, this.velocity = new c.Physics.P2.InversePointProxy(this.world, this.data.velocity), 
        this.force = new c.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new c.Point(), 
        this.onBeginContact = new c.Signal(), this.onEndContact = new c.Signal(), this.collidesWith = [], 
        this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, 
        this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, 
        this._groupCallbackContext = {}, this._reset = !1, b && (this.setRectangleFromSprite(b), 
        b.exists && this.game.physics.p2.addBody(this));
    }, c.Physics.P2.Body.prototype = {
        createBodyCallback: function(a, b, c) {
            var d = -1;
            a.id ? d = a.id : a.body && (d = a.body.id), d > -1 && (null === b ? (delete this._bodyCallbacks[d], 
            delete this._bodyCallbackContext[d]) : (this._bodyCallbacks[d] = b, this._bodyCallbackContext[d] = c));
        },
        createGroupCallback: function(a, b, c) {
            null === b ? (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]) : (this._groupCallbacks[a.mask] = b, 
            this._groupCallbackContext[a.mask] = c);
        },
        getCollisionMask: function() {
            var a = 0;
            this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
            for (var b = 0; b < this.collidesWith.length; b++) a |= this.collidesWith[b].mask;
            return a;
        },
        updateCollisionMask: function(a) {
            var b = this.getCollisionMask();
            if (void 0 === a) for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].collisionMask = b; else a.collisionMask = b;
        },
        setCollisionGroup: function(a, b) {
            var c = this.getCollisionMask();
            if (void 0 === b) for (var d = this.data.shapes.length - 1; d >= 0; d--) this.data.shapes[d].collisionGroup = a.mask, 
            this.data.shapes[d].collisionMask = c; else b.collisionGroup = a.mask, b.collisionMask = c;
        },
        clearCollision: function(a, b, c) {
            if (void 0 === a && (a = !0), void 0 === b && (b = !0), void 0 === c) for (var d = this.data.shapes.length - 1; d >= 0; d--) a && (this.data.shapes[d].collisionGroup = null), 
            b && (this.data.shapes[d].collisionMask = null); else a && (c.collisionGroup = null), 
            b && (c.collisionMask = null);
            a && (this.collidesWith.length = 0);
        },
        collides: function(a, b, c, d) {
            if (Array.isArray(a)) for (var e = 0; e < a.length; e++) -1 === this.collidesWith.indexOf(a[e]) && (this.collidesWith.push(a[e]), 
            b && this.createGroupCallback(a[e], b, c)); else -1 === this.collidesWith.indexOf(a) && (this.collidesWith.push(a), 
            b && this.createGroupCallback(a, b, c));
            var f = this.getCollisionMask();
            if (void 0 === d) for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f; else d.collisionMask = f;
        },
        adjustCenterOfMass: function() {
            this.data.adjustCenterOfMass(), this.shapeChanged();
        },
        getVelocityAtPoint: function(a, b) {
            return this.data.getVelocityAtPoint(a, b);
        },
        applyDamping: function(a) {
            this.data.applyDamping(a);
        },
        applyImpulse: function(a, b, c) {
            this.data.applyImpulse(a, [ this.world.pxmi(b), this.world.pxmi(c) ]);
        },
        applyImpulseLocal: function(a, b, c) {
            this.data.applyImpulseLocal(a, [ this.world.pxmi(b), this.world.pxmi(c) ]);
        },
        applyForce: function(a, b, c) {
            this.data.applyForce(a, [ this.world.pxmi(b), this.world.pxmi(c) ]);
        },
        setZeroForce: function() {
            this.data.setZeroForce();
        },
        setZeroRotation: function() {
            this.data.angularVelocity = 0;
        },
        setZeroVelocity: function() {
            this.data.velocity[0] = 0, this.data.velocity[1] = 0;
        },
        setZeroDamping: function() {
            this.data.damping = 0, this.data.angularDamping = 0;
        },
        toLocalFrame: function(a, b) {
            return this.data.toLocalFrame(a, b);
        },
        toWorldFrame: function(a, b) {
            return this.data.toWorldFrame(a, b);
        },
        rotateLeft: function(a) {
            this.data.angularVelocity = this.world.pxm(-a);
        },
        rotateRight: function(a) {
            this.data.angularVelocity = this.world.pxm(a);
        },
        moveForward: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = b * Math.cos(c), this.data.velocity[1] = b * Math.sin(c);
        },
        moveBackward: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = -(b * Math.cos(c)), this.data.velocity[1] = -(b * Math.sin(c));
        },
        thrust: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c);
        },
        reverse: function(a) {
            var b = this.world.pxmi(-a), c = this.data.angle + Math.PI / 2;
            this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c);
        },
        moveLeft: function(a) {
            this.data.velocity[0] = this.world.pxmi(-a);
        },
        moveRight: function(a) {
            this.data.velocity[0] = this.world.pxmi(a);
        },
        moveUp: function(a) {
            this.data.velocity[1] = this.world.pxmi(-a);
        },
        moveDown: function(a) {
            this.data.velocity[1] = this.world.pxmi(a);
        },
        preUpdate: function() {
            this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1);
        },
        postUpdate: function() {
            this.sprite.x = this.world.mpxi(this.data.position[0]), this.sprite.y = this.world.mpxi(this.data.position[1]), 
            this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), 
            this.dirty = !1;
        },
        reset: function(a, b, c, d) {
            void 0 === c && (c = !1), void 0 === d && (d = !1), this.setZeroForce(), this.setZeroVelocity(), 
            this.setZeroRotation(), c && this.setZeroDamping(), d && (this.mass = 1), this.x = a, 
            this.y = b;
        },
        addToWorld: function() {
            if (this.game.physics.p2._toRemove) for (var a = 0; a < this.game.physics.p2._toRemove.length; a++) this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
            this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this);
        },
        removeFromWorld: function() {
            this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this);
        },
        destroy: function() {
            this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, 
            this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), 
            this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null);
        },
        clearShapes: function() {
            for (var a = this.data.shapes.length; a--; ) this.data.removeShape(this.data.shapes[a]);
            this.shapeChanged();
        },
        addShape: function(a, b, c, d) {
            return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), 
            this.data.addShape(a, [ this.world.pxmi(b), this.world.pxmi(c) ], d), this.shapeChanged(), 
            a;
        },
        addCircle: function(a, b, c, d) {
            var e = new p2.Circle({
                radius: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d);
        },
        addRectangle: function(a, b, c, d, e) {
            var f = new p2.Box({
                width: this.world.pxm(a),
                height: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e);
        },
        addPlane: function(a, b, c) {
            var d = new p2.Plane();
            return this.addShape(d, a, b, c);
        },
        addParticle: function(a, b, c) {
            var d = new p2.Particle();
            return this.addShape(d, a, b, c);
        },
        addLine: function(a, b, c, d) {
            var e = new p2.Line({
                length: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d);
        },
        addCapsule: function(a, b, c, d, e) {
            var f = new p2.Capsule({
                length: this.world.pxm(a),
                radius: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e);
        },
        addPolygon: function(a, b) {
            a = a || {}, Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
            var c = [];
            if (1 === b.length && Array.isArray(b[0])) c = b[0].slice(0); else if (Array.isArray(b[0])) c = b.slice(); else if ("number" == typeof b[0]) for (var d = 0, e = b.length; e > d; d += 2) c.push([ b[d], b[d + 1] ]);
            var f = c.length - 1;
            c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
            for (var g = 0; g < c.length; g++) c[g][0] = this.world.pxmi(c[g][0]), c[g][1] = this.world.pxmi(c[g][1]);
            var h = this.data.fromPolygon(c, a);
            return this.shapeChanged(), h;
        },
        removeShape: function(a) {
            var b = this.data.removeShape(a);
            return this.shapeChanged(), b;
        },
        setCircle: function(a, b, c, d) {
            return this.clearShapes(), this.addCircle(a, b, c, d);
        },
        setRectangle: function(a, b, c, d, e) {
            return void 0 === a && (a = 16), void 0 === b && (b = 16), this.clearShapes(), this.addRectangle(a, b, c, d, e);
        },
        setRectangleFromSprite: function(a) {
            return void 0 === a && (a = this.sprite), this.clearShapes(), this.addRectangle(a.width, a.height, 0, 0, a.rotation);
        },
        setMaterial: function(a, b) {
            if (void 0 === b) for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].material = a; else b.material = a;
        },
        shapeChanged: function() {
            this.debugBody && this.debugBody.draw();
        },
        addPhaserPolygon: function(a, b) {
            for (var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++) {
                var f = c[e], g = this.addFixture(f);
                d[f.filter.group] = d[f.filter.group] || [], d[f.filter.group] = d[f.filter.group].concat(g), 
                f.fixtureKey && (d[f.fixtureKey] = g);
            }
            return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), d;
        },
        addFixture: function(a) {
            var b = [];
            if (a.circle) {
                var c = new p2.Circle({
                    radius: this.world.pxm(a.circle.radius)
                });
                c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor;
                var d = p2.vec2.create();
                d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2), d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2), 
                this.data.addShape(c, d), b.push(c);
            } else for (var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++) {
                for (var h = e[g], i = [], j = 0; j < h.length; j += 2) i.push([ this.world.pxmi(h[j]), this.world.pxmi(h[j + 1]) ]);
                for (var c = new p2.Convex({
                    vertices: i
                }), k = 0; k !== c.vertices.length; k++) {
                    var l = c.vertices[k];
                    p2.vec2.sub(l, l, c.centerOfMass);
                }
                p2.vec2.scale(f, c.centerOfMass, 1), f[0] -= this.world.pxmi(this.sprite.width / 2), 
                f[1] -= this.world.pxmi(this.sprite.height / 2), c.updateTriangles(), c.updateCenterOfMass(), 
                c.updateBoundingRadius(), c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, 
                c.sensor = a.isSensor, this.data.addShape(c, f), b.push(c);
            }
            return b;
        },
        loadPolygon: function(a, b) {
            if (null === a) var c = b; else var c = this.game.cache.getPhysicsData(a, b);
            for (var d = p2.vec2.create(), e = 0; e < c.length; e++) {
                for (var f = [], g = 0; g < c[e].shape.length; g += 2) f.push([ this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1]) ]);
                for (var h = new p2.Convex({
                    vertices: f
                }), i = 0; i !== h.vertices.length; i++) {
                    var j = h.vertices[i];
                    p2.vec2.sub(j, j, h.centerOfMass);
                }
                p2.vec2.scale(d, h.centerOfMass, 1), d[0] -= this.world.pxmi(this.sprite.width / 2), 
                d[1] -= this.world.pxmi(this.sprite.height / 2), h.updateTriangles(), h.updateCenterOfMass(), 
                h.updateBoundingRadius(), this.data.addShape(h, d);
            }
            return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0;
        }
    }, c.Physics.P2.Body.prototype.constructor = c.Physics.P2.Body, c.Physics.P2.Body.DYNAMIC = 1, 
    c.Physics.P2.Body.STATIC = 2, c.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(c.Physics.P2.Body.prototype, "static", {
        get: function() {
            return this.data.type === c.Physics.P2.Body.STATIC;
        },
        set: function(a) {
            a && this.data.type !== c.Physics.P2.Body.STATIC ? (this.data.type = c.Physics.P2.Body.STATIC, 
            this.mass = 0) : a || this.data.type !== c.Physics.P2.Body.STATIC || (this.data.type = c.Physics.P2.Body.DYNAMIC, 
            this.mass = 1);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "dynamic", {
        get: function() {
            return this.data.type === c.Physics.P2.Body.DYNAMIC;
        },
        set: function(a) {
            a && this.data.type !== c.Physics.P2.Body.DYNAMIC ? (this.data.type = c.Physics.P2.Body.DYNAMIC, 
            this.mass = 1) : a || this.data.type !== c.Physics.P2.Body.DYNAMIC || (this.data.type = c.Physics.P2.Body.STATIC, 
            this.mass = 0);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "kinematic", {
        get: function() {
            return this.data.type === c.Physics.P2.Body.KINEMATIC;
        },
        set: function(a) {
            a && this.data.type !== c.Physics.P2.Body.KINEMATIC ? (this.data.type = c.Physics.P2.Body.KINEMATIC, 
            this.mass = 4) : a || this.data.type !== c.Physics.P2.Body.KINEMATIC || (this.data.type = c.Physics.P2.Body.STATIC, 
            this.mass = 0);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "allowSleep", {
        get: function() {
            return this.data.allowSleep;
        },
        set: function(a) {
            a !== this.data.allowSleep && (this.data.allowSleep = a);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "angle", {
        get: function() {
            return c.Math.wrapAngle(c.Math.radToDeg(this.data.angle));
        },
        set: function(a) {
            this.data.angle = c.Math.degToRad(c.Math.wrapAngle(a));
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularDamping", {
        get: function() {
            return this.data.angularDamping;
        },
        set: function(a) {
            this.data.angularDamping = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularForce", {
        get: function() {
            return this.data.angularForce;
        },
        set: function(a) {
            this.data.angularForce = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularVelocity", {
        get: function() {
            return this.data.angularVelocity;
        },
        set: function(a) {
            this.data.angularVelocity = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "damping", {
        get: function() {
            return this.data.damping;
        },
        set: function(a) {
            this.data.damping = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "fixedRotation", {
        get: function() {
            return this.data.fixedRotation;
        },
        set: function(a) {
            a !== this.data.fixedRotation && (this.data.fixedRotation = a);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "inertia", {
        get: function() {
            return this.data.inertia;
        },
        set: function(a) {
            this.data.inertia = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "mass", {
        get: function() {
            return this.data.mass;
        },
        set: function(a) {
            a !== this.data.mass && (this.data.mass = a, this.data.updateMassProperties());
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "motionState", {
        get: function() {
            return this.data.type;
        },
        set: function(a) {
            a !== this.data.type && (this.data.type = a);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "rotation", {
        get: function() {
            return this.data.angle;
        },
        set: function(a) {
            this.data.angle = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function() {
            return this.data.sleepSpeedLimit;
        },
        set: function(a) {
            this.data.sleepSpeedLimit = a;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.data.position[0]);
        },
        set: function(a) {
            this.data.position[0] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.data.position[1]);
        },
        set: function(a) {
            this.data.position[1] = this.world.pxmi(a);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "id", {
        get: function() {
            return this.data.id;
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "debug", {
        get: function() {
            return null !== this.debugBody;
        },
        set: function(a) {
            a && !this.debugBody ? this.debugBody = new c.Physics.P2.BodyDebug(this.game, this.data) : !a && this.debugBody && (this.debugBody.destroy(), 
            this.debugBody = null);
        }
    }), Object.defineProperty(c.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function() {
            return this._collideWorldBounds;
        },
        set: function(a) {
            a && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !a && this._collideWorldBounds && (this._collideWorldBounds = !1, 
            this.updateCollisionMask());
        }
    }), c.Physics.P2.BodyDebug = function(a, b, d) {
        c.Group.call(this, a);
        var e = {
            pixelsPerLengthUnit: a.physics.p2.mpx(1),
            debugPolygons: !1,
            lineWidth: 1,
            alpha: .5
        };
        this.settings = c.Utils.extend(e, d), this.ppu = this.settings.pixelsPerLengthUnit, 
        this.ppu = -1 * this.ppu, this.body = b, this.canvas = new c.Graphics(a), this.canvas.alpha = this.settings.alpha, 
        this.add(this.canvas), this.draw(), this.updateSpriteTransform();
    }, c.Physics.P2.BodyDebug.prototype = Object.create(c.Group.prototype), c.Physics.P2.BodyDebug.prototype.constructor = c.Physics.P2.BodyDebug, 
    c.Utils.extend(c.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function() {
            this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, 
            this.rotation = this.body.angle;
        },
        draw: function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
            if (h = this.body, j = this.canvas, j.clear(), c = parseInt(this.randomPastelHex(), 16), 
            f = 16711680, g = this.lineWidth, h instanceof p2.Body && h.shapes.length) {
                var p = h.shapes.length;
                for (d = 0; d !== p; ) {
                    if (b = h.shapes[d], i = b.position || 0, a = b.angle || 0, b instanceof p2.Circle) this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g); else if (b instanceof p2.Capsule) this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g); else if (b instanceof p2.Plane) this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a); else if (b instanceof p2.Line) this.drawLine(j, b.length * this.ppu, f, g); else if (b instanceof p2.Box) this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g); else if (b instanceof p2.Convex) {
                        for (l = [], m = p2.vec2.create(), e = n = 0, o = b.vertices.length; o >= 0 ? o > n : n > o; e = o >= 0 ? ++n : --n) k = b.vertices[e], 
                        p2.vec2.rotate(m, k, a), l.push([ (m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu ]);
                        this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [ i[0] * this.ppu, -i[1] * this.ppu ]);
                    }
                    d++;
                }
            }
        },
        drawRectangle: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1), a.beginFill(h), 
            a.drawRect(b - e / 2, c - f / 2, e, f);
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            void 0 === g && (g = 1), void 0 === f && (f = 16777215), a.lineStyle(g, 0, 1), a.beginFill(f, 1), 
            a.drawCircle(b, c, 2 * -e), a.endFill(), a.moveTo(b, c), a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d));
        },
        drawLine: function(a, b, c, d) {
            void 0 === d && (d = 1), void 0 === c && (c = 0), a.lineStyle(5 * d, c, 1), a.moveTo(-b / 2, 0), 
            a.lineTo(b / 2, 0);
        },
        drawConvex: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s;
            if (void 0 === f && (f = 1), void 0 === d && (d = 0), g) {
                for (i = [ 16711680, 65280, 255 ], j = 0; j !== b.length + 1; ) l = b[j % b.length], 
                m = b[(j + 1) % b.length], o = l[0], r = l[1], p = m[0], s = m[1], a.lineStyle(f, i[j % i.length], 1), 
                a.moveTo(o, -r), a.lineTo(p, -s), a.drawCircle(o, -r, 2 * f), j++;
                return a.lineStyle(f, 0, 1), a.drawCircle(h[0], h[1], 2 * f);
            }
            for (a.lineStyle(f, d, 1), a.beginFill(e), j = 0; j !== b.length; ) k = b[j], n = k[0], 
            q = k[1], 0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q), j++;
            return a.endFill(), b.length > 2 ? (a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]), 
            a.lineTo(b[0][0], -b[0][1])) : void 0;
        },
        drawPath: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q, r;
            for (void 0 === e && (e = 1), void 0 === c && (c = 0), a.lineStyle(e, c, 1), "number" == typeof d && a.beginFill(d), 
            h = null, i = null, g = 0; g < b.length; ) p = b[g], q = p[0], r = p[1], (q !== h || r !== i) && (0 === g ? a.moveTo(q, r) : (j = h, 
            k = i, l = q, m = r, n = b[(g + 1) % b.length][0], o = b[(g + 1) % b.length][1], 
            f = (l - j) * (o - k) - (n - j) * (m - k), 0 !== f && a.lineTo(q, r)), h = q, i = r), 
            g++;
            "number" == typeof d && a.endFill(), b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]), 
            a.lineTo(b[0][0], b[0][1]));
        },
        drawPlane: function(a, b, c, d, e, f, g, h, i, j) {
            var k, l, m;
            void 0 === f && (f = 1), void 0 === d && (d = 16777215), a.lineStyle(f, e, 11), 
            a.beginFill(d), k = i, a.moveTo(b, -c), l = b + Math.cos(j) * this.game.width, m = c + Math.sin(j) * this.game.height, 
            a.lineTo(l, -m), a.moveTo(b, -c), l = b + Math.cos(j) * -this.game.width, m = c + Math.sin(j) * -this.game.height, 
            a.lineTo(l, -m);
        },
        drawCapsule: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1);
            var j = Math.cos(d), k = Math.sin(d);
            a.beginFill(h, 1), a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f), a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f), 
            a.endFill(), a.lineStyle(i, g, 0), a.beginFill(h, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), 
            a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c), 
            a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.endFill(), a.lineStyle(i, g, 1), 
            a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), 
            a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c);
        },
        randomPastelHex: function() {
            var a, b, c, d;
            return c = [ 255, 255, 255 ], d = Math.floor(256 * Math.random()), b = Math.floor(256 * Math.random()), 
            a = Math.floor(256 * Math.random()), d = Math.floor((d + 3 * c[0]) / 4), b = Math.floor((b + 3 * c[1]) / 4), 
            a = Math.floor((a + 3 * c[2]) / 4), this.rgbToHex(d, b, a);
        },
        rgbToHex: function(a, b, c) {
            return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c);
        },
        componentToHex: function(a) {
            var b;
            return b = a.toString(16), 2 === b.len ? b : b + "0";
        }
    }), c.Physics.P2.Spring = function(a, b, c, d, e, f, g, h, i, j) {
        this.game = a.game, this.world = a, void 0 === d && (d = 1), void 0 === e && (e = 100), 
        void 0 === f && (f = 1), d = a.pxm(d);
        var k = {
            restLength: d,
            stiffness: e,
            damping: f
        };
        "undefined" != typeof g && null !== g && (k.worldAnchorA = [ a.pxm(g[0]), a.pxm(g[1]) ]), 
        "undefined" != typeof h && null !== h && (k.worldAnchorB = [ a.pxm(h[0]), a.pxm(h[1]) ]), 
        "undefined" != typeof i && null !== i && (k.localAnchorA = [ a.pxm(i[0]), a.pxm(i[1]) ]), 
        "undefined" != typeof j && null !== j && (k.localAnchorB = [ a.pxm(j[0]), a.pxm(j[1]) ]), 
        this.data = new p2.LinearSpring(b, c, k), this.data.parent = this;
    }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.RotationalSpring = function(a, b, c, d, e, f) {
        this.game = a.game, this.world = a, void 0 === d && (d = null), void 0 === e && (e = 100), 
        void 0 === f && (f = 1), d && (d = a.pxm(d));
        var g = {
            restAngle: d,
            stiffness: e,
            damping: f
        };
        this.data = new p2.RotationalSpring(b, c, g), this.data.parent = this;
    }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.Material = function(a) {
        this.name = a, p2.Material.call(this);
    }, c.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), c.Physics.P2.Material.prototype.constructor = c.Physics.P2.Material, 
    c.Physics.P2.ContactMaterial = function(a, b, c) {
        p2.ContactMaterial.call(this, a, b, c);
    }, c.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), 
    c.Physics.P2.ContactMaterial.prototype.constructor = c.Physics.P2.ContactMaterial, 
    c.Physics.P2.CollisionGroup = function(a) {
        this.mask = a;
    }, c.Physics.P2.DistanceConstraint = function(a, b, c, d, e, f, g) {
        void 0 === d && (d = 100), void 0 === e && (e = [ 0, 0 ]), void 0 === f && (f = [ 0, 0 ]), 
        void 0 === g && (g = Number.MAX_VALUE), this.game = a.game, this.world = a, d = a.pxm(d), 
        e = [ a.pxmi(e[0]), a.pxmi(e[1]) ], f = [ a.pxmi(f[0]), a.pxmi(f[1]) ];
        var h = {
            distance: d,
            localAnchorA: e,
            localAnchorB: f,
            maxForce: g
        };
        p2.DistanceConstraint.call(this, b, c, h);
    }, c.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), 
    c.Physics.P2.DistanceConstraint.prototype.constructor = c.Physics.P2.DistanceConstraint, 
    c.Physics.P2.GearConstraint = function(a, b, c, d, e) {
        void 0 === d && (d = 0), void 0 === e && (e = 1), this.game = a.game, this.world = a;
        var f = {
            angle: d,
            ratio: e
        };
        p2.GearConstraint.call(this, b, c, f);
    }, c.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), 
    c.Physics.P2.GearConstraint.prototype.constructor = c.Physics.P2.GearConstraint, 
    c.Physics.P2.LockConstraint = function(a, b, c, d, e, f) {
        void 0 === d && (d = [ 0, 0 ]), void 0 === e && (e = 0), void 0 === f && (f = Number.MAX_VALUE), 
        this.game = a.game, this.world = a, d = [ a.pxm(d[0]), a.pxm(d[1]) ];
        var g = {
            localOffsetB: d,
            localAngleB: e,
            maxForce: f
        };
        p2.LockConstraint.call(this, b, c, g);
    }, c.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), 
    c.Physics.P2.LockConstraint.prototype.constructor = c.Physics.P2.LockConstraint, 
    c.Physics.P2.PrismaticConstraint = function(a, b, c, d, e, f, g, h) {
        void 0 === d && (d = !0), void 0 === e && (e = [ 0, 0 ]), void 0 === f && (f = [ 0, 0 ]), 
        void 0 === g && (g = [ 0, 0 ]), void 0 === h && (h = Number.MAX_VALUE), this.game = a.game, 
        this.world = a, e = [ a.pxmi(e[0]), a.pxmi(e[1]) ], f = [ a.pxmi(f[0]), a.pxmi(f[1]) ];
        var i = {
            localAnchorA: e,
            localAnchorB: f,
            localAxisA: g,
            maxForce: h,
            disableRotationalLock: !d
        };
        p2.PrismaticConstraint.call(this, b, c, i);
    }, c.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), 
    c.Physics.P2.PrismaticConstraint.prototype.constructor = c.Physics.P2.PrismaticConstraint, 
    c.Physics.P2.RevoluteConstraint = function(a, b, c, d, e, f, g) {
        void 0 === f && (f = Number.MAX_VALUE), void 0 === g && (g = null), this.game = a.game, 
        this.world = a, c = [ a.pxmi(c[0]), a.pxmi(c[1]) ], e = [ a.pxmi(e[0]), a.pxmi(e[1]) ], 
        g && (g = [ a.pxmi(g[0]), a.pxmi(g[1]) ]);
        var h = {
            worldPivot: g,
            localPivotA: c,
            localPivotB: e,
            maxForce: f
        };
        p2.RevoluteConstraint.call(this, b, d, h);
    }, c.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), 
    c.Physics.P2.RevoluteConstraint.prototype.constructor = c.Physics.P2.RevoluteConstraint, 
    c.ImageCollection = function(a, b, c, d, e, f, g) {
        (void 0 === c || 0 >= c) && (c = 32), (void 0 === d || 0 >= d) && (d = 32), void 0 === e && (e = 0), 
        void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.imageWidth = 0 | c, 
        this.imageHeight = 0 | d, this.imageMargin = 0 | e, this.imageSpacing = 0 | f, this.properties = g || {}, 
        this.images = [], this.total = 0;
    }, c.ImageCollection.prototype = {
        containsImageIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total;
        },
        addImage: function(a, b) {
            this.images.push({
                gid: a,
                image: b
            }), this.total++;
        }
    }, c.ImageCollection.prototype.constructor = c.ImageCollection, c.Tile = function(a, b, c, d, e, f) {
        this.layer = a, this.index = b, this.x = c, this.y = d, this.rotation = 0, this.flipped = !1, 
        this.worldX = c * e, this.worldY = d * f, this.width = e, this.height = f, this.centerX = Math.abs(e / 2), 
        this.centerY = Math.abs(f / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, 
        this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, 
        this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, 
        this.collisionCallback = null, this.collisionCallbackContext = this;
    }, c.Tile.prototype = {
        containsPoint: function(a, b) {
            return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom);
        },
        intersects: function(a, b, c, d) {
            return c <= this.worldX ? !1 : d <= this.worldY ? !1 : a >= this.worldX + this.width ? !1 : b >= this.worldY + this.height ? !1 : !0;
        },
        setCollisionCallback: function(a, b) {
            this.collisionCallback = a, this.collisionCallbackContext = b;
        },
        destroy: function() {
            this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null;
        },
        setCollision: function(a, b, c, d) {
            this.collideLeft = a, this.collideRight = b, this.collideUp = c, this.collideDown = d, 
            this.faceLeft = a, this.faceRight = b, this.faceTop = c, this.faceBottom = d;
        },
        resetCollision: function() {
            this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, 
            this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1;
        },
        isInteresting: function(a, b) {
            return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : b ? this.faceTop || this.faceBottom || this.faceLeft || this.faceRight : !1;
        },
        copy: function(a) {
            this.index = a.index, this.alpha = a.alpha, this.properties = a.properties, this.collideUp = a.collideUp, 
            this.collideDown = a.collideDown, this.collideLeft = a.collideLeft, this.collideRight = a.collideRight, 
            this.collisionCallback = a.collisionCallback, this.collisionCallbackContext = a.collisionCallbackContext;
        }
    }, c.Tile.prototype.constructor = c.Tile, Object.defineProperty(c.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
    }), Object.defineProperty(c.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        }
    }), Object.defineProperty(c.Tile.prototype, "left", {
        get: function() {
            return this.worldX;
        }
    }), Object.defineProperty(c.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width;
        }
    }), Object.defineProperty(c.Tile.prototype, "top", {
        get: function() {
            return this.worldY;
        }
    }), Object.defineProperty(c.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height;
        }
    }), c.Tilemap = function(a, b, d, e, f, g) {
        this.game = a, this.key = b;
        var h = c.TilemapParser.parse(this.game, b, d, e, f, g);
        null !== h && (this.width = h.width, this.height = h.height, this.tileWidth = h.tileWidth, 
        this.tileHeight = h.tileHeight, this.orientation = h.orientation, this.format = h.format, 
        this.version = h.version, this.properties = h.properties, this.widthInPixels = h.widthInPixels, 
        this.heightInPixels = h.heightInPixels, this.layers = h.layers, this.tilesets = h.tilesets, 
        this.imagecollections = h.imagecollections, this.tiles = h.tiles, this.objects = h.objects, 
        this.collideIndexes = [], this.collision = h.collision, this.images = h.images, 
        this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, 
        this._tempB = 0);
    }, c.Tilemap.CSV = 0, c.Tilemap.TILED_JSON = 1, c.Tilemap.NORTH = 0, c.Tilemap.EAST = 1, 
    c.Tilemap.SOUTH = 2, c.Tilemap.WEST = 3, c.Tilemap.prototype = {
        create: function(a, b, c, d, e, f) {
            return void 0 === f && (f = this.game.world), this.width = b, this.height = c, this.setTileSize(d, e), 
            this.layers.length = 0, this.createBlankLayer(a, b, c, d, e, f);
        },
        setTileSize: function(a, b) {
            this.tileWidth = a, this.tileHeight = b, this.widthInPixels = this.width * a, this.heightInPixels = this.height * b;
        },
        addTilesetImage: function(a, b, d, e, f, g, h) {
            if (void 0 === a) return null;
            void 0 === d && (d = this.tileWidth), void 0 === e && (e = this.tileHeight), void 0 === f && (f = 0), 
            void 0 === g && (g = 0), void 0 === h && (h = 0), 0 === d && (d = 32), 0 === e && (e = 32);
            var i = null;
            if ((void 0 === b || null === b) && (b = a), b instanceof c.BitmapData) i = b.canvas; else {
                if (!this.game.cache.checkImageKey(b)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + b + '"'), 
                null;
                i = this.game.cache.getImage(b);
            }
            var j = this.getTilesetIndex(a);
            if (null === j && this.format === c.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + b + '"'), 
            null;
            if (this.tilesets[j]) return this.tilesets[j].setImage(i), this.tilesets[j];
            var k = new c.Tileset(a, h, d, e, f, g, {});
            k.setImage(i), this.tilesets.push(k);
            for (var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h; r < h + k.total && (this.tiles[r] = [ m, n, l ], 
            m += d + g, o++, o !== k.total) && (p++, p !== k.columns || (m = f, n += e + g, 
            p = 0, q++, q !== k.rows)); r++) ;
            return k;
        },
        createFromObjects: function(a, b, d, e, f, g, h, i, j) {
            if (void 0 === f && (f = !0), void 0 === g && (g = !1), void 0 === h && (h = this.game.world), 
            void 0 === i && (i = c.Sprite), void 0 === j && (j = !0), !this.objects[a]) return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + a);
            for (var k = 0; k < this.objects[a].length; k++) {
                var l = !1, m = this.objects[a][k];
                if (void 0 !== m.gid && "number" == typeof b && m.gid === b ? l = !0 : void 0 !== m.id && "number" == typeof b && m.id === b ? l = !0 : void 0 !== m.name && "string" == typeof b && m.name === b && (l = !0), 
                l) {
                    var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
                    n.name = m.name, n.visible = m.visible, n.autoCull = g, n.exists = f, m.width && (n.width = m.width), 
                    m.height && (n.height = m.height), m.rotation && (n.angle = m.rotation), j && (n.y -= n.height), 
                    h.add(n);
                    for (var o in m.properties) h.set(n, o, m.properties[o], !1, !1, 0, !0);
                }
            }
        },
        createFromTiles: function(a, b, d, e, f, g) {
            "number" == typeof a && (a = [ a ]), void 0 === b || null === b ? b = [] : "number" == typeof b && (b = [ b ]), 
            e = this.getLayer(e), void 0 === f && (f = this.game.world), void 0 === g && (g = {}), 
            void 0 === g.customClass && (g.customClass = c.Sprite), void 0 === g.adjustY && (g.adjustY = !0);
            var h = this.layers[e].width, i = this.layers[e].height;
            if (this.copy(0, 0, h, i, e), this._results.length < 2) return 0;
            for (var j, k = 0, l = 1, m = this._results.length; m > l; l++) if (-1 !== a.indexOf(this._results[l].index)) {
                j = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
                for (var n in g) j[n] = g[n];
                f.add(j), k++;
            }
            if (1 === b.length) for (l = 0; l < a.length; l++) this.replace(a[l], b[0], 0, 0, h, i, e); else if (b.length > 1) for (l = 0; l < a.length; l++) this.replace(a[l], b[l], 0, 0, h, i, e);
            return k;
        },
        createLayer: function(a, b, d, e) {
            void 0 === b && (b = this.game.width), void 0 === d && (d = this.game.height), void 0 === e && (e = this.game.world);
            var f = a;
            return "string" == typeof a && (f = this.getLayerIndex(a)), null === f || f > this.layers.length ? void console.warn("Tilemap.createLayer: Invalid layer ID given: " + f) : e.add(new c.TilemapLayer(this.game, this, f, b, d));
        },
        createBlankLayer: function(a, b, d, e, f, g) {
            if (void 0 === g && (g = this.game.world), null !== this.getLayerIndex(a)) return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
            for (var h, i = {
                name: a,
                x: 0,
                y: 0,
                width: b,
                height: d,
                widthInPixels: b * e,
                heightInPixels: d * f,
                alpha: 1,
                visible: !0,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            }, j = [], k = 0; d > k; k++) {
                h = [];
                for (var l = 0; b > l; l++) h.push(new c.Tile(i, -1, l, k, e, f));
                j.push(h);
            }
            i.data = j, this.layers.push(i), this.currentLayer = this.layers.length - 1;
            var m = i.widthInPixels, n = i.heightInPixels;
            m > this.game.width && (m = this.game.width), n > this.game.height && (n = this.game.height);
            var j = new c.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
            return j.name = a, g.add(j);
        },
        getIndex: function(a, b) {
            for (var c = 0; c < a.length; c++) if (a[c].name === b) return c;
            return null;
        },
        getLayerIndex: function(a) {
            return this.getIndex(this.layers, a);
        },
        getTilesetIndex: function(a) {
            return this.getIndex(this.tilesets, a);
        },
        getImageIndex: function(a) {
            return this.getIndex(this.images, a);
        },
        getObjectIndex: function(a) {
            return this.getIndex(this.objects, a);
        },
        setTileIndexCallback: function(a, b, c, d) {
            if (d = this.getLayer(d), "number" == typeof a) this.layers[d].callbacks[a] = {
                callback: b,
                callbackContext: c
            }; else for (var e = 0, f = a.length; f > e; e++) this.layers[d].callbacks[a[e]] = {
                callback: b,
                callbackContext: c
            };
        },
        setTileLocationCallback: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g), this.copy(a, b, c, d, g), !(this._results.length < 2)) for (var h = 1; h < this._results.length; h++) this._results[h].setCollisionCallback(e, f);
        },
        setCollision: function(a, b, c, d) {
            if (void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c), "number" == typeof a) return this.setCollisionByIndex(a, b, c, !0);
            if (Array.isArray(a)) {
                for (var e = 0; e < a.length; e++) this.setCollisionByIndex(a[e], b, c, !1);
                d && this.calculateFaces(c);
            }
        },
        setCollisionBetween: function(a, b, c, d, e) {
            if (void 0 === c && (c = !0), void 0 === e && (e = !0), d = this.getLayer(d), !(a > b)) {
                for (var f = a; b >= f; f++) this.setCollisionByIndex(f, c, d, !1);
                e && this.calculateFaces(d);
            }
        },
        setCollisionByExclusion: function(a, b, c, d) {
            void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c);
            for (var e = 0, f = this.tiles.length; f > e; e++) -1 === a.indexOf(e) && this.setCollisionByIndex(e, b, c, !1);
            d && this.calculateFaces(c);
        },
        setCollisionByIndex: function(a, b, c, d) {
            if (void 0 === b && (b = !0), void 0 === c && (c = this.currentLayer), void 0 === d && (d = !0), 
            b) this.collideIndexes.push(a); else {
                var e = this.collideIndexes.indexOf(a);
                e > -1 && this.collideIndexes.splice(e, 1);
            }
            for (var f = 0; f < this.layers[c].height; f++) for (var g = 0; g < this.layers[c].width; g++) {
                var h = this.layers[c].data[f][g];
                h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(), 
                h.faceTop = b, h.faceBottom = b, h.faceLeft = b, h.faceRight = b);
            }
            return d && this.calculateFaces(c), c;
        },
        getLayer: function(a) {
            return void 0 === a ? a = this.currentLayer : "string" == typeof a ? a = this.getLayerIndex(a) : a instanceof c.TilemapLayer && (a = a.index), 
            a;
        },
        setPreventRecalculate: function(a) {
            if (a === !0 && this.preventingRecalculate !== !0 && (this.preventingRecalculate = !0, 
            this.needToRecalculate = {}), a === !1 && this.preventingRecalculate === !0) {
                this.preventingRecalculate = !1;
                for (var b in this.needToRecalculate) this.calculateFaces(b);
                this.needToRecalculate = !1;
            }
        },
        calculateFaces: function(a) {
            if (this.preventingRecalculate) return void (this.needToRecalculate[a] = !0);
            for (var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; g > f; f++) for (var h = 0, i = this.layers[a].width; i > h; h++) {
                var j = this.layers[a].data[f][h];
                j && (b = this.getTileAbove(a, h, f), c = this.getTileBelow(a, h, f), d = this.getTileLeft(a, h, f), 
                e = this.getTileRight(a, h, f), j.collides && (j.faceTop = !0, j.faceBottom = !0, 
                j.faceLeft = !0, j.faceRight = !0), b && b.collides && (j.faceTop = !1), c && c.collides && (j.faceBottom = !1), 
                d && d.collides && (j.faceLeft = !1), e && e.collides && (j.faceRight = !1));
            }
        },
        getTileAbove: function(a, b, c) {
            return c > 0 ? this.layers[a].data[c - 1][b] : null;
        },
        getTileBelow: function(a, b, c) {
            return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null;
        },
        getTileLeft: function(a, b, c) {
            return b > 0 ? this.layers[a].data[c][b - 1] : null;
        },
        getTileRight: function(a, b, c) {
            return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null;
        },
        setLayer: function(a) {
            a = this.getLayer(a), this.layers[a] && (this.currentLayer = a);
        },
        hasTile: function(a, b, c) {
            return c = this.getLayer(c), this.layers[c].data[b][a].index > -1;
        },
        removeTile: function(a, b, d) {
            if (d = this.getLayer(d), a >= 0 && a < this.layers[d].width && b >= 0 && b < this.layers[d].height && this.hasTile(a, b, d)) {
                var e = this.layers[d].data[b][a];
                return this.layers[d].data[b][a] = new c.Tile(this.layers[d], -1, a, b, this.tileWidth, this.tileHeight), 
                this.layers[d].dirty = !0, this.calculateFaces(d), e;
            }
        },
        removeTileWorldXY: function(a, b, c, d, e) {
            return e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, 
            this.removeTile(a, b, e);
        },
        putTile: function(a, b, d, e) {
            if (null === a) return this.removeTile(b, d, e);
            if (e = this.getLayer(e), b >= 0 && b < this.layers[e].width && d >= 0 && d < this.layers[e].height) {
                var f;
                return a instanceof c.Tile ? (f = a.index, this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : this.layers[e].data[d][b] = new c.Tile(e, f, b, d, a.width, a.height)) : (f = a, 
                this.hasTile(b, d, e) ? this.layers[e].data[d][b].index = f : this.layers[e].data[d][b] = new c.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight)), 
                this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision(), 
                this.layers[e].dirty = !0, this.calculateFaces(e), this.layers[e].data[d][b];
            }
            return null;
        },
        putTileWorldXY: function(a, b, c, d, e, f) {
            return f = this.getLayer(f), b = this.game.math.snapToFloor(b, d) / d, c = this.game.math.snapToFloor(c, e) / e, 
            this.putTile(a, b, c, f);
        },
        searchTileIndex: function(a, b, c, d) {
            void 0 === b && (b = 0), void 0 === c && (c = !1), d = this.getLayer(d);
            var e = 0;
            if (c) {
                for (var f = this.layers[d].height - 1; f >= 0; f--) for (var g = this.layers[d].width - 1; g >= 0; g--) if (this.layers[d].data[f][g].index === a) {
                    if (e === b) return this.layers[d].data[f][g];
                    e++;
                }
            } else for (var f = 0; f < this.layers[d].height; f++) for (var g = 0; g < this.layers[d].width; g++) if (this.layers[d].data[f][g].index === a) {
                if (e === b) return this.layers[d].data[f][g];
                e++;
            }
            return null;
        },
        getTile: function(a, b, c, d) {
            return void 0 === d && (d = !1), c = this.getLayer(c), a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? -1 === this.layers[c].data[b][a].index ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null;
        },
        getTileWorldXY: function(a, b, c, d, e, f) {
            return void 0 === c && (c = this.tileWidth), void 0 === d && (d = this.tileHeight), 
            e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, 
            this.getTile(a, b, e, f);
        },
        copy: function(a, b, c, d, e) {
            if (e = this.getLayer(e), !this.layers[e]) return void (this._results.length = 0);
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.layers[e].width), 
            void 0 === d && (d = this.layers[e].height), 0 > a && (a = 0), 0 > b && (b = 0), 
            c > this.layers[e].width && (c = this.layers[e].width), d > this.layers[e].height && (d = this.layers[e].height), 
            this._results.length = 0, this._results.push({
                x: a,
                y: b,
                width: c,
                height: d,
                layer: e
            });
            for (var f = b; b + d > f; f++) for (var g = a; a + c > g; g++) this._results.push(this.layers[e].data[f][g]);
            return this._results;
        },
        paste: function(a, b, c, d) {
            if (void 0 === a && (a = 0), void 0 === b && (b = 0), d = this.getLayer(d), c && !(c.length < 2)) {
                for (var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++) this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
                this.layers[d].dirty = !0, this.calculateFaces(d);
            }
        },
        swap: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._tempA = a, 
            this._tempB = b, this._results.forEach(this.swapHandler, this), this.paste(c, d, this._results, g));
        },
        swapHandler: function(a) {
            a.index === this._tempA ? a.index = this._tempB : a.index === this._tempB && (a.index = this._tempA);
        },
        forEach: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._results.forEach(a, b), 
            this.paste(c, d, this._results, g));
        },
        replace: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g), this.copy(c, d, e, f, g), !(this._results.length < 2)) {
                for (var h = 1; h < this._results.length; h++) this._results[h].index === a && (this._results[h].index = b);
                this.paste(c, d, this._results, g);
            }
        },
        random: function(a, b, c, d, e) {
            if (e = this.getLayer(e), this.copy(a, b, c, d, e), !(this._results.length < 2)) {
                for (var f = [], g = 1; g < this._results.length; g++) if (this._results[g].index) {
                    var h = this._results[g].index;
                    -1 === f.indexOf(h) && f.push(h);
                }
                for (var i = 1; i < this._results.length; i++) this._results[i].index = this.game.rnd.pick(f);
                this.paste(a, b, this._results, e);
            }
        },
        shuffle: function(a, b, d, e, f) {
            if (f = this.getLayer(f), this.copy(a, b, d, e, f), !(this._results.length < 2)) {
                for (var g = [], h = 1; h < this._results.length; h++) this._results[h].index && g.push(this._results[h].index);
                c.ArrayUtils.shuffle(g);
                for (var i = 1; i < this._results.length; i++) this._results[i].index = g[i - 1];
                this.paste(a, b, this._results, f);
            }
        },
        fill: function(a, b, c, d, e, f) {
            if (f = this.getLayer(f), this.copy(b, c, d, e, f), !(this._results.length < 2)) {
                for (var g = 1; g < this._results.length; g++) this._results[g].index = a;
                this.paste(b, c, this._results, f);
            }
        },
        removeAllLayers: function() {
            this.layers.length = 0, this.currentLayer = 0;
        },
        dump: function() {
            for (var a = "", b = [ "" ], c = 0; c < this.layers[this.currentLayer].height; c++) {
                for (var d = 0; d < this.layers[this.currentLayer].width; d++) a += "%c  ", b.push(this.layers[this.currentLayer].data[c][d] > 1 ? this.debugMap[this.layers[this.currentLayer].data[c][d]] ? "background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]] : "background: #ffffff" : "background: rgb(0, 0, 0)");
                a += "\n";
            }
            b[0] = a, console.log.apply(console, b);
        },
        destroy: function() {
            this.removeAllLayers(), this.data = [], this.game = null;
        }
    }, c.Tilemap.prototype.constructor = c.Tilemap, Object.defineProperty(c.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer];
        },
        set: function(a) {
            a !== this.currentLayer && this.setLayer(a);
        }
    }), c.TilemapLayer = function(a, b, d, e, f) {
        e |= 0, f |= 0, c.Sprite.call(this, a, 0, 0), this.map = b, this.index = d, this.layer = b.layers[d], 
        this.canvas = PIXI.CanvasPool.create(this, e, f), this.context = this.canvas.getContext("2d"), 
        this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = c.TILEMAPLAYER, 
        this.physicsType = c.TILEMAPLAYER, this.renderSettings = {
            enableScrollDelta: !1,
            overdrawRatio: .2,
            copyCanvas: null
        }, this.debug = !1, this.exists = !0, this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: !0,
            debugAlpha: .5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, 
        this._wrap = !1, this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: b.tileWidth,
            tileHeight: b.tileHeight,
            cw: b.tileWidth,
            ch: b.tileHeight,
            tilesets: []
        }, this._scrollX = 0, this._scrollY = 0, this._results = [], a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = c.TilemapLayer.ensureSharedCopyCanvas()), 
        this.fixedToCamera = !0;
    }, c.TilemapLayer.prototype = Object.create(c.Sprite.prototype), c.TilemapLayer.prototype.constructor = c.TilemapLayer, 
    c.TilemapLayer.prototype.preUpdateCore = c.Component.Core.preUpdate, c.TilemapLayer.sharedCopyCanvas = null, 
    c.TilemapLayer.ensureSharedCopyCanvas = function() {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = c.Canvas.create(2, 2)), 
        this.sharedCopyCanvas;
    }, c.TilemapLayer.prototype.preUpdate = function() {
        return this.preUpdateCore();
    }, c.TilemapLayer.prototype.postUpdate = function() {
        c.Component.FixedToCamera.postUpdate.call(this);
        var a = this.game.camera;
        this.scrollX = a.x * this.scrollFactorX / this.scale.x, this.scrollY = a.y * this.scrollFactorY / this.scale.y, 
        this.render();
    }, c.TilemapLayer.prototype.destroy = function() {
        PIXI.CanvasPool.remove(this), c.Component.Destroy.prototype.destroy.call(this);
    }, c.TilemapLayer.prototype.resize = function(a, b) {
        this.canvas.width = a, this.canvas.height = b, this.texture.frame.resize(a, b), 
        this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, 
        this.texture.baseTexture.width = a, this.texture.baseTexture.height = b, this.texture.baseTexture.dirty(), 
        this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0;
    }, c.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y);
    }, c.TilemapLayer.prototype._fixX = function(a) {
        return 0 > a && (a = 0), 1 === this.scrollFactorX ? a : this._scrollX + (a - this._scrollX / this.scrollFactorX);
    }, c.TilemapLayer.prototype._unfixX = function(a) {
        return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX);
    }, c.TilemapLayer.prototype._fixY = function(a) {
        return 0 > a && (a = 0), 1 === this.scrollFactorY ? a : this._scrollY + (a - this._scrollY / this.scrollFactorY);
    }, c.TilemapLayer.prototype._unfixY = function(a) {
        return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY);
    }, c.TilemapLayer.prototype.getTileX = function(a) {
        return Math.floor(this._fixX(a) / this._mc.tileWidth);
    }, c.TilemapLayer.prototype.getTileY = function(a) {
        return Math.floor(this._fixY(a) / this._mc.tileHeight);
    }, c.TilemapLayer.prototype.getTileXY = function(a, b, c) {
        return c.x = this.getTileX(a), c.y = this.getTileY(b), c;
    }, c.TilemapLayer.prototype.getRayCastTiles = function(a, b, c, d) {
        b || (b = this.rayStepRate), void 0 === c && (c = !1), void 0 === d && (d = !1);
        var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
        if (0 === e.length) return [];
        for (var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++) for (var i = 0; i < f.length; i++) {
            var j = e[h], k = f[i];
            if (j.containsPoint(k[0], k[1])) {
                g.push(j);
                break;
            }
        }
        return g;
    }, c.TilemapLayer.prototype.getTiles = function(a, b, c, d, e, f) {
        void 0 === e && (e = !1), void 0 === f && (f = !1);
        var g = !(e || f);
        a = this._fixX(a), b = this._fixY(b);
        for (var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length; ) this._results.pop();
        for (var l = i; i + k > l; l++) for (var m = h; h + j > m; m++) {
            var n = this.layer.data[l];
            n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m]);
        }
        return this._results.slice();
    }, c.TilemapLayer.prototype.resolveTileset = function(a) {
        var b = this._mc.tilesets;
        if (2e3 > a) for (;b.length < a; ) b.push(void 0);
        var c = this.map.tiles[a] && this.map.tiles[a][2];
        if (null != c) {
            var d = this.map.tilesets[c];
            if (d && d.containsTileIndex(a)) return b[a] = d;
        }
        return b[a] = null;
    }, c.TilemapLayer.prototype.resetTilesetCache = function() {
        for (var a = this._mc.tilesets; a.length; ) a.pop();
    }, c.TilemapLayer.prototype.setScale = function(a, b) {
        a = a || 1, b = b || a;
        for (var c = 0; c < this.layer.data.length; c++) for (var d = this.layer.data[c], e = 0; e < d.length; e++) {
            var f = d[e];
            f.width = this.map.tileWidth * a, f.height = this.map.tileHeight * b, f.worldX = f.x * f.width, 
            f.worldY = f.y * f.height;
        }
        this.scale.setTo(a, b);
    }, c.TilemapLayer.prototype.shiftCanvas = function(a, b, c) {
        var d = a.canvas, e = d.width - Math.abs(b), f = d.height - Math.abs(c), g = 0, h = 0, i = b, j = c;
        0 > b && (g = -b, i = 0), 0 > c && (h = -c, j = 0);
        var k = this.renderSettings.copyCanvas;
        if (k) {
            (k.width < e || k.height < f) && (k.width = e, k.height = f);
            var l = k.getContext("2d");
            l.clearRect(0, 0, e, f), l.drawImage(d, g, h, e, f, 0, 0, e, f), a.clearRect(i, j, e, f), 
            a.drawImage(k, 0, 0, e, f, i, j, e, f);
        } else a.save(), a.globalCompositeOperation = "copy", a.drawImage(d, g, h, e, f, i, j, e, f), 
        a.restore();
    }, c.TilemapLayer.prototype.renderRegion = function(a, b, c, d, e, f) {
        var g = this.context, h = this.layer.width, i = this.layer.height, j = this._mc.tileWidth, k = this._mc.tileHeight, l = this._mc.tilesets, m = 0 / 0;
        this._wrap || (e >= c && (c = Math.max(0, c), e = Math.min(h - 1, e)), f >= d && (d = Math.max(0, d), 
        f = Math.min(i - 1, f)));
        var n, o, p, q, r, s, t = c * j - a, u = d * k - b, v = (c + (1 << 20) * h) % h, w = (d + (1 << 20) * i) % i;
        for (g.fillStyle = this.tileColor, q = w, s = f - d, o = u; s >= 0; q++, s--, o += k) {
            q >= i && (q -= i);
            var x = this.layer.data[q];
            for (p = v, r = e - c, n = t; r >= 0; p++, r--, n += j) {
                p >= h && (p -= h);
                var y = x[p];
                if (y && !(y.index < 0)) {
                    var z = y.index, A = l[z];
                    void 0 === A && (A = this.resolveTileset(z)), y.alpha === m || this.debug || (g.globalAlpha = y.alpha, 
                    m = y.alpha), A ? y.rotation || y.flipped ? (g.save(), g.translate(n + y.centerX, o + y.centerY), 
                    g.rotate(y.rotation), y.flipped && g.scale(-1, 1), A.draw(g, -y.centerX, -y.centerY, z), 
                    g.restore()) : A.draw(g, n, o, z) : this.debugSettings.missingImageFill && (g.fillStyle = this.debugSettings.missingImageFill, 
                    g.fillRect(n, o, j, k)), y.debug && this.debugSettings.debuggedTileOverfill && (g.fillStyle = this.debugSettings.debuggedTileOverfill, 
                    g.fillRect(n, o, j, k));
                }
            }
        }
    }, c.TilemapLayer.prototype.renderDeltaScroll = function(a, b) {
        var c = this._mc.scrollX, d = this._mc.scrollY, e = this.canvas.width, f = this.canvas.height, g = this._mc.tileWidth, h = this._mc.tileHeight, i = 0, j = -g, k = 0, l = -h;
        if (0 > a ? (i = e + a, j = e - 1) : a > 0 && (j = a), 0 > b ? (k = f + b, l = f - 1) : b > 0 && (l = b), 
        this.shiftCanvas(this.context, a, b), i = Math.floor((i + c) / g), j = Math.floor((j + c) / g), 
        k = Math.floor((k + d) / h), l = Math.floor((l + d) / h), j >= i) {
            this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
            var m = Math.floor((0 + d) / h), n = Math.floor((f - 1 + d) / h);
            this.renderRegion(c, d, i, m, j, n);
        }
        if (l >= k) {
            this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
            var o = Math.floor((0 + c) / g), p = Math.floor((e - 1 + c) / g);
            this.renderRegion(c, d, o, k, p, l);
        }
    }, c.TilemapLayer.prototype.renderFull = function() {
        var a = this._mc.scrollX, b = this._mc.scrollY, c = this.canvas.width, d = this.canvas.height, e = this._mc.tileWidth, f = this._mc.tileHeight, g = Math.floor(a / e), h = Math.floor((c - 1 + a) / e), i = Math.floor(b / f), j = Math.floor((d - 1 + b) / f);
        this.context.clearRect(0, 0, c, d), this.renderRegion(a, b, g, i, h, j);
    }, c.TilemapLayer.prototype.render = function() {
        var a = !1;
        if (this.visible) {
            (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, a = !0);
            var b = this.canvas.width, c = this.canvas.height, d = 0 | this._scrollX, e = 0 | this._scrollY, f = this._mc, g = f.scrollX - d, h = f.scrollY - e;
            if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c) return this.context.save(), 
            f.scrollX = d, f.scrollY = e, (f.renderWidth !== b || f.renderHeight !== c) && (f.renderWidth = b, 
            f.renderHeight = c), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, 
            this.debugSettings.forceFullRedraw && (a = !0)), !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(), 
            this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), 
            this.dirty = !1, this.context.restore(), !0;
        }
    }, c.TilemapLayer.prototype.renderDebug = function() {
        var a, b, c, d, e, f, g = this._mc.scrollX, h = this._mc.scrollY, i = this.context, j = this.canvas.width, k = this.canvas.height, l = this.layer.width, m = this.layer.height, n = this._mc.tileWidth, o = this._mc.tileHeight, p = Math.floor(g / n), q = Math.floor((j - 1 + g) / n), r = Math.floor(h / o), s = Math.floor((k - 1 + h) / o), t = p * n - g, u = r * o - h, v = (p + (1 << 20) * l) % l, w = (r + (1 << 20) * m) % m;
        for (i.strokeStyle = this.debugSettings.facingEdgeStroke, d = w, f = s - r, b = u; f >= 0; d++, 
        f--, b += o) {
            d >= m && (d -= m);
            var x = this.layer.data[d];
            for (c = v, e = q - p, a = t; e >= 0; c++, e--, a += n) {
                c >= l && (c -= l);
                var y = x[c];
                !y || y.index < 0 || !y.collides || (this.debugSettings.collidingTileOverfill && (i.fillStyle = this.debugSettings.collidingTileOverfill, 
                i.fillRect(a, b, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (i.beginPath(), 
                y.faceTop && (i.moveTo(a, b), i.lineTo(a + this._mc.cw, b)), y.faceBottom && (i.moveTo(a, b + this._mc.ch), 
                i.lineTo(a + this._mc.cw, b + this._mc.ch)), y.faceLeft && (i.moveTo(a, b), i.lineTo(a, b + this._mc.ch)), 
                y.faceRight && (i.moveTo(a + this._mc.cw, b), i.lineTo(a + this._mc.cw, b + this._mc.ch)), 
                i.stroke()));
            }
        }
    }, Object.defineProperty(c.TilemapLayer.prototype, "wrap", {
        get: function() {
            return this._wrap;
        },
        set: function(a) {
            this._wrap = a, this.dirty = !0;
        }
    }), Object.defineProperty(c.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._scrollX;
        },
        set: function(a) {
            this._scrollX = a;
        }
    }), Object.defineProperty(c.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._scrollY;
        },
        set: function(a) {
            this._scrollY = a;
        }
    }), Object.defineProperty(c.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw;
        },
        set: function(a) {
            this._mc.cw = 0 | a, this.dirty = !0;
        }
    }), Object.defineProperty(c.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch;
        },
        set: function(a) {
            this._mc.ch = 0 | a, this.dirty = !0;
        }
    }), c.TilemapParser = {
        INSERT_NULL: !1,
        parse: function(a, b, d, e, f, g) {
            if (void 0 === d && (d = 32), void 0 === e && (e = 32), void 0 === f && (f = 10), 
            void 0 === g && (g = 10), void 0 === b) return this.getEmptyData();
            if (null === b) return this.getEmptyData(d, e, f, g);
            var h = a.cache.getTilemapData(b);
            if (h) {
                if (h.format === c.Tilemap.CSV) return this.parseCSV(b, h.data, d, e);
                if (!h.format || h.format === c.Tilemap.TILED_JSON) return this.parseTiledJSON(h.data);
            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + b);
        },
        parseCSV: function(a, b, d, e) {
            var f = this.getEmptyData();
            b = b.trim();
            for (var g = [], h = b.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++) {
                g[k] = [];
                for (var l = h[k].split(","), m = 0; m < l.length; m++) g[k][m] = new c.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
                0 === j && (j = l.length);
            }
            return f.format = c.Tilemap.CSV, f.name = a, f.width = j, f.height = i, f.tileWidth = d, 
            f.tileHeight = e, f.widthInPixels = j * d, f.heightInPixels = i * e, f.layers[0].width = j, 
            f.layers[0].height = i, f.layers[0].widthInPixels = f.widthInPixels, f.layers[0].heightInPixels = f.heightInPixels, 
            f.layers[0].data = g, f;
        },
        getEmptyData: function(a, b, c, d) {
            var e = {};
            e.width = 0, e.height = 0, e.tileWidth = 0, e.tileHeight = 0, "undefined" != typeof a && null !== a && (e.tileWidth = a), 
            "undefined" != typeof b && null !== b && (e.tileHeight = b), "undefined" != typeof c && null !== c && (e.width = c), 
            "undefined" != typeof d && null !== d && (e.height = d), e.orientation = "orthogonal", 
            e.version = "1", e.properties = {}, e.widthInPixels = 0, e.heightInPixels = 0;
            var f = [], g = {
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: !0,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: []
            };
            return f.push(g), e.layers = f, e.images = [], e.objects = {}, e.collision = {}, 
            e.tilesets = [], e.tiles = [], e;
        },
        parseTiledJSON: function(a) {
            function b(a, b) {
                var c = {};
                for (var d in b) {
                    var e = b[d];
                    "undefined" != typeof a[e] && (c[e] = a[e]);
                }
                return c;
            }
            if ("orthogonal" !== a.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"), 
            null;
            var d = {};
            d.width = a.width, d.height = a.height, d.tileWidth = a.tilewidth, d.tileHeight = a.tileheight, 
            d.orientation = a.orientation, d.format = c.Tilemap.TILED_JSON, d.version = a.version, 
            d.properties = a.properties, d.widthInPixels = d.width * d.tileWidth, d.heightInPixels = d.height * d.tileHeight;
            for (var e = [], f = 0; f < a.layers.length; f++) if ("tilelayer" === a.layers[f].type) {
                var g = a.layers[f], h = {
                    name: g.name,
                    x: g.x,
                    y: g.y,
                    width: g.width,
                    height: g.height,
                    widthInPixels: g.width * a.tilewidth,
                    heightInPixels: g.height * a.tileheight,
                    alpha: g.opacity,
                    visible: g.visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                g.properties && (h.properties = g.properties);
                for (var i, j, k, l, m = 0, n = [], o = [], p = 0, q = g.data.length; q > p; p++) {
                    if (i = 0, j = !1, l = g.data[p], l > 536870912) switch (k = 0, l > 2147483648 && (l -= 2147483648, 
                    k += 4), l > 1073741824 && (l -= 1073741824, k += 2), l > 536870912 && (l -= 536870912, 
                    k += 1), k) {
                      case 5:
                        i = Math.PI / 2;
                        break;

                      case 6:
                        i = Math.PI;
                        break;

                      case 3:
                        i = 3 * Math.PI / 2;
                        break;

                      case 4:
                        i = 0, j = !0;
                        break;

                      case 7:
                        i = Math.PI / 2, j = !0;
                        break;

                      case 2:
                        i = Math.PI, j = !0;
                        break;

                      case 1:
                        i = 3 * Math.PI / 2, j = !0;
                    }
                    l > 0 ? (n.push(new c.Tile(h, l, m, o.length, a.tilewidth, a.tileheight)), n[n.length - 1].rotation = i, 
                    n[n.length - 1].flipped = j) : n.push(c.TilemapParser.INSERT_NULL ? null : new c.Tile(h, -1, m, o.length, a.tilewidth, a.tileheight)), 
                    m++, m === g.width && (o.push(n), m = 0, n = []);
                }
                h.data = o, e.push(h);
            }
            d.layers = e;
            for (var r = [], f = 0; f < a.layers.length; f++) if ("imagelayer" === a.layers[f].type) {
                var s = a.layers[f], t = {
                    name: s.name,
                    image: s.image,
                    x: s.x,
                    y: s.y,
                    alpha: s.opacity,
                    visible: s.visible,
                    properties: {}
                };
                s.properties && (t.properties = s.properties), r.push(t);
            }
            d.images = r;
            for (var u = [], v = [], f = 0; f < a.tilesets.length; f++) {
                var w = a.tilesets[f];
                if (w.image) {
                    var x = new c.Tileset(w.name, w.firstgid, w.tilewidth, w.tileheight, w.margin, w.spacing, w.properties);
                    w.tileproperties && (x.tileProperties = w.tileproperties), x.updateTileData(w.imagewidth, w.imageheight), 
                    u.push(x);
                } else {
                    var y = new c.ImageCollection(w.name, w.firstgid, w.tilewidth, w.tileheight, w.margin, w.spacing, w.properties);
                    for (var f in w.tiles) {
                        var t = w.tiles[f].image, l = w.firstgid + parseInt(f, 10);
                        y.addImage(l, t);
                    }
                    v.push(y);
                }
            }
            d.tilesets = u, d.imagecollections = v;
            for (var z = {}, A = {}, f = 0; f < a.layers.length; f++) if ("objectgroup" === a.layers[f].type) {
                var B = a.layers[f];
                z[B.name] = [], A[B.name] = [];
                for (var C = 0, q = B.objects.length; q > C; C++) if (B.objects[C].gid) {
                    var D = {
                        gid: B.objects[C].gid,
                        name: B.objects[C].name,
                        type: B.objects[C].hasOwnProperty("type") ? B.objects[C].type : "",
                        x: B.objects[C].x,
                        y: B.objects[C].y,
                        visible: B.objects[C].visible,
                        properties: B.objects[C].properties
                    };
                    B.objects[C].rotation && (D.rotation = B.objects[C].rotation), z[B.name].push(D);
                } else if (B.objects[C].polyline) {
                    var D = {
                        name: B.objects[C].name,
                        type: B.objects[C].type,
                        x: B.objects[C].x,
                        y: B.objects[C].y,
                        width: B.objects[C].width,
                        height: B.objects[C].height,
                        visible: B.objects[C].visible,
                        properties: B.objects[C].properties
                    };
                    B.objects[C].rotation && (D.rotation = B.objects[C].rotation), D.polyline = [];
                    for (var E = 0; E < B.objects[C].polyline.length; E++) D.polyline.push([ B.objects[C].polyline[E].x, B.objects[C].polyline[E].y ]);
                    A[B.name].push(D), z[B.name].push(D);
                } else if (B.objects[C].polygon) {
                    var D = b(B.objects[C], [ "name", "type", "x", "y", "visible", "rotation", "properties" ]);
                    D.polygon = [];
                    for (var E = 0; E < B.objects[C].polygon.length; E++) D.polygon.push([ B.objects[C].polygon[E].x, B.objects[C].polygon[E].y ]);
                    z[B.name].push(D);
                } else if (B.objects[C].ellipse) {
                    var D = b(B.objects[C], [ "name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties" ]);
                    z[B.name].push(D);
                } else {
                    var D = b(B.objects[C], [ "name", "type", "x", "y", "width", "height", "visible", "rotation", "properties" ]);
                    D.rectangle = !0, z[B.name].push(D);
                }
            }
            d.objects = z, d.collision = A, d.tiles = [];
            for (var f = 0; f < d.tilesets.length; f++) for (var w = d.tilesets[f], m = w.tileMargin, F = w.tileMargin, G = 0, H = 0, I = 0, p = w.firstgid; p < w.firstgid + w.total && (d.tiles[p] = [ m, F, f ], 
            m += w.tileWidth + w.tileSpacing, G++, G !== w.total) && (H++, H !== w.columns || (m = w.tileMargin, 
            F += w.tileHeight + w.tileSpacing, H = 0, I++, I !== w.rows)); p++) ;
            for (var h, J, K, w, f = 0; f < d.layers.length; f++) {
                h = d.layers[f];
                for (var L = 0; L < h.data.length; L++) {
                    n = h.data[L];
                    for (var M = 0; M < n.length; M++) J = n[M], null === J || J.index < 0 || (K = d.tiles[J.index][2], 
                    w = d.tilesets[K], w.tileProperties && w.tileProperties[J.index - w.firstgid] && (J.properties = c.Utils.mixin(w.tileProperties[J.index - w.firstgid], J.properties)));
                }
            }
            return d;
        }
    }, c.Tileset = function(a, b, c, d, e, f, g) {
        (void 0 === c || 0 >= c) && (c = 32), (void 0 === d || 0 >= d) && (d = 32), void 0 === e && (e = 0), 
        void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.tileWidth = 0 | c, 
        this.tileHeight = 0 | d, this.tileMargin = 0 | e, this.tileSpacing = 0 | f, this.properties = g || {}, 
        this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = [];
    }, c.Tileset.prototype = {
        draw: function(a, b, c, d) {
            var e = d - this.firstgid << 1;
            e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight);
        },
        containsTileIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total;
        },
        setImage: function(a) {
            this.image = a, this.updateTileData(a.width, a.height);
        },
        setSpacing: function(a, b) {
            this.tileMargin = 0 | a, this.tileSpacing = 0 | b, this.image && this.updateTileData(this.image.width, this.image.height);
        },
        updateTileData: function(a, b) {
            var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing), d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            (c % 1 !== 0 || d % 1 !== 0) && console.warn("Phaser.Tileset - image tile area is not an even multiple of tile size"), 
            c = Math.floor(c), d = Math.floor(d), (this.rows && this.rows !== c || this.columns && this.columns !== d) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"), 
            this.rows = c, this.columns = d, this.total = c * d, this.drawCoords.length = 0;
            for (var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++) {
                for (var h = 0; h < this.columns; h++) this.drawCoords.push(e), this.drawCoords.push(f), 
                e += this.tileWidth + this.tileSpacing;
                e = this.tileMargin, f += this.tileHeight + this.tileSpacing;
            }
        }
    }, c.Tileset.prototype.constructor = c.Tileset, c.Particles = function(a) {
        this.game = a, this.emitters = {}, this.ID = 0;
    }, c.Particles.prototype = {
        add: function(a) {
            return this.emitters[a.name] = a, a;
        },
        remove: function(a) {
            delete this.emitters[a.name];
        },
        update: function() {
            for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update();
        }
    }, c.Particles.prototype.constructor = c.Particles, c.Particles.Arcade = {}, c.Particles.Arcade.Emitter = function(a, b, d, e) {
        this.maxParticles = e || 50, c.Group.call(this, a), this.name = "emitter" + this.game.particles.ID++, 
        this.type = c.EMITTER, this.physicsType = c.GROUP, this.area = new c.Rectangle(b, d, 1, 1), 
        this.minParticleSpeed = new c.Point(-100, -100), this.maxParticleSpeed = new c.Point(100, 100), 
        this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, 
        this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, 
        this.gravity = 100, this.particleClass = c.Particle, this.particleDrag = new c.Point(), 
        this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new c.Point(), 
        this.on = !1, this.particleAnchor = new c.Point(.5, .5), this.blendMode = c.blendModes.NORMAL, 
        this.emitX = b, this.emitY = d, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, 
        this.particleSendToBack = !1, this._minParticleScale = new c.Point(1, 1), this._maxParticleScale = new c.Point(1, 1), 
        this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, 
        this._flowTotal = 0, this._explode = !0, this._frames = null;
    }, c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype), c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter, 
    c.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on && this.game.time.time >= this._timer) if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 
        0 !== this._flowTotal) if (this._flowQuantity > 0) {
            for (var a = 0; a < this._flowQuantity; a++) if (this.emitParticle() && (this._counter++, 
            -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                this.on = !1;
                break;
            }
        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1)); else this.emitParticle() && (this._counter++, 
        this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
        for (var a = this.children.length; a--; ) this.children[a].exists && this.children[a].update();
    }, c.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, c, d, e) {
        void 0 === b && (b = 0), void 0 === c && (c = this.maxParticles), void 0 === d && (d = !1), 
        void 0 === e && (e = !1);
        var f, g = 0, h = a, i = b;
        for (this._frames = b, c > this.maxParticles && (this.maxParticles = c); c > g; ) Array.isArray(a) && (h = this.game.rnd.pick(a)), 
        Array.isArray(b) && (i = this.game.rnd.pick(b)), f = new this.particleClass(this.game, 0, 0, h, i), 
        this.game.physics.arcade.enable(f, !1), d ? (f.body.checkCollision.any = !0, f.body.checkCollision.none = !1) : f.body.checkCollision.none = !0, 
        f.body.collideWorldBounds = e, f.body.skipQuadTree = !0, f.exists = !1, f.visible = !1, 
        f.anchor.copyFrom(this.particleAnchor), this.add(f), g++;
        return this;
    }, c.Particles.Arcade.Emitter.prototype.kill = function() {
        this.on = !1, this.alive = !1, this.exists = !1;
    }, c.Particles.Arcade.Emitter.prototype.revive = function() {
        this.alive = !0, this.exists = !0;
    }, c.Particles.Arcade.Emitter.prototype.explode = function(a, b) {
        this._flowTotal = 0, this.start(!0, a, 0, b, !1);
    }, c.Particles.Arcade.Emitter.prototype.flow = function(a, b, c, d, e) {
        (void 0 === c || 0 === c) && (c = 1), void 0 === d && (d = -1), void 0 === e && (e = !0), 
        c > this.maxParticles && (c = this.maxParticles), this._counter = 0, this._flowQuantity = c, 
        this._flowTotal = d, e ? (this.start(!0, a, b, c), this._counter += c, this.on = !0, 
        this._timer = this.game.time.time + b * this.game.time.slowMotion) : this.start(!1, a, b, c);
    }, c.Particles.Arcade.Emitter.prototype.start = function(a, b, c, d, e) {
        if (void 0 === a && (a = !0), void 0 === b && (b = 0), (void 0 === c || null === c) && (c = 250), 
        void 0 === d && (d = 0), void 0 === e && (e = !1), d > this.maxParticles && (d = this.maxParticles), 
        this.revive(), this.visible = !0, this.lifespan = b, this.frequency = c, a || e) for (var f = 0; d > f; f++) this.emitParticle(); else this.on = !0, 
        this._quantity += d, this._counter = 0, this._timer = this.game.time.time + c * this.game.time.slowMotion;
    }, c.Particles.Arcade.Emitter.prototype.emitParticle = function() {
        var a = this.getFirstExists(!1);
        return null === a ? !1 : (this.width > 1 || this.height > 1 ? a.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom)) : a.reset(this.emitX, this.emitY), 
        a.angle = 0, a.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(a) : this.particleSendToBack && this.sendToBack(a), 
        this.autoScale ? a.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? a.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale)) : (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) && a.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), 
        a.frame = Array.isArray("object" === this._frames) ? this.game.rnd.pick(this._frames) : this._frames, 
        this.autoAlpha ? a.setAlphaData(this.alphaData) : a.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha), 
        a.blendMode = this.blendMode, a.body.updateBounds(), a.body.bounce.setTo(this.bounce.x, this.bounce.y), 
        a.body.velocity.x = this.game.rnd.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), 
        a.body.velocity.y = this.game.rnd.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), 
        a.body.angularVelocity = this.game.rnd.between(this.minRotation, this.maxRotation), 
        a.body.gravity.y = this.gravity, a.body.drag.x = this.particleDrag.x, a.body.drag.y = this.particleDrag.y, 
        a.body.angularDrag = this.angularDrag, a.onEmit(), !0);
    }, c.Particles.Arcade.Emitter.prototype.destroy = function() {
        this.game.particles.remove(this), c.Group.prototype.destroy.call(this, !0, !1);
    }, c.Particles.Arcade.Emitter.prototype.setSize = function(a, b) {
        this.area.width = a, this.area.height = b;
    }, c.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) {
        a = a || 0, b = b || 0, this.minParticleSpeed.x = a, this.maxParticleSpeed.x = b;
    }, c.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) {
        a = a || 0, b = b || 0, this.minParticleSpeed.y = a, this.maxParticleSpeed.y = b;
    }, c.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) {
        a = a || 0, b = b || 0, this.minRotation = a, this.maxRotation = b;
    }, c.Particles.Arcade.Emitter.prototype.setAlpha = function(a, b, d, e, f) {
        if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 0), void 0 === e && (e = c.Easing.Linear.None), 
        void 0 === f && (f = !1), this.minParticleAlpha = a, this.maxParticleAlpha = b, 
        this.autoAlpha = !1, d > 0 && a !== b) {
            var g = {
                v: a
            }, h = this.game.make.tween(g).to({
                v: b
            }, d, e);
            h.yoyo(f), this.alphaData = h.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0;
        }
    }, c.Particles.Arcade.Emitter.prototype.setScale = function(a, b, d, e, f, g, h) {
        if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 1), void 0 === e && (e = 1), 
        void 0 === f && (f = 0), void 0 === g && (g = c.Easing.Linear.None), void 0 === h && (h = !1), 
        this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(a, d), 
        this._maxParticleScale.set(b, e), this.autoScale = !1, f > 0 && (a !== b || d !== e)) {
            var i = {
                x: a,
                y: d
            }, j = this.game.make.tween(i).to({
                x: b,
                y: e
            }, f, g);
            j.yoyo(h), this.scaleData = j.generateData(60), this.scaleData.reverse(), this.autoScale = !0;
        }
    }, c.Particles.Arcade.Emitter.prototype.at = function(a) {
        a.center ? (this.emitX = a.center.x, this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width, 
        this.emitY = a.world.y + a.anchor.y * a.height);
    }, Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width;
        },
        set: function(a) {
            this.area.width = a;
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height;
        },
        set: function(a) {
            this.area.height = a;
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX;
        },
        set: function(a) {
            this.emitX = a;
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY;
        },
        set: function(a) {
            this.emitY = a;
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2);
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2);
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2);
        }
    }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2);
        }
    }), c.Video = function(a, b, d) {
        if (void 0 === b && (b = null), void 0 === d && (d = null), this.game = a, this.key = b, 
        this.width = 0, this.height = 0, this.type = c.VIDEO, this.disableTextureUpload = !1, 
        this.touchLocked = !1, this.onPlay = new c.Signal(), this.onChangeSource = new c.Signal(), 
        this.onComplete = new c.Signal(), this.onAccess = new c.Signal(), this.onError = new c.Signal(), 
        this.onTimeout = new c.Signal(), this.timeout = 15e3, this._timeOutID = null, this.video = null, 
        this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, 
        this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, 
        this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, 
        b && this.game.cache.checkVideoKey(b)) {
            var e = this.game.cache.getVideo(b);
            e.isBlob ? this.createVideoFromBlob(e.data) : this.video = e.data, this.width = this.video.videoWidth, 
            this.height = this.video.videoHeight;
        } else d && this.createVideoFromURL(d, !1);
        this.video && !d ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(PIXI.TextureCache.__default.baseTexture.source), 
        this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), 
        this.textureFrame = new c.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), 
        this.texture.valid = !1, null !== b && this.video && (this.texture.valid = this.video.canplay), 
        this.snapshot = null, c.BitmapData && (this.snapshot = new c.BitmapData(this.game, "", this.width, this.height)), 
        !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : e && (e.locked = !1);
    }, c.Video.prototype = {
        connectToMediaStream: function(a, b) {
            return a && b && (this.video = a, this.videoStream = b, this.isStreaming = !0, this.baseTexture.source = this.video, 
            this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), 
            this;
        },
        startMediaStream: function(a, b, c) {
            if (void 0 === a && (a = !1), void 0 === b && (b = null), void 0 === c && (c = null), 
            !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), 
            !1;
            null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), 
            this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), 
            null !== b && (this.video.width = b), null !== c && (this.video.height = c), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: a,
                    video: !0
                }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
            } catch (d) {
                this.getUserMediaError(d);
            }
            return this;
        },
        getUserMediaTimeout: function() {
            clearTimeout(this._timeOutID), this.onTimeout.dispatch(this);
        },
        getUserMediaError: function(a) {
            clearTimeout(this._timeOutID), this.onError.dispatch(this, a);
        },
        getUserMediaSuccess: function(a) {
            clearTimeout(this._timeOutID), this.videoStream = a, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = a : this.video.src = window.URL && window.URL.createObjectURL(a) || a;
            var b = this;
            this.video.onloadeddata = function() {
                function a() {
                    if (c > 0) if (b.video.videoWidth > 0) {
                        var d = b.video.videoWidth, e = b.video.videoHeight;
                        isNaN(b.video.videoHeight) && (e = d / (4 / 3)), b.video.play(), b.isStreaming = !0, 
                        b.baseTexture.source = b.video, b.updateTexture(null, d, e), b.onAccess.dispatch(b);
                    } else window.setTimeout(a, 500); else console.warn("Unable to connect to video stream. Webcam error?");
                    c--;
                }
                var c = 10;
                a();
            };
        },
        createVideoFromBlob: function(a) {
            var b = this;
            return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), 
            this.video.addEventListener("loadeddata", function(a) {
                b.updateTexture(a);
            }, !0), this.video.src = window.URL.createObjectURL(a), this.video.canplay = !0, 
            this;
        },
        createVideoFromURL: function(a, b) {
            return void 0 === b && (b = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), 
            this.video.controls = !1, b && this.video.setAttribute("autoplay", "autoplay"), 
            this.video.src = a, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, 
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), 
            this.key = a, this;
        },
        updateTexture: function(a, b, c) {
            var d = !1;
            (void 0 === b || null === b) && (b = this.video.videoWidth, d = !0), (void 0 === c || null === c) && (c = this.video.videoHeight), 
            this.width = b, this.height = c, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), 
            this.baseTexture.forceLoaded(b, c), this.texture.frame.resize(b, c), this.texture.width = b, 
            this.texture.height = c, this.texture.valid = !0, this.snapshot && this.snapshot.resize(b, c), 
            d && null !== this.key && (this.onChangeSource.dispatch(this, b, c), this._autoplay && (this.video.play(), 
            this.onPlay.dispatch(this, this.loop, this.playbackRate)));
        },
        complete: function() {
            this.onComplete.dispatch(this);
        },
        play: function(a, b) {
            return void 0 === a && (a = !1), void 0 === b && (b = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), 
            this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), 
            this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), 
            this.video.addEventListener("ended", this.complete.bind(this), !0), this.video.loop = a ? "loop" : "", 
            this.video.playbackRate = b, this.touchLocked ? this._pending = !0 : (this._pending = !1, 
            null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, 
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : this.video.addEventListener("playing", this.playHandler.bind(this), !0)), 
            this.video.play(), this.onPlay.dispatch(this, a, b)), this;
        },
        playHandler: function() {
            this.video.removeEventListener("playing", this.playHandler.bind(this)), this.updateTexture();
        },
        stop: function() {
            return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), 
            this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), 
            this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), 
            this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), 
            this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this.complete.bind(this), !0), 
            this.video.removeEventListener("playing", this.playHandler.bind(this), !0), this.touchLocked ? this._pending = !1 : this.video.pause()), 
            this;
        },
        add: function(a) {
            if (Array.isArray(a)) for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this); else a.loadTexture(this);
            return this;
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1, f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        render: function() {
            !this.disableTextureUpload && this.playing && this.baseTexture.dirty();
        },
        setMute: function() {
            this._muted || (this._muted = !0, this.video.muted = !0);
        },
        unsetMute: function() {
            this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1);
        },
        setPause: function() {
            this._paused || this.touchLocked || (this._paused = !0, this.video.pause());
        },
        setResume: function() {
            !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play());
        },
        changeSource: function(a, b) {
            return void 0 === b && (b = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, 
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), 
            this.video.src = a, this.video.load(), this._autoplay = b, b || (this.paused = !0), 
            this;
        },
        checkVideoProgress: function() {
            4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming));
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0;
        },
        unlock: function() {
            if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), 
            this.key) {
                var a = this.game.cache.getVideo(this.key);
                a && !a.isBlob && (a.locked = !1);
            }
            return !0;
        },
        grab: function(a, b, c) {
            return void 0 === a && (a = !1), void 0 === b && (b = 1), void 0 === c && (c = null), 
            null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (a && this.snapshot.cls(), 
            this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), 
            this.snapshot);
        },
        removeVideoElement: function() {
            if (this.video) {
                for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes(); ) this.video.removeChild(this.video.firstChild);
                this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null;
            }
        },
        destroy: function() {
            this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), 
            this._retryID && window.clearTimeout(this._retryID);
        }
    }, Object.defineProperty(c.Video.prototype, "currentTime", {
        get: function() {
            return this.video ? this.video.currentTime : 0;
        },
        set: function(a) {
            this.video.currentTime = a;
        }
    }), Object.defineProperty(c.Video.prototype, "duration", {
        get: function() {
            return this.video ? this.video.duration : 0;
        }
    }), Object.defineProperty(c.Video.prototype, "progress", {
        get: function() {
            return this.video ? this.video.currentTime / this.video.duration : 0;
        }
    }), Object.defineProperty(c.Video.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(a) {
            if (a = a || null) {
                if (this._muted) return;
                this._codeMuted = !0, this.setMute();
            } else {
                if (!this._muted) return;
                this._codeMuted = !1, this.unsetMute();
            }
        }
    }), Object.defineProperty(c.Video.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(a) {
            if (a = a || null, !this.touchLocked) if (a) {
                if (this._paused) return;
                this._codePaused = !0, this.setPause();
            } else {
                if (!this._paused) return;
                this._codePaused = !1, this.setResume();
            }
        }
    }), Object.defineProperty(c.Video.prototype, "volume", {
        get: function() {
            return this.video ? this.video.volume : 1;
        },
        set: function(a) {
            0 > a ? a = 0 : a > 1 && (a = 1), this.video && (this.video.volume = a);
        }
    }), Object.defineProperty(c.Video.prototype, "playbackRate", {
        get: function() {
            return this.video ? this.video.playbackRate : 1;
        },
        set: function(a) {
            this.video && (this.video.playbackRate = a);
        }
    }), Object.defineProperty(c.Video.prototype, "loop", {
        get: function() {
            return this.video ? this.video.loop : !1;
        },
        set: function(a) {
            a && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "");
        }
    }), Object.defineProperty(c.Video.prototype, "playing", {
        get: function() {
            return !(this.video.paused && this.video.ended);
        }
    }), c.Video.prototype.constructor = c.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = c.blendModes), 
    void 0 === PIXI.scaleModes && (PIXI.scaleModes = c.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture())), 
    void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix()), 
    void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix()), 
    void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = c.POLYGON, PIXI.Graphics.RECT = c.RECTANGLE, 
    PIXI.Graphics.CIRC = c.CIRCLE, PIXI.Graphics.ELIP = c.ELLIPSE, PIXI.Graphics.RREC = c.ROUNDEDRECTANGLE), 
    PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = c), 
    exports.Phaser = c) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
        return b.Phaser = c;
    }()) : b.Phaser = c, c;
}.call(this);

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        !function() {
            var d3 = {
                version: "3.5.6"
            };
            var d3_arraySlice = [].slice, d3_array = function(list) {
                return d3_arraySlice.call(list);
            };
            var d3_document = this.document;
            function d3_documentElement(node) {
                return node && (node.ownerDocument || node.document || node).documentElement;
            }
            function d3_window(node) {
                return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
            }
            if (d3_document) {
                try {
                    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
                } catch (e) {
                    d3_array = function(list) {
                        var i = list.length, array = new Array(i);
                        while (i--) array[i] = list[i];
                        return array;
                    };
                }
            }
            if (!Date.now) Date.now = function() {
                return +new Date();
            };
            if (d3_document) {
                try {
                    d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
                } catch (error) {
                    var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
                    d3_element_prototype.setAttribute = function(name, value) {
                        d3_element_setAttribute.call(this, name, value + "");
                    };
                    d3_element_prototype.setAttributeNS = function(space, local, value) {
                        d3_element_setAttributeNS.call(this, space, local, value + "");
                    };
                    d3_style_prototype.setProperty = function(name, value, priority) {
                        d3_style_setProperty.call(this, name, value + "", priority);
                    };
                }
            }
            d3.ascending = d3_ascending;
            function d3_ascending(a, b) {
                return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
            }
            d3.descending = function(a, b) {
                return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
            };
            d3.min = function(array, f) {
                var i = -1, n = array.length, a, b;
                if (arguments.length === 1) {
                    while (++i < n) if ((b = array[i]) != null && b >= b) {
                        a = b;
                        break;
                    }
                    while (++i < n) if ((b = array[i]) != null && a > b) a = b;
                } else {
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                        a = b;
                        break;
                    }
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
                }
                return a;
            };
            d3.max = function(array, f) {
                var i = -1, n = array.length, a, b;
                if (arguments.length === 1) {
                    while (++i < n) if ((b = array[i]) != null && b >= b) {
                        a = b;
                        break;
                    }
                    while (++i < n) if ((b = array[i]) != null && b > a) a = b;
                } else {
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                        a = b;
                        break;
                    }
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
                }
                return a;
            };
            d3.extent = function(array, f) {
                var i = -1, n = array.length, a, b, c;
                if (arguments.length === 1) {
                    while (++i < n) if ((b = array[i]) != null && b >= b) {
                        a = c = b;
                        break;
                    }
                    while (++i < n) if ((b = array[i]) != null) {
                        if (a > b) a = b;
                        if (c < b) c = b;
                    }
                } else {
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                        a = c = b;
                        break;
                    }
                    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                        if (a > b) a = b;
                        if (c < b) c = b;
                    }
                }
                return [ a, c ];
            };
            function d3_number(x) {
                return x === null ? NaN : +x;
            }
            function d3_numeric(x) {
                return !isNaN(x);
            }
            d3.sum = function(array, f) {
                var s = 0, n = array.length, a, i = -1;
                if (arguments.length === 1) {
                    while (++i < n) if (d3_numeric(a = +array[i])) s += a;
                } else {
                    while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
                }
                return s;
            };
            d3.mean = function(array, f) {
                var s = 0, n = array.length, a, i = -1, j = n;
                if (arguments.length === 1) {
                    while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
                } else {
                    while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
                }
                if (j) return s / j;
            };
            d3.quantile = function(values, p) {
                var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
                return e ? v + e * (values[h] - v) : v;
            };
            d3.median = function(array, f) {
                var numbers = [], n = array.length, a, i = -1;
                if (arguments.length === 1) {
                    while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
                } else {
                    while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
                }
                if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
            };
            d3.variance = function(array, f) {
                var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
                if (arguments.length === 1) {
                    while (++i < n) {
                        if (d3_numeric(a = d3_number(array[i]))) {
                            d = a - m;
                            m += d / ++j;
                            s += d * (a - m);
                        }
                    }
                } else {
                    while (++i < n) {
                        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                            d = a - m;
                            m += d / ++j;
                            s += d * (a - m);
                        }
                    }
                }
                if (j > 1) return s / (j - 1);
            };
            d3.deviation = function() {
                var v = d3.variance.apply(this, arguments);
                return v ? Math.sqrt(v) : v;
            };
            function d3_bisector(compare) {
                return {
                    left: function(a, x, lo, hi) {
                        if (arguments.length < 3) lo = 0;
                        if (arguments.length < 4) hi = a.length;
                        while (lo < hi) {
                            var mid = lo + hi >>> 1;
                            if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
                        }
                        return lo;
                    },
                    right: function(a, x, lo, hi) {
                        if (arguments.length < 3) lo = 0;
                        if (arguments.length < 4) hi = a.length;
                        while (lo < hi) {
                            var mid = lo + hi >>> 1;
                            if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
                        }
                        return lo;
                    }
                };
            }
            var d3_bisect = d3_bisector(d3_ascending);
            d3.bisectLeft = d3_bisect.left;
            d3.bisect = d3.bisectRight = d3_bisect.right;
            d3.bisector = function(f) {
                return d3_bisector(f.length === 1 ? function(d, x) {
                    return d3_ascending(f(d), x);
                } : f);
            };
            d3.shuffle = function(array, i0, i1) {
                if ((m = arguments.length) < 3) {
                    i1 = array.length;
                    if (m < 2) i0 = 0;
                }
                var m = i1 - i0, t, i;
                while (m) {
                    i = Math.random() * m-- | 0;
                    t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
                }
                return array;
            };
            d3.permute = function(array, indexes) {
                var i = indexes.length, permutes = new Array(i);
                while (i--) permutes[i] = array[indexes[i]];
                return permutes;
            };
            d3.pairs = function(array) {
                var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
                while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
                return pairs;
            };
            d3.zip = function() {
                if (!(n = arguments.length)) return [];
                for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
                    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
                        zip[j] = arguments[j][i];
                    }
                }
                return zips;
            };
            function d3_zipLength(d) {
                return d.length;
            }
            d3.transpose = function(matrix) {
                return d3.zip.apply(d3, matrix);
            };
            d3.keys = function(map) {
                var keys = [];
                for (var key in map) keys.push(key);
                return keys;
            };
            d3.values = function(map) {
                var values = [];
                for (var key in map) values.push(map[key]);
                return values;
            };
            d3.entries = function(map) {
                var entries = [];
                for (var key in map) entries.push({
                    key: key,
                    value: map[key]
                });
                return entries;
            };
            d3.merge = function(arrays) {
                var n = arrays.length, m, i = -1, j = 0, merged, array;
                while (++i < n) j += arrays[i].length;
                merged = new Array(j);
                while (--n >= 0) {
                    array = arrays[n];
                    m = array.length;
                    while (--m >= 0) {
                        merged[--j] = array[m];
                    }
                }
                return merged;
            };
            var abs = Math.abs;
            d3.range = function(start, stop, step) {
                if (arguments.length < 3) {
                    step = 1;
                    if (arguments.length < 2) {
                        stop = start;
                        start = 0;
                    }
                }
                if ((stop - start) / step === Infinity) throw new Error("infinite range");
                var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
                start *= k, stop *= k, step *= k;
                if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
                return range;
            };
            function d3_range_integerScale(x) {
                var k = 1;
                while (x * k % 1) k *= 10;
                return k;
            }
            function d3_class(ctor, properties) {
                for (var key in properties) {
                    Object.defineProperty(ctor.prototype, key, {
                        value: properties[key],
                        enumerable: false
                    });
                }
            }
            d3.map = function(object, f) {
                var map = new d3_Map();
                if (object instanceof d3_Map) {
                    object.forEach(function(key, value) {
                        map.set(key, value);
                    });
                } else if (Array.isArray(object)) {
                    var i = -1, n = object.length, o;
                    if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
                } else {
                    for (var key in object) map.set(key, object[key]);
                }
                return map;
            };
            function d3_Map() {
                this._ = Object.create(null);
            }
            var d3_map_proto = "__proto__", d3_map_zero = "\x00";
            d3_class(d3_Map, {
                has: d3_map_has,
                get: function(key) {
                    return this._[d3_map_escape(key)];
                },
                set: function(key, value) {
                    return this._[d3_map_escape(key)] = value;
                },
                remove: d3_map_remove,
                keys: d3_map_keys,
                values: function() {
                    var values = [];
                    for (var key in this._) values.push(this._[key]);
                    return values;
                },
                entries: function() {
                    var entries = [];
                    for (var key in this._) entries.push({
                        key: d3_map_unescape(key),
                        value: this._[key]
                    });
                    return entries;
                },
                size: d3_map_size,
                empty: d3_map_empty,
                forEach: function(f) {
                    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
                }
            });
            function d3_map_escape(key) {
                return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
            }
            function d3_map_unescape(key) {
                return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
            }
            function d3_map_has(key) {
                return d3_map_escape(key) in this._;
            }
            function d3_map_remove(key) {
                return (key = d3_map_escape(key)) in this._ && delete this._[key];
            }
            function d3_map_keys() {
                var keys = [];
                for (var key in this._) keys.push(d3_map_unescape(key));
                return keys;
            }
            function d3_map_size() {
                var size = 0;
                for (var key in this._) ++size;
                return size;
            }
            function d3_map_empty() {
                for (var key in this._) return false;
                return true;
            }
            d3.nest = function() {
                var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
                function map(mapType, array, depth) {
                    if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
                    var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
                    while (++i < n) {
                        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                            values.push(object);
                        } else {
                            valuesByKey.set(keyValue, [ object ]);
                        }
                    }
                    if (mapType) {
                        object = mapType();
                        setter = function(keyValue, values) {
                            object.set(keyValue, map(mapType, values, depth));
                        };
                    } else {
                        object = {};
                        setter = function(keyValue, values) {
                            object[keyValue] = map(mapType, values, depth);
                        };
                    }
                    valuesByKey.forEach(setter);
                    return object;
                }
                function entries(map, depth) {
                    if (depth >= keys.length) return map;
                    var array = [], sortKey = sortKeys[depth++];
                    map.forEach(function(key, keyMap) {
                        array.push({
                            key: key,
                            values: entries(keyMap, depth)
                        });
                    });
                    return sortKey ? array.sort(function(a, b) {
                        return sortKey(a.key, b.key);
                    }) : array;
                }
                nest.map = function(array, mapType) {
                    return map(mapType, array, 0);
                };
                nest.entries = function(array) {
                    return entries(map(d3.map, array, 0), 0);
                };
                nest.key = function(d) {
                    keys.push(d);
                    return nest;
                };
                nest.sortKeys = function(order) {
                    sortKeys[keys.length - 1] = order;
                    return nest;
                };
                nest.sortValues = function(order) {
                    sortValues = order;
                    return nest;
                };
                nest.rollup = function(f) {
                    rollup = f;
                    return nest;
                };
                return nest;
            };
            d3.set = function(array) {
                var set = new d3_Set();
                if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
                return set;
            };
            function d3_Set() {
                this._ = Object.create(null);
            }
            d3_class(d3_Set, {
                has: d3_map_has,
                add: function(key) {
                    this._[d3_map_escape(key += "")] = true;
                    return key;
                },
                remove: d3_map_remove,
                values: d3_map_keys,
                size: d3_map_size,
                empty: d3_map_empty,
                forEach: function(f) {
                    for (var key in this._) f.call(this, d3_map_unescape(key));
                }
            });
            d3.behavior = {};
            function d3_identity(d) {
                return d;
            }
            d3.rebind = function(target, source) {
                var i = 1, n = arguments.length, method;
                while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
                return target;
            };
            function d3_rebind(target, source, method) {
                return function() {
                    var value = method.apply(source, arguments);
                    return value === source ? target : value;
                };
            }
            function d3_vendorSymbol(object, name) {
                if (name in object) return name;
                name = name.charAt(0).toUpperCase() + name.slice(1);
                for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
                    var prefixName = d3_vendorPrefixes[i] + name;
                    if (prefixName in object) return prefixName;
                }
            }
            var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
            function d3_noop() {}
            d3.dispatch = function() {
                var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
                while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
                return dispatch;
            };
            function d3_dispatch() {}
            d3_dispatch.prototype.on = function(type, listener) {
                var i = type.indexOf("."), name = "";
                if (i >= 0) {
                    name = type.slice(i + 1);
                    type = type.slice(0, i);
                }
                if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
                if (arguments.length === 2) {
                    if (listener == null) for (type in this) {
                        if (this.hasOwnProperty(type)) this[type].on(name, null);
                    }
                    return this;
                }
            };
            function d3_dispatch_event(dispatch) {
                var listeners = [], listenerByName = new d3_Map();
                function event() {
                    var z = listeners, i = -1, n = z.length, l;
                    while (++i < n) if (l = z[i].on) l.apply(this, arguments);
                    return dispatch;
                }
                event.on = function(name, listener) {
                    var l = listenerByName.get(name), i;
                    if (arguments.length < 2) return l && l.on;
                    if (l) {
                        l.on = null;
                        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                        listenerByName.remove(name);
                    }
                    if (listener) listeners.push(listenerByName.set(name, {
                        on: listener
                    }));
                    return dispatch;
                };
                return event;
            }
            d3.event = null;
            function d3_eventPreventDefault() {
                d3.event.preventDefault();
            }
            function d3_eventSource() {
                var e = d3.event, s;
                while (s = e.sourceEvent) e = s;
                return e;
            }
            function d3_eventDispatch(target) {
                var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
                while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
                dispatch.of = function(thiz, argumentz) {
                    return function(e1) {
                        try {
                            var e0 = e1.sourceEvent = d3.event;
                            e1.target = target;
                            d3.event = e1;
                            dispatch[e1.type].apply(thiz, argumentz);
                        } finally {
                            d3.event = e0;
                        }
                    };
                };
                return dispatch;
            }
            d3.requote = function(s) {
                return s.replace(d3_requote_re, "\\$&");
            };
            var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
            var d3_subclass = {}.__proto__ ? function(object, prototype) {
                object.__proto__ = prototype;
            } : function(object, prototype) {
                for (var property in prototype) object[property] = prototype[property];
            };
            function d3_selection(groups) {
                d3_subclass(groups, d3_selectionPrototype);
                return groups;
            }
            var d3_select = function(s, n) {
                return n.querySelector(s);
            }, d3_selectAll = function(s, n) {
                return n.querySelectorAll(s);
            }, d3_selectMatches = function(n, s) {
                var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
                d3_selectMatches = function(n, s) {
                    return d3_selectMatcher.call(n, s);
                };
                return d3_selectMatches(n, s);
            };
            if (typeof Sizzle === "function") {
                d3_select = function(s, n) {
                    return Sizzle(s, n)[0] || null;
                };
                d3_selectAll = Sizzle;
                d3_selectMatches = Sizzle.matchesSelector;
            }
            d3.selection = function() {
                return d3.select(d3_document.documentElement);
            };
            var d3_selectionPrototype = d3.selection.prototype = [];
            d3_selectionPrototype.select = function(selector) {
                var subgroups = [], subgroup, subnode, group, node;
                selector = d3_selection_selector(selector);
                for (var j = -1, m = this.length; ++j < m; ) {
                    subgroups.push(subgroup = []);
                    subgroup.parentNode = (group = this[j]).parentNode;
                    for (var i = -1, n = group.length; ++i < n; ) {
                        if (node = group[i]) {
                            subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                            if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                        } else {
                            subgroup.push(null);
                        }
                    }
                }
                return d3_selection(subgroups);
            };
            function d3_selection_selector(selector) {
                return typeof selector === "function" ? selector : function() {
                    return d3_select(selector, this);
                };
            }
            d3_selectionPrototype.selectAll = function(selector) {
                var subgroups = [], subgroup, node;
                selector = d3_selection_selectorAll(selector);
                for (var j = -1, m = this.length; ++j < m; ) {
                    for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                        if (node = group[i]) {
                            subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                            subgroup.parentNode = node;
                        }
                    }
                }
                return d3_selection(subgroups);
            };
            function d3_selection_selectorAll(selector) {
                return typeof selector === "function" ? selector : function() {
                    return d3_selectAll(selector, this);
                };
            }
            var d3_nsPrefix = {
                svg: "http://www.w3.org/2000/svg",
                xhtml: "http://www.w3.org/1999/xhtml",
                xlink: "http://www.w3.org/1999/xlink",
                xml: "http://www.w3.org/XML/1998/namespace",
                xmlns: "http://www.w3.org/2000/xmlns/"
            };
            d3.ns = {
                prefix: d3_nsPrefix,
                qualify: function(name) {
                    var i = name.indexOf(":"), prefix = name;
                    if (i >= 0) {
                        prefix = name.slice(0, i);
                        name = name.slice(i + 1);
                    }
                    return d3_nsPrefix.hasOwnProperty(prefix) ? {
                        space: d3_nsPrefix[prefix],
                        local: name
                    } : name;
                }
            };
            d3_selectionPrototype.attr = function(name, value) {
                if (arguments.length < 2) {
                    if (typeof name === "string") {
                        var node = this.node();
                        name = d3.ns.qualify(name);
                        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
                    }
                    for (value in name) this.each(d3_selection_attr(value, name[value]));
                    return this;
                }
                return this.each(d3_selection_attr(name, value));
            };
            function d3_selection_attr(name, value) {
                name = d3.ns.qualify(name);
                function attrNull() {
                    this.removeAttribute(name);
                }
                function attrNullNS() {
                    this.removeAttributeNS(name.space, name.local);
                }
                function attrConstant() {
                    this.setAttribute(name, value);
                }
                function attrConstantNS() {
                    this.setAttributeNS(name.space, name.local, value);
                }
                function attrFunction() {
                    var x = value.apply(this, arguments);
                    if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
                }
                function attrFunctionNS() {
                    var x = value.apply(this, arguments);
                    if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
                }
                return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
            }
            function d3_collapse(s) {
                return s.trim().replace(/\s+/g, " ");
            }
            d3_selectionPrototype.classed = function(name, value) {
                if (arguments.length < 2) {
                    if (typeof name === "string") {
                        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                        if (value = node.classList) {
                            while (++i < n) if (!value.contains(name[i])) return false;
                        } else {
                            value = node.getAttribute("class");
                            while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                        }
                        return true;
                    }
                    for (value in name) this.each(d3_selection_classed(value, name[value]));
                    return this;
                }
                return this.each(d3_selection_classed(name, value));
            };
            function d3_selection_classedRe(name) {
                return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
            }
            function d3_selection_classes(name) {
                return (name + "").trim().split(/^|\s+/);
            }
            function d3_selection_classed(name, value) {
                name = d3_selection_classes(name).map(d3_selection_classedName);
                var n = name.length;
                function classedConstant() {
                    var i = -1;
                    while (++i < n) name[i](this, value);
                }
                function classedFunction() {
                    var i = -1, x = value.apply(this, arguments);
                    while (++i < n) name[i](this, x);
                }
                return typeof value === "function" ? classedFunction : classedConstant;
            }
            function d3_selection_classedName(name) {
                var re = d3_selection_classedRe(name);
                return function(node, value) {
                    if (c = node.classList) return value ? c.add(name) : c.remove(name);
                    var c = node.getAttribute("class") || "";
                    if (value) {
                        re.lastIndex = 0;
                        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
                    } else {
                        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
                    }
                };
            }
            d3_selectionPrototype.style = function(name, value, priority) {
                var n = arguments.length;
                if (n < 3) {
                    if (typeof name !== "string") {
                        if (n < 2) value = "";
                        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                        return this;
                    }
                    if (n < 2) {
                        var node = this.node();
                        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
                    }
                    priority = "";
                }
                return this.each(d3_selection_style(name, value, priority));
            };
            function d3_selection_style(name, value, priority) {
                function styleNull() {
                    this.style.removeProperty(name);
                }
                function styleConstant() {
                    this.style.setProperty(name, value, priority);
                }
                function styleFunction() {
                    var x = value.apply(this, arguments);
                    if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
                }
                return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
            }
            d3_selectionPrototype.property = function(name, value) {
                if (arguments.length < 2) {
                    if (typeof name === "string") return this.node()[name];
                    for (value in name) this.each(d3_selection_property(value, name[value]));
                    return this;
                }
                return this.each(d3_selection_property(name, value));
            };
            function d3_selection_property(name, value) {
                function propertyNull() {
                    delete this[name];
                }
                function propertyConstant() {
                    this[name] = value;
                }
                function propertyFunction() {
                    var x = value.apply(this, arguments);
                    if (x == null) delete this[name]; else this[name] = x;
                }
                return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
            }
            d3_selectionPrototype.text = function(value) {
                return arguments.length ? this.each(typeof value === "function" ? function() {
                    var v = value.apply(this, arguments);
                    this.textContent = v == null ? "" : v;
                } : value == null ? function() {
                    this.textContent = "";
                } : function() {
                    this.textContent = value;
                }) : this.node().textContent;
            };
            d3_selectionPrototype.html = function(value) {
                return arguments.length ? this.each(typeof value === "function" ? function() {
                    var v = value.apply(this, arguments);
                    this.innerHTML = v == null ? "" : v;
                } : value == null ? function() {
                    this.innerHTML = "";
                } : function() {
                    this.innerHTML = value;
                }) : this.node().innerHTML;
            };
            d3_selectionPrototype.append = function(name) {
                name = d3_selection_creator(name);
                return this.select(function() {
                    return this.appendChild(name.apply(this, arguments));
                });
            };
            function d3_selection_creator(name) {
                function create() {
                    var document = this.ownerDocument, namespace = this.namespaceURI;
                    return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
                }
                function createNS() {
                    return this.ownerDocument.createElementNS(name.space, name.local);
                }
                return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
            }
            d3_selectionPrototype.insert = function(name, before) {
                name = d3_selection_creator(name);
                before = d3_selection_selector(before);
                return this.select(function() {
                    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
                });
            };
            d3_selectionPrototype.remove = function() {
                return this.each(d3_selectionRemove);
            };
            function d3_selectionRemove() {
                var parent = this.parentNode;
                if (parent) parent.removeChild(this);
            }
            d3_selectionPrototype.data = function(value, key) {
                var i = -1, n = this.length, group, node;
                if (!arguments.length) {
                    value = new Array(n = (group = this[0]).length);
                    while (++i < n) {
                        if (node = group[i]) {
                            value[i] = node.__data__;
                        }
                    }
                    return value;
                }
                function bind(group, groupData) {
                    var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
                    if (key) {
                        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                        for (i = -1; ++i < n; ) {
                            if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                                exitNodes[i] = node;
                            } else {
                                nodeByKeyValue.set(keyValue, node);
                            }
                            keyValues[i] = keyValue;
                        }
                        for (i = -1; ++i < m; ) {
                            if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                                enterNodes[i] = d3_selection_dataNode(nodeData);
                            } else if (node !== true) {
                                updateNodes[i] = node;
                                node.__data__ = nodeData;
                            }
                            nodeByKeyValue.set(keyValue, true);
                        }
                        for (i = -1; ++i < n; ) {
                            if (nodeByKeyValue.get(keyValues[i]) !== true) {
                                exitNodes[i] = group[i];
                            }
                        }
                    } else {
                        for (i = -1; ++i < n0; ) {
                            node = group[i];
                            nodeData = groupData[i];
                            if (node) {
                                node.__data__ = nodeData;
                                updateNodes[i] = node;
                            } else {
                                enterNodes[i] = d3_selection_dataNode(nodeData);
                            }
                        }
                        for (;i < m; ++i) {
                            enterNodes[i] = d3_selection_dataNode(groupData[i]);
                        }
                        for (;i < n; ++i) {
                            exitNodes[i] = group[i];
                        }
                    }
                    enterNodes.update = updateNodes;
                    enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
                    enter.push(enterNodes);
                    update.push(updateNodes);
                    exit.push(exitNodes);
                }
                var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
                if (typeof value === "function") {
                    while (++i < n) {
                        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
                    }
                } else {
                    while (++i < n) {
                        bind(group = this[i], value);
                    }
                }
                update.enter = function() {
                    return enter;
                };
                update.exit = function() {
                    return exit;
                };
                return update;
            };
            function d3_selection_dataNode(data) {
                return {
                    __data__: data
                };
            }
            d3_selectionPrototype.datum = function(value) {
                return arguments.length ? this.property("__data__", value) : this.property("__data__");
            };
            d3_selectionPrototype.filter = function(filter) {
                var subgroups = [], subgroup, group, node;
                if (typeof filter !== "function") filter = d3_selection_filter(filter);
                for (var j = 0, m = this.length; j < m; j++) {
                    subgroups.push(subgroup = []);
                    subgroup.parentNode = (group = this[j]).parentNode;
                    for (var i = 0, n = group.length; i < n; i++) {
                        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                            subgroup.push(node);
                        }
                    }
                }
                return d3_selection(subgroups);
            };
            function d3_selection_filter(selector) {
                return function() {
                    return d3_selectMatches(this, selector);
                };
            }
            d3_selectionPrototype.order = function() {
                for (var j = -1, m = this.length; ++j < m; ) {
                    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                        if (node = group[i]) {
                            if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                            next = node;
                        }
                    }
                }
                return this;
            };
            d3_selectionPrototype.sort = function(comparator) {
                comparator = d3_selection_sortComparator.apply(this, arguments);
                for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
                return this.order();
            };
            function d3_selection_sortComparator(comparator) {
                if (!arguments.length) comparator = d3_ascending;
                return function(a, b) {
                    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
                };
            }
            d3_selectionPrototype.each = function(callback) {
                return d3_selection_each(this, function(node, i, j) {
                    callback.call(node, node.__data__, i, j);
                });
            };
            function d3_selection_each(groups, callback) {
                for (var j = 0, m = groups.length; j < m; j++) {
                    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                        if (node = group[i]) callback(node, i, j);
                    }
                }
                return groups;
            }
            d3_selectionPrototype.call = function(callback) {
                var args = d3_array(arguments);
                callback.apply(args[0] = this, args);
                return this;
            };
            d3_selectionPrototype.empty = function() {
                return !this.node();
            };
            d3_selectionPrototype.node = function() {
                for (var j = 0, m = this.length; j < m; j++) {
                    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                        var node = group[i];
                        if (node) return node;
                    }
                }
                return null;
            };
            d3_selectionPrototype.size = function() {
                var n = 0;
                d3_selection_each(this, function() {
                    ++n;
                });
                return n;
            };
            function d3_selection_enter(selection) {
                d3_subclass(selection, d3_selection_enterPrototype);
                return selection;
            }
            var d3_selection_enterPrototype = [];
            d3.selection.enter = d3_selection_enter;
            d3.selection.enter.prototype = d3_selection_enterPrototype;
            d3_selection_enterPrototype.append = d3_selectionPrototype.append;
            d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
            d3_selection_enterPrototype.node = d3_selectionPrototype.node;
            d3_selection_enterPrototype.call = d3_selectionPrototype.call;
            d3_selection_enterPrototype.size = d3_selectionPrototype.size;
            d3_selection_enterPrototype.select = function(selector) {
                var subgroups = [], subgroup, subnode, upgroup, group, node;
                for (var j = -1, m = this.length; ++j < m; ) {
                    upgroup = (group = this[j]).update;
                    subgroups.push(subgroup = []);
                    subgroup.parentNode = group.parentNode;
                    for (var i = -1, n = group.length; ++i < n; ) {
                        if (node = group[i]) {
                            subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                            subnode.__data__ = node.__data__;
                        } else {
                            subgroup.push(null);
                        }
                    }
                }
                return d3_selection(subgroups);
            };
            d3_selection_enterPrototype.insert = function(name, before) {
                if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
                return d3_selectionPrototype.insert.call(this, name, before);
            };
            function d3_selection_enterInsertBefore(enter) {
                var i0, j0;
                return function(d, i, j) {
                    var group = enter[j].update, n = group.length, node;
                    if (j != j0) j0 = j, i0 = 0;
                    if (i >= i0) i0 = i + 1;
                    while (!(node = group[i0]) && ++i0 < n) ;
                    return node;
                };
            }
            d3.select = function(node) {
                var group;
                if (typeof node === "string") {
                    group = [ d3_select(node, d3_document) ];
                    group.parentNode = d3_document.documentElement;
                } else {
                    group = [ node ];
                    group.parentNode = d3_documentElement(node);
                }
                return d3_selection([ group ]);
            };
            d3.selectAll = function(nodes) {
                var group;
                if (typeof nodes === "string") {
                    group = d3_array(d3_selectAll(nodes, d3_document));
                    group.parentNode = d3_document.documentElement;
                } else {
                    group = nodes;
                    group.parentNode = null;
                }
                return d3_selection([ group ]);
            };
            d3_selectionPrototype.on = function(type, listener, capture) {
                var n = arguments.length;
                if (n < 3) {
                    if (typeof type !== "string") {
                        if (n < 2) listener = false;
                        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                        return this;
                    }
                    if (n < 2) return (n = this.node()["__on" + type]) && n._;
                    capture = false;
                }
                return this.each(d3_selection_on(type, listener, capture));
            };
            function d3_selection_on(type, listener, capture) {
                var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
                if (i > 0) type = type.slice(0, i);
                var filter = d3_selection_onFilters.get(type);
                if (filter) type = filter, wrap = d3_selection_onFilter;
                function onRemove() {
                    var l = this[name];
                    if (l) {
                        this.removeEventListener(type, l, l.$);
                        delete this[name];
                    }
                }
                function onAdd() {
                    var l = wrap(listener, d3_array(arguments));
                    onRemove.call(this);
                    this.addEventListener(type, this[name] = l, l.$ = capture);
                    l._ = listener;
                }
                function removeAll() {
                    var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
                    for (var name in this) {
                        if (match = name.match(re)) {
                            var l = this[name];
                            this.removeEventListener(match[1], l, l.$);
                            delete this[name];
                        }
                    }
                }
                return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
            }
            var d3_selection_onFilters = d3.map({
                mouseenter: "mouseover",
                mouseleave: "mouseout"
            });
            if (d3_document) {
                d3_selection_onFilters.forEach(function(k) {
                    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
                });
            }
            function d3_selection_onListener(listener, argumentz) {
                return function(e) {
                    var o = d3.event;
                    d3.event = e;
                    argumentz[0] = this.__data__;
                    try {
                        listener.apply(this, argumentz);
                    } finally {
                        d3.event = o;
                    }
                };
            }
            function d3_selection_onFilter(listener, argumentz) {
                var l = d3_selection_onListener(listener, argumentz);
                return function(e) {
                    var target = this, related = e.relatedTarget;
                    if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                        l.call(target, e);
                    }
                };
            }
            var d3_event_dragSelect, d3_event_dragId = 0;
            function d3_event_dragSuppress(node) {
                var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
                if (d3_event_dragSelect == null) {
                    d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
                }
                if (d3_event_dragSelect) {
                    var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
                    style[d3_event_dragSelect] = "none";
                }
                return function(suppressClick) {
                    w.on(name, null);
                    if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
                    if (suppressClick) {
                        var off = function() {
                            w.on(click, null);
                        };
                        w.on(click, function() {
                            d3_eventPreventDefault();
                            off();
                        }, true);
                        setTimeout(off, 0);
                    }
                };
            }
            d3.mouse = function(container) {
                return d3_mousePoint(container, d3_eventSource());
            };
            var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
            function d3_mousePoint(container, e) {
                if (e.changedTouches) e = e.changedTouches[0];
                var svg = container.ownerSVGElement || container;
                if (svg.createSVGPoint) {
                    var point = svg.createSVGPoint();
                    if (d3_mouse_bug44083 < 0) {
                        var window = d3_window(container);
                        if (window.scrollX || window.scrollY) {
                            svg = d3.select("body").append("svg").style({
                                position: "absolute",
                                top: 0,
                                left: 0,
                                margin: 0,
                                padding: 0,
                                border: "none"
                            }, "important");
                            var ctm = svg[0][0].getScreenCTM();
                            d3_mouse_bug44083 = !(ctm.f || ctm.e);
                            svg.remove();
                        }
                    }
                    if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
                    point.y = e.clientY;
                    point = point.matrixTransform(container.getScreenCTM().inverse());
                    return [ point.x, point.y ];
                }
                var rect = container.getBoundingClientRect();
                return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
            }
            d3.touch = function(container, touches, identifier) {
                if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
                if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
                    if ((touch = touches[i]).identifier === identifier) {
                        return d3_mousePoint(container, touch);
                    }
                }
            };
            d3.behavior.drag = function() {
                var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
                function drag() {
                    this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
                }
                function dragstart(id, position, subject, move, end) {
                    return function() {
                        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                        if (origin) {
                            dragOffset = origin.apply(that, arguments);
                            dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
                        } else {
                            dragOffset = [ 0, 0 ];
                        }
                        dispatch({
                            type: "dragstart"
                        });
                        function moved() {
                            var position1 = position(parent, dragId), dx, dy;
                            if (!position1) return;
                            dx = position1[0] - position0[0];
                            dy = position1[1] - position0[1];
                            dragged |= dx | dy;
                            position0 = position1;
                            dispatch({
                                type: "drag",
                                x: position1[0] + dragOffset[0],
                                y: position1[1] + dragOffset[1],
                                dx: dx,
                                dy: dy
                            });
                        }
                        function ended() {
                            if (!position(parent, dragId)) return;
                            dragSubject.on(move + dragName, null).on(end + dragName, null);
                            dragRestore(dragged && d3.event.target === target);
                            dispatch({
                                type: "dragend"
                            });
                        }
                    };
                }
                drag.origin = function(x) {
                    if (!arguments.length) return origin;
                    origin = x;
                    return drag;
                };
                return d3.rebind(drag, event, "on");
            };
            function d3_behavior_dragTouchId() {
                return d3.event.changedTouches[0].identifier;
            }
            d3.touches = function(container, touches) {
                if (arguments.length < 2) touches = d3_eventSource().touches;
                return touches ? d3_array(touches).map(function(touch) {
                    var point = d3_mousePoint(container, touch);
                    point.identifier = touch.identifier;
                    return point;
                }) : [];
            };
            var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
            function d3_sgn(x) {
                return x > 0 ? 1 : x < 0 ? -1 : 0;
            }
            function d3_cross2d(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
            }
            function d3_acos(x) {
                return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
            }
            function d3_asin(x) {
                return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
            }
            function d3_sinh(x) {
                return ((x = Math.exp(x)) - 1 / x) / 2;
            }
            function d3_cosh(x) {
                return ((x = Math.exp(x)) + 1 / x) / 2;
            }
            function d3_tanh(x) {
                return ((x = Math.exp(2 * x)) - 1) / (x + 1);
            }
            function d3_haversin(x) {
                return (x = Math.sin(x / 2)) * x;
            }
            var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
            d3.interpolateZoom = function(p0, p1) {
                var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
                var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
                function interpolate(t) {
                    var s = t * S;
                    if (dr) {
                        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
                    }
                    return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
                }
                interpolate.duration = S * 1e3;
                return interpolate;
            };
            d3.behavior.zoom = function() {
                var view = {
                    x: 0,
                    y: 0,
                    k: 1
                }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
                if (!d3_behavior_zoomWheel) {
                    d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
                    }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                        return d3.event.wheelDelta;
                    }, "mousewheel") : (d3_behavior_zoomDelta = function() {
                        return -d3.event.detail;
                    }, "MozMousePixelScroll");
                }
                function zoom(g) {
                    g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
                }
                zoom.event = function(g) {
                    g.each(function() {
                        var dispatch = event.of(this, arguments), view1 = view;
                        if (d3_transitionInheritId) {
                            d3.select(this).transition().each("start.zoom", function() {
                                view = this.__chart__ || {
                                    x: 0,
                                    y: 0,
                                    k: 1
                                };
                                zoomstarted(dispatch);
                            }).tween("zoom:zoom", function() {
                                var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
                                return function(t) {
                                    var l = i(t), k = dx / l[2];
                                    this.__chart__ = view = {
                                        x: cx - l[0] * k,
                                        y: cy - l[1] * k,
                                        k: k
                                    };
                                    zoomed(dispatch);
                                };
                            }).each("interrupt.zoom", function() {
                                zoomended(dispatch);
                            }).each("end.zoom", function() {
                                zoomended(dispatch);
                            });
                        } else {
                            this.__chart__ = view;
                            zoomstarted(dispatch);
                            zoomed(dispatch);
                            zoomended(dispatch);
                        }
                    });
                };
                zoom.translate = function(_) {
                    if (!arguments.length) return [ view.x, view.y ];
                    view = {
                        x: +_[0],
                        y: +_[1],
                        k: view.k
                    };
                    rescale();
                    return zoom;
                };
                zoom.scale = function(_) {
                    if (!arguments.length) return view.k;
                    view = {
                        x: view.x,
                        y: view.y,
                        k: +_
                    };
                    rescale();
                    return zoom;
                };
                zoom.scaleExtent = function(_) {
                    if (!arguments.length) return scaleExtent;
                    scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
                    return zoom;
                };
                zoom.center = function(_) {
                    if (!arguments.length) return center;
                    center = _ && [ +_[0], +_[1] ];
                    return zoom;
                };
                zoom.size = function(_) {
                    if (!arguments.length) return size;
                    size = _ && [ +_[0], +_[1] ];
                    return zoom;
                };
                zoom.duration = function(_) {
                    if (!arguments.length) return duration;
                    duration = +_;
                    return zoom;
                };
                zoom.x = function(z) {
                    if (!arguments.length) return x1;
                    x1 = z;
                    x0 = z.copy();
                    view = {
                        x: 0,
                        y: 0,
                        k: 1
                    };
                    return zoom;
                };
                zoom.y = function(z) {
                    if (!arguments.length) return y1;
                    y1 = z;
                    y0 = z.copy();
                    view = {
                        x: 0,
                        y: 0,
                        k: 1
                    };
                    return zoom;
                };
                function location(p) {
                    return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
                }
                function point(l) {
                    return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
                }
                function scaleTo(s) {
                    view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
                }
                function translateTo(p, l) {
                    l = point(l);
                    view.x += p[0] - l[0];
                    view.y += p[1] - l[1];
                }
                function zoomTo(that, p, l, k) {
                    that.__chart__ = {
                        x: view.x,
                        y: view.y,
                        k: view.k
                    };
                    scaleTo(Math.pow(2, k));
                    translateTo(center0 = p, l);
                    that = d3.select(that);
                    if (duration > 0) that = that.transition().duration(duration);
                    that.call(zoom.event);
                }
                function rescale() {
                    if (x1) x1.domain(x0.range().map(function(x) {
                        return (x - view.x) / view.k;
                    }).map(x0.invert));
                    if (y1) y1.domain(y0.range().map(function(y) {
                        return (y - view.y) / view.k;
                    }).map(y0.invert));
                }
                function zoomstarted(dispatch) {
                    if (!zooming++) dispatch({
                        type: "zoomstart"
                    });
                }
                function zoomed(dispatch) {
                    rescale();
                    dispatch({
                        type: "zoom",
                        scale: view.k,
                        translate: [ view.x, view.y ]
                    });
                }
                function zoomended(dispatch) {
                    if (!--zooming) dispatch({
                        type: "zoomend"
                    }), center0 = null;
                }
                function mousedowned() {
                    var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
                    d3_selection_interrupt.call(that);
                    zoomstarted(dispatch);
                    function moved() {
                        dragged = 1;
                        translateTo(d3.mouse(that), location0);
                        zoomed(dispatch);
                    }
                    function ended() {
                        subject.on(mousemove, null).on(mouseup, null);
                        dragRestore(dragged && d3.event.target === target);
                        zoomended(dispatch);
                    }
                }
                function touchstarted() {
                    var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
                    started();
                    zoomstarted(dispatch);
                    subject.on(mousedown, null).on(touchstart, started);
                    function relocate() {
                        var touches = d3.touches(that);
                        scale0 = view.k;
                        touches.forEach(function(t) {
                            if (t.identifier in locations0) locations0[t.identifier] = location(t);
                        });
                        return touches;
                    }
                    function started() {
                        var target = d3.event.target;
                        d3.select(target).on(touchmove, moved).on(touchend, ended);
                        targets.push(target);
                        var changed = d3.event.changedTouches;
                        for (var i = 0, n = changed.length; i < n; ++i) {
                            locations0[changed[i].identifier] = null;
                        }
                        var touches = relocate(), now = Date.now();
                        if (touches.length === 1) {
                            if (now - touchtime < 500) {
                                var p = touches[0];
                                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                                d3_eventPreventDefault();
                            }
                            touchtime = now;
                        } else if (touches.length > 1) {
                            var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                            distance0 = dx * dx + dy * dy;
                        }
                    }
                    function moved() {
                        var touches = d3.touches(that), p0, l0, p1, l1;
                        d3_selection_interrupt.call(that);
                        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                            p1 = touches[i];
                            if (l1 = locations0[p1.identifier]) {
                                if (l0) break;
                                p0 = p1, l0 = l1;
                            }
                        }
                        if (l1) {
                            var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                            p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                            l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                            scaleTo(scale1 * scale0);
                        }
                        touchtime = null;
                        translateTo(p0, l0);
                        zoomed(dispatch);
                    }
                    function ended() {
                        if (d3.event.touches.length) {
                            var changed = d3.event.changedTouches;
                            for (var i = 0, n = changed.length; i < n; ++i) {
                                delete locations0[changed[i].identifier];
                            }
                            for (var identifier in locations0) {
                                return void relocate();
                            }
                        }
                        d3.selectAll(targets).on(zoomName, null);
                        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                        dragRestore();
                        zoomended(dispatch);
                    }
                }
                function mousewheeled() {
                    var dispatch = event.of(this, arguments);
                    if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
                    translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
                    mousewheelTimer = setTimeout(function() {
                        mousewheelTimer = null;
                        zoomended(dispatch);
                    }, 50);
                    d3_eventPreventDefault();
                    scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
                    translateTo(center0, translate0);
                    zoomed(dispatch);
                }
                function dblclicked() {
                    var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
                    zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
                }
                return d3.rebind(zoom, event, "on");
            };
            var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
            d3.color = d3_color;
            function d3_color() {}
            d3_color.prototype.toString = function() {
                return this.rgb() + "";
            };
            d3.hsl = d3_hsl;
            function d3_hsl(h, s, l) {
                return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
            }
            var d3_hslPrototype = d3_hsl.prototype = new d3_color();
            d3_hslPrototype.brighter = function(k) {
                k = Math.pow(.7, arguments.length ? k : 1);
                return new d3_hsl(this.h, this.s, this.l / k);
            };
            d3_hslPrototype.darker = function(k) {
                k = Math.pow(.7, arguments.length ? k : 1);
                return new d3_hsl(this.h, this.s, k * this.l);
            };
            d3_hslPrototype.rgb = function() {
                return d3_hsl_rgb(this.h, this.s, this.l);
            };
            function d3_hsl_rgb(h, s, l) {
                var m1, m2;
                h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
                s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
                l = l < 0 ? 0 : l > 1 ? 1 : l;
                m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
                m1 = 2 * l - m2;
                function v(h) {
                    if (h > 360) h -= 360; else if (h < 0) h += 360;
                    if (h < 60) return m1 + (m2 - m1) * h / 60;
                    if (h < 180) return m2;
                    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
                    return m1;
                }
                function vv(h) {
                    return Math.round(v(h) * 255);
                }
                return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
            }
            d3.hcl = d3_hcl;
            function d3_hcl(h, c, l) {
                return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
            }
            var d3_hclPrototype = d3_hcl.prototype = new d3_color();
            d3_hclPrototype.brighter = function(k) {
                return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
            };
            d3_hclPrototype.darker = function(k) {
                return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
            };
            d3_hclPrototype.rgb = function() {
                return d3_hcl_lab(this.h, this.c, this.l).rgb();
            };
            function d3_hcl_lab(h, c, l) {
                if (isNaN(h)) h = 0;
                if (isNaN(c)) c = 0;
                return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
            }
            d3.lab = d3_lab;
            function d3_lab(l, a, b) {
                return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
            }
            var d3_lab_K = 18;
            var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
            var d3_labPrototype = d3_lab.prototype = new d3_color();
            d3_labPrototype.brighter = function(k) {
                return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
            };
            d3_labPrototype.darker = function(k) {
                return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
            };
            d3_labPrototype.rgb = function() {
                return d3_lab_rgb(this.l, this.a, this.b);
            };
            function d3_lab_rgb(l, a, b) {
                var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
                x = d3_lab_xyz(x) * d3_lab_X;
                y = d3_lab_xyz(y) * d3_lab_Y;
                z = d3_lab_xyz(z) * d3_lab_Z;
                return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
            }
            function d3_lab_hcl(l, a, b) {
                return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
            }
            function d3_lab_xyz(x) {
                return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
            }
            function d3_xyz_lab(x) {
                return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
            }
            function d3_xyz_rgb(r) {
                return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
            }
            d3.rgb = d3_rgb;
            function d3_rgb(r, g, b) {
                return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
            }
            function d3_rgbNumber(value) {
                return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
            }
            function d3_rgbString(value) {
                return d3_rgbNumber(value) + "";
            }
            var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
            d3_rgbPrototype.brighter = function(k) {
                k = Math.pow(.7, arguments.length ? k : 1);
                var r = this.r, g = this.g, b = this.b, i = 30;
                if (!r && !g && !b) return new d3_rgb(i, i, i);
                if (r && r < i) r = i;
                if (g && g < i) g = i;
                if (b && b < i) b = i;
                return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
            };
            d3_rgbPrototype.darker = function(k) {
                k = Math.pow(.7, arguments.length ? k : 1);
                return new d3_rgb(k * this.r, k * this.g, k * this.b);
            };
            d3_rgbPrototype.hsl = function() {
                return d3_rgb_hsl(this.r, this.g, this.b);
            };
            d3_rgbPrototype.toString = function() {
                return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
            };
            function d3_rgb_hex(v) {
                return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
            }
            function d3_rgb_parse(format, rgb, hsl) {
                format = format.toLowerCase();
                var r = 0, g = 0, b = 0, m1, m2, color;
                m1 = /([a-z]+)\((.*)\)/.exec(format);
                if (m1) {
                    m2 = m1[2].split(",");
                    switch (m1[1]) {
                      case "hsl":
                        {
                            return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                        }

                      case "rgb":
                        {
                            return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                        }
                    }
                }
                if (color = d3_rgb_names.get(format)) {
                    return rgb(color.r, color.g, color.b);
                }
                if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
                    if (format.length === 4) {
                        r = (color & 3840) >> 4;
                        r = r >> 4 | r;
                        g = color & 240;
                        g = g >> 4 | g;
                        b = color & 15;
                        b = b << 4 | b;
                    } else if (format.length === 7) {
                        r = (color & 16711680) >> 16;
                        g = (color & 65280) >> 8;
                        b = color & 255;
                    }
                }
                return rgb(r, g, b);
            }
            function d3_rgb_hsl(r, g, b) {
                var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
                if (d) {
                    s = l < .5 ? d / (max + min) : d / (2 - max - min);
                    if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
                    h *= 60;
                } else {
                    h = NaN;
                    s = l > 0 && l < 1 ? 0 : h;
                }
                return new d3_hsl(h, s, l);
            }
            function d3_rgb_lab(r, g, b) {
                r = d3_rgb_xyz(r);
                g = d3_rgb_xyz(g);
                b = d3_rgb_xyz(b);
                var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
                return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
            }
            function d3_rgb_xyz(r) {
                return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
            }
            function d3_rgb_parseNumber(c) {
                var f = parseFloat(c);
                return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
            }
            var d3_rgb_names = d3.map({
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            });
            d3_rgb_names.forEach(function(key, value) {
                d3_rgb_names.set(key, d3_rgbNumber(value));
            });
            function d3_functor(v) {
                return typeof v === "function" ? v : function() {
                    return v;
                };
            }
            d3.functor = d3_functor;
            d3.xhr = d3_xhrType(d3_identity);
            function d3_xhrType(response) {
                return function(url, mimeType, callback) {
                    if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
                    mimeType = null;
                    return d3_xhr(url, mimeType, response, callback);
                };
            }
            function d3_xhr(url, mimeType, response, callback) {
                var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
                if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
                "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
                    request.readyState > 3 && respond();
                };
                function respond() {
                    var status = request.status, result;
                    if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                        try {
                            result = response.call(xhr, request);
                        } catch (e) {
                            dispatch.error.call(xhr, e);
                            return;
                        }
                        dispatch.load.call(xhr, result);
                    } else {
                        dispatch.error.call(xhr, request);
                    }
                }
                request.onprogress = function(event) {
                    var o = d3.event;
                    d3.event = event;
                    try {
                        dispatch.progress.call(xhr, request);
                    } finally {
                        d3.event = o;
                    }
                };
                xhr.header = function(name, value) {
                    name = (name + "").toLowerCase();
                    if (arguments.length < 2) return headers[name];
                    if (value == null) delete headers[name]; else headers[name] = value + "";
                    return xhr;
                };
                xhr.mimeType = function(value) {
                    if (!arguments.length) return mimeType;
                    mimeType = value == null ? null : value + "";
                    return xhr;
                };
                xhr.responseType = function(value) {
                    if (!arguments.length) return responseType;
                    responseType = value;
                    return xhr;
                };
                xhr.response = function(value) {
                    response = value;
                    return xhr;
                };
                [ "get", "post" ].forEach(function(method) {
                    xhr[method] = function() {
                        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
                    };
                });
                xhr.send = function(method, data, callback) {
                    if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
                    request.open(method, url, true);
                    if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
                    if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
                    if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
                    if (responseType != null) request.responseType = responseType;
                    if (callback != null) xhr.on("error", callback).on("load", function(request) {
                        callback(null, request);
                    });
                    dispatch.beforesend.call(xhr, request);
                    request.send(data == null ? null : data);
                    return xhr;
                };
                xhr.abort = function() {
                    request.abort();
                    return xhr;
                };
                d3.rebind(xhr, dispatch, "on");
                return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
            }
            function d3_xhr_fixCallback(callback) {
                return callback.length === 1 ? function(error, request) {
                    callback(error == null ? request : null);
                } : callback;
            }
            function d3_xhrHasResponse(request) {
                var type = request.responseType;
                return type && type !== "text" ? request.response : request.responseText;
            }
            d3.dsv = function(delimiter, mimeType) {
                var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
                function dsv(url, row, callback) {
                    if (arguments.length < 3) callback = row, row = null;
                    var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
                    xhr.row = function(_) {
                        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
                    };
                    return xhr;
                }
                function response(request) {
                    return dsv.parse(request.responseText);
                }
                function typedResponse(f) {
                    return function(request) {
                        return dsv.parse(request.responseText, f);
                    };
                }
                dsv.parse = function(text, f) {
                    var o;
                    return dsv.parseRows(text, function(row, i) {
                        if (o) return o(row, i - 1);
                        var a = new Function("d", "return {" + row.map(function(name, i) {
                            return JSON.stringify(name) + ": d[" + i + "]";
                        }).join(",") + "}");
                        o = f ? function(row, i) {
                            return f(a(row), i);
                        } : a;
                    });
                };
                dsv.parseRows = function(text, f) {
                    var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
                    function token() {
                        if (I >= N) return EOF;
                        if (eol) return eol = false, EOL;
                        var j = I;
                        if (text.charCodeAt(j) === 34) {
                            var i = j;
                            while (i++ < N) {
                                if (text.charCodeAt(i) === 34) {
                                    if (text.charCodeAt(i + 1) !== 34) break;
                                    ++i;
                                }
                            }
                            I = i + 2;
                            var c = text.charCodeAt(i + 1);
                            if (c === 13) {
                                eol = true;
                                if (text.charCodeAt(i + 2) === 10) ++I;
                            } else if (c === 10) {
                                eol = true;
                            }
                            return text.slice(j + 1, i).replace(/""/g, '"');
                        }
                        while (I < N) {
                            var c = text.charCodeAt(I++), k = 1;
                            if (c === 10) eol = true; else if (c === 13) {
                                eol = true;
                                if (text.charCodeAt(I) === 10) ++I, ++k;
                            } else if (c !== delimiterCode) continue;
                            return text.slice(j, I - k);
                        }
                        return text.slice(j);
                    }
                    while ((t = token()) !== EOF) {
                        var a = [];
                        while (t !== EOL && t !== EOF) {
                            a.push(t);
                            t = token();
                        }
                        if (f && (a = f(a, n++)) == null) continue;
                        rows.push(a);
                    }
                    return rows;
                };
                dsv.format = function(rows) {
                    if (Array.isArray(rows[0])) return dsv.formatRows(rows);
                    var fieldSet = new d3_Set(), fields = [];
                    rows.forEach(function(row) {
                        for (var field in row) {
                            if (!fieldSet.has(field)) {
                                fields.push(fieldSet.add(field));
                            }
                        }
                    });
                    return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                        return fields.map(function(field) {
                            return formatValue(row[field]);
                        }).join(delimiter);
                    })).join("\n");
                };
                dsv.formatRows = function(rows) {
                    return rows.map(formatRow).join("\n");
                };
                function formatRow(row) {
                    return row.map(formatValue).join(delimiter);
                }
                function formatValue(text) {
                    return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
                }
                return dsv;
            };
            d3.csv = d3.dsv(",", "text/csv");
            d3.tsv = d3.dsv("	", "text/tab-separated-values");
            var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
                setTimeout(callback, 17);
            };
            d3.timer = function(callback, delay, then) {
                var n = arguments.length;
                if (n < 2) delay = 0;
                if (n < 3) then = Date.now();
                var time = then + delay, timer = {
                    c: callback,
                    t: time,
                    f: false,
                    n: null
                };
                if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
                d3_timer_queueTail = timer;
                if (!d3_timer_interval) {
                    d3_timer_timeout = clearTimeout(d3_timer_timeout);
                    d3_timer_interval = 1;
                    d3_timer_frame(d3_timer_step);
                }
            };
            function d3_timer_step() {
                var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
                if (delay > 24) {
                    if (isFinite(delay)) {
                        clearTimeout(d3_timer_timeout);
                        d3_timer_timeout = setTimeout(d3_timer_step, delay);
                    }
                    d3_timer_interval = 0;
                } else {
                    d3_timer_interval = 1;
                    d3_timer_frame(d3_timer_step);
                }
            }
            d3.timer.flush = function() {
                d3_timer_mark();
                d3_timer_sweep();
            };
            function d3_timer_mark() {
                var now = Date.now();
                d3_timer_active = d3_timer_queueHead;
                while (d3_timer_active) {
                    if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
                    d3_timer_active = d3_timer_active.n;
                }
                return now;
            }
            function d3_timer_sweep() {
                var t0, t1 = d3_timer_queueHead, time = Infinity;
                while (t1) {
                    if (t1.f) {
                        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
                    } else {
                        if (t1.t < time) time = t1.t;
                        t1 = (t0 = t1).n;
                    }
                }
                d3_timer_queueTail = t0;
                return time;
            }
            function d3_format_precision(x, p) {
                return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
            }
            d3.round = function(x, n) {
                return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
            };
            var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
            d3.formatPrefix = function(value, precision) {
                var i = 0;
                if (value) {
                    if (value < 0) value *= -1;
                    if (precision) value = d3.round(value, d3_format_precision(value, precision));
                    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
                    i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
                }
                return d3_formatPrefixes[8 + i / 3];
            };
            function d3_formatPrefix(d, i) {
                var k = Math.pow(10, abs(8 - i) * 3);
                return {
                    scale: i > 8 ? function(d) {
                        return d / k;
                    } : function(d) {
                        return d * k;
                    },
                    symbol: d
                };
            }
            function d3_locale_numberFormat(locale) {
                var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
                    var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
                    while (i > 0 && g > 0) {
                        if (length + g + 1 > width) g = Math.max(1, width - length);
                        t.push(value.substring(i -= g, i + g));
                        if ((length += g + 1) > width) break;
                        g = locale_grouping[j = (j + 1) % locale_grouping.length];
                    }
                    return t.reverse().join(locale_thousands);
                } : d3_identity;
                return function(specifier) {
                    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
                    if (precision) precision = +precision.substring(1);
                    if (zfill || fill === "0" && align === "=") {
                        zfill = fill = "0";
                        align = "=";
                    }
                    switch (type) {
                      case "n":
                        comma = true;
                        type = "g";
                        break;

                      case "%":
                        scale = 100;
                        suffix = "%";
                        type = "f";
                        break;

                      case "p":
                        scale = 100;
                        suffix = "%";
                        type = "r";
                        break;

                      case "b":
                      case "o":
                      case "x":
                      case "X":
                        if (symbol === "#") prefix = "0" + type.toLowerCase();

                      case "c":
                        exponent = false;

                      case "d":
                        integer = true;
                        precision = 0;
                        break;

                      case "s":
                        scale = -1;
                        type = "r";
                        break;
                    }
                    if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
                    if (type == "r" && !precision) type = "g";
                    if (precision != null) {
                        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
                    }
                    type = d3_format_types.get(type) || d3_format_typeDefault;
                    var zcomma = zfill && comma;
                    return function(value) {
                        var fullSuffix = suffix;
                        if (integer && value % 1) return "";
                        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                        if (scale < 0) {
                            var unit = d3.formatPrefix(value, precision);
                            value = unit.scale(value);
                            fullSuffix = unit.symbol + suffix;
                        } else {
                            value *= scale;
                        }
                        value = type(value, precision);
                        var i = value.lastIndexOf("."), before, after;
                        if (i < 0) {
                            var j = exponent ? value.lastIndexOf("e") : -1;
                            if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
                        } else {
                            before = value.substring(0, i);
                            after = locale_decimal + value.substring(i + 1);
                        }
                        if (!zfill && comma) before = formatGroup(before, Infinity);
                        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                        negative += prefix;
                        value = before + after;
                        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
                    };
                };
            }
            var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
            var d3_format_types = d3.map({
                b: function(x) {
                    return x.toString(2);
                },
                c: function(x) {
                    return String.fromCharCode(x);
                },
                o: function(x) {
                    return x.toString(8);
                },
                x: function(x) {
                    return x.toString(16);
                },
                X: function(x) {
                    return x.toString(16).toUpperCase();
                },
                g: function(x, p) {
                    return x.toPrecision(p);
                },
                e: function(x, p) {
                    return x.toExponential(p);
                },
                f: function(x, p) {
                    return x.toFixed(p);
                },
                r: function(x, p) {
                    return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
                }
            });
            function d3_format_typeDefault(x) {
                return x + "";
            }
            var d3_time = d3.time = {}, d3_date = Date;
            function d3_date_utc() {
                this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
            }
            d3_date_utc.prototype = {
                getDate: function() {
                    return this._.getUTCDate();
                },
                getDay: function() {
                    return this._.getUTCDay();
                },
                getFullYear: function() {
                    return this._.getUTCFullYear();
                },
                getHours: function() {
                    return this._.getUTCHours();
                },
                getMilliseconds: function() {
                    return this._.getUTCMilliseconds();
                },
                getMinutes: function() {
                    return this._.getUTCMinutes();
                },
                getMonth: function() {
                    return this._.getUTCMonth();
                },
                getSeconds: function() {
                    return this._.getUTCSeconds();
                },
                getTime: function() {
                    return this._.getTime();
                },
                getTimezoneOffset: function() {
                    return 0;
                },
                valueOf: function() {
                    return this._.valueOf();
                },
                setDate: function() {
                    d3_time_prototype.setUTCDate.apply(this._, arguments);
                },
                setDay: function() {
                    d3_time_prototype.setUTCDay.apply(this._, arguments);
                },
                setFullYear: function() {
                    d3_time_prototype.setUTCFullYear.apply(this._, arguments);
                },
                setHours: function() {
                    d3_time_prototype.setUTCHours.apply(this._, arguments);
                },
                setMilliseconds: function() {
                    d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
                },
                setMinutes: function() {
                    d3_time_prototype.setUTCMinutes.apply(this._, arguments);
                },
                setMonth: function() {
                    d3_time_prototype.setUTCMonth.apply(this._, arguments);
                },
                setSeconds: function() {
                    d3_time_prototype.setUTCSeconds.apply(this._, arguments);
                },
                setTime: function() {
                    d3_time_prototype.setTime.apply(this._, arguments);
                }
            };
            var d3_time_prototype = Date.prototype;
            function d3_time_interval(local, step, number) {
                function round(date) {
                    var d0 = local(date), d1 = offset(d0, 1);
                    return date - d0 < d1 - date ? d0 : d1;
                }
                function ceil(date) {
                    step(date = local(new d3_date(date - 1)), 1);
                    return date;
                }
                function offset(date, k) {
                    step(date = new d3_date(+date), k);
                    return date;
                }
                function range(t0, t1, dt) {
                    var time = ceil(t0), times = [];
                    if (dt > 1) {
                        while (time < t1) {
                            if (!(number(time) % dt)) times.push(new Date(+time));
                            step(time, 1);
                        }
                    } else {
                        while (time < t1) times.push(new Date(+time)), step(time, 1);
                    }
                    return times;
                }
                function range_utc(t0, t1, dt) {
                    try {
                        d3_date = d3_date_utc;
                        var utc = new d3_date_utc();
                        utc._ = t0;
                        return range(utc, t1, dt);
                    } finally {
                        d3_date = Date;
                    }
                }
                local.floor = local;
                local.round = round;
                local.ceil = ceil;
                local.offset = offset;
                local.range = range;
                var utc = local.utc = d3_time_interval_utc(local);
                utc.floor = utc;
                utc.round = d3_time_interval_utc(round);
                utc.ceil = d3_time_interval_utc(ceil);
                utc.offset = d3_time_interval_utc(offset);
                utc.range = range_utc;
                return local;
            }
            function d3_time_interval_utc(method) {
                return function(date, k) {
                    try {
                        d3_date = d3_date_utc;
                        var utc = new d3_date_utc();
                        utc._ = date;
                        return method(utc, k)._;
                    } finally {
                        d3_date = Date;
                    }
                };
            }
            d3_time.year = d3_time_interval(function(date) {
                date = d3_time.day(date);
                date.setMonth(0, 1);
                return date;
            }, function(date, offset) {
                date.setFullYear(date.getFullYear() + offset);
            }, function(date) {
                return date.getFullYear();
            });
            d3_time.years = d3_time.year.range;
            d3_time.years.utc = d3_time.year.utc.range;
            d3_time.day = d3_time_interval(function(date) {
                var day = new d3_date(2e3, 0);
                day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                return day;
            }, function(date, offset) {
                date.setDate(date.getDate() + offset);
            }, function(date) {
                return date.getDate() - 1;
            });
            d3_time.days = d3_time.day.range;
            d3_time.days.utc = d3_time.day.utc.range;
            d3_time.dayOfYear = function(date) {
                var year = d3_time.year(date);
                return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
            };
            [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
                i = 7 - i;
                var interval = d3_time[day] = d3_time_interval(function(date) {
                    (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
                    return date;
                }, function(date, offset) {
                    date.setDate(date.getDate() + Math.floor(offset) * 7);
                }, function(date) {
                    var day = d3_time.year(date).getDay();
                    return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
                });
                d3_time[day + "s"] = interval.range;
                d3_time[day + "s"].utc = interval.utc.range;
                d3_time[day + "OfYear"] = function(date) {
                    var day = d3_time.year(date).getDay();
                    return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
                };
            });
            d3_time.week = d3_time.sunday;
            d3_time.weeks = d3_time.sunday.range;
            d3_time.weeks.utc = d3_time.sunday.utc.range;
            d3_time.weekOfYear = d3_time.sundayOfYear;
            function d3_locale_timeFormat(locale) {
                var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
                function d3_time_format(template) {
                    var n = template.length;
                    function format(date) {
                        var string = [], i = -1, j = 0, c, p, f;
                        while (++i < n) {
                            if (template.charCodeAt(i) === 37) {
                                string.push(template.slice(j, i));
                                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                                if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                                string.push(c);
                                j = i + 1;
                            }
                        }
                        string.push(template.slice(j, i));
                        return string.join("");
                    }
                    format.parse = function(string) {
                        var d = {
                            y: 1900,
                            m: 0,
                            d: 1,
                            H: 0,
                            M: 0,
                            S: 0,
                            L: 0,
                            Z: null
                        }, i = d3_time_parse(d, template, string, 0);
                        if (i != string.length) return null;
                        if ("p" in d) d.H = d.H % 12 + d.p * 12;
                        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
                            date.setFullYear(d.y, 0, 1);
                            date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                        } else date.setFullYear(d.y, d.m, d.d);
                        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                        return localZ ? date._ : date;
                    };
                    format.toString = function() {
                        return template;
                    };
                    return format;
                }
                function d3_time_parse(date, template, string, j) {
                    var c, p, t, i = 0, n = template.length, m = string.length;
                    while (i < n) {
                        if (j >= m) return -1;
                        c = template.charCodeAt(i++);
                        if (c === 37) {
                            t = template.charAt(i++);
                            p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                            if (!p || (j = p(date, string, j)) < 0) return -1;
                        } else if (c != string.charCodeAt(j++)) {
                            return -1;
                        }
                    }
                    return j;
                }
                d3_time_format.utc = function(template) {
                    var local = d3_time_format(template);
                    function format(date) {
                        try {
                            d3_date = d3_date_utc;
                            var utc = new d3_date();
                            utc._ = date;
                            return local(utc);
                        } finally {
                            d3_date = Date;
                        }
                    }
                    format.parse = function(string) {
                        try {
                            d3_date = d3_date_utc;
                            var date = local.parse(string);
                            return date && date._;
                        } finally {
                            d3_date = Date;
                        }
                    };
                    format.toString = local.toString;
                    return format;
                };
                d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
                var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
                locale_periods.forEach(function(p, i) {
                    d3_time_periodLookup.set(p.toLowerCase(), i);
                });
                var d3_time_formats = {
                    a: function(d) {
                        return locale_shortDays[d.getDay()];
                    },
                    A: function(d) {
                        return locale_days[d.getDay()];
                    },
                    b: function(d) {
                        return locale_shortMonths[d.getMonth()];
                    },
                    B: function(d) {
                        return locale_months[d.getMonth()];
                    },
                    c: d3_time_format(locale_dateTime),
                    d: function(d, p) {
                        return d3_time_formatPad(d.getDate(), p, 2);
                    },
                    e: function(d, p) {
                        return d3_time_formatPad(d.getDate(), p, 2);
                    },
                    H: function(d, p) {
                        return d3_time_formatPad(d.getHours(), p, 2);
                    },
                    I: function(d, p) {
                        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
                    },
                    j: function(d, p) {
                        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
                    },
                    L: function(d, p) {
                        return d3_time_formatPad(d.getMilliseconds(), p, 3);
                    },
                    m: function(d, p) {
                        return d3_time_formatPad(d.getMonth() + 1, p, 2);
                    },
                    M: function(d, p) {
                        return d3_time_formatPad(d.getMinutes(), p, 2);
                    },
                    p: function(d) {
                        return locale_periods[+(d.getHours() >= 12)];
                    },
                    S: function(d, p) {
                        return d3_time_formatPad(d.getSeconds(), p, 2);
                    },
                    U: function(d, p) {
                        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
                    },
                    w: function(d) {
                        return d.getDay();
                    },
                    W: function(d, p) {
                        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
                    },
                    x: d3_time_format(locale_date),
                    X: d3_time_format(locale_time),
                    y: function(d, p) {
                        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
                    },
                    Y: function(d, p) {
                        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
                    },
                    Z: d3_time_zone,
                    "%": function() {
                        return "%";
                    }
                };
                var d3_time_parsers = {
                    a: d3_time_parseWeekdayAbbrev,
                    A: d3_time_parseWeekday,
                    b: d3_time_parseMonthAbbrev,
                    B: d3_time_parseMonth,
                    c: d3_time_parseLocaleFull,
                    d: d3_time_parseDay,
                    e: d3_time_parseDay,
                    H: d3_time_parseHour24,
                    I: d3_time_parseHour24,
                    j: d3_time_parseDayOfYear,
                    L: d3_time_parseMilliseconds,
                    m: d3_time_parseMonthNumber,
                    M: d3_time_parseMinutes,
                    p: d3_time_parseAmPm,
                    S: d3_time_parseSeconds,
                    U: d3_time_parseWeekNumberSunday,
                    w: d3_time_parseWeekdayNumber,
                    W: d3_time_parseWeekNumberMonday,
                    x: d3_time_parseLocaleDate,
                    X: d3_time_parseLocaleTime,
                    y: d3_time_parseYear,
                    Y: d3_time_parseFullYear,
                    Z: d3_time_parseZone,
                    "%": d3_time_parseLiteralPercent
                };
                function d3_time_parseWeekdayAbbrev(date, string, i) {
                    d3_time_dayAbbrevRe.lastIndex = 0;
                    var n = d3_time_dayAbbrevRe.exec(string.slice(i));
                    return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
                }
                function d3_time_parseWeekday(date, string, i) {
                    d3_time_dayRe.lastIndex = 0;
                    var n = d3_time_dayRe.exec(string.slice(i));
                    return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
                }
                function d3_time_parseMonthAbbrev(date, string, i) {
                    d3_time_monthAbbrevRe.lastIndex = 0;
                    var n = d3_time_monthAbbrevRe.exec(string.slice(i));
                    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
                }
                function d3_time_parseMonth(date, string, i) {
                    d3_time_monthRe.lastIndex = 0;
                    var n = d3_time_monthRe.exec(string.slice(i));
                    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
                }
                function d3_time_parseLocaleFull(date, string, i) {
                    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
                }
                function d3_time_parseLocaleDate(date, string, i) {
                    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
                }
                function d3_time_parseLocaleTime(date, string, i) {
                    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
                }
                function d3_time_parseAmPm(date, string, i) {
                    var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
                    return n == null ? -1 : (date.p = n, i);
                }
                return d3_time_format;
            }
            var d3_time_formatPads = {
                "-": "",
                _: " ",
                "0": "0"
            }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
            function d3_time_formatPad(value, fill, width) {
                var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
                return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
            }
            function d3_time_formatRe(names) {
                return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
            }
            function d3_time_formatLookup(names) {
                var map = new d3_Map(), i = -1, n = names.length;
                while (++i < n) map.set(names[i].toLowerCase(), i);
                return map;
            }
            function d3_time_parseWeekdayNumber(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 1));
                return n ? (date.w = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseWeekNumberSunday(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i));
                return n ? (date.U = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseWeekNumberMonday(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i));
                return n ? (date.W = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseFullYear(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 4));
                return n ? (date.y = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseYear(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
            }
            function d3_time_parseZone(date, string, i) {
                return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
                i + 5) : -1;
            }
            function d3_time_expandYear(d) {
                return d + (d > 68 ? 1900 : 2e3);
            }
            function d3_time_parseMonthNumber(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
            }
            function d3_time_parseDay(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.d = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseDayOfYear(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 3));
                return n ? (date.j = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseHour24(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.H = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseMinutes(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.M = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseSeconds(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 2));
                return n ? (date.S = +n[0], i + n[0].length) : -1;
            }
            function d3_time_parseMilliseconds(date, string, i) {
                d3_time_numberRe.lastIndex = 0;
                var n = d3_time_numberRe.exec(string.slice(i, i + 3));
                return n ? (date.L = +n[0], i + n[0].length) : -1;
            }
            function d3_time_zone(d) {
                var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
                return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
            }
            function d3_time_parseLiteralPercent(date, string, i) {
                d3_time_percentRe.lastIndex = 0;
                var n = d3_time_percentRe.exec(string.slice(i, i + 1));
                return n ? i + n[0].length : -1;
            }
            function d3_time_formatMulti(formats) {
                var n = formats.length, i = -1;
                while (++i < n) formats[i][0] = this(formats[i][0]);
                return function(date) {
                    var i = 0, f = formats[i];
                    while (!f[1](date)) f = formats[++i];
                    return f[0](date);
                };
            }
            d3.locale = function(locale) {
                return {
                    numberFormat: d3_locale_numberFormat(locale),
                    timeFormat: d3_locale_timeFormat(locale)
                };
            };
            var d3_locale_enUS = d3.locale({
                decimal: ".",
                thousands: ",",
                grouping: [ 3 ],
                currency: [ "$", "" ],
                dateTime: "%a %b %e %X %Y",
                date: "%m/%d/%Y",
                time: "%H:%M:%S",
                periods: [ "AM", "PM" ],
                days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
            });
            d3.format = d3_locale_enUS.numberFormat;
            d3.geo = {};
            function d3_adder() {}
            d3_adder.prototype = {
                s: 0,
                t: 0,
                add: function(y) {
                    d3_adderSum(y, this.t, d3_adderTemp);
                    d3_adderSum(d3_adderTemp.s, this.s, this);
                    if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
                },
                reset: function() {
                    this.s = this.t = 0;
                },
                valueOf: function() {
                    return this.s;
                }
            };
            var d3_adderTemp = new d3_adder();
            function d3_adderSum(a, b, o) {
                var x = o.s = a + b, bv = x - a, av = x - bv;
                o.t = a - av + (b - bv);
            }
            d3.geo.stream = function(object, listener) {
                if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
                    d3_geo_streamObjectType[object.type](object, listener);
                } else {
                    d3_geo_streamGeometry(object, listener);
                }
            };
            function d3_geo_streamGeometry(geometry, listener) {
                if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
                    d3_geo_streamGeometryType[geometry.type](geometry, listener);
                }
            }
            var d3_geo_streamObjectType = {
                Feature: function(feature, listener) {
                    d3_geo_streamGeometry(feature.geometry, listener);
                },
                FeatureCollection: function(object, listener) {
                    var features = object.features, i = -1, n = features.length;
                    while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
                }
            };
            var d3_geo_streamGeometryType = {
                Sphere: function(object, listener) {
                    listener.sphere();
                },
                Point: function(object, listener) {
                    object = object.coordinates;
                    listener.point(object[0], object[1], object[2]);
                },
                MultiPoint: function(object, listener) {
                    var coordinates = object.coordinates, i = -1, n = coordinates.length;
                    while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
                },
                LineString: function(object, listener) {
                    d3_geo_streamLine(object.coordinates, listener, 0);
                },
                MultiLineString: function(object, listener) {
                    var coordinates = object.coordinates, i = -1, n = coordinates.length;
                    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
                },
                Polygon: function(object, listener) {
                    d3_geo_streamPolygon(object.coordinates, listener);
                },
                MultiPolygon: function(object, listener) {
                    var coordinates = object.coordinates, i = -1, n = coordinates.length;
                    while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
                },
                GeometryCollection: function(object, listener) {
                    var geometries = object.geometries, i = -1, n = geometries.length;
                    while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
                }
            };
            function d3_geo_streamLine(coordinates, listener, closed) {
                var i = -1, n = coordinates.length - closed, coordinate;
                listener.lineStart();
                while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
                listener.lineEnd();
            }
            function d3_geo_streamPolygon(coordinates, listener) {
                var i = -1, n = coordinates.length;
                listener.polygonStart();
                while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
                listener.polygonEnd();
            }
            d3.geo.area = function(object) {
                d3_geo_areaSum = 0;
                d3.geo.stream(object, d3_geo_area);
                return d3_geo_areaSum;
            };
            var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
            var d3_geo_area = {
                sphere: function() {
                    d3_geo_areaSum += 4 * π;
                },
                point: d3_noop,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: function() {
                    d3_geo_areaRingSum.reset();
                    d3_geo_area.lineStart = d3_geo_areaRingStart;
                },
                polygonEnd: function() {
                    var area = 2 * d3_geo_areaRingSum;
                    d3_geo_areaSum += area < 0 ? 4 * π + area : area;
                    d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
                }
            };
            function d3_geo_areaRingStart() {
                var λ00, φ00, λ0, cosφ0, sinφ0;
                d3_geo_area.point = function(λ, φ) {
                    d3_geo_area.point = nextPoint;
                    λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
                    sinφ0 = Math.sin(φ);
                };
                function nextPoint(λ, φ) {
                    λ *= d3_radians;
                    φ = φ * d3_radians / 2 + π / 4;
                    var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
                    d3_geo_areaRingSum.add(Math.atan2(v, u));
                    λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
                }
                d3_geo_area.lineEnd = function() {
                    nextPoint(λ00, φ00);
                };
            }
            function d3_geo_cartesian(spherical) {
                var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
                return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
            }
            function d3_geo_cartesianDot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            function d3_geo_cartesianCross(a, b) {
                return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
            }
            function d3_geo_cartesianAdd(a, b) {
                a[0] += b[0];
                a[1] += b[1];
                a[2] += b[2];
            }
            function d3_geo_cartesianScale(vector, k) {
                return [ vector[0] * k, vector[1] * k, vector[2] * k ];
            }
            function d3_geo_cartesianNormalize(d) {
                var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
                d[0] /= l;
                d[1] /= l;
                d[2] /= l;
            }
            function d3_geo_spherical(cartesian) {
                return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
            }
            function d3_geo_sphericalEqual(a, b) {
                return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
            }
            d3.geo.bounds = function() {
                var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
                var bound = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        bound.point = ringPoint;
                        bound.lineStart = ringStart;
                        bound.lineEnd = ringEnd;
                        dλSum = 0;
                        d3_geo_area.polygonStart();
                    },
                    polygonEnd: function() {
                        d3_geo_area.polygonEnd();
                        bound.point = point;
                        bound.lineStart = lineStart;
                        bound.lineEnd = lineEnd;
                        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
                        range[0] = λ0, range[1] = λ1;
                    }
                };
                function point(λ, φ) {
                    ranges.push(range = [ λ0 = λ, λ1 = λ ]);
                    if (φ < φ0) φ0 = φ;
                    if (φ > φ1) φ1 = φ;
                }
                function linePoint(λ, φ) {
                    var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
                    if (p0) {
                        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                        d3_geo_cartesianNormalize(inflection);
                        inflection = d3_geo_spherical(inflection);
                        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                            var φi = inflection[1] * d3_degrees;
                            if (φi > φ1) φ1 = φi;
                        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                            var φi = -inflection[1] * d3_degrees;
                            if (φi < φ0) φ0 = φi;
                        } else {
                            if (φ < φ0) φ0 = φ;
                            if (φ > φ1) φ1 = φ;
                        }
                        if (antimeridian) {
                            if (λ < λ_) {
                                if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                            } else {
                                if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                            }
                        } else {
                            if (λ1 >= λ0) {
                                if (λ < λ0) λ0 = λ;
                                if (λ > λ1) λ1 = λ;
                            } else {
                                if (λ > λ_) {
                                    if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                                } else {
                                    if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                                }
                            }
                        }
                    } else {
                        point(λ, φ);
                    }
                    p0 = p, λ_ = λ;
                }
                function lineStart() {
                    bound.point = linePoint;
                }
                function lineEnd() {
                    range[0] = λ0, range[1] = λ1;
                    bound.point = point;
                    p0 = null;
                }
                function ringPoint(λ, φ) {
                    if (p0) {
                        var dλ = λ - λ_;
                        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
                    } else λ__ = λ, φ__ = φ;
                    d3_geo_area.point(λ, φ);
                    linePoint(λ, φ);
                }
                function ringStart() {
                    d3_geo_area.lineStart();
                }
                function ringEnd() {
                    ringPoint(λ__, φ__);
                    d3_geo_area.lineEnd();
                    if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
                    range[0] = λ0, range[1] = λ1;
                    p0 = null;
                }
                function angle(λ0, λ1) {
                    return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
                }
                function compareRanges(a, b) {
                    return a[0] - b[0];
                }
                function withinRange(x, range) {
                    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
                }
                return function(feature) {
                    φ1 = λ1 = -(λ0 = φ0 = Infinity);
                    ranges = [];
                    d3.geo.stream(feature, bound);
                    var n = ranges.length;
                    if (n) {
                        ranges.sort(compareRanges);
                        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                            b = ranges[i];
                            if (withinRange(b[0], a) || withinRange(b[1], a)) {
                                if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                                if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                            } else {
                                merged.push(a = b);
                            }
                        }
                        var best = -Infinity, dλ;
                        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                            b = merged[i];
                            if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
                        }
                    }
                    ranges = range = null;
                    return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
                };
            }();
            d3.geo.centroid = function(object) {
                d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
                d3.geo.stream(object, d3_geo_centroid);
                var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
                if (m < ε2) {
                    x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
                    if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
                    m = x * x + y * y + z * z;
                    if (m < ε2) return [ NaN, NaN ];
                }
                return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
            };
            var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
            var d3_geo_centroid = {
                sphere: d3_noop,
                point: d3_geo_centroidPoint,
                lineStart: d3_geo_centroidLineStart,
                lineEnd: d3_geo_centroidLineEnd,
                polygonStart: function() {
                    d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
                },
                polygonEnd: function() {
                    d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
                }
            };
            function d3_geo_centroidPoint(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians);
                d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
            }
            function d3_geo_centroidPointXYZ(x, y, z) {
                ++d3_geo_centroidW0;
                d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
                d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
                d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
            }
            function d3_geo_centroidLineStart() {
                var x0, y0, z0;
                d3_geo_centroid.point = function(λ, φ) {
                    λ *= d3_radians;
                    var cosφ = Math.cos(φ *= d3_radians);
                    x0 = cosφ * Math.cos(λ);
                    y0 = cosφ * Math.sin(λ);
                    z0 = Math.sin(φ);
                    d3_geo_centroid.point = nextPoint;
                    d3_geo_centroidPointXYZ(x0, y0, z0);
                };
                function nextPoint(λ, φ) {
                    λ *= d3_radians;
                    var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
                    d3_geo_centroidW1 += w;
                    d3_geo_centroidX1 += w * (x0 + (x0 = x));
                    d3_geo_centroidY1 += w * (y0 + (y0 = y));
                    d3_geo_centroidZ1 += w * (z0 + (z0 = z));
                    d3_geo_centroidPointXYZ(x0, y0, z0);
                }
            }
            function d3_geo_centroidLineEnd() {
                d3_geo_centroid.point = d3_geo_centroidPoint;
            }
            function d3_geo_centroidRingStart() {
                var λ00, φ00, x0, y0, z0;
                d3_geo_centroid.point = function(λ, φ) {
                    λ00 = λ, φ00 = φ;
                    d3_geo_centroid.point = nextPoint;
                    λ *= d3_radians;
                    var cosφ = Math.cos(φ *= d3_radians);
                    x0 = cosφ * Math.cos(λ);
                    y0 = cosφ * Math.sin(λ);
                    z0 = Math.sin(φ);
                    d3_geo_centroidPointXYZ(x0, y0, z0);
                };
                d3_geo_centroid.lineEnd = function() {
                    nextPoint(λ00, φ00);
                    d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
                    d3_geo_centroid.point = d3_geo_centroidPoint;
                };
                function nextPoint(λ, φ) {
                    λ *= d3_radians;
                    var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
                    d3_geo_centroidX2 += v * cx;
                    d3_geo_centroidY2 += v * cy;
                    d3_geo_centroidZ2 += v * cz;
                    d3_geo_centroidW1 += w;
                    d3_geo_centroidX1 += w * (x0 + (x0 = x));
                    d3_geo_centroidY1 += w * (y0 + (y0 = y));
                    d3_geo_centroidZ1 += w * (z0 + (z0 = z));
                    d3_geo_centroidPointXYZ(x0, y0, z0);
                }
            }
            function d3_geo_compose(a, b) {
                function compose(x, y) {
                    return x = a(x, y), b(x[0], x[1]);
                }
                if (a.invert && b.invert) compose.invert = function(x, y) {
                    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
                };
                return compose;
            }
            function d3_true() {
                return true;
            }
            function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
                var subject = [], clip = [];
                segments.forEach(function(segment) {
                    if ((n = segment.length - 1) <= 0) return;
                    var n, p0 = segment[0], p1 = segment[n];
                    if (d3_geo_sphericalEqual(p0, p1)) {
                        listener.lineStart();
                        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                        listener.lineEnd();
                        return;
                    }
                    var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
                    a.o = b;
                    subject.push(a);
                    clip.push(b);
                    a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
                    b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
                    a.o = b;
                    subject.push(a);
                    clip.push(b);
                });
                clip.sort(compare);
                d3_geo_clipPolygonLinkCircular(subject);
                d3_geo_clipPolygonLinkCircular(clip);
                if (!subject.length) return;
                for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
                    clip[i].e = entry = !entry;
                }
                var start = subject[0], points, point;
                while (1) {
                    var current = start, isSubject = true;
                    while (current.v) if ((current = current.n) === start) return;
                    points = current.z;
                    listener.lineStart();
                    do {
                        current.v = current.o.v = true;
                        if (current.e) {
                            if (isSubject) {
                                for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
                            } else {
                                interpolate(current.x, current.n.x, 1, listener);
                            }
                            current = current.n;
                        } else {
                            if (isSubject) {
                                points = current.p.z;
                                for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
                            } else {
                                interpolate(current.x, current.p.x, -1, listener);
                            }
                            current = current.p;
                        }
                        current = current.o;
                        points = current.z;
                        isSubject = !isSubject;
                    } while (!current.v);
                    listener.lineEnd();
                }
            }
            function d3_geo_clipPolygonLinkCircular(array) {
                if (!(n = array.length)) return;
                var n, i = 0, a = array[0], b;
                while (++i < n) {
                    a.n = b = array[i];
                    b.p = a;
                    a = b;
                }
                a.n = b = array[0];
                b.p = a;
            }
            function d3_geo_clipPolygonIntersection(point, points, other, entry) {
                this.x = point;
                this.z = points;
                this.o = other;
                this.e = entry;
                this.v = false;
                this.n = this.p = null;
            }
            function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
                return function(rotate, listener) {
                    var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
                    var clip = {
                        point: point,
                        lineStart: lineStart,
                        lineEnd: lineEnd,
                        polygonStart: function() {
                            clip.point = pointRing;
                            clip.lineStart = ringStart;
                            clip.lineEnd = ringEnd;
                            segments = [];
                            polygon = [];
                        },
                        polygonEnd: function() {
                            clip.point = point;
                            clip.lineStart = lineStart;
                            clip.lineEnd = lineEnd;
                            segments = d3.merge(segments);
                            var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                            if (segments.length) {
                                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                            } else if (clipStartInside) {
                                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                                listener.lineStart();
                                interpolate(null, null, 1, listener);
                                listener.lineEnd();
                            }
                            if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                            segments = polygon = null;
                        },
                        sphere: function() {
                            listener.polygonStart();
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                            listener.polygonEnd();
                        }
                    };
                    function point(λ, φ) {
                        var point = rotate(λ, φ);
                        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
                    }
                    function pointLine(λ, φ) {
                        var point = rotate(λ, φ);
                        line.point(point[0], point[1]);
                    }
                    function lineStart() {
                        clip.point = pointLine;
                        line.lineStart();
                    }
                    function lineEnd() {
                        clip.point = point;
                        line.lineEnd();
                    }
                    var segments;
                    var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
                    function pointRing(λ, φ) {
                        ring.push([ λ, φ ]);
                        var point = rotate(λ, φ);
                        ringListener.point(point[0], point[1]);
                    }
                    function ringStart() {
                        ringListener.lineStart();
                        ring = [];
                    }
                    function ringEnd() {
                        pointRing(ring[0][0], ring[0][1]);
                        ringListener.lineEnd();
                        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                        ring.pop();
                        polygon.push(ring);
                        ring = null;
                        if (!n) return;
                        if (clean & 1) {
                            segment = ringSegments[0];
                            var n = segment.length - 1, i = -1, point;
                            if (n > 0) {
                                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                                listener.lineStart();
                                while (++i < n) listener.point((point = segment[i])[0], point[1]);
                                listener.lineEnd();
                            }
                            return;
                        }
                        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
                    }
                    return clip;
                };
            }
            function d3_geo_clipSegmentLength1(segment) {
                return segment.length > 1;
            }
            function d3_geo_clipBufferListener() {
                var lines = [], line;
                return {
                    lineStart: function() {
                        lines.push(line = []);
                    },
                    point: function(λ, φ) {
                        line.push([ λ, φ ]);
                    },
                    lineEnd: d3_noop,
                    buffer: function() {
                        var buffer = lines;
                        lines = [];
                        line = null;
                        return buffer;
                    },
                    rejoin: function() {
                        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
                    }
                };
            }
            function d3_geo_clipSort(a, b) {
                return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
            }
            var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
            function d3_geo_clipAntimeridianLine(listener) {
                var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
                return {
                    lineStart: function() {
                        listener.lineStart();
                        clean = 1;
                    },
                    point: function(λ1, φ1) {
                        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                        if (abs(dλ - π) < ε) {
                            listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                            listener.point(sλ0, φ0);
                            listener.lineEnd();
                            listener.lineStart();
                            listener.point(sλ1, φ0);
                            listener.point(λ1, φ0);
                            clean = 0;
                        } else if (sλ0 !== sλ1 && dλ >= π) {
                            if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                            if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                            φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                            listener.point(sλ0, φ0);
                            listener.lineEnd();
                            listener.lineStart();
                            listener.point(sλ1, φ0);
                            clean = 0;
                        }
                        listener.point(λ0 = λ1, φ0 = φ1);
                        sλ0 = sλ1;
                    },
                    lineEnd: function() {
                        listener.lineEnd();
                        λ0 = φ0 = NaN;
                    },
                    clean: function() {
                        return 2 - clean;
                    }
                };
            }
            function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
                var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
                return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
            }
            function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
                var φ;
                if (from == null) {
                    φ = direction * halfπ;
                    listener.point(-π, φ);
                    listener.point(0, φ);
                    listener.point(π, φ);
                    listener.point(π, 0);
                    listener.point(π, -φ);
                    listener.point(0, -φ);
                    listener.point(-π, -φ);
                    listener.point(-π, 0);
                    listener.point(-π, φ);
                } else if (abs(from[0] - to[0]) > ε) {
                    var s = from[0] < to[0] ? π : -π;
                    φ = direction * s / 2;
                    listener.point(-s, φ);
                    listener.point(0, φ);
                    listener.point(s, φ);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function d3_geo_pointInPolygon(point, polygon) {
                var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
                d3_geo_areaRingSum.reset();
                for (var i = 0, n = polygon.length; i < n; ++i) {
                    var ring = polygon[i], m = ring.length;
                    if (!m) continue;
                    var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
                    while (true) {
                        if (j === m) j = 0;
                        point = ring[j];
                        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                            var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                            d3_geo_cartesianNormalize(arc);
                            var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                            d3_geo_cartesianNormalize(intersection);
                            var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                            if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                            }
                        }
                        if (!j++) break;
                        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
                    }
                }
                return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
            }
            function d3_geo_clipCircle(radius) {
                var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
                return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
                function visible(λ, φ) {
                    return Math.cos(λ) * Math.cos(φ) > cr;
                }
                function clipLine(listener) {
                    var point0, c0, v0, v00, clean;
                    return {
                        lineStart: function() {
                            v00 = v0 = false;
                            clean = 1;
                        },
                        point: function(λ, φ) {
                            var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                            if (!point0 && (v00 = v0 = v)) listener.lineStart();
                            if (v !== v0) {
                                point2 = intersect(point0, point1);
                                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                                    point1[0] += ε;
                                    point1[1] += ε;
                                    v = visible(point1[0], point1[1]);
                                }
                            }
                            if (v !== v0) {
                                clean = 0;
                                if (v) {
                                    listener.lineStart();
                                    point2 = intersect(point1, point0);
                                    listener.point(point2[0], point2[1]);
                                } else {
                                    point2 = intersect(point0, point1);
                                    listener.point(point2[0], point2[1]);
                                    listener.lineEnd();
                                }
                                point0 = point2;
                            } else if (notHemisphere && point0 && smallRadius ^ v) {
                                var t;
                                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                                    clean = 0;
                                    if (smallRadius) {
                                        listener.lineStart();
                                        listener.point(t[0][0], t[0][1]);
                                        listener.point(t[1][0], t[1][1]);
                                        listener.lineEnd();
                                    } else {
                                        listener.point(t[1][0], t[1][1]);
                                        listener.lineEnd();
                                        listener.lineStart();
                                        listener.point(t[0][0], t[0][1]);
                                    }
                                }
                            }
                            if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                                listener.point(point1[0], point1[1]);
                            }
                            point0 = point1, v0 = v, c0 = c;
                        },
                        lineEnd: function() {
                            if (v0) listener.lineEnd();
                            point0 = null;
                        },
                        clean: function() {
                            return clean | (v00 && v0) << 1;
                        }
                    };
                }
                function intersect(a, b, two) {
                    var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
                    var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                    if (!determinant) return !two && a;
                    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
                    d3_geo_cartesianAdd(A, B);
                    var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
                    if (t2 < 0) return;
                    var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
                    d3_geo_cartesianAdd(q, A);
                    q = d3_geo_spherical(q);
                    if (!two) return q;
                    var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
                    if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
                    var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
                    if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
                    if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                        d3_geo_cartesianAdd(q1, A);
                        return [ q, d3_geo_spherical(q1) ];
                    }
                }
                function code(λ, φ) {
                    var r = smallRadius ? radius : π - radius, code = 0;
                    if (λ < -r) code |= 1; else if (λ > r) code |= 2;
                    if (φ < -r) code |= 4; else if (φ > r) code |= 8;
                    return code;
                }
            }
            function d3_geom_clipLine(x0, y0, x1, y1) {
                return function(line) {
                    var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
                    r = x0 - ax;
                    if (!dx && r > 0) return;
                    r /= dx;
                    if (dx < 0) {
                        if (r < t0) return;
                        if (r < t1) t1 = r;
                    } else if (dx > 0) {
                        if (r > t1) return;
                        if (r > t0) t0 = r;
                    }
                    r = x1 - ax;
                    if (!dx && r < 0) return;
                    r /= dx;
                    if (dx < 0) {
                        if (r > t1) return;
                        if (r > t0) t0 = r;
                    } else if (dx > 0) {
                        if (r < t0) return;
                        if (r < t1) t1 = r;
                    }
                    r = y0 - ay;
                    if (!dy && r > 0) return;
                    r /= dy;
                    if (dy < 0) {
                        if (r < t0) return;
                        if (r < t1) t1 = r;
                    } else if (dy > 0) {
                        if (r > t1) return;
                        if (r > t0) t0 = r;
                    }
                    r = y1 - ay;
                    if (!dy && r < 0) return;
                    r /= dy;
                    if (dy < 0) {
                        if (r > t1) return;
                        if (r > t0) t0 = r;
                    } else if (dy > 0) {
                        if (r < t0) return;
                        if (r < t1) t1 = r;
                    }
                    if (t0 > 0) line.a = {
                        x: ax + t0 * dx,
                        y: ay + t0 * dy
                    };
                    if (t1 < 1) line.b = {
                        x: ax + t1 * dx,
                        y: ay + t1 * dy
                    };
                    return line;
                };
            }
            var d3_geo_clipExtentMAX = 1e9;
            d3.geo.clipExtent = function() {
                var x0, y0, x1, y1, stream, clip, clipExtent = {
                    stream: function(output) {
                        if (stream) stream.valid = false;
                        stream = clip(output);
                        stream.valid = true;
                        return stream;
                    },
                    extent: function(_) {
                        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                        if (stream) stream.valid = false, stream = null;
                        return clipExtent;
                    }
                };
                return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
            };
            function d3_geo_clipExtent(x0, y0, x1, y1) {
                return function(listener) {
                    var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
                    var clip = {
                        point: point,
                        lineStart: lineStart,
                        lineEnd: lineEnd,
                        polygonStart: function() {
                            listener = bufferListener;
                            segments = [];
                            polygon = [];
                            clean = true;
                        },
                        polygonEnd: function() {
                            listener = listener_;
                            segments = d3.merge(segments);
                            var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
                            if (inside || visible) {
                                listener.polygonStart();
                                if (inside) {
                                    listener.lineStart();
                                    interpolate(null, null, 1, listener);
                                    listener.lineEnd();
                                }
                                if (visible) {
                                    d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                                }
                                listener.polygonEnd();
                            }
                            segments = polygon = ring = null;
                        }
                    };
                    function insidePolygon(p) {
                        var wn = 0, n = polygon.length, y = p[1];
                        for (var i = 0; i < n; ++i) {
                            for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                                b = v[j];
                                if (a[1] <= y) {
                                    if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                                } else {
                                    if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                                }
                                a = b;
                            }
                        }
                        return wn !== 0;
                    }
                    function interpolate(from, to, direction, listener) {
                        var a = 0, a1 = 0;
                        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                            do {
                                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                            } while ((a = (a + direction + 4) % 4) !== a1);
                        } else {
                            listener.point(to[0], to[1]);
                        }
                    }
                    function pointVisible(x, y) {
                        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
                    }
                    function point(x, y) {
                        if (pointVisible(x, y)) listener.point(x, y);
                    }
                    var x__, y__, v__, x_, y_, v_, first, clean;
                    function lineStart() {
                        clip.point = linePoint;
                        if (polygon) polygon.push(ring = []);
                        first = true;
                        v_ = false;
                        x_ = y_ = NaN;
                    }
                    function lineEnd() {
                        if (segments) {
                            linePoint(x__, y__);
                            if (v__ && v_) bufferListener.rejoin();
                            segments.push(bufferListener.buffer());
                        }
                        clip.point = point;
                        if (v_) listener.lineEnd();
                    }
                    function linePoint(x, y) {
                        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                        var v = pointVisible(x, y);
                        if (polygon) ring.push([ x, y ]);
                        if (first) {
                            x__ = x, y__ = y, v__ = v;
                            first = false;
                            if (v) {
                                listener.lineStart();
                                listener.point(x, y);
                            }
                        } else {
                            if (v && v_) listener.point(x, y); else {
                                var l = {
                                    a: {
                                        x: x_,
                                        y: y_
                                    },
                                    b: {
                                        x: x,
                                        y: y
                                    }
                                };
                                if (clipLine(l)) {
                                    if (!v_) {
                                        listener.lineStart();
                                        listener.point(l.a.x, l.a.y);
                                    }
                                    listener.point(l.b.x, l.b.y);
                                    if (!v) listener.lineEnd();
                                    clean = false;
                                } else if (v) {
                                    listener.lineStart();
                                    listener.point(x, y);
                                    clean = false;
                                }
                            }
                        }
                        x_ = x, y_ = y, v_ = v;
                    }
                    return clip;
                };
                function corner(p, direction) {
                    return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
                }
                function compare(a, b) {
                    return comparePoints(a.x, b.x);
                }
                function comparePoints(a, b) {
                    var ca = corner(a, 1), cb = corner(b, 1);
                    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
                }
            }
            function d3_geo_conic(projectAt) {
                var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
                p.parallels = function(_) {
                    if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
                    return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
                };
                return p;
            }
            function d3_geo_conicEqualArea(φ0, φ1) {
                var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
                function forward(λ, φ) {
                    var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
                    return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
                }
                forward.invert = function(x, y) {
                    var ρ0_y = ρ0 - y;
                    return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
                };
                return forward;
            }
            (d3.geo.conicEqualArea = function() {
                return d3_geo_conic(d3_geo_conicEqualArea);
            }).raw = d3_geo_conicEqualArea;
            d3.geo.albers = function() {
                return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
            };
            d3.geo.albersUsa = function() {
                var lower48 = d3.geo.albers();
                var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
                var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
                var point, pointStream = {
                    point: function(x, y) {
                        point = [ x, y ];
                    }
                }, lower48Point, alaskaPoint, hawaiiPoint;
                function albersUsa(coordinates) {
                    var x = coordinates[0], y = coordinates[1];
                    point = null;
                    (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
                    return point;
                }
                albersUsa.invert = function(coordinates) {
                    var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                    return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
                };
                albersUsa.stream = function(stream) {
                    var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
                    return {
                        point: function(x, y) {
                            lower48Stream.point(x, y);
                            alaskaStream.point(x, y);
                            hawaiiStream.point(x, y);
                        },
                        sphere: function() {
                            lower48Stream.sphere();
                            alaskaStream.sphere();
                            hawaiiStream.sphere();
                        },
                        lineStart: function() {
                            lower48Stream.lineStart();
                            alaskaStream.lineStart();
                            hawaiiStream.lineStart();
                        },
                        lineEnd: function() {
                            lower48Stream.lineEnd();
                            alaskaStream.lineEnd();
                            hawaiiStream.lineEnd();
                        },
                        polygonStart: function() {
                            lower48Stream.polygonStart();
                            alaskaStream.polygonStart();
                            hawaiiStream.polygonStart();
                        },
                        polygonEnd: function() {
                            lower48Stream.polygonEnd();
                            alaskaStream.polygonEnd();
                            hawaiiStream.polygonEnd();
                        }
                    };
                };
                albersUsa.precision = function(_) {
                    if (!arguments.length) return lower48.precision();
                    lower48.precision(_);
                    alaska.precision(_);
                    hawaii.precision(_);
                    return albersUsa;
                };
                albersUsa.scale = function(_) {
                    if (!arguments.length) return lower48.scale();
                    lower48.scale(_);
                    alaska.scale(_ * .35);
                    hawaii.scale(_);
                    return albersUsa.translate(lower48.translate());
                };
                albersUsa.translate = function(_) {
                    if (!arguments.length) return lower48.translate();
                    var k = lower48.scale(), x = +_[0], y = +_[1];
                    lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
                    alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
                    hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
                    return albersUsa;
                };
                return albersUsa.scale(1070);
            };
            var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
                point: d3_noop,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: function() {
                    d3_geo_pathAreaPolygon = 0;
                    d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
                },
                polygonEnd: function() {
                    d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
                    d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
                }
            };
            function d3_geo_pathAreaRingStart() {
                var x00, y00, x0, y0;
                d3_geo_pathArea.point = function(x, y) {
                    d3_geo_pathArea.point = nextPoint;
                    x00 = x0 = x, y00 = y0 = y;
                };
                function nextPoint(x, y) {
                    d3_geo_pathAreaPolygon += y0 * x - x0 * y;
                    x0 = x, y0 = y;
                }
                d3_geo_pathArea.lineEnd = function() {
                    nextPoint(x00, y00);
                };
            }
            var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
            var d3_geo_pathBounds = {
                point: d3_geo_pathBoundsPoint,
                lineStart: d3_noop,
                lineEnd: d3_noop,
                polygonStart: d3_noop,
                polygonEnd: d3_noop
            };
            function d3_geo_pathBoundsPoint(x, y) {
                if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
                if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
                if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
                if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
            }
            function d3_geo_pathBuffer() {
                var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
                var stream = {
                    point: point,
                    lineStart: function() {
                        stream.point = pointLineStart;
                    },
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        stream.lineEnd = lineEndPolygon;
                    },
                    polygonEnd: function() {
                        stream.lineEnd = lineEnd;
                        stream.point = point;
                    },
                    pointRadius: function(_) {
                        pointCircle = d3_geo_pathBufferCircle(_);
                        return stream;
                    },
                    result: function() {
                        if (buffer.length) {
                            var result = buffer.join("");
                            buffer = [];
                            return result;
                        }
                    }
                };
                function point(x, y) {
                    buffer.push("M", x, ",", y, pointCircle);
                }
                function pointLineStart(x, y) {
                    buffer.push("M", x, ",", y);
                    stream.point = pointLine;
                }
                function pointLine(x, y) {
                    buffer.push("L", x, ",", y);
                }
                function lineEnd() {
                    stream.point = point;
                }
                function lineEndPolygon() {
                    buffer.push("Z");
                }
                return stream;
            }
            function d3_geo_pathBufferCircle(radius) {
                return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
            }
            var d3_geo_pathCentroid = {
                point: d3_geo_pathCentroidPoint,
                lineStart: d3_geo_pathCentroidLineStart,
                lineEnd: d3_geo_pathCentroidLineEnd,
                polygonStart: function() {
                    d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
                },
                polygonEnd: function() {
                    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
                    d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
                    d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
                }
            };
            function d3_geo_pathCentroidPoint(x, y) {
                d3_geo_centroidX0 += x;
                d3_geo_centroidY0 += y;
                ++d3_geo_centroidZ0;
            }
            function d3_geo_pathCentroidLineStart() {
                var x0, y0;
                d3_geo_pathCentroid.point = function(x, y) {
                    d3_geo_pathCentroid.point = nextPoint;
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y);
                };
                function nextPoint(x, y) {
                    var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
                    d3_geo_centroidX1 += z * (x0 + x) / 2;
                    d3_geo_centroidY1 += z * (y0 + y) / 2;
                    d3_geo_centroidZ1 += z;
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y);
                }
            }
            function d3_geo_pathCentroidLineEnd() {
                d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            }
            function d3_geo_pathCentroidRingStart() {
                var x00, y00, x0, y0;
                d3_geo_pathCentroid.point = function(x, y) {
                    d3_geo_pathCentroid.point = nextPoint;
                    d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
                };
                function nextPoint(x, y) {
                    var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
                    d3_geo_centroidX1 += z * (x0 + x) / 2;
                    d3_geo_centroidY1 += z * (y0 + y) / 2;
                    d3_geo_centroidZ1 += z;
                    z = y0 * x - x0 * y;
                    d3_geo_centroidX2 += z * (x0 + x);
                    d3_geo_centroidY2 += z * (y0 + y);
                    d3_geo_centroidZ2 += z * 3;
                    d3_geo_pathCentroidPoint(x0 = x, y0 = y);
                }
                d3_geo_pathCentroid.lineEnd = function() {
                    nextPoint(x00, y00);
                };
            }
            function d3_geo_pathContext(context) {
                var pointRadius = 4.5;
                var stream = {
                    point: point,
                    lineStart: function() {
                        stream.point = pointLineStart;
                    },
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        stream.lineEnd = lineEndPolygon;
                    },
                    polygonEnd: function() {
                        stream.lineEnd = lineEnd;
                        stream.point = point;
                    },
                    pointRadius: function(_) {
                        pointRadius = _;
                        return stream;
                    },
                    result: d3_noop
                };
                function point(x, y) {
                    context.moveTo(x + pointRadius, y);
                    context.arc(x, y, pointRadius, 0, τ);
                }
                function pointLineStart(x, y) {
                    context.moveTo(x, y);
                    stream.point = pointLine;
                }
                function pointLine(x, y) {
                    context.lineTo(x, y);
                }
                function lineEnd() {
                    stream.point = point;
                }
                function lineEndPolygon() {
                    context.closePath();
                }
                return stream;
            }
            function d3_geo_resample(project) {
                var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
                function resample(stream) {
                    return (maxDepth ? resampleRecursive : resampleNone)(stream);
                }
                function resampleNone(stream) {
                    return d3_geo_transformPoint(stream, function(x, y) {
                        x = project(x, y);
                        stream.point(x[0], x[1]);
                    });
                }
                function resampleRecursive(stream) {
                    var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
                    var resample = {
                        point: point,
                        lineStart: lineStart,
                        lineEnd: lineEnd,
                        polygonStart: function() {
                            stream.polygonStart();
                            resample.lineStart = ringStart;
                        },
                        polygonEnd: function() {
                            stream.polygonEnd();
                            resample.lineStart = lineStart;
                        }
                    };
                    function point(x, y) {
                        x = project(x, y);
                        stream.point(x[0], x[1]);
                    }
                    function lineStart() {
                        x0 = NaN;
                        resample.point = linePoint;
                        stream.lineStart();
                    }
                    function linePoint(λ, φ) {
                        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
                        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                        stream.point(x0, y0);
                    }
                    function lineEnd() {
                        resample.point = point;
                        stream.lineEnd();
                    }
                    function ringStart() {
                        lineStart();
                        resample.point = ringPoint;
                        resample.lineEnd = ringEnd;
                    }
                    function ringPoint(λ, φ) {
                        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                        resample.point = linePoint;
                    }
                    function ringEnd() {
                        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                        resample.lineEnd = lineEnd;
                        lineEnd();
                    }
                    return resample;
                }
                function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
                    var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                    if (d2 > 4 * δ2 && depth--) {
                        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                            resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                            stream.point(x2, y2);
                            resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                        }
                    }
                }
                resample.precision = function(_) {
                    if (!arguments.length) return Math.sqrt(δ2);
                    maxDepth = (δ2 = _ * _) > 0 && 16;
                    return resample;
                };
                return resample;
            }
            d3.geo.path = function() {
                var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
                function path(object) {
                    if (object) {
                        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                        d3.geo.stream(object, cacheStream);
                    }
                    return contextStream.result();
                }
                path.area = function(object) {
                    d3_geo_pathAreaSum = 0;
                    d3.geo.stream(object, projectStream(d3_geo_pathArea));
                    return d3_geo_pathAreaSum;
                };
                path.centroid = function(object) {
                    d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
                    d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
                    return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
                };
                path.bounds = function(object) {
                    d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
                    d3.geo.stream(object, projectStream(d3_geo_pathBounds));
                    return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
                };
                path.projection = function(_) {
                    if (!arguments.length) return projection;
                    projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
                    return reset();
                };
                path.context = function(_) {
                    if (!arguments.length) return context;
                    contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
                    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
                    return reset();
                };
                path.pointRadius = function(_) {
                    if (!arguments.length) return pointRadius;
                    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
                    return path;
                };
                function reset() {
                    cacheStream = null;
                    return path;
                }
                return path.projection(d3.geo.albersUsa()).context(null);
            };
            function d3_geo_pathProjectStream(project) {
                var resample = d3_geo_resample(function(x, y) {
                    return project([ x * d3_degrees, y * d3_degrees ]);
                });
                return function(stream) {
                    return d3_geo_projectionRadians(resample(stream));
                };
            }
            d3.geo.transform = function(methods) {
                return {
                    stream: function(stream) {
                        var transform = new d3_geo_transform(stream);
                        for (var k in methods) transform[k] = methods[k];
                        return transform;
                    }
                };
            };
            function d3_geo_transform(stream) {
                this.stream = stream;
            }
            d3_geo_transform.prototype = {
                point: function(x, y) {
                    this.stream.point(x, y);
                },
                sphere: function() {
                    this.stream.sphere();
                },
                lineStart: function() {
                    this.stream.lineStart();
                },
                lineEnd: function() {
                    this.stream.lineEnd();
                },
                polygonStart: function() {
                    this.stream.polygonStart();
                },
                polygonEnd: function() {
                    this.stream.polygonEnd();
                }
            };
            function d3_geo_transformPoint(stream, point) {
                return {
                    point: point,
                    sphere: function() {
                        stream.sphere();
                    },
                    lineStart: function() {
                        stream.lineStart();
                    },
                    lineEnd: function() {
                        stream.lineEnd();
                    },
                    polygonStart: function() {
                        stream.polygonStart();
                    },
                    polygonEnd: function() {
                        stream.polygonEnd();
                    }
                };
            }
            d3.geo.projection = d3_geo_projection;
            d3.geo.projectionMutator = d3_geo_projectionMutator;
            function d3_geo_projection(project) {
                return d3_geo_projectionMutator(function() {
                    return project;
                })();
            }
            function d3_geo_projectionMutator(projectAt) {
                var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
                    x = project(x, y);
                    return [ x[0] * k + δx, δy - x[1] * k ];
                }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
                function projection(point) {
                    point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
                    return [ point[0] * k + δx, δy - point[1] * k ];
                }
                function invert(point) {
                    point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
                    return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
                }
                projection.stream = function(output) {
                    if (stream) stream.valid = false;
                    stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
                    stream.valid = true;
                    return stream;
                };
                projection.clipAngle = function(_) {
                    if (!arguments.length) return clipAngle;
                    preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
                    return invalidate();
                };
                projection.clipExtent = function(_) {
                    if (!arguments.length) return clipExtent;
                    clipExtent = _;
                    postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
                    return invalidate();
                };
                projection.scale = function(_) {
                    if (!arguments.length) return k;
                    k = +_;
                    return reset();
                };
                projection.translate = function(_) {
                    if (!arguments.length) return [ x, y ];
                    x = +_[0];
                    y = +_[1];
                    return reset();
                };
                projection.center = function(_) {
                    if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
                    λ = _[0] % 360 * d3_radians;
                    φ = _[1] % 360 * d3_radians;
                    return reset();
                };
                projection.rotate = function(_) {
                    if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
                    δλ = _[0] % 360 * d3_radians;
                    δφ = _[1] % 360 * d3_radians;
                    δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
                    return reset();
                };
                d3.rebind(projection, projectResample, "precision");
                function reset() {
                    projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
                    var center = project(λ, φ);
                    δx = x - center[0] * k;
                    δy = y + center[1] * k;
                    return invalidate();
                }
                function invalidate() {
                    if (stream) stream.valid = false, stream = null;
                    return projection;
                }
                return function() {
                    project = projectAt.apply(this, arguments);
                    projection.invert = project.invert && invert;
                    return reset();
                };
            }
            function d3_geo_projectionRadians(stream) {
                return d3_geo_transformPoint(stream, function(x, y) {
                    stream.point(x * d3_radians, y * d3_radians);
                });
            }
            function d3_geo_equirectangular(λ, φ) {
                return [ λ, φ ];
            }
            (d3.geo.equirectangular = function() {
                return d3_geo_projection(d3_geo_equirectangular);
            }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
            d3.geo.rotation = function(rotate) {
                rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
                function forward(coordinates) {
                    coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
                    return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
                }
                forward.invert = function(coordinates) {
                    coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
                    return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
                };
                return forward;
            };
            function d3_geo_identityRotation(λ, φ) {
                return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
            }
            d3_geo_identityRotation.invert = d3_geo_equirectangular;
            function d3_geo_rotation(δλ, δφ, δγ) {
                return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
            }
            function d3_geo_forwardRotationλ(δλ) {
                return function(λ, φ) {
                    return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
                };
            }
            function d3_geo_rotationλ(δλ) {
                var rotation = d3_geo_forwardRotationλ(δλ);
                rotation.invert = d3_geo_forwardRotationλ(-δλ);
                return rotation;
            }
            function d3_geo_rotationφγ(δφ, δγ) {
                var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
                function rotation(λ, φ) {
                    var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
                    return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
                }
                rotation.invert = function(λ, φ) {
                    var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
                    return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
                };
                return rotation;
            }
            d3.geo.circle = function() {
                var origin = [ 0, 0 ], angle, precision = 6, interpolate;
                function circle() {
                    var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
                    interpolate(null, null, 1, {
                        point: function(x, y) {
                            ring.push(x = rotate(x, y));
                            x[0] *= d3_degrees, x[1] *= d3_degrees;
                        }
                    });
                    return {
                        type: "Polygon",
                        coordinates: [ ring ]
                    };
                }
                circle.origin = function(x) {
                    if (!arguments.length) return origin;
                    origin = x;
                    return circle;
                };
                circle.angle = function(x) {
                    if (!arguments.length) return angle;
                    interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
                    return circle;
                };
                circle.precision = function(_) {
                    if (!arguments.length) return precision;
                    interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
                    return circle;
                };
                return circle.angle(90);
            };
            function d3_geo_circleInterpolate(radius, precision) {
                var cr = Math.cos(radius), sr = Math.sin(radius);
                return function(from, to, direction, listener) {
                    var step = direction * precision;
                    if (from != null) {
                        from = d3_geo_circleAngle(cr, from);
                        to = d3_geo_circleAngle(cr, to);
                        if (direction > 0 ? from < to : from > to) from += direction * τ;
                    } else {
                        from = radius + direction * τ;
                        to = radius - .5 * step;
                    }
                    for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
                    }
                };
            }
            function d3_geo_circleAngle(cr, point) {
                var a = d3_geo_cartesian(point);
                a[0] -= cr;
                d3_geo_cartesianNormalize(a);
                var angle = d3_acos(-a[1]);
                return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
            }
            d3.geo.distance = function(a, b) {
                var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
                return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
            };
            d3.geo.graticule = function() {
                var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
                function graticule() {
                    return {
                        type: "MultiLineString",
                        coordinates: lines()
                    };
                }
                function lines() {
                    return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                        return abs(x % DX) > ε;
                    }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                        return abs(y % DY) > ε;
                    }).map(y));
                }
                graticule.lines = function() {
                    return lines().map(function(coordinates) {
                        return {
                            type: "LineString",
                            coordinates: coordinates
                        };
                    });
                };
                graticule.outline = function() {
                    return {
                        type: "Polygon",
                        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
                    };
                };
                graticule.extent = function(_) {
                    if (!arguments.length) return graticule.minorExtent();
                    return graticule.majorExtent(_).minorExtent(_);
                };
                graticule.majorExtent = function(_) {
                    if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
                    X0 = +_[0][0], X1 = +_[1][0];
                    Y0 = +_[0][1], Y1 = +_[1][1];
                    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
                    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
                    return graticule.precision(precision);
                };
                graticule.minorExtent = function(_) {
                    if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                    x0 = +_[0][0], x1 = +_[1][0];
                    y0 = +_[0][1], y1 = +_[1][1];
                    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
                    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
                    return graticule.precision(precision);
                };
                graticule.step = function(_) {
                    if (!arguments.length) return graticule.minorStep();
                    return graticule.majorStep(_).minorStep(_);
                };
                graticule.majorStep = function(_) {
                    if (!arguments.length) return [ DX, DY ];
                    DX = +_[0], DY = +_[1];
                    return graticule;
                };
                graticule.minorStep = function(_) {
                    if (!arguments.length) return [ dx, dy ];
                    dx = +_[0], dy = +_[1];
                    return graticule;
                };
                graticule.precision = function(_) {
                    if (!arguments.length) return precision;
                    precision = +_;
                    x = d3_geo_graticuleX(y0, y1, 90);
                    y = d3_geo_graticuleY(x0, x1, precision);
                    X = d3_geo_graticuleX(Y0, Y1, 90);
                    Y = d3_geo_graticuleY(X0, X1, precision);
                    return graticule;
                };
                return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
            };
            function d3_geo_graticuleX(y0, y1, dy) {
                var y = d3.range(y0, y1 - ε, dy).concat(y1);
                return function(x) {
                    return y.map(function(y) {
                        return [ x, y ];
                    });
                };
            }
            function d3_geo_graticuleY(x0, x1, dx) {
                var x = d3.range(x0, x1 - ε, dx).concat(x1);
                return function(y) {
                    return x.map(function(x) {
                        return [ x, y ];
                    });
                };
            }
            function d3_source(d) {
                return d.source;
            }
            function d3_target(d) {
                return d.target;
            }
            d3.geo.greatArc = function() {
                var source = d3_source, source_, target = d3_target, target_;
                function greatArc() {
                    return {
                        type: "LineString",
                        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
                    };
                }
                greatArc.distance = function() {
                    return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
                };
                greatArc.source = function(_) {
                    if (!arguments.length) return source;
                    source = _, source_ = typeof _ === "function" ? null : _;
                    return greatArc;
                };
                greatArc.target = function(_) {
                    if (!arguments.length) return target;
                    target = _, target_ = typeof _ === "function" ? null : _;
                    return greatArc;
                };
                greatArc.precision = function() {
                    return arguments.length ? greatArc : 0;
                };
                return greatArc;
            };
            d3.geo.interpolate = function(source, target) {
                return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
            };
            function d3_geo_interpolate(x0, y0, x1, y1) {
                var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
                var interpolate = d ? function(t) {
                    var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
                    return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
                } : function() {
                    return [ x0 * d3_degrees, y0 * d3_degrees ];
                };
                interpolate.distance = d;
                return interpolate;
            }
            d3.geo.length = function(object) {
                d3_geo_lengthSum = 0;
                d3.geo.stream(object, d3_geo_length);
                return d3_geo_lengthSum;
            };
            var d3_geo_lengthSum;
            var d3_geo_length = {
                sphere: d3_noop,
                point: d3_noop,
                lineStart: d3_geo_lengthLineStart,
                lineEnd: d3_noop,
                polygonStart: d3_noop,
                polygonEnd: d3_noop
            };
            function d3_geo_lengthLineStart() {
                var λ0, sinφ0, cosφ0;
                d3_geo_length.point = function(λ, φ) {
                    λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
                    d3_geo_length.point = nextPoint;
                };
                d3_geo_length.lineEnd = function() {
                    d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
                };
                function nextPoint(λ, φ) {
                    var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
                    d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
                    λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
                }
            }
            function d3_geo_azimuthal(scale, angle) {
                function azimuthal(λ, φ) {
                    var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
                    return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
                }
                azimuthal.invert = function(x, y) {
                    var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
                    return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
                };
                return azimuthal;
            }
            var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
                return Math.sqrt(2 / (1 + cosλcosφ));
            }, function(ρ) {
                return 2 * Math.asin(ρ / 2);
            });
            (d3.geo.azimuthalEqualArea = function() {
                return d3_geo_projection(d3_geo_azimuthalEqualArea);
            }).raw = d3_geo_azimuthalEqualArea;
            var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
                var c = Math.acos(cosλcosφ);
                return c && c / Math.sin(c);
            }, d3_identity);
            (d3.geo.azimuthalEquidistant = function() {
                return d3_geo_projection(d3_geo_azimuthalEquidistant);
            }).raw = d3_geo_azimuthalEquidistant;
            function d3_geo_conicConformal(φ0, φ1) {
                var cosφ0 = Math.cos(φ0), t = function(φ) {
                    return Math.tan(π / 4 + φ / 2);
                }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
                if (!n) return d3_geo_mercator;
                function forward(λ, φ) {
                    if (F > 0) {
                        if (φ < -halfπ + ε) φ = -halfπ + ε;
                    } else {
                        if (φ > halfπ - ε) φ = halfπ - ε;
                    }
                    var ρ = F / Math.pow(t(φ), n);
                    return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
                }
                forward.invert = function(x, y) {
                    var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
                    return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
                };
                return forward;
            }
            (d3.geo.conicConformal = function() {
                return d3_geo_conic(d3_geo_conicConformal);
            }).raw = d3_geo_conicConformal;
            function d3_geo_conicEquidistant(φ0, φ1) {
                var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
                if (abs(n) < ε) return d3_geo_equirectangular;
                function forward(λ, φ) {
                    var ρ = G - φ;
                    return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
                }
                forward.invert = function(x, y) {
                    var ρ0_y = G - y;
                    return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
                };
                return forward;
            }
            (d3.geo.conicEquidistant = function() {
                return d3_geo_conic(d3_geo_conicEquidistant);
            }).raw = d3_geo_conicEquidistant;
            var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
                return 1 / cosλcosφ;
            }, Math.atan);
            (d3.geo.gnomonic = function() {
                return d3_geo_projection(d3_geo_gnomonic);
            }).raw = d3_geo_gnomonic;
            function d3_geo_mercator(λ, φ) {
                return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
            }
            d3_geo_mercator.invert = function(x, y) {
                return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
            };
            function d3_geo_mercatorProjection(project) {
                var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
                m.scale = function() {
                    var v = scale.apply(m, arguments);
                    return v === m ? clipAuto ? m.clipExtent(null) : m : v;
                };
                m.translate = function() {
                    var v = translate.apply(m, arguments);
                    return v === m ? clipAuto ? m.clipExtent(null) : m : v;
                };
                m.clipExtent = function(_) {
                    var v = clipExtent.apply(m, arguments);
                    if (v === m) {
                        if (clipAuto = _ == null) {
                            var k = π * scale(), t = translate();
                            clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                        }
                    } else if (clipAuto) {
                        v = null;
                    }
                    return v;
                };
                return m.clipExtent(null);
            }
            (d3.geo.mercator = function() {
                return d3_geo_mercatorProjection(d3_geo_mercator);
            }).raw = d3_geo_mercator;
            var d3_geo_orthographic = d3_geo_azimuthal(function() {
                return 1;
            }, Math.asin);
            (d3.geo.orthographic = function() {
                return d3_geo_projection(d3_geo_orthographic);
            }).raw = d3_geo_orthographic;
            var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
                return 1 / (1 + cosλcosφ);
            }, function(ρ) {
                return 2 * Math.atan(ρ);
            });
            (d3.geo.stereographic = function() {
                return d3_geo_projection(d3_geo_stereographic);
            }).raw = d3_geo_stereographic;
            function d3_geo_transverseMercator(λ, φ) {
                return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
            }
            d3_geo_transverseMercator.invert = function(x, y) {
                return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
            };
            (d3.geo.transverseMercator = function() {
                var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
                projection.center = function(_) {
                    return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
                };
                projection.rotate = function(_) {
                    return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
                    [ _[0], _[1], _[2] - 90 ]);
                };
                return rotate([ 0, 0, 90 ]);
            }).raw = d3_geo_transverseMercator;
            d3.geom = {};
            function d3_geom_pointX(d) {
                return d[0];
            }
            function d3_geom_pointY(d) {
                return d[1];
            }
            d3.geom.hull = function(vertices) {
                var x = d3_geom_pointX, y = d3_geom_pointY;
                if (arguments.length) return hull(vertices);
                function hull(data) {
                    if (data.length < 3) return [];
                    var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
                    for (i = 0; i < n; i++) {
                        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
                    }
                    points.sort(d3_geom_hullOrder);
                    for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
                    var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
                    var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
                    for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
                    for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
                    return polygon;
                }
                hull.x = function(_) {
                    return arguments.length ? (x = _, hull) : x;
                };
                hull.y = function(_) {
                    return arguments.length ? (y = _, hull) : y;
                };
                return hull;
            };
            function d3_geom_hullUpper(points) {
                var n = points.length, hull = [ 0, 1 ], hs = 2;
                for (var i = 2; i < n; i++) {
                    while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
                    hull[hs++] = i;
                }
                return hull.slice(0, hs);
            }
            function d3_geom_hullOrder(a, b) {
                return a[0] - b[0] || a[1] - b[1];
            }
            d3.geom.polygon = function(coordinates) {
                d3_subclass(coordinates, d3_geom_polygonPrototype);
                return coordinates;
            };
            var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
            d3_geom_polygonPrototype.area = function() {
                var i = -1, n = this.length, a, b = this[n - 1], area = 0;
                while (++i < n) {
                    a = b;
                    b = this[i];
                    area += a[1] * b[0] - a[0] * b[1];
                }
                return area * .5;
            };
            d3_geom_polygonPrototype.centroid = function(k) {
                var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
                if (!arguments.length) k = -1 / (6 * this.area());
                while (++i < n) {
                    a = b;
                    b = this[i];
                    c = a[0] * b[1] - b[0] * a[1];
                    x += (a[0] + b[0]) * c;
                    y += (a[1] + b[1]) * c;
                }
                return [ x * k, y * k ];
            };
            d3_geom_polygonPrototype.clip = function(subject) {
                var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
                while (++i < n) {
                    input = subject.slice();
                    subject.length = 0;
                    b = this[i];
                    c = input[(m = input.length - closed) - 1];
                    j = -1;
                    while (++j < m) {
                        d = input[j];
                        if (d3_geom_polygonInside(d, a, b)) {
                            if (!d3_geom_polygonInside(c, a, b)) {
                                subject.push(d3_geom_polygonIntersect(c, d, a, b));
                            }
                            subject.push(d);
                        } else if (d3_geom_polygonInside(c, a, b)) {
                            subject.push(d3_geom_polygonIntersect(c, d, a, b));
                        }
                        c = d;
                    }
                    if (closed) subject.push(subject[0]);
                    a = b;
                }
                return subject;
            };
            function d3_geom_polygonInside(p, a, b) {
                return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
            }
            function d3_geom_polygonIntersect(c, d, a, b) {
                var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
                return [ x1 + ua * x21, y1 + ua * y21 ];
            }
            function d3_geom_polygonClosed(coordinates) {
                var a = coordinates[0], b = coordinates[coordinates.length - 1];
                return !(a[0] - b[0] || a[1] - b[1]);
            }
            var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
            function d3_geom_voronoiBeach() {
                d3_geom_voronoiRedBlackNode(this);
                this.edge = this.site = this.circle = null;
            }
            function d3_geom_voronoiCreateBeach(site) {
                var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
                beach.site = site;
                return beach;
            }
            function d3_geom_voronoiDetachBeach(beach) {
                d3_geom_voronoiDetachCircle(beach);
                d3_geom_voronoiBeaches.remove(beach);
                d3_geom_voronoiBeachPool.push(beach);
                d3_geom_voronoiRedBlackNode(beach);
            }
            function d3_geom_voronoiRemoveBeach(beach) {
                var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
                    x: x,
                    y: y
                }, previous = beach.P, next = beach.N, disappearing = [ beach ];
                d3_geom_voronoiDetachBeach(beach);
                var lArc = previous;
                while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
                    previous = lArc.P;
                    disappearing.unshift(lArc);
                    d3_geom_voronoiDetachBeach(lArc);
                    lArc = previous;
                }
                disappearing.unshift(lArc);
                d3_geom_voronoiDetachCircle(lArc);
                var rArc = next;
                while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
                    next = rArc.N;
                    disappearing.push(rArc);
                    d3_geom_voronoiDetachBeach(rArc);
                    rArc = next;
                }
                disappearing.push(rArc);
                d3_geom_voronoiDetachCircle(rArc);
                var nArcs = disappearing.length, iArc;
                for (iArc = 1; iArc < nArcs; ++iArc) {
                    rArc = disappearing[iArc];
                    lArc = disappearing[iArc - 1];
                    d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
                }
                lArc = disappearing[0];
                rArc = disappearing[nArcs - 1];
                rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
                d3_geom_voronoiAttachCircle(lArc);
                d3_geom_voronoiAttachCircle(rArc);
            }
            function d3_geom_voronoiAddBeach(site) {
                var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
                while (node) {
                    dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
                    if (dxl > ε) node = node.L; else {
                        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                        if (dxr > ε) {
                            if (!node.R) {
                                lArc = node;
                                break;
                            }
                            node = node.R;
                        } else {
                            if (dxl > -ε) {
                                lArc = node.P;
                                rArc = node;
                            } else if (dxr > -ε) {
                                lArc = node;
                                rArc = node.N;
                            } else {
                                lArc = rArc = node;
                            }
                            break;
                        }
                    }
                }
                var newArc = d3_geom_voronoiCreateBeach(site);
                d3_geom_voronoiBeaches.insert(lArc, newArc);
                if (!lArc && !rArc) return;
                if (lArc === rArc) {
                    d3_geom_voronoiDetachCircle(lArc);
                    rArc = d3_geom_voronoiCreateBeach(lArc.site);
                    d3_geom_voronoiBeaches.insert(newArc, rArc);
                    newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
                    d3_geom_voronoiAttachCircle(lArc);
                    d3_geom_voronoiAttachCircle(rArc);
                    return;
                }
                if (!rArc) {
                    newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
                    return;
                }
                d3_geom_voronoiDetachCircle(lArc);
                d3_geom_voronoiDetachCircle(rArc);
                var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
                    x: (cy * hb - by * hc) / d + ax,
                    y: (bx * hc - cx * hb) / d + ay
                };
                d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
                newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
                rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
                d3_geom_voronoiAttachCircle(lArc);
                d3_geom_voronoiAttachCircle(rArc);
            }
            function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
                var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
                if (!pby2) return rfocx;
                var lArc = arc.P;
                if (!lArc) return -Infinity;
                site = lArc.site;
                var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
                if (!plby2) return lfocx;
                var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
                if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
                return (rfocx + lfocx) / 2;
            }
            function d3_geom_voronoiRightBreakPoint(arc, directrix) {
                var rArc = arc.N;
                if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
                var site = arc.site;
                return site.y === directrix ? site.x : Infinity;
            }
            function d3_geom_voronoiCell(site) {
                this.site = site;
                this.edges = [];
            }
            d3_geom_voronoiCell.prototype.prepare = function() {
                var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
                while (iHalfEdge--) {
                    edge = halfEdges[iHalfEdge].edge;
                    if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
                }
                halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
                return halfEdges.length;
            };
            function d3_geom_voronoiCloseCells(extent) {
                var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
                while (iCell--) {
                    cell = cells[iCell];
                    if (!cell || !cell.prepare()) continue;
                    halfEdges = cell.edges;
                    nHalfEdges = halfEdges.length;
                    iHalfEdge = 0;
                    while (iHalfEdge < nHalfEdges) {
                        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                            halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                                x: x0,
                                y: abs(x2 - x0) < ε ? y2 : y1
                            } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                                x: abs(y2 - y1) < ε ? x2 : x1,
                                y: y1
                            } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                                x: x1,
                                y: abs(x2 - x1) < ε ? y2 : y0
                            } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                                x: abs(y2 - y0) < ε ? x2 : x0,
                                y: y0
                            } : null), cell.site, null));
                            ++nHalfEdges;
                        }
                    }
                }
            }
            function d3_geom_voronoiHalfEdgeOrder(a, b) {
                return b.angle - a.angle;
            }
            function d3_geom_voronoiCircle() {
                d3_geom_voronoiRedBlackNode(this);
                this.x = this.y = this.arc = this.site = this.cy = null;
            }
            function d3_geom_voronoiAttachCircle(arc) {
                var lArc = arc.P, rArc = arc.N;
                if (!lArc || !rArc) return;
                var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
                if (lSite === rSite) return;
                var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
                var d = 2 * (ax * cy - ay * cx);
                if (d >= -ε2) return;
                var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
                var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
                circle.arc = arc;
                circle.site = cSite;
                circle.x = x + bx;
                circle.y = cy + Math.sqrt(x * x + y * y);
                circle.cy = cy;
                arc.circle = circle;
                var before = null, node = d3_geom_voronoiCircles._;
                while (node) {
                    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                        if (node.L) node = node.L; else {
                            before = node.P;
                            break;
                        }
                    } else {
                        if (node.R) node = node.R; else {
                            before = node;
                            break;
                        }
                    }
                }
                d3_geom_voronoiCircles.insert(before, circle);
                if (!before) d3_geom_voronoiFirstCircle = circle;
            }
            function d3_geom_voronoiDetachCircle(arc) {
                var circle = arc.circle;
                if (circle) {
                    if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
                    d3_geom_voronoiCircles.remove(circle);
                    d3_geom_voronoiCirclePool.push(circle);
                    d3_geom_voronoiRedBlackNode(circle);
                    arc.circle = null;
                }
            }
            function d3_geom_voronoiClipEdges(extent) {
                var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
                while (i--) {
                    e = edges[i];
                    if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                        e.a = e.b = null;
                        edges.splice(i, 1);
                    }
                }
            }
            function d3_geom_voronoiConnectEdge(edge, extent) {
                var vb = edge.b;
                if (vb) return true;
                var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
                if (ry === ly) {
                    if (fx < x0 || fx >= x1) return;
                    if (lx > rx) {
                        if (!va) va = {
                            x: fx,
                            y: y0
                        }; else if (va.y >= y1) return;
                        vb = {
                            x: fx,
                            y: y1
                        };
                    } else {
                        if (!va) va = {
                            x: fx,
                            y: y1
                        }; else if (va.y < y0) return;
                        vb = {
                            x: fx,
                            y: y0
                        };
                    }
                } else {
                    fm = (lx - rx) / (ry - ly);
                    fb = fy - fm * fx;
                    if (fm < -1 || fm > 1) {
                        if (lx > rx) {
                            if (!va) va = {
                                x: (y0 - fb) / fm,
                                y: y0
                            }; else if (va.y >= y1) return;
                            vb = {
                                x: (y1 - fb) / fm,
                                y: y1
                            };
                        } else {
                            if (!va) va = {
                                x: (y1 - fb) / fm,
                                y: y1
                            }; else if (va.y < y0) return;
                            vb = {
                                x: (y0 - fb) / fm,
                                y: y0
                            };
                        }
                    } else {
                        if (ly < ry) {
                            if (!va) va = {
                                x: x0,
                                y: fm * x0 + fb
                            }; else if (va.x >= x1) return;
                            vb = {
                                x: x1,
                                y: fm * x1 + fb
                            };
                        } else {
                            if (!va) va = {
                                x: x1,
                                y: fm * x1 + fb
                            }; else if (va.x < x0) return;
                            vb = {
                                x: x0,
                                y: fm * x0 + fb
                            };
                        }
                    }
                }
                edge.a = va;
                edge.b = vb;
                return true;
            }
            function d3_geom_voronoiEdge(lSite, rSite) {
                this.l = lSite;
                this.r = rSite;
                this.a = this.b = null;
            }
            function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
                var edge = new d3_geom_voronoiEdge(lSite, rSite);
                d3_geom_voronoiEdges.push(edge);
                if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
                if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
                d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
                d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
                return edge;
            }
            function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
                var edge = new d3_geom_voronoiEdge(lSite, null);
                edge.a = va;
                edge.b = vb;
                d3_geom_voronoiEdges.push(edge);
                return edge;
            }
            function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
                if (!edge.a && !edge.b) {
                    edge.a = vertex;
                    edge.l = lSite;
                    edge.r = rSite;
                } else if (edge.l === rSite) {
                    edge.b = vertex;
                } else {
                    edge.a = vertex;
                }
            }
            function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
                var va = edge.a, vb = edge.b;
                this.edge = edge;
                this.site = lSite;
                this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
            }
            d3_geom_voronoiHalfEdge.prototype = {
                start: function() {
                    return this.edge.l === this.site ? this.edge.a : this.edge.b;
                },
                end: function() {
                    return this.edge.l === this.site ? this.edge.b : this.edge.a;
                }
            };
            function d3_geom_voronoiRedBlackTree() {
                this._ = null;
            }
            function d3_geom_voronoiRedBlackNode(node) {
                node.U = node.C = node.L = node.R = node.P = node.N = null;
            }
            d3_geom_voronoiRedBlackTree.prototype = {
                insert: function(after, node) {
                    var parent, grandpa, uncle;
                    if (after) {
                        node.P = after;
                        node.N = after.N;
                        if (after.N) after.N.P = node;
                        after.N = node;
                        if (after.R) {
                            after = after.R;
                            while (after.L) after = after.L;
                            after.L = node;
                        } else {
                            after.R = node;
                        }
                        parent = after;
                    } else if (this._) {
                        after = d3_geom_voronoiRedBlackFirst(this._);
                        node.P = null;
                        node.N = after;
                        after.P = after.L = node;
                        parent = after;
                    } else {
                        node.P = node.N = null;
                        this._ = node;
                        parent = null;
                    }
                    node.L = node.R = null;
                    node.U = parent;
                    node.C = true;
                    after = node;
                    while (parent && parent.C) {
                        grandpa = parent.U;
                        if (parent === grandpa.L) {
                            uncle = grandpa.R;
                            if (uncle && uncle.C) {
                                parent.C = uncle.C = false;
                                grandpa.C = true;
                                after = grandpa;
                            } else {
                                if (after === parent.R) {
                                    d3_geom_voronoiRedBlackRotateLeft(this, parent);
                                    after = parent;
                                    parent = after.U;
                                }
                                parent.C = false;
                                grandpa.C = true;
                                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                            }
                        } else {
                            uncle = grandpa.L;
                            if (uncle && uncle.C) {
                                parent.C = uncle.C = false;
                                grandpa.C = true;
                                after = grandpa;
                            } else {
                                if (after === parent.L) {
                                    d3_geom_voronoiRedBlackRotateRight(this, parent);
                                    after = parent;
                                    parent = after.U;
                                }
                                parent.C = false;
                                grandpa.C = true;
                                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                            }
                        }
                        parent = after.U;
                    }
                    this._.C = false;
                },
                remove: function(node) {
                    if (node.N) node.N.P = node.P;
                    if (node.P) node.P.N = node.N;
                    node.N = node.P = null;
                    var parent = node.U, sibling, left = node.L, right = node.R, next, red;
                    if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
                    if (parent) {
                        if (parent.L === node) parent.L = next; else parent.R = next;
                    } else {
                        this._ = next;
                    }
                    if (left && right) {
                        red = next.C;
                        next.C = node.C;
                        next.L = left;
                        left.U = next;
                        if (next !== right) {
                            parent = next.U;
                            next.U = node.U;
                            node = next.R;
                            parent.L = node;
                            next.R = right;
                            right.U = next;
                        } else {
                            next.U = parent;
                            parent = next;
                            node = next.R;
                        }
                    } else {
                        red = node.C;
                        node = next;
                    }
                    if (node) node.U = parent;
                    if (red) return;
                    if (node && node.C) {
                        node.C = false;
                        return;
                    }
                    do {
                        if (node === this._) break;
                        if (node === parent.L) {
                            sibling = parent.R;
                            if (sibling.C) {
                                sibling.C = false;
                                parent.C = true;
                                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                                sibling = parent.R;
                            }
                            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                                if (!sibling.R || !sibling.R.C) {
                                    sibling.L.C = false;
                                    sibling.C = true;
                                    d3_geom_voronoiRedBlackRotateRight(this, sibling);
                                    sibling = parent.R;
                                }
                                sibling.C = parent.C;
                                parent.C = sibling.R.C = false;
                                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                                node = this._;
                                break;
                            }
                        } else {
                            sibling = parent.L;
                            if (sibling.C) {
                                sibling.C = false;
                                parent.C = true;
                                d3_geom_voronoiRedBlackRotateRight(this, parent);
                                sibling = parent.L;
                            }
                            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                                if (!sibling.L || !sibling.L.C) {
                                    sibling.R.C = false;
                                    sibling.C = true;
                                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                                    sibling = parent.L;
                                }
                                sibling.C = parent.C;
                                parent.C = sibling.L.C = false;
                                d3_geom_voronoiRedBlackRotateRight(this, parent);
                                node = this._;
                                break;
                            }
                        }
                        sibling.C = true;
                        node = parent;
                        parent = parent.U;
                    } while (!node.C);
                    if (node) node.C = false;
                }
            };
            function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
                var p = node, q = node.R, parent = p.U;
                if (parent) {
                    if (parent.L === p) parent.L = q; else parent.R = q;
                } else {
                    tree._ = q;
                }
                q.U = parent;
                p.U = q;
                p.R = q.L;
                if (p.R) p.R.U = p;
                q.L = p;
            }
            function d3_geom_voronoiRedBlackRotateRight(tree, node) {
                var p = node, q = node.L, parent = p.U;
                if (parent) {
                    if (parent.L === p) parent.L = q; else parent.R = q;
                } else {
                    tree._ = q;
                }
                q.U = parent;
                p.U = q;
                p.L = q.R;
                if (p.L) p.L.U = p;
                q.R = p;
            }
            function d3_geom_voronoiRedBlackFirst(node) {
                while (node.L) node = node.L;
                return node;
            }
            function d3_geom_voronoi(sites, bbox) {
                var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
                d3_geom_voronoiEdges = [];
                d3_geom_voronoiCells = new Array(sites.length);
                d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
                d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
                while (true) {
                    circle = d3_geom_voronoiFirstCircle;
                    if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                        if (site.x !== x0 || site.y !== y0) {
                            d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                            d3_geom_voronoiAddBeach(site);
                            x0 = site.x, y0 = site.y;
                        }
                        site = sites.pop();
                    } else if (circle) {
                        d3_geom_voronoiRemoveBeach(circle.arc);
                    } else {
                        break;
                    }
                }
                if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
                var diagram = {
                    cells: d3_geom_voronoiCells,
                    edges: d3_geom_voronoiEdges
                };
                d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
                return diagram;
            }
            function d3_geom_voronoiVertexOrder(a, b) {
                return b.y - a.y || b.x - a.x;
            }
            d3.geom.voronoi = function(points) {
                var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
                if (points) return voronoi(points);
                function voronoi(data) {
                    var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
                    d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                            var s = e.start();
                            return [ s.x, s.y ];
                        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
                        polygon.point = data[i];
                    });
                    return polygons;
                }
                function sites(data) {
                    return data.map(function(d, i) {
                        return {
                            x: Math.round(fx(d, i) / ε) * ε,
                            y: Math.round(fy(d, i) / ε) * ε,
                            i: i
                        };
                    });
                }
                voronoi.links = function(data) {
                    return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                        return edge.l && edge.r;
                    }).map(function(edge) {
                        return {
                            source: data[edge.l.i],
                            target: data[edge.r.i]
                        };
                    });
                };
                voronoi.triangles = function(data) {
                    var triangles = [];
                    d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                        while (++j < m) {
                            e0 = e1;
                            s0 = s1;
                            e1 = edges[j].edge;
                            s1 = e1.l === site ? e1.r : e1.l;
                            if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                                triangles.push([ data[i], data[s0.i], data[s1.i] ]);
                            }
                        }
                    });
                    return triangles;
                };
                voronoi.x = function(_) {
                    return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
                };
                voronoi.y = function(_) {
                    return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
                };
                voronoi.clipExtent = function(_) {
                    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
                    clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
                    return voronoi;
                };
                voronoi.size = function(_) {
                    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
                    return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
                };
                return voronoi;
            };
            var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
            function d3_geom_voronoiTriangleArea(a, b, c) {
                return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
            }
            d3.geom.delaunay = function(vertices) {
                return d3.geom.voronoi().triangles(vertices);
            };
            d3.geom.quadtree = function(points, x1, y1, x2, y2) {
                var x = d3_geom_pointX, y = d3_geom_pointY, compat;
                if (compat = arguments.length) {
                    x = d3_geom_quadtreeCompatX;
                    y = d3_geom_quadtreeCompatY;
                    if (compat === 3) {
                        y2 = y1;
                        x2 = x1;
                        y1 = x1 = 0;
                    }
                    return quadtree(points);
                }
                function quadtree(data) {
                    var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
                    if (x1 != null) {
                        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
                    } else {
                        x2_ = y2_ = -(x1_ = y1_ = Infinity);
                        xs = [], ys = [];
                        n = data.length;
                        if (compat) for (i = 0; i < n; ++i) {
                            d = data[i];
                            if (d.x < x1_) x1_ = d.x;
                            if (d.y < y1_) y1_ = d.y;
                            if (d.x > x2_) x2_ = d.x;
                            if (d.y > y2_) y2_ = d.y;
                            xs.push(d.x);
                            ys.push(d.y);
                        } else for (i = 0; i < n; ++i) {
                            var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                            if (x_ < x1_) x1_ = x_;
                            if (y_ < y1_) y1_ = y_;
                            if (x_ > x2_) x2_ = x_;
                            if (y_ > y2_) y2_ = y_;
                            xs.push(x_);
                            ys.push(y_);
                        }
                    }
                    var dx = x2_ - x1_, dy = y2_ - y1_;
                    if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
                    function insert(n, d, x, y, x1, y1, x2, y2) {
                        if (isNaN(x) || isNaN(y)) return;
                        if (n.leaf) {
                            var nx = n.x, ny = n.y;
                            if (nx != null) {
                                if (abs(nx - x) + abs(ny - y) < .01) {
                                    insertChild(n, d, x, y, x1, y1, x2, y2);
                                } else {
                                    var nPoint = n.point;
                                    n.x = n.y = n.point = null;
                                    insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                                    insertChild(n, d, x, y, x1, y1, x2, y2);
                                }
                            } else {
                                n.x = x, n.y = y, n.point = d;
                            }
                        } else {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    }
                    function insertChild(n, d, x, y, x1, y1, x2, y2) {
                        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                        n.leaf = false;
                        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                        if (right) x1 = xm; else x2 = xm;
                        if (below) y1 = ym; else y2 = ym;
                        insert(n, d, x, y, x1, y1, x2, y2);
                    }
                    var root = d3_geom_quadtreeNode();
                    root.add = function(d) {
                        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
                    };
                    root.visit = function(f) {
                        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
                    };
                    root.find = function(point) {
                        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
                    };
                    i = -1;
                    if (x1 == null) {
                        while (++i < n) {
                            insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                        }
                        --i;
                    } else data.forEach(root.add);
                    xs = ys = data = d = null;
                    return root;
                }
                quadtree.x = function(_) {
                    return arguments.length ? (x = _, quadtree) : x;
                };
                quadtree.y = function(_) {
                    return arguments.length ? (y = _, quadtree) : y;
                };
                quadtree.extent = function(_) {
                    if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
                    if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
                    y2 = +_[1][1];
                    return quadtree;
                };
                quadtree.size = function(_) {
                    if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
                    if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
                    return quadtree;
                };
                return quadtree;
            };
            function d3_geom_quadtreeCompatX(d) {
                return d.x;
            }
            function d3_geom_quadtreeCompatY(d) {
                return d.y;
            }
            function d3_geom_quadtreeNode() {
                return {
                    leaf: true,
                    nodes: [],
                    point: null,
                    x: null,
                    y: null
                };
            }
            function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
                if (!f(node, x1, y1, x2, y2)) {
                    var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
                    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
                    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
                    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
                    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
                }
            }
            function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
                var minDistance2 = Infinity, closestPoint;
                (function find(node, x1, y1, x2, y2) {
                    if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
                    if (point = node.point) {
                        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                        if (distance2 < minDistance2) {
                            var distance = Math.sqrt(minDistance2 = distance2);
                            x0 = x - distance, y0 = y - distance;
                            x3 = x + distance, y3 = y + distance;
                            closestPoint = point;
                        }
                    }
                    var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
                    for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                        if (node = children[i & 3]) switch (i & 3) {
                          case 0:
                            find(node, x1, y1, xm, ym);
                            break;

                          case 1:
                            find(node, xm, y1, x2, ym);
                            break;

                          case 2:
                            find(node, x1, ym, xm, y2);
                            break;

                          case 3:
                            find(node, xm, ym, x2, y2);
                            break;
                        }
                    }
                })(root, x0, y0, x3, y3);
                return closestPoint;
            }
            d3.interpolateRgb = d3_interpolateRgb;
            function d3_interpolateRgb(a, b) {
                a = d3.rgb(a);
                b = d3.rgb(b);
                var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
                return function(t) {
                    return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
                };
            }
            d3.interpolateObject = d3_interpolateObject;
            function d3_interpolateObject(a, b) {
                var i = {}, c = {}, k;
                for (k in a) {
                    if (k in b) {
                        i[k] = d3_interpolate(a[k], b[k]);
                    } else {
                        c[k] = a[k];
                    }
                }
                for (k in b) {
                    if (!(k in a)) {
                        c[k] = b[k];
                    }
                }
                return function(t) {
                    for (k in i) c[k] = i[k](t);
                    return c;
                };
            }
            d3.interpolateNumber = d3_interpolateNumber;
            function d3_interpolateNumber(a, b) {
                a = +a, b = +b;
                return function(t) {
                    return a * (1 - t) + b * t;
                };
            }
            d3.interpolateString = d3_interpolateString;
            function d3_interpolateString(a, b) {
                var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
                a = a + "", b = b + "";
                while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
                    if ((bs = bm.index) > bi) {
                        bs = b.slice(bi, bs);
                        if (s[i]) s[i] += bs; else s[++i] = bs;
                    }
                    if ((am = am[0]) === (bm = bm[0])) {
                        if (s[i]) s[i] += bm; else s[++i] = bm;
                    } else {
                        s[++i] = null;
                        q.push({
                            i: i,
                            x: d3_interpolateNumber(am, bm)
                        });
                    }
                    bi = d3_interpolate_numberB.lastIndex;
                }
                if (bi < b.length) {
                    bs = b.slice(bi);
                    if (s[i]) s[i] += bs; else s[++i] = bs;
                }
                return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
                    return b(t) + "";
                }) : function() {
                    return b;
                } : (b = q.length, function(t) {
                    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                    return s.join("");
                });
            }
            var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
            d3.interpolate = d3_interpolate;
            function d3_interpolate(a, b) {
                var i = d3.interpolators.length, f;
                while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
                return f;
            }
            d3.interpolators = [ function(a, b) {
                var t = typeof b;
                return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
            } ];
            d3.interpolateArray = d3_interpolateArray;
            function d3_interpolateArray(a, b) {
                var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
                for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
                for (;i < na; ++i) c[i] = a[i];
                for (;i < nb; ++i) c[i] = b[i];
                return function(t) {
                    for (i = 0; i < n0; ++i) c[i] = x[i](t);
                    return c;
                };
            }
            var d3_ease_default = function() {
                return d3_identity;
            };
            var d3_ease = d3.map({
                linear: d3_ease_default,
                poly: d3_ease_poly,
                quad: function() {
                    return d3_ease_quad;
                },
                cubic: function() {
                    return d3_ease_cubic;
                },
                sin: function() {
                    return d3_ease_sin;
                },
                exp: function() {
                    return d3_ease_exp;
                },
                circle: function() {
                    return d3_ease_circle;
                },
                elastic: d3_ease_elastic,
                back: d3_ease_back,
                bounce: function() {
                    return d3_ease_bounce;
                }
            });
            var d3_ease_mode = d3.map({
                "in": d3_identity,
                out: d3_ease_reverse,
                "in-out": d3_ease_reflect,
                "out-in": function(f) {
                    return d3_ease_reflect(d3_ease_reverse(f));
                }
            });
            d3.ease = function(name) {
                var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
                t = d3_ease.get(t) || d3_ease_default;
                m = d3_ease_mode.get(m) || d3_identity;
                return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
            };
            function d3_ease_clamp(f) {
                return function(t) {
                    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
                };
            }
            function d3_ease_reverse(f) {
                return function(t) {
                    return 1 - f(1 - t);
                };
            }
            function d3_ease_reflect(f) {
                return function(t) {
                    return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
                };
            }
            function d3_ease_quad(t) {
                return t * t;
            }
            function d3_ease_cubic(t) {
                return t * t * t;
            }
            function d3_ease_cubicInOut(t) {
                if (t <= 0) return 0;
                if (t >= 1) return 1;
                var t2 = t * t, t3 = t2 * t;
                return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
            }
            function d3_ease_poly(e) {
                return function(t) {
                    return Math.pow(t, e);
                };
            }
            function d3_ease_sin(t) {
                return 1 - Math.cos(t * halfπ);
            }
            function d3_ease_exp(t) {
                return Math.pow(2, 10 * (t - 1));
            }
            function d3_ease_circle(t) {
                return 1 - Math.sqrt(1 - t * t);
            }
            function d3_ease_elastic(a, p) {
                var s;
                if (arguments.length < 2) p = .45;
                if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
                return function(t) {
                    return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
                };
            }
            function d3_ease_back(s) {
                if (!s) s = 1.70158;
                return function(t) {
                    return t * t * ((s + 1) * t - s);
                };
            }
            function d3_ease_bounce(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
            }
            d3.interpolateHcl = d3_interpolateHcl;
            function d3_interpolateHcl(a, b) {
                a = d3.hcl(a);
                b = d3.hcl(b);
                var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
                if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
                if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
                return function(t) {
                    return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
                };
            }
            d3.interpolateHsl = d3_interpolateHsl;
            function d3_interpolateHsl(a, b) {
                a = d3.hsl(a);
                b = d3.hsl(b);
                var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
                if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
                if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
                return function(t) {
                    return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
                };
            }
            d3.interpolateLab = d3_interpolateLab;
            function d3_interpolateLab(a, b) {
                a = d3.lab(a);
                b = d3.lab(b);
                var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
                return function(t) {
                    return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
                };
            }
            d3.interpolateRound = d3_interpolateRound;
            function d3_interpolateRound(a, b) {
                b -= a;
                return function(t) {
                    return Math.round(a + b * t);
                };
            }
            d3.transform = function(string) {
                var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
                return (d3.transform = function(string) {
                    if (string != null) {
                        g.setAttribute("transform", string);
                        var t = g.transform.baseVal.consolidate();
                    }
                    return new d3_transform(t ? t.matrix : d3_transformIdentity);
                })(string);
            };
            function d3_transform(m) {
                var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
                if (r0[0] * r1[1] < r1[0] * r0[1]) {
                    r0[0] *= -1;
                    r0[1] *= -1;
                    kx *= -1;
                    kz *= -1;
                }
                this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
                this.translate = [ m.e, m.f ];
                this.scale = [ kx, ky ];
                this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
            }
            d3_transform.prototype.toString = function() {
                return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
            };
            function d3_transformDot(a, b) {
                return a[0] * b[0] + a[1] * b[1];
            }
            function d3_transformNormalize(a) {
                var k = Math.sqrt(d3_transformDot(a, a));
                if (k) {
                    a[0] /= k;
                    a[1] /= k;
                }
                return k;
            }
            function d3_transformCombine(a, b, k) {
                a[0] += k * b[0];
                a[1] += k * b[1];
                return a;
            }
            var d3_transformIdentity = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0
            };
            d3.interpolateTransform = d3_interpolateTransform;
            function d3_interpolateTransform(a, b) {
                var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
                if (ta[0] != tb[0] || ta[1] != tb[1]) {
                    s.push("translate(", null, ",", null, ")");
                    q.push({
                        i: 1,
                        x: d3_interpolateNumber(ta[0], tb[0])
                    }, {
                        i: 3,
                        x: d3_interpolateNumber(ta[1], tb[1])
                    });
                } else if (tb[0] || tb[1]) {
                    s.push("translate(" + tb + ")");
                } else {
                    s.push("");
                }
                if (ra != rb) {
                    if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
                    q.push({
                        i: s.push(s.pop() + "rotate(", null, ")") - 2,
                        x: d3_interpolateNumber(ra, rb)
                    });
                } else if (rb) {
                    s.push(s.pop() + "rotate(" + rb + ")");
                }
                if (wa != wb) {
                    q.push({
                        i: s.push(s.pop() + "skewX(", null, ")") - 2,
                        x: d3_interpolateNumber(wa, wb)
                    });
                } else if (wb) {
                    s.push(s.pop() + "skewX(" + wb + ")");
                }
                if (ka[0] != kb[0] || ka[1] != kb[1]) {
                    n = s.push(s.pop() + "scale(", null, ",", null, ")");
                    q.push({
                        i: n - 4,
                        x: d3_interpolateNumber(ka[0], kb[0])
                    }, {
                        i: n - 2,
                        x: d3_interpolateNumber(ka[1], kb[1])
                    });
                } else if (kb[0] != 1 || kb[1] != 1) {
                    s.push(s.pop() + "scale(" + kb + ")");
                }
                n = q.length;
                return function(t) {
                    var i = -1, o;
                    while (++i < n) s[(o = q[i]).i] = o.x(t);
                    return s.join("");
                };
            }
            function d3_uninterpolateNumber(a, b) {
                b = (b -= a = +a) || 1 / b;
                return function(x) {
                    return (x - a) / b;
                };
            }
            function d3_uninterpolateClamp(a, b) {
                b = (b -= a = +a) || 1 / b;
                return function(x) {
                    return Math.max(0, Math.min(1, (x - a) / b));
                };
            }
            d3.layout = {};
            d3.layout.bundle = function() {
                return function(links) {
                    var paths = [], i = -1, n = links.length;
                    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
                    return paths;
                };
            };
            function d3_layout_bundlePath(link) {
                var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
                while (start !== lca) {
                    start = start.parent;
                    points.push(start);
                }
                var k = points.length;
                while (end !== lca) {
                    points.splice(k, 0, end);
                    end = end.parent;
                }
                return points;
            }
            function d3_layout_bundleAncestors(node) {
                var ancestors = [], parent = node.parent;
                while (parent != null) {
                    ancestors.push(node);
                    node = parent;
                    parent = parent.parent;
                }
                ancestors.push(node);
                return ancestors;
            }
            function d3_layout_bundleLeastCommonAncestor(a, b) {
                if (a === b) return a;
                var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
                while (aNode === bNode) {
                    sharedNode = aNode;
                    aNode = aNodes.pop();
                    bNode = bNodes.pop();
                }
                return sharedNode;
            }
            d3.layout.chord = function() {
                var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
                function relayout() {
                    var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
                    chords = [];
                    groups = [];
                    k = 0, i = -1;
                    while (++i < n) {
                        x = 0, j = -1;
                        while (++j < n) {
                            x += matrix[i][j];
                        }
                        groupSums.push(x);
                        subgroupIndex.push(d3.range(n));
                        k += x;
                    }
                    if (sortGroups) {
                        groupIndex.sort(function(a, b) {
                            return sortGroups(groupSums[a], groupSums[b]);
                        });
                    }
                    if (sortSubgroups) {
                        subgroupIndex.forEach(function(d, i) {
                            d.sort(function(a, b) {
                                return sortSubgroups(matrix[i][a], matrix[i][b]);
                            });
                        });
                    }
                    k = (τ - padding * n) / k;
                    x = 0, i = -1;
                    while (++i < n) {
                        x0 = x, j = -1;
                        while (++j < n) {
                            var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                            subgroups[di + "-" + dj] = {
                                index: di,
                                subindex: dj,
                                startAngle: a0,
                                endAngle: a1,
                                value: v
                            };
                        }
                        groups[di] = {
                            index: di,
                            startAngle: x0,
                            endAngle: x,
                            value: (x - x0) / k
                        };
                        x += padding;
                    }
                    i = -1;
                    while (++i < n) {
                        j = i - 1;
                        while (++j < n) {
                            var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                            if (source.value || target.value) {
                                chords.push(source.value < target.value ? {
                                    source: target,
                                    target: source
                                } : {
                                    source: source,
                                    target: target
                                });
                            }
                        }
                    }
                    if (sortChords) resort();
                }
                function resort() {
                    chords.sort(function(a, b) {
                        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
                    });
                }
                chord.matrix = function(x) {
                    if (!arguments.length) return matrix;
                    n = (matrix = x) && matrix.length;
                    chords = groups = null;
                    return chord;
                };
                chord.padding = function(x) {
                    if (!arguments.length) return padding;
                    padding = x;
                    chords = groups = null;
                    return chord;
                };
                chord.sortGroups = function(x) {
                    if (!arguments.length) return sortGroups;
                    sortGroups = x;
                    chords = groups = null;
                    return chord;
                };
                chord.sortSubgroups = function(x) {
                    if (!arguments.length) return sortSubgroups;
                    sortSubgroups = x;
                    chords = null;
                    return chord;
                };
                chord.sortChords = function(x) {
                    if (!arguments.length) return sortChords;
                    sortChords = x;
                    if (chords) resort();
                    return chord;
                };
                chord.chords = function() {
                    if (!chords) relayout();
                    return chords;
                };
                chord.groups = function() {
                    if (!groups) relayout();
                    return groups;
                };
                return chord;
            };
            d3.layout.force = function() {
                var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
                function repulse(node) {
                    return function(quad, x1, _, x2) {
                        if (quad.point !== node) {
                            var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                            if (dw * dw / theta2 < dn) {
                                if (dn < chargeDistance2) {
                                    var k = quad.charge / dn;
                                    node.px -= dx * k;
                                    node.py -= dy * k;
                                }
                                return true;
                            }
                            if (quad.point && dn && dn < chargeDistance2) {
                                var k = quad.pointCharge / dn;
                                node.px -= dx * k;
                                node.py -= dy * k;
                            }
                        }
                        return !quad.charge;
                    };
                }
                force.tick = function() {
                    if ((alpha *= .99) < .005) {
                        event.end({
                            type: "end",
                            alpha: alpha = 0
                        });
                        return true;
                    }
                    var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
                    for (i = 0; i < m; ++i) {
                        o = links[i];
                        s = o.source;
                        t = o.target;
                        x = t.x - s.x;
                        y = t.y - s.y;
                        if (l = x * x + y * y) {
                            l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                            x *= l;
                            y *= l;
                            t.x -= x * (k = s.weight / (t.weight + s.weight));
                            t.y -= y * k;
                            s.x += x * (k = 1 - k);
                            s.y += y * k;
                        }
                    }
                    if (k = alpha * gravity) {
                        x = size[0] / 2;
                        y = size[1] / 2;
                        i = -1;
                        if (k) while (++i < n) {
                            o = nodes[i];
                            o.x += (x - o.x) * k;
                            o.y += (y - o.y) * k;
                        }
                    }
                    if (charge) {
                        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                        i = -1;
                        while (++i < n) {
                            if (!(o = nodes[i]).fixed) {
                                q.visit(repulse(o));
                            }
                        }
                    }
                    i = -1;
                    while (++i < n) {
                        o = nodes[i];
                        if (o.fixed) {
                            o.x = o.px;
                            o.y = o.py;
                        } else {
                            o.x -= (o.px - (o.px = o.x)) * friction;
                            o.y -= (o.py - (o.py = o.y)) * friction;
                        }
                    }
                    event.tick({
                        type: "tick",
                        alpha: alpha
                    });
                };
                force.nodes = function(x) {
                    if (!arguments.length) return nodes;
                    nodes = x;
                    return force;
                };
                force.links = function(x) {
                    if (!arguments.length) return links;
                    links = x;
                    return force;
                };
                force.size = function(x) {
                    if (!arguments.length) return size;
                    size = x;
                    return force;
                };
                force.linkDistance = function(x) {
                    if (!arguments.length) return linkDistance;
                    linkDistance = typeof x === "function" ? x : +x;
                    return force;
                };
                force.distance = force.linkDistance;
                force.linkStrength = function(x) {
                    if (!arguments.length) return linkStrength;
                    linkStrength = typeof x === "function" ? x : +x;
                    return force;
                };
                force.friction = function(x) {
                    if (!arguments.length) return friction;
                    friction = +x;
                    return force;
                };
                force.charge = function(x) {
                    if (!arguments.length) return charge;
                    charge = typeof x === "function" ? x : +x;
                    return force;
                };
                force.chargeDistance = function(x) {
                    if (!arguments.length) return Math.sqrt(chargeDistance2);
                    chargeDistance2 = x * x;
                    return force;
                };
                force.gravity = function(x) {
                    if (!arguments.length) return gravity;
                    gravity = +x;
                    return force;
                };
                force.theta = function(x) {
                    if (!arguments.length) return Math.sqrt(theta2);
                    theta2 = x * x;
                    return force;
                };
                force.alpha = function(x) {
                    if (!arguments.length) return alpha;
                    x = +x;
                    if (alpha) {
                        if (x > 0) alpha = x; else alpha = 0;
                    } else if (x > 0) {
                        event.start({
                            type: "start",
                            alpha: alpha = x
                        });
                        d3.timer(force.tick);
                    }
                    return force;
                };
                force.start = function() {
                    var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
                    for (i = 0; i < n; ++i) {
                        (o = nodes[i]).index = i;
                        o.weight = 0;
                    }
                    for (i = 0; i < m; ++i) {
                        o = links[i];
                        if (typeof o.source == "number") o.source = nodes[o.source];
                        if (typeof o.target == "number") o.target = nodes[o.target];
                        ++o.source.weight;
                        ++o.target.weight;
                    }
                    for (i = 0; i < n; ++i) {
                        o = nodes[i];
                        if (isNaN(o.x)) o.x = position("x", w);
                        if (isNaN(o.y)) o.y = position("y", h);
                        if (isNaN(o.px)) o.px = o.x;
                        if (isNaN(o.py)) o.py = o.y;
                    }
                    distances = [];
                    if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
                    strengths = [];
                    if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
                    charges = [];
                    if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
                    function position(dimension, size) {
                        if (!neighbors) {
                            neighbors = new Array(n);
                            for (j = 0; j < n; ++j) {
                                neighbors[j] = [];
                            }
                            for (j = 0; j < m; ++j) {
                                var o = links[j];
                                neighbors[o.source.index].push(o.target);
                                neighbors[o.target.index].push(o.source);
                            }
                        }
                        var candidates = neighbors[i], j = -1, l = candidates.length, x;
                        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
                        return Math.random() * size;
                    }
                    return force.resume();
                };
                force.resume = function() {
                    return force.alpha(.1);
                };
                force.stop = function() {
                    return force.alpha(0);
                };
                force.drag = function() {
                    if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
                    if (!arguments.length) return drag;
                    this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
                };
                function dragmove(d) {
                    d.px = d3.event.x, d.py = d3.event.y;
                    force.resume();
                }
                return d3.rebind(force, event, "on");
            };
            function d3_layout_forceDragstart(d) {
                d.fixed |= 2;
            }
            function d3_layout_forceDragend(d) {
                d.fixed &= ~6;
            }
            function d3_layout_forceMouseover(d) {
                d.fixed |= 4;
                d.px = d.x, d.py = d.y;
            }
            function d3_layout_forceMouseout(d) {
                d.fixed &= ~4;
            }
            function d3_layout_forceAccumulate(quad, alpha, charges) {
                var cx = 0, cy = 0;
                quad.charge = 0;
                if (!quad.leaf) {
                    var nodes = quad.nodes, n = nodes.length, i = -1, c;
                    while (++i < n) {
                        c = nodes[i];
                        if (c == null) continue;
                        d3_layout_forceAccumulate(c, alpha, charges);
                        quad.charge += c.charge;
                        cx += c.charge * c.cx;
                        cy += c.charge * c.cy;
                    }
                }
                if (quad.point) {
                    if (!quad.leaf) {
                        quad.point.x += Math.random() - .5;
                        quad.point.y += Math.random() - .5;
                    }
                    var k = alpha * charges[quad.point.index];
                    quad.charge += quad.pointCharge = k;
                    cx += k * quad.point.x;
                    cy += k * quad.point.y;
                }
                quad.cx = cx / quad.charge;
                quad.cy = cy / quad.charge;
            }
            var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
            d3.layout.hierarchy = function() {
                var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
                function hierarchy(root) {
                    var stack = [ root ], nodes = [], node;
                    root.depth = 0;
                    while ((node = stack.pop()) != null) {
                        nodes.push(node);
                        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                            var n, childs, child;
                            while (--n >= 0) {
                                stack.push(child = childs[n]);
                                child.parent = node;
                                child.depth = node.depth + 1;
                            }
                            if (value) node.value = 0;
                            node.children = childs;
                        } else {
                            if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                            delete node.children;
                        }
                    }
                    d3_layout_hierarchyVisitAfter(root, function(node) {
                        var childs, parent;
                        if (sort && (childs = node.children)) childs.sort(sort);
                        if (value && (parent = node.parent)) parent.value += node.value;
                    });
                    return nodes;
                }
                hierarchy.sort = function(x) {
                    if (!arguments.length) return sort;
                    sort = x;
                    return hierarchy;
                };
                hierarchy.children = function(x) {
                    if (!arguments.length) return children;
                    children = x;
                    return hierarchy;
                };
                hierarchy.value = function(x) {
                    if (!arguments.length) return value;
                    value = x;
                    return hierarchy;
                };
                hierarchy.revalue = function(root) {
                    if (value) {
                        d3_layout_hierarchyVisitBefore(root, function(node) {
                            if (node.children) node.value = 0;
                        });
                        d3_layout_hierarchyVisitAfter(root, function(node) {
                            var parent;
                            if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                            if (parent = node.parent) parent.value += node.value;
                        });
                    }
                    return root;
                };
                return hierarchy;
            };
            function d3_layout_hierarchyRebind(object, hierarchy) {
                d3.rebind(object, hierarchy, "sort", "children", "value");
                object.nodes = object;
                object.links = d3_layout_hierarchyLinks;
                return object;
            }
            function d3_layout_hierarchyVisitBefore(node, callback) {
                var nodes = [ node ];
                while ((node = nodes.pop()) != null) {
                    callback(node);
                    if ((children = node.children) && (n = children.length)) {
                        var n, children;
                        while (--n >= 0) nodes.push(children[n]);
                    }
                }
            }
            function d3_layout_hierarchyVisitAfter(node, callback) {
                var nodes = [ node ], nodes2 = [];
                while ((node = nodes.pop()) != null) {
                    nodes2.push(node);
                    if ((children = node.children) && (n = children.length)) {
                        var i = -1, n, children;
                        while (++i < n) nodes.push(children[i]);
                    }
                }
                while ((node = nodes2.pop()) != null) {
                    callback(node);
                }
            }
            function d3_layout_hierarchyChildren(d) {
                return d.children;
            }
            function d3_layout_hierarchyValue(d) {
                return d.value;
            }
            function d3_layout_hierarchySort(a, b) {
                return b.value - a.value;
            }
            function d3_layout_hierarchyLinks(nodes) {
                return d3.merge(nodes.map(function(parent) {
                    return (parent.children || []).map(function(child) {
                        return {
                            source: parent,
                            target: child
                        };
                    });
                }));
            }
            d3.layout.partition = function() {
                var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
                function position(node, x, dx, dy) {
                    var children = node.children;
                    node.x = x;
                    node.y = node.depth * dy;
                    node.dx = dx;
                    node.dy = dy;
                    if (children && (n = children.length)) {
                        var i = -1, n, c, d;
                        dx = node.value ? dx / node.value : 0;
                        while (++i < n) {
                            position(c = children[i], x, d = c.value * dx, dy);
                            x += d;
                        }
                    }
                }
                function depth(node) {
                    var children = node.children, d = 0;
                    if (children && (n = children.length)) {
                        var i = -1, n;
                        while (++i < n) d = Math.max(d, depth(children[i]));
                    }
                    return 1 + d;
                }
                function partition(d, i) {
                    var nodes = hierarchy.call(this, d, i);
                    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
                    return nodes;
                }
                partition.size = function(x) {
                    if (!arguments.length) return size;
                    size = x;
                    return partition;
                };
                return d3_layout_hierarchyRebind(partition, hierarchy);
            };
            d3.layout.pie = function() {
                var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
                function pie(data) {
                    var n = data.length, values = data.map(function(d, i) {
                        return +value.call(pie, d, i);
                    }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
                    if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                        return values[j] - values[i];
                    } : function(i, j) {
                        return sort(data[i], data[j]);
                    });
                    index.forEach(function(i) {
                        arcs[i] = {
                            data: data[i],
                            value: v = values[i],
                            startAngle: a,
                            endAngle: a += v * k + pa,
                            padAngle: p
                        };
                    });
                    return arcs;
                }
                pie.value = function(_) {
                    if (!arguments.length) return value;
                    value = _;
                    return pie;
                };
                pie.sort = function(_) {
                    if (!arguments.length) return sort;
                    sort = _;
                    return pie;
                };
                pie.startAngle = function(_) {
                    if (!arguments.length) return startAngle;
                    startAngle = _;
                    return pie;
                };
                pie.endAngle = function(_) {
                    if (!arguments.length) return endAngle;
                    endAngle = _;
                    return pie;
                };
                pie.padAngle = function(_) {
                    if (!arguments.length) return padAngle;
                    padAngle = _;
                    return pie;
                };
                return pie;
            };
            var d3_layout_pieSortByValue = {};
            d3.layout.stack = function() {
                var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
                function stack(data, index) {
                    if (!(n = data.length)) return data;
                    var series = data.map(function(d, i) {
                        return values.call(stack, d, i);
                    });
                    var points = series.map(function(d) {
                        return d.map(function(v, i) {
                            return [ x.call(stack, v, i), y.call(stack, v, i) ];
                        });
                    });
                    var orders = order.call(stack, points, index);
                    series = d3.permute(series, orders);
                    points = d3.permute(points, orders);
                    var offsets = offset.call(stack, points, index);
                    var m = series[0].length, n, i, j, o;
                    for (j = 0; j < m; ++j) {
                        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                        for (i = 1; i < n; ++i) {
                            out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                        }
                    }
                    return data;
                }
                stack.values = function(x) {
                    if (!arguments.length) return values;
                    values = x;
                    return stack;
                };
                stack.order = function(x) {
                    if (!arguments.length) return order;
                    order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
                    return stack;
                };
                stack.offset = function(x) {
                    if (!arguments.length) return offset;
                    offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
                    return stack;
                };
                stack.x = function(z) {
                    if (!arguments.length) return x;
                    x = z;
                    return stack;
                };
                stack.y = function(z) {
                    if (!arguments.length) return y;
                    y = z;
                    return stack;
                };
                stack.out = function(z) {
                    if (!arguments.length) return out;
                    out = z;
                    return stack;
                };
                return stack;
            };
            function d3_layout_stackX(d) {
                return d.x;
            }
            function d3_layout_stackY(d) {
                return d.y;
            }
            function d3_layout_stackOut(d, y0, y) {
                d.y0 = y0;
                d.y = y;
            }
            var d3_layout_stackOrders = d3.map({
                "inside-out": function(data) {
                    var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                        return max[a] - max[b];
                    }), top = 0, bottom = 0, tops = [], bottoms = [];
                    for (i = 0; i < n; ++i) {
                        j = index[i];
                        if (top < bottom) {
                            top += sums[j];
                            tops.push(j);
                        } else {
                            bottom += sums[j];
                            bottoms.push(j);
                        }
                    }
                    return bottoms.reverse().concat(tops);
                },
                reverse: function(data) {
                    return d3.range(data.length).reverse();
                },
                "default": d3_layout_stackOrderDefault
            });
            var d3_layout_stackOffsets = d3.map({
                silhouette: function(data) {
                    var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
                    for (j = 0; j < m; ++j) {
                        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                        if (o > max) max = o;
                        sums.push(o);
                    }
                    for (j = 0; j < m; ++j) {
                        y0[j] = (max - sums[j]) / 2;
                    }
                    return y0;
                },
                wiggle: function(data) {
                    var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
                    y0[0] = o = o0 = 0;
                    for (j = 1; j < m; ++j) {
                        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                            for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                            }
                            s2 += s3 * data[i][j][1];
                        }
                        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                        if (o < o0) o0 = o;
                    }
                    for (j = 0; j < m; ++j) y0[j] -= o0;
                    return y0;
                },
                expand: function(data) {
                    var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
                    for (j = 0; j < m; ++j) {
                        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
                    }
                    for (j = 0; j < m; ++j) y0[j] = 0;
                    return y0;
                },
                zero: d3_layout_stackOffsetZero
            });
            function d3_layout_stackOrderDefault(data) {
                return d3.range(data.length);
            }
            function d3_layout_stackOffsetZero(data) {
                var j = -1, m = data[0].length, y0 = [];
                while (++j < m) y0[j] = 0;
                return y0;
            }
            function d3_layout_stackMaxIndex(array) {
                var i = 1, j = 0, v = array[0][1], k, n = array.length;
                for (;i < n; ++i) {
                    if ((k = array[i][1]) > v) {
                        j = i;
                        v = k;
                    }
                }
                return j;
            }
            function d3_layout_stackReduceSum(d) {
                return d.reduce(d3_layout_stackSum, 0);
            }
            function d3_layout_stackSum(p, d) {
                return p + d[1];
            }
            d3.layout.histogram = function() {
                var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
                function histogram(data, i) {
                    var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
                    while (++i < m) {
                        bin = bins[i] = [];
                        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                        bin.y = 0;
                    }
                    if (m > 0) {
                        i = -1;
                        while (++i < n) {
                            x = values[i];
                            if (x >= range[0] && x <= range[1]) {
                                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                                bin.y += k;
                                bin.push(data[i]);
                            }
                        }
                    }
                    return bins;
                }
                histogram.value = function(x) {
                    if (!arguments.length) return valuer;
                    valuer = x;
                    return histogram;
                };
                histogram.range = function(x) {
                    if (!arguments.length) return ranger;
                    ranger = d3_functor(x);
                    return histogram;
                };
                histogram.bins = function(x) {
                    if (!arguments.length) return binner;
                    binner = typeof x === "number" ? function(range) {
                        return d3_layout_histogramBinFixed(range, x);
                    } : d3_functor(x);
                    return histogram;
                };
                histogram.frequency = function(x) {
                    if (!arguments.length) return frequency;
                    frequency = !!x;
                    return histogram;
                };
                return histogram;
            };
            function d3_layout_histogramBinSturges(range, values) {
                return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
            }
            function d3_layout_histogramBinFixed(range, n) {
                var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
                while (++x <= n) f[x] = m * x + b;
                return f;
            }
            function d3_layout_histogramRange(values) {
                return [ d3.min(values), d3.max(values) ];
            }
            d3.layout.pack = function() {
                var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
                function pack(d, i) {
                    var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                        return radius;
                    };
                    root.x = root.y = 0;
                    d3_layout_hierarchyVisitAfter(root, function(d) {
                        d.r = +r(d.value);
                    });
                    d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                    if (padding) {
                        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                        d3_layout_hierarchyVisitAfter(root, function(d) {
                            d.r += dr;
                        });
                        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                        d3_layout_hierarchyVisitAfter(root, function(d) {
                            d.r -= dr;
                        });
                    }
                    d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
                    return nodes;
                }
                pack.size = function(_) {
                    if (!arguments.length) return size;
                    size = _;
                    return pack;
                };
                pack.radius = function(_) {
                    if (!arguments.length) return radius;
                    radius = _ == null || typeof _ === "function" ? _ : +_;
                    return pack;
                };
                pack.padding = function(_) {
                    if (!arguments.length) return padding;
                    padding = +_;
                    return pack;
                };
                return d3_layout_hierarchyRebind(pack, hierarchy);
            };
            function d3_layout_packSort(a, b) {
                return a.value - b.value;
            }
            function d3_layout_packInsert(a, b) {
                var c = a._pack_next;
                a._pack_next = b;
                b._pack_prev = a;
                b._pack_next = c;
                c._pack_prev = b;
            }
            function d3_layout_packSplice(a, b) {
                a._pack_next = b;
                b._pack_prev = a;
            }
            function d3_layout_packIntersects(a, b) {
                var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
                return .999 * dr * dr > dx * dx + dy * dy;
            }
            function d3_layout_packSiblings(node) {
                if (!(nodes = node.children) || !(n = nodes.length)) return;
                var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
                function bound(node) {
                    xMin = Math.min(node.x - node.r, xMin);
                    xMax = Math.max(node.x + node.r, xMax);
                    yMin = Math.min(node.y - node.r, yMin);
                    yMax = Math.max(node.y + node.r, yMax);
                }
                nodes.forEach(d3_layout_packLink);
                a = nodes[0];
                a.x = -a.r;
                a.y = 0;
                bound(a);
                if (n > 1) {
                    b = nodes[1];
                    b.x = b.r;
                    b.y = 0;
                    bound(b);
                    if (n > 2) {
                        c = nodes[2];
                        d3_layout_packPlace(a, b, c);
                        bound(c);
                        d3_layout_packInsert(a, c);
                        a._pack_prev = c;
                        d3_layout_packInsert(c, b);
                        b = a._pack_next;
                        for (i = 3; i < n; i++) {
                            d3_layout_packPlace(a, b, c = nodes[i]);
                            var isect = 0, s1 = 1, s2 = 1;
                            for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                                if (d3_layout_packIntersects(j, c)) {
                                    isect = 1;
                                    break;
                                }
                            }
                            if (isect == 1) {
                                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                                    if (d3_layout_packIntersects(k, c)) {
                                        break;
                                    }
                                }
                            }
                            if (isect) {
                                if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                                i--;
                            } else {
                                d3_layout_packInsert(a, c);
                                b = c;
                                bound(c);
                            }
                        }
                    }
                }
                var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
                for (i = 0; i < n; i++) {
                    c = nodes[i];
                    c.x -= cx;
                    c.y -= cy;
                    cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
                }
                node.r = cr;
                nodes.forEach(d3_layout_packUnlink);
            }
            function d3_layout_packLink(node) {
                node._pack_next = node._pack_prev = node;
            }
            function d3_layout_packUnlink(node) {
                delete node._pack_next;
                delete node._pack_prev;
            }
            function d3_layout_packTransform(node, x, y, k) {
                var children = node.children;
                node.x = x += k * node.x;
                node.y = y += k * node.y;
                node.r *= k;
                if (children) {
                    var i = -1, n = children.length;
                    while (++i < n) d3_layout_packTransform(children[i], x, y, k);
                }
            }
            function d3_layout_packPlace(a, b, c) {
                var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
                if (db && (dx || dy)) {
                    var da = b.r + c.r, dc = dx * dx + dy * dy;
                    da *= da;
                    db *= db;
                    var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
                    c.x = a.x + x * dx + y * dy;
                    c.y = a.y + x * dy - y * dx;
                } else {
                    c.x = a.x + db;
                    c.y = a.y;
                }
            }
            d3.layout.tree = function() {
                var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
                function tree(d, i) {
                    var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
                    d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
                    d3_layout_hierarchyVisitBefore(root1, secondWalk);
                    if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
                        var left = root0, right = root0, bottom = root0;
                        d3_layout_hierarchyVisitBefore(root0, function(node) {
                            if (node.x < left.x) left = node;
                            if (node.x > right.x) right = node;
                            if (node.depth > bottom.depth) bottom = node;
                        });
                        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                        d3_layout_hierarchyVisitBefore(root0, function(node) {
                            node.x = (node.x + tx) * kx;
                            node.y = node.depth * ky;
                        });
                    }
                    return nodes;
                }
                function wrapTree(root0) {
                    var root1 = {
                        A: null,
                        children: [ root0 ]
                    }, queue = [ root1 ], node1;
                    while ((node1 = queue.pop()) != null) {
                        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                            queue.push((children[i] = child = {
                                _: children[i],
                                parent: node1,
                                children: (child = children[i].children) && child.slice() || [],
                                A: null,
                                a: null,
                                z: 0,
                                m: 0,
                                c: 0,
                                s: 0,
                                t: null,
                                i: i
                            }).a = child);
                        }
                    }
                    return root1.children[0];
                }
                function firstWalk(v) {
                    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
                    if (children.length) {
                        d3_layout_treeShift(v);
                        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                        if (w) {
                            v.z = w.z + separation(v._, w._);
                            v.m = v.z - midpoint;
                        } else {
                            v.z = midpoint;
                        }
                    } else if (w) {
                        v.z = w.z + separation(v._, w._);
                    }
                    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
                }
                function secondWalk(v) {
                    v._.x = v.z + v.parent.m;
                    v.m += v.parent.m;
                }
                function apportion(v, w, ancestor) {
                    if (w) {
                        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                            vom = d3_layout_treeLeft(vom);
                            vop = d3_layout_treeRight(vop);
                            vop.a = v;
                            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                            if (shift > 0) {
                                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                                sip += shift;
                                sop += shift;
                            }
                            sim += vim.m;
                            sip += vip.m;
                            som += vom.m;
                            sop += vop.m;
                        }
                        if (vim && !d3_layout_treeRight(vop)) {
                            vop.t = vim;
                            vop.m += sim - sop;
                        }
                        if (vip && !d3_layout_treeLeft(vom)) {
                            vom.t = vip;
                            vom.m += sip - som;
                            ancestor = v;
                        }
                    }
                    return ancestor;
                }
                function sizeNode(node) {
                    node.x *= size[0];
                    node.y = node.depth * size[1];
                }
                tree.separation = function(x) {
                    if (!arguments.length) return separation;
                    separation = x;
                    return tree;
                };
                tree.size = function(x) {
                    if (!arguments.length) return nodeSize ? null : size;
                    nodeSize = (size = x) == null ? sizeNode : null;
                    return tree;
                };
                tree.nodeSize = function(x) {
                    if (!arguments.length) return nodeSize ? size : null;
                    nodeSize = (size = x) == null ? null : sizeNode;
                    return tree;
                };
                return d3_layout_hierarchyRebind(tree, hierarchy);
            };
            function d3_layout_treeSeparation(a, b) {
                return a.parent == b.parent ? 1 : 2;
            }
            function d3_layout_treeLeft(v) {
                var children = v.children;
                return children.length ? children[0] : v.t;
            }
            function d3_layout_treeRight(v) {
                var children = v.children, n;
                return (n = children.length) ? children[n - 1] : v.t;
            }
            function d3_layout_treeMove(wm, wp, shift) {
                var change = shift / (wp.i - wm.i);
                wp.c -= change;
                wp.s += shift;
                wm.c += change;
                wp.z += shift;
                wp.m += shift;
            }
            function d3_layout_treeShift(v) {
                var shift = 0, change = 0, children = v.children, i = children.length, w;
                while (--i >= 0) {
                    w = children[i];
                    w.z += shift;
                    w.m += shift;
                    shift += w.s + (change += w.c);
                }
            }
            function d3_layout_treeAncestor(vim, v, ancestor) {
                return vim.a.parent === v.parent ? vim.a : ancestor;
            }
            d3.layout.cluster = function() {
                var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
                function cluster(d, i) {
                    var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
                    d3_layout_hierarchyVisitAfter(root, function(node) {
                        var children = node.children;
                        if (children && children.length) {
                            node.x = d3_layout_clusterX(children);
                            node.y = d3_layout_clusterY(children);
                        } else {
                            node.x = previousNode ? x += separation(node, previousNode) : 0;
                            node.y = 0;
                            previousNode = node;
                        }
                    });
                    var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
                    d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                        node.x = (node.x - root.x) * size[0];
                        node.y = (root.y - node.y) * size[1];
                    } : function(node) {
                        node.x = (node.x - x0) / (x1 - x0) * size[0];
                        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
                    });
                    return nodes;
                }
                cluster.separation = function(x) {
                    if (!arguments.length) return separation;
                    separation = x;
                    return cluster;
                };
                cluster.size = function(x) {
                    if (!arguments.length) return nodeSize ? null : size;
                    nodeSize = (size = x) == null;
                    return cluster;
                };
                cluster.nodeSize = function(x) {
                    if (!arguments.length) return nodeSize ? size : null;
                    nodeSize = (size = x) != null;
                    return cluster;
                };
                return d3_layout_hierarchyRebind(cluster, hierarchy);
            };
            function d3_layout_clusterY(children) {
                return 1 + d3.max(children, function(child) {
                    return child.y;
                });
            }
            function d3_layout_clusterX(children) {
                return children.reduce(function(x, child) {
                    return x + child.x;
                }, 0) / children.length;
            }
            function d3_layout_clusterLeft(node) {
                var children = node.children;
                return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
            }
            function d3_layout_clusterRight(node) {
                var children = node.children, n;
                return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
            }
            d3.layout.treemap = function() {
                var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
                function scale(children, k) {
                    var i = -1, n = children.length, child, area;
                    while (++i < n) {
                        area = (child = children[i]).value * (k < 0 ? 0 : k);
                        child.area = isNaN(area) || area <= 0 ? 0 : area;
                    }
                }
                function squarify(node) {
                    var children = node.children;
                    if (children && children.length) {
                        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                        scale(remaining, rect.dx * rect.dy / node.value);
                        row.area = 0;
                        while ((n = remaining.length) > 0) {
                            row.push(child = remaining[n - 1]);
                            row.area += child.area;
                            if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                                remaining.pop();
                                best = score;
                            } else {
                                row.area -= row.pop().area;
                                position(row, u, rect, false);
                                u = Math.min(rect.dx, rect.dy);
                                row.length = row.area = 0;
                                best = Infinity;
                            }
                        }
                        if (row.length) {
                            position(row, u, rect, true);
                            row.length = row.area = 0;
                        }
                        children.forEach(squarify);
                    }
                }
                function stickify(node) {
                    var children = node.children;
                    if (children && children.length) {
                        var rect = pad(node), remaining = children.slice(), child, row = [];
                        scale(remaining, rect.dx * rect.dy / node.value);
                        row.area = 0;
                        while (child = remaining.pop()) {
                            row.push(child);
                            row.area += child.area;
                            if (child.z != null) {
                                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                                row.length = row.area = 0;
                            }
                        }
                        children.forEach(stickify);
                    }
                }
                function worst(row, u) {
                    var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
                    while (++i < n) {
                        if (!(r = row[i].area)) continue;
                        if (r < rmin) rmin = r;
                        if (r > rmax) rmax = r;
                    }
                    s *= s;
                    u *= u;
                    return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
                }
                function position(row, u, rect, flush) {
                    var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
                    if (u == rect.dx) {
                        if (flush || v > rect.dy) v = rect.dy;
                        while (++i < n) {
                            o = row[i];
                            o.x = x;
                            o.y = y;
                            o.dy = v;
                            x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                        }
                        o.z = true;
                        o.dx += rect.x + rect.dx - x;
                        rect.y += v;
                        rect.dy -= v;
                    } else {
                        if (flush || v > rect.dx) v = rect.dx;
                        while (++i < n) {
                            o = row[i];
                            o.x = x;
                            o.y = y;
                            o.dx = v;
                            y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                        }
                        o.z = false;
                        o.dy += rect.y + rect.dy - y;
                        rect.x += v;
                        rect.dx -= v;
                    }
                }
                function treemap(d) {
                    var nodes = stickies || hierarchy(d), root = nodes[0];
                    root.x = 0;
                    root.y = 0;
                    root.dx = size[0];
                    root.dy = size[1];
                    if (stickies) hierarchy.revalue(root);
                    scale([ root ], root.dx * root.dy / root.value);
                    (stickies ? stickify : squarify)(root);
                    if (sticky) stickies = nodes;
                    return nodes;
                }
                treemap.size = function(x) {
                    if (!arguments.length) return size;
                    size = x;
                    return treemap;
                };
                treemap.padding = function(x) {
                    if (!arguments.length) return padding;
                    function padFunction(node) {
                        var p = x.call(treemap, node, node.depth);
                        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
                    }
                    function padConstant(node) {
                        return d3_layout_treemapPad(node, x);
                    }
                    var type;
                    pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
                    padConstant) : padConstant;
                    return treemap;
                };
                treemap.round = function(x) {
                    if (!arguments.length) return round != Number;
                    round = x ? Math.round : Number;
                    return treemap;
                };
                treemap.sticky = function(x) {
                    if (!arguments.length) return sticky;
                    sticky = x;
                    stickies = null;
                    return treemap;
                };
                treemap.ratio = function(x) {
                    if (!arguments.length) return ratio;
                    ratio = x;
                    return treemap;
                };
                treemap.mode = function(x) {
                    if (!arguments.length) return mode;
                    mode = x + "";
                    return treemap;
                };
                return d3_layout_hierarchyRebind(treemap, hierarchy);
            };
            function d3_layout_treemapPadNull(node) {
                return {
                    x: node.x,
                    y: node.y,
                    dx: node.dx,
                    dy: node.dy
                };
            }
            function d3_layout_treemapPad(node, padding) {
                var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
                if (dx < 0) {
                    x += dx / 2;
                    dx = 0;
                }
                if (dy < 0) {
                    y += dy / 2;
                    dy = 0;
                }
                return {
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy
                };
            }
            d3.random = {
                normal: function(µ, σ) {
                    var n = arguments.length;
                    if (n < 2) σ = 1;
                    if (n < 1) µ = 0;
                    return function() {
                        var x, y, r;
                        do {
                            x = Math.random() * 2 - 1;
                            y = Math.random() * 2 - 1;
                            r = x * x + y * y;
                        } while (!r || r > 1);
                        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
                    };
                },
                logNormal: function() {
                    var random = d3.random.normal.apply(d3, arguments);
                    return function() {
                        return Math.exp(random());
                    };
                },
                bates: function(m) {
                    var random = d3.random.irwinHall(m);
                    return function() {
                        return random() / m;
                    };
                },
                irwinHall: function(m) {
                    return function() {
                        for (var s = 0, j = 0; j < m; j++) s += Math.random();
                        return s;
                    };
                }
            };
            d3.scale = {};
            function d3_scaleExtent(domain) {
                var start = domain[0], stop = domain[domain.length - 1];
                return start < stop ? [ start, stop ] : [ stop, start ];
            }
            function d3_scaleRange(scale) {
                return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
            }
            function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
                var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
                return function(x) {
                    return i(u(x));
                };
            }
            function d3_scale_nice(domain, nice) {
                var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
                if (x1 < x0) {
                    dx = i0, i0 = i1, i1 = dx;
                    dx = x0, x0 = x1, x1 = dx;
                }
                domain[i0] = nice.floor(x0);
                domain[i1] = nice.ceil(x1);
                return domain;
            }
            function d3_scale_niceStep(step) {
                return step ? {
                    floor: function(x) {
                        return Math.floor(x / step) * step;
                    },
                    ceil: function(x) {
                        return Math.ceil(x / step) * step;
                    }
                } : d3_scale_niceIdentity;
            }
            var d3_scale_niceIdentity = {
                floor: d3_identity,
                ceil: d3_identity
            };
            function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
                var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
                if (domain[k] < domain[0]) {
                    domain = domain.slice().reverse();
                    range = range.slice().reverse();
                }
                while (++j <= k) {
                    u.push(uninterpolate(domain[j - 1], domain[j]));
                    i.push(interpolate(range[j - 1], range[j]));
                }
                return function(x) {
                    var j = d3.bisect(domain, x, 1, k) - 1;
                    return i[j](u[j](x));
                };
            }
            d3.scale.linear = function() {
                return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
            };
            function d3_scale_linear(domain, range, interpolate, clamp) {
                var output, input;
                function rescale() {
                    var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
                    output = linear(domain, range, uninterpolate, interpolate);
                    input = linear(range, domain, uninterpolate, d3_interpolate);
                    return scale;
                }
                function scale(x) {
                    return output(x);
                }
                scale.invert = function(y) {
                    return input(y);
                };
                scale.domain = function(x) {
                    if (!arguments.length) return domain;
                    domain = x.map(Number);
                    return rescale();
                };
                scale.range = function(x) {
                    if (!arguments.length) return range;
                    range = x;
                    return rescale();
                };
                scale.rangeRound = function(x) {
                    return scale.range(x).interpolate(d3_interpolateRound);
                };
                scale.clamp = function(x) {
                    if (!arguments.length) return clamp;
                    clamp = x;
                    return rescale();
                };
                scale.interpolate = function(x) {
                    if (!arguments.length) return interpolate;
                    interpolate = x;
                    return rescale();
                };
                scale.ticks = function(m) {
                    return d3_scale_linearTicks(domain, m);
                };
                scale.tickFormat = function(m, format) {
                    return d3_scale_linearTickFormat(domain, m, format);
                };
                scale.nice = function(m) {
                    d3_scale_linearNice(domain, m);
                    return rescale();
                };
                scale.copy = function() {
                    return d3_scale_linear(domain, range, interpolate, clamp);
                };
                return rescale();
            }
            function d3_scale_linearRebind(scale, linear) {
                return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
            }
            function d3_scale_linearNice(domain, m) {
                return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
            }
            function d3_scale_linearTickRange(domain, m) {
                if (m == null) m = 10;
                var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
                if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
                extent[0] = Math.ceil(extent[0] / step) * step;
                extent[1] = Math.floor(extent[1] / step) * step + step * .5;
                extent[2] = step;
                return extent;
            }
            function d3_scale_linearTicks(domain, m) {
                return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
            }
            function d3_scale_linearTickFormat(domain, m, format) {
                var range = d3_scale_linearTickRange(domain, m);
                if (format) {
                    var match = d3_format_re.exec(format);
                    match.shift();
                    if (match[8] === "s") {
                        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                        match[8] = "f";
                        format = d3.format(match.join(""));
                        return function(d) {
                            return format(prefix.scale(d)) + prefix.symbol;
                        };
                    }
                    if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
                    format = match.join("");
                } else {
                    format = ",." + d3_scale_linearPrecision(range[2]) + "f";
                }
                return d3.format(format);
            }
            var d3_scale_linearFormatSignificant = {
                s: 1,
                g: 1,
                p: 1,
                r: 1,
                e: 1
            };
            function d3_scale_linearPrecision(value) {
                return -Math.floor(Math.log(value) / Math.LN10 + .01);
            }
            function d3_scale_linearFormatPrecision(type, range) {
                var p = d3_scale_linearPrecision(range[2]);
                return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
            }
            d3.scale.log = function() {
                return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
            };
            function d3_scale_log(linear, base, positive, domain) {
                function log(x) {
                    return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
                }
                function pow(x) {
                    return positive ? Math.pow(base, x) : -Math.pow(base, -x);
                }
                function scale(x) {
                    return linear(log(x));
                }
                scale.invert = function(x) {
                    return pow(linear.invert(x));
                };
                scale.domain = function(x) {
                    if (!arguments.length) return domain;
                    positive = x[0] >= 0;
                    linear.domain((domain = x.map(Number)).map(log));
                    return scale;
                };
                scale.base = function(_) {
                    if (!arguments.length) return base;
                    base = +_;
                    linear.domain(domain.map(log));
                    return scale;
                };
                scale.nice = function() {
                    var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
                    linear.domain(niced);
                    domain = niced.map(pow);
                    return scale;
                };
                scale.ticks = function() {
                    var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
                    if (isFinite(j - i)) {
                        if (positive) {
                            for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                            ticks.push(pow(i));
                        } else {
                            ticks.push(pow(i));
                            for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                        }
                        for (i = 0; ticks[i] < u; i++) {}
                        for (j = ticks.length; ticks[j - 1] > v; j--) {}
                        ticks = ticks.slice(i, j);
                    }
                    return ticks;
                };
                scale.tickFormat = function(n, format) {
                    if (!arguments.length) return d3_scale_logFormat;
                    if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
                    var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
                    Math.floor), e;
                    return function(d) {
                        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
                    };
                };
                scale.copy = function() {
                    return d3_scale_log(linear.copy(), base, positive, domain);
                };
                return d3_scale_linearRebind(scale, linear);
            }
            var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
                floor: function(x) {
                    return -Math.ceil(-x);
                },
                ceil: function(x) {
                    return -Math.floor(-x);
                }
            };
            d3.scale.pow = function() {
                return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
            };
            function d3_scale_pow(linear, exponent, domain) {
                var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
                function scale(x) {
                    return linear(powp(x));
                }
                scale.invert = function(x) {
                    return powb(linear.invert(x));
                };
                scale.domain = function(x) {
                    if (!arguments.length) return domain;
                    linear.domain((domain = x.map(Number)).map(powp));
                    return scale;
                };
                scale.ticks = function(m) {
                    return d3_scale_linearTicks(domain, m);
                };
                scale.tickFormat = function(m, format) {
                    return d3_scale_linearTickFormat(domain, m, format);
                };
                scale.nice = function(m) {
                    return scale.domain(d3_scale_linearNice(domain, m));
                };
                scale.exponent = function(x) {
                    if (!arguments.length) return exponent;
                    powp = d3_scale_powPow(exponent = x);
                    powb = d3_scale_powPow(1 / exponent);
                    linear.domain(domain.map(powp));
                    return scale;
                };
                scale.copy = function() {
                    return d3_scale_pow(linear.copy(), exponent, domain);
                };
                return d3_scale_linearRebind(scale, linear);
            }
            function d3_scale_powPow(e) {
                return function(x) {
                    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
                };
            }
            d3.scale.sqrt = function() {
                return d3.scale.pow().exponent(.5);
            };
            d3.scale.ordinal = function() {
                return d3_scale_ordinal([], {
                    t: "range",
                    a: [ [] ]
                });
            };
            function d3_scale_ordinal(domain, ranger) {
                var index, range, rangeBand;
                function scale(x) {
                    return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
                }
                function steps(start, step) {
                    return d3.range(domain.length).map(function(i) {
                        return start + step * i;
                    });
                }
                scale.domain = function(x) {
                    if (!arguments.length) return domain;
                    domain = [];
                    index = new d3_Map();
                    var i = -1, n = x.length, xi;
                    while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
                    return scale[ranger.t].apply(scale, ranger.a);
                };
                scale.range = function(x) {
                    if (!arguments.length) return range;
                    range = x;
                    rangeBand = 0;
                    ranger = {
                        t: "range",
                        a: arguments
                    };
                    return scale;
                };
                scale.rangePoints = function(x, padding) {
                    if (arguments.length < 2) padding = 0;
                    var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
                    0) : (stop - start) / (domain.length - 1 + padding);
                    range = steps(start + step * padding / 2, step);
                    rangeBand = 0;
                    ranger = {
                        t: "rangePoints",
                        a: arguments
                    };
                    return scale;
                };
                scale.rangeRoundPoints = function(x, padding) {
                    if (arguments.length < 2) padding = 0;
                    var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
                    0) : (stop - start) / (domain.length - 1 + padding) | 0;
                    range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
                    rangeBand = 0;
                    ranger = {
                        t: "rangeRoundPoints",
                        a: arguments
                    };
                    return scale;
                };
                scale.rangeBands = function(x, padding, outerPadding) {
                    if (arguments.length < 2) padding = 0;
                    if (arguments.length < 3) outerPadding = padding;
                    var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
                    range = steps(start + step * outerPadding, step);
                    if (reverse) range.reverse();
                    rangeBand = step * (1 - padding);
                    ranger = {
                        t: "rangeBands",
                        a: arguments
                    };
                    return scale;
                };
                scale.rangeRoundBands = function(x, padding, outerPadding) {
                    if (arguments.length < 2) padding = 0;
                    if (arguments.length < 3) outerPadding = padding;
                    var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
                    range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
                    if (reverse) range.reverse();
                    rangeBand = Math.round(step * (1 - padding));
                    ranger = {
                        t: "rangeRoundBands",
                        a: arguments
                    };
                    return scale;
                };
                scale.rangeBand = function() {
                    return rangeBand;
                };
                scale.rangeExtent = function() {
                    return d3_scaleExtent(ranger.a[0]);
                };
                scale.copy = function() {
                    return d3_scale_ordinal(domain, ranger);
                };
                return scale.domain(domain);
            }
            d3.scale.category10 = function() {
                return d3.scale.ordinal().range(d3_category10);
            };
            d3.scale.category20 = function() {
                return d3.scale.ordinal().range(d3_category20);
            };
            d3.scale.category20b = function() {
                return d3.scale.ordinal().range(d3_category20b);
            };
            d3.scale.category20c = function() {
                return d3.scale.ordinal().range(d3_category20c);
            };
            var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
            var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
            var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
            var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
            d3.scale.quantile = function() {
                return d3_scale_quantile([], []);
            };
            function d3_scale_quantile(domain, range) {
                var thresholds;
                function rescale() {
                    var k = 0, q = range.length;
                    thresholds = [];
                    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
                    return scale;
                }
                function scale(x) {
                    if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
                }
                scale.domain = function(x) {
                    if (!arguments.length) return domain;
                    domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
                    return rescale();
                };
                scale.range = function(x) {
                    if (!arguments.length) return range;
                    range = x;
                    return rescale();
                };
                scale.quantiles = function() {
                    return thresholds;
                };
                scale.invertExtent = function(y) {
                    y = range.indexOf(y);
                    return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
                };
                scale.copy = function() {
                    return d3_scale_quantile(domain, range);
                };
                return rescale();
            }
            d3.scale.quantize = function() {
                return d3_scale_quantize(0, 1, [ 0, 1 ]);
            };
            function d3_scale_quantize(x0, x1, range) {
                var kx, i;
                function scale(x) {
                    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
                }
                function rescale() {
                    kx = range.length / (x1 - x0);
                    i = range.length - 1;
                    return scale;
                }
                scale.domain = function(x) {
                    if (!arguments.length) return [ x0, x1 ];
                    x0 = +x[0];
                    x1 = +x[x.length - 1];
                    return rescale();
                };
                scale.range = function(x) {
                    if (!arguments.length) return range;
                    range = x;
                    return rescale();
                };
                scale.invertExtent = function(y) {
                    y = range.indexOf(y);
                    y = y < 0 ? NaN : y / kx + x0;
                    return [ y, y + 1 / kx ];
                };
                scale.copy = function() {
                    return d3_scale_quantize(x0, x1, range);
                };
                return rescale();
            }
            d3.scale.threshold = function() {
                return d3_scale_threshold([ .5 ], [ 0, 1 ]);
            };
            function d3_scale_threshold(domain, range) {
                function scale(x) {
                    if (x <= x) return range[d3.bisect(domain, x)];
                }
                scale.domain = function(_) {
                    if (!arguments.length) return domain;
                    domain = _;
                    return scale;
                };
                scale.range = function(_) {
                    if (!arguments.length) return range;
                    range = _;
                    return scale;
                };
                scale.invertExtent = function(y) {
                    y = range.indexOf(y);
                    return [ domain[y - 1], domain[y] ];
                };
                scale.copy = function() {
                    return d3_scale_threshold(domain, range);
                };
                return scale;
            }
            d3.scale.identity = function() {
                return d3_scale_identity([ 0, 1 ]);
            };
            function d3_scale_identity(domain) {
                function identity(x) {
                    return +x;
                }
                identity.invert = identity;
                identity.domain = identity.range = function(x) {
                    if (!arguments.length) return domain;
                    domain = x.map(identity);
                    return identity;
                };
                identity.ticks = function(m) {
                    return d3_scale_linearTicks(domain, m);
                };
                identity.tickFormat = function(m, format) {
                    return d3_scale_linearTickFormat(domain, m, format);
                };
                identity.copy = function() {
                    return d3_scale_identity(domain);
                };
                return identity;
            }
            d3.svg = {};
            function d3_zero() {
                return 0;
            }
            d3.svg.arc = function() {
                var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
                function arc() {
                    var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
                    if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
                    if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
                    var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
                    if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                        if (!cw) p1 *= -1;
                        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
                    }
                    if (r1) {
                        x0 = r1 * Math.cos(a0 + p1);
                        y0 = r1 * Math.sin(a0 + p1);
                        x1 = r1 * Math.cos(a1 - p1);
                        y1 = r1 * Math.sin(a1 - p1);
                        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                            var h1 = (a0 + a1) / 2;
                            x0 = r1 * Math.cos(h1);
                            y0 = r1 * Math.sin(h1);
                            x1 = y1 = null;
                        }
                    } else {
                        x0 = y0 = 0;
                    }
                    if (r0) {
                        x2 = r0 * Math.cos(a1 - p0);
                        y2 = r0 * Math.sin(a1 - p0);
                        x3 = r0 * Math.cos(a0 + p0);
                        y3 = r0 * Math.sin(a0 + p0);
                        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                            var h0 = (a0 + a1) / 2;
                            x2 = r0 * Math.cos(h0);
                            y2 = r0 * Math.sin(h0);
                            x3 = y3 = null;
                        }
                    } else {
                        x2 = y2 = 0;
                    }
                    if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                        cr = r0 < r1 ^ cw ? 0 : 1;
                        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                        if (x1 != null) {
                            var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                            if (rc === rc1) {
                                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                            } else {
                                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                            }
                        } else {
                            path.push("M", x0, ",", y0);
                        }
                        if (x3 != null) {
                            var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                            if (rc === rc0) {
                                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                            } else {
                                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                            }
                        } else {
                            path.push("L", x2, ",", y2);
                        }
                    } else {
                        path.push("M", x0, ",", y0);
                        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                        path.push("L", x2, ",", y2);
                        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
                    }
                    path.push("Z");
                    return path.join("");
                }
                function circleSegment(r1, cw) {
                    return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
                }
                arc.innerRadius = function(v) {
                    if (!arguments.length) return innerRadius;
                    innerRadius = d3_functor(v);
                    return arc;
                };
                arc.outerRadius = function(v) {
                    if (!arguments.length) return outerRadius;
                    outerRadius = d3_functor(v);
                    return arc;
                };
                arc.cornerRadius = function(v) {
                    if (!arguments.length) return cornerRadius;
                    cornerRadius = d3_functor(v);
                    return arc;
                };
                arc.padRadius = function(v) {
                    if (!arguments.length) return padRadius;
                    padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
                    return arc;
                };
                arc.startAngle = function(v) {
                    if (!arguments.length) return startAngle;
                    startAngle = d3_functor(v);
                    return arc;
                };
                arc.endAngle = function(v) {
                    if (!arguments.length) return endAngle;
                    endAngle = d3_functor(v);
                    return arc;
                };
                arc.padAngle = function(v) {
                    if (!arguments.length) return padAngle;
                    padAngle = d3_functor(v);
                    return arc;
                };
                arc.centroid = function() {
                    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
                    return [ Math.cos(a) * r, Math.sin(a) * r ];
                };
                return arc;
            };
            var d3_svg_arcAuto = "auto";
            function d3_svg_arcInnerRadius(d) {
                return d.innerRadius;
            }
            function d3_svg_arcOuterRadius(d) {
                return d.outerRadius;
            }
            function d3_svg_arcStartAngle(d) {
                return d.startAngle;
            }
            function d3_svg_arcEndAngle(d) {
                return d.endAngle;
            }
            function d3_svg_arcPadAngle(d) {
                return d && d.padAngle;
            }
            function d3_svg_arcSweep(x0, y0, x1, y1) {
                return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
            }
            function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
                var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
                if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
                return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
            }
            function d3_svg_line(projection) {
                var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
                function line(data) {
                    var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
                    function segment() {
                        segments.push("M", interpolate(projection(points), tension));
                    }
                    while (++i < n) {
                        if (defined.call(this, d = data[i], i)) {
                            points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                        } else if (points.length) {
                            segment();
                            points = [];
                        }
                    }
                    if (points.length) segment();
                    return segments.length ? segments.join("") : null;
                }
                line.x = function(_) {
                    if (!arguments.length) return x;
                    x = _;
                    return line;
                };
                line.y = function(_) {
                    if (!arguments.length) return y;
                    y = _;
                    return line;
                };
                line.defined = function(_) {
                    if (!arguments.length) return defined;
                    defined = _;
                    return line;
                };
                line.interpolate = function(_) {
                    if (!arguments.length) return interpolateKey;
                    if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
                    return line;
                };
                line.tension = function(_) {
                    if (!arguments.length) return tension;
                    tension = _;
                    return line;
                };
                return line;
            }
            d3.svg.line = function() {
                return d3_svg_line(d3_identity);
            };
            var d3_svg_lineInterpolators = d3.map({
                linear: d3_svg_lineLinear,
                "linear-closed": d3_svg_lineLinearClosed,
                step: d3_svg_lineStep,
                "step-before": d3_svg_lineStepBefore,
                "step-after": d3_svg_lineStepAfter,
                basis: d3_svg_lineBasis,
                "basis-open": d3_svg_lineBasisOpen,
                "basis-closed": d3_svg_lineBasisClosed,
                bundle: d3_svg_lineBundle,
                cardinal: d3_svg_lineCardinal,
                "cardinal-open": d3_svg_lineCardinalOpen,
                "cardinal-closed": d3_svg_lineCardinalClosed,
                monotone: d3_svg_lineMonotone
            });
            d3_svg_lineInterpolators.forEach(function(key, value) {
                value.key = key;
                value.closed = /-closed$/.test(key);
            });
            function d3_svg_lineLinear(points) {
                return points.join("L");
            }
            function d3_svg_lineLinearClosed(points) {
                return d3_svg_lineLinear(points) + "Z";
            }
            function d3_svg_lineStep(points) {
                var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
                while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
                if (n > 1) path.push("H", p[0]);
                return path.join("");
            }
            function d3_svg_lineStepBefore(points) {
                var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
                while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
                return path.join("");
            }
            function d3_svg_lineStepAfter(points) {
                var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
                while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
                return path.join("");
            }
            function d3_svg_lineCardinalOpen(points, tension) {
                return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
            }
            function d3_svg_lineCardinalClosed(points, tension) {
                return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
                points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
            }
            function d3_svg_lineCardinal(points, tension) {
                return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
            }
            function d3_svg_lineHermite(points, tangents) {
                if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
                    return d3_svg_lineLinear(points);
                }
                var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
                if (quad) {
                    path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
                    p0 = points[1];
                    pi = 2;
                }
                if (tangents.length > 1) {
                    t = tangents[1];
                    p = points[pi];
                    pi++;
                    path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
                    for (var i = 2; i < tangents.length; i++, pi++) {
                        p = points[pi];
                        t = tangents[i];
                        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
                    }
                }
                if (quad) {
                    var lp = points[pi];
                    path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
                }
                return path;
            }
            function d3_svg_lineCardinalTangents(points, tension) {
                var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
                while (++i < n) {
                    p0 = p1;
                    p1 = p2;
                    p2 = points[i];
                    tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
                }
                return tangents;
            }
            function d3_svg_lineBasis(points) {
                if (points.length < 3) return d3_svg_lineLinear(points);
                var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
                points.push(points[n - 1]);
                while (++i <= n) {
                    pi = points[i];
                    px.shift();
                    px.push(pi[0]);
                    py.shift();
                    py.push(pi[1]);
                    d3_svg_lineBasisBezier(path, px, py);
                }
                points.pop();
                path.push("L", pi);
                return path.join("");
            }
            function d3_svg_lineBasisOpen(points) {
                if (points.length < 4) return d3_svg_lineLinear(points);
                var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
                while (++i < 3) {
                    pi = points[i];
                    px.push(pi[0]);
                    py.push(pi[1]);
                }
                path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
                --i;
                while (++i < n) {
                    pi = points[i];
                    px.shift();
                    px.push(pi[0]);
                    py.shift();
                    py.push(pi[1]);
                    d3_svg_lineBasisBezier(path, px, py);
                }
                return path.join("");
            }
            function d3_svg_lineBasisClosed(points) {
                var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
                while (++i < 4) {
                    pi = points[i % n];
                    px.push(pi[0]);
                    py.push(pi[1]);
                }
                path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
                --i;
                while (++i < m) {
                    pi = points[i % n];
                    px.shift();
                    px.push(pi[0]);
                    py.shift();
                    py.push(pi[1]);
                    d3_svg_lineBasisBezier(path, px, py);
                }
                return path.join("");
            }
            function d3_svg_lineBundle(points, tension) {
                var n = points.length - 1;
                if (n) {
                    var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
                    while (++i <= n) {
                        p = points[i];
                        t = i / n;
                        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
                    }
                }
                return d3_svg_lineBasis(points);
            }
            function d3_svg_lineDot4(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
            }
            var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
            function d3_svg_lineBasisBezier(path, x, y) {
                path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
            }
            function d3_svg_lineSlope(p0, p1) {
                return (p1[1] - p0[1]) / (p1[0] - p0[0]);
            }
            function d3_svg_lineFiniteDifferences(points) {
                var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
                while (++i < j) {
                    m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
                }
                m[i] = d;
                return m;
            }
            function d3_svg_lineMonotoneTangents(points) {
                var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
                while (++i < j) {
                    d = d3_svg_lineSlope(points[i], points[i + 1]);
                    if (abs(d) < ε) {
                        m[i] = m[i + 1] = 0;
                    } else {
                        a = m[i] / d;
                        b = m[i + 1] / d;
                        s = a * a + b * b;
                        if (s > 9) {
                            s = d * 3 / Math.sqrt(s);
                            m[i] = s * a;
                            m[i + 1] = s * b;
                        }
                    }
                }
                i = -1;
                while (++i <= j) {
                    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
                    tangents.push([ s || 0, m[i] * s || 0 ]);
                }
                return tangents;
            }
            function d3_svg_lineMonotone(points) {
                return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
            }
            d3.svg.line.radial = function() {
                var line = d3_svg_line(d3_svg_lineRadial);
                line.radius = line.x, delete line.x;
                line.angle = line.y, delete line.y;
                return line;
            };
            function d3_svg_lineRadial(points) {
                var point, i = -1, n = points.length, r, a;
                while (++i < n) {
                    point = points[i];
                    r = point[0];
                    a = point[1] - halfπ;
                    point[0] = r * Math.cos(a);
                    point[1] = r * Math.sin(a);
                }
                return points;
            }
            function d3_svg_area(projection) {
                var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
                function area(data) {
                    var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                        return x;
                    } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                        return y;
                    } : d3_functor(y1), x, y;
                    function segment() {
                        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
                    }
                    while (++i < n) {
                        if (defined.call(this, d = data[i], i)) {
                            points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                            points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                        } else if (points0.length) {
                            segment();
                            points0 = [];
                            points1 = [];
                        }
                    }
                    if (points0.length) segment();
                    return segments.length ? segments.join("") : null;
                }
                area.x = function(_) {
                    if (!arguments.length) return x1;
                    x0 = x1 = _;
                    return area;
                };
                area.x0 = function(_) {
                    if (!arguments.length) return x0;
                    x0 = _;
                    return area;
                };
                area.x1 = function(_) {
                    if (!arguments.length) return x1;
                    x1 = _;
                    return area;
                };
                area.y = function(_) {
                    if (!arguments.length) return y1;
                    y0 = y1 = _;
                    return area;
                };
                area.y0 = function(_) {
                    if (!arguments.length) return y0;
                    y0 = _;
                    return area;
                };
                area.y1 = function(_) {
                    if (!arguments.length) return y1;
                    y1 = _;
                    return area;
                };
                area.defined = function(_) {
                    if (!arguments.length) return defined;
                    defined = _;
                    return area;
                };
                area.interpolate = function(_) {
                    if (!arguments.length) return interpolateKey;
                    if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
                    interpolateReverse = interpolate.reverse || interpolate;
                    L = interpolate.closed ? "M" : "L";
                    return area;
                };
                area.tension = function(_) {
                    if (!arguments.length) return tension;
                    tension = _;
                    return area;
                };
                return area;
            }
            d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
            d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
            d3.svg.area = function() {
                return d3_svg_area(d3_identity);
            };
            d3.svg.area.radial = function() {
                var area = d3_svg_area(d3_svg_lineRadial);
                area.radius = area.x, delete area.x;
                area.innerRadius = area.x0, delete area.x0;
                area.outerRadius = area.x1, delete area.x1;
                area.angle = area.y, delete area.y;
                area.startAngle = area.y0, delete area.y0;
                area.endAngle = area.y1, delete area.y1;
                return area;
            };
            d3.svg.chord = function() {
                var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
                function chord(d, i) {
                    var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
                    return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
                }
                function subgroup(self, f, d, i) {
                    var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
                    return {
                        r: r,
                        a0: a0,
                        a1: a1,
                        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
                    };
                }
                function equals(a, b) {
                    return a.a0 == b.a0 && a.a1 == b.a1;
                }
                function arc(r, p, a) {
                    return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
                }
                function curve(r0, p0, r1, p1) {
                    return "Q 0,0 " + p1;
                }
                chord.radius = function(v) {
                    if (!arguments.length) return radius;
                    radius = d3_functor(v);
                    return chord;
                };
                chord.source = function(v) {
                    if (!arguments.length) return source;
                    source = d3_functor(v);
                    return chord;
                };
                chord.target = function(v) {
                    if (!arguments.length) return target;
                    target = d3_functor(v);
                    return chord;
                };
                chord.startAngle = function(v) {
                    if (!arguments.length) return startAngle;
                    startAngle = d3_functor(v);
                    return chord;
                };
                chord.endAngle = function(v) {
                    if (!arguments.length) return endAngle;
                    endAngle = d3_functor(v);
                    return chord;
                };
                return chord;
            };
            function d3_svg_chordRadius(d) {
                return d.radius;
            }
            d3.svg.diagonal = function() {
                var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
                function diagonal(d, i) {
                    var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                        x: p0.x,
                        y: m
                    }, {
                        x: p3.x,
                        y: m
                    }, p3 ];
                    p = p.map(projection);
                    return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
                }
                diagonal.source = function(x) {
                    if (!arguments.length) return source;
                    source = d3_functor(x);
                    return diagonal;
                };
                diagonal.target = function(x) {
                    if (!arguments.length) return target;
                    target = d3_functor(x);
                    return diagonal;
                };
                diagonal.projection = function(x) {
                    if (!arguments.length) return projection;
                    projection = x;
                    return diagonal;
                };
                return diagonal;
            };
            function d3_svg_diagonalProjection(d) {
                return [ d.x, d.y ];
            }
            d3.svg.diagonal.radial = function() {
                var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
                diagonal.projection = function(x) {
                    return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
                };
                return diagonal;
            };
            function d3_svg_diagonalRadialProjection(projection) {
                return function() {
                    var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
                    return [ r * Math.cos(a), r * Math.sin(a) ];
                };
            }
            d3.svg.symbol = function() {
                var type = d3_svg_symbolType, size = d3_svg_symbolSize;
                function symbol(d, i) {
                    return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
                }
                symbol.type = function(x) {
                    if (!arguments.length) return type;
                    type = d3_functor(x);
                    return symbol;
                };
                symbol.size = function(x) {
                    if (!arguments.length) return size;
                    size = d3_functor(x);
                    return symbol;
                };
                return symbol;
            };
            function d3_svg_symbolSize() {
                return 64;
            }
            function d3_svg_symbolType() {
                return "circle";
            }
            function d3_svg_symbolCircle(size) {
                var r = Math.sqrt(size / π);
                return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
            }
            var d3_svg_symbols = d3.map({
                circle: d3_svg_symbolCircle,
                cross: function(size) {
                    var r = Math.sqrt(size / 5) / 2;
                    return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                },
                diamond: function(size) {
                    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
                    return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
                },
                square: function(size) {
                    var r = Math.sqrt(size) / 2;
                    return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                },
                "triangle-down": function(size) {
                    var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
                    return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                },
                "triangle-up": function(size) {
                    var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
                    return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                }
            });
            d3.svg.symbolTypes = d3_svg_symbols.keys();
            var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
            d3_selectionPrototype.transition = function(name) {
                var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                    time: Date.now(),
                    ease: d3_ease_cubicInOut,
                    delay: 0,
                    duration: 250
                };
                for (var j = -1, m = this.length; ++j < m; ) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                        subgroup.push(node);
                    }
                }
                return d3_transition(subgroups, ns, id);
            };
            d3_selectionPrototype.interrupt = function(name) {
                return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
            };
            var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
            function d3_selection_interruptNS(ns) {
                return function() {
                    var lock, active;
                    if ((lock = this[ns]) && (active = lock[lock.active])) {
                        if (--lock.count) delete lock[lock.active]; else delete this[ns];
                        lock.active += .5;
                        active.event && active.event.interrupt.call(this, this.__data__, active.index);
                    }
                };
            }
            function d3_transition(groups, ns, id) {
                d3_subclass(groups, d3_transitionPrototype);
                groups.namespace = ns;
                groups.id = id;
                return groups;
            }
            var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
            d3_transitionPrototype.call = d3_selectionPrototype.call;
            d3_transitionPrototype.empty = d3_selectionPrototype.empty;
            d3_transitionPrototype.node = d3_selectionPrototype.node;
            d3_transitionPrototype.size = d3_selectionPrototype.size;
            d3.transition = function(selection, name) {
                return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
            };
            d3.transition.prototype = d3_transitionPrototype;
            d3_transitionPrototype.select = function(selector) {
                var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
                selector = d3_selection_selector(selector);
                for (var j = -1, m = this.length; ++j < m; ) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                            if ("__data__" in node) subnode.__data__ = node.__data__;
                            d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                            subgroup.push(subnode);
                        } else {
                            subgroup.push(null);
                        }
                    }
                }
                return d3_transition(subgroups, ns, id);
            };
            d3_transitionPrototype.selectAll = function(selector) {
                var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
                selector = d3_selection_selectorAll(selector);
                for (var j = -1, m = this.length; ++j < m; ) {
                    for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                        if (node = group[i]) {
                            transition = node[ns][id];
                            subnodes = selector.call(node, node.__data__, i, j);
                            subgroups.push(subgroup = []);
                            for (var k = -1, o = subnodes.length; ++k < o; ) {
                                if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                                subgroup.push(subnode);
                            }
                        }
                    }
                }
                return d3_transition(subgroups, ns, id);
            };
            d3_transitionPrototype.filter = function(filter) {
                var subgroups = [], subgroup, group, node;
                if (typeof filter !== "function") filter = d3_selection_filter(filter);
                for (var j = 0, m = this.length; j < m; j++) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                            subgroup.push(node);
                        }
                    }
                }
                return d3_transition(subgroups, this.namespace, this.id);
            };
            d3_transitionPrototype.tween = function(name, tween) {
                var id = this.id, ns = this.namespace;
                if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
                return d3_selection_each(this, tween == null ? function(node) {
                    node[ns][id].tween.remove(name);
                } : function(node) {
                    node[ns][id].tween.set(name, tween);
                });
            };
            function d3_transition_tween(groups, name, value, tween) {
                var id = groups.id, ns = groups.namespace;
                return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
                    node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
                } : (value = tween(value), function(node) {
                    node[ns][id].tween.set(name, value);
                }));
            }
            d3_transitionPrototype.attr = function(nameNS, value) {
                if (arguments.length < 2) {
                    for (value in nameNS) this.attr(value, nameNS[value]);
                    return this;
                }
                var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
                function attrNull() {
                    this.removeAttribute(name);
                }
                function attrNullNS() {
                    this.removeAttributeNS(name.space, name.local);
                }
                function attrTween(b) {
                    return b == null ? attrNull : (b += "", function() {
                        var a = this.getAttribute(name), i;
                        return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttribute(name, i(t));
                        });
                    });
                }
                function attrTweenNS(b) {
                    return b == null ? attrNullNS : (b += "", function() {
                        var a = this.getAttributeNS(name.space, name.local), i;
                        return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttributeNS(name.space, name.local, i(t));
                        });
                    });
                }
                return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
            };
            d3_transitionPrototype.attrTween = function(nameNS, tween) {
                var name = d3.ns.qualify(nameNS);
                function attrTween(d, i) {
                    var f = tween.call(this, d, i, this.getAttribute(name));
                    return f && function(t) {
                        this.setAttribute(name, f(t));
                    };
                }
                function attrTweenNS(d, i) {
                    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                    return f && function(t) {
                        this.setAttributeNS(name.space, name.local, f(t));
                    };
                }
                return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
            };
            d3_transitionPrototype.style = function(name, value, priority) {
                var n = arguments.length;
                if (n < 3) {
                    if (typeof name !== "string") {
                        if (n < 2) value = "";
                        for (priority in name) this.style(priority, name[priority], value);
                        return this;
                    }
                    priority = "";
                }
                function styleNull() {
                    this.style.removeProperty(name);
                }
                function styleString(b) {
                    return b == null ? styleNull : (b += "", function() {
                        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                        return a !== b && (i = d3_interpolate(a, b), function(t) {
                            this.style.setProperty(name, i(t), priority);
                        });
                    });
                }
                return d3_transition_tween(this, "style." + name, value, styleString);
            };
            d3_transitionPrototype.styleTween = function(name, tween, priority) {
                if (arguments.length < 3) priority = "";
                function styleTween(d, i) {
                    var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
                    return f && function(t) {
                        this.style.setProperty(name, f(t), priority);
                    };
                }
                return this.tween("style." + name, styleTween);
            };
            d3_transitionPrototype.text = function(value) {
                return d3_transition_tween(this, "text", value, d3_transition_text);
            };
            function d3_transition_text(b) {
                if (b == null) b = "";
                return function() {
                    this.textContent = b;
                };
            }
            d3_transitionPrototype.remove = function() {
                var ns = this.namespace;
                return this.each("end.transition", function() {
                    var p;
                    if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
                });
            };
            d3_transitionPrototype.ease = function(value) {
                var id = this.id, ns = this.namespace;
                if (arguments.length < 1) return this.node()[ns][id].ease;
                if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
                return d3_selection_each(this, function(node) {
                    node[ns][id].ease = value;
                });
            };
            d3_transitionPrototype.delay = function(value) {
                var id = this.id, ns = this.namespace;
                if (arguments.length < 1) return this.node()[ns][id].delay;
                return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
                    node[ns][id].delay = +value.call(node, node.__data__, i, j);
                } : (value = +value, function(node) {
                    node[ns][id].delay = value;
                }));
            };
            d3_transitionPrototype.duration = function(value) {
                var id = this.id, ns = this.namespace;
                if (arguments.length < 1) return this.node()[ns][id].duration;
                return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
                    node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
                } : (value = Math.max(1, value), function(node) {
                    node[ns][id].duration = value;
                }));
            };
            d3_transitionPrototype.each = function(type, listener) {
                var id = this.id, ns = this.namespace;
                if (arguments.length < 2) {
                    var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
                    try {
                        d3_transitionInheritId = id;
                        d3_selection_each(this, function(node, i, j) {
                            d3_transitionInherit = node[ns][id];
                            type.call(node, node.__data__, i, j);
                        });
                    } finally {
                        d3_transitionInherit = inherit;
                        d3_transitionInheritId = inheritId;
                    }
                } else {
                    d3_selection_each(this, function(node) {
                        var transition = node[ns][id];
                        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
                    });
                }
                return this;
            };
            d3_transitionPrototype.transition = function() {
                var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
                for (var j = 0, m = this.length; j < m; j++) {
                    subgroups.push(subgroup = []);
                    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                        if (node = group[i]) {
                            transition = node[ns][id0];
                            d3_transitionNode(node, i, ns, id1, {
                                time: transition.time,
                                ease: transition.ease,
                                delay: transition.delay + transition.duration,
                                duration: transition.duration
                            });
                        }
                        subgroup.push(node);
                    }
                }
                return d3_transition(subgroups, ns, id1);
            };
            function d3_transitionNamespace(name) {
                return name == null ? "__transition__" : "__transition_" + name + "__";
            }
            function d3_transitionNode(node, i, ns, id, inherit) {
                var lock = node[ns] || (node[ns] = {
                    active: 0,
                    count: 0
                }), transition = lock[id];
                if (!transition) {
                    var time = inherit.time;
                    transition = lock[id] = {
                        tween: new d3_Map(),
                        time: time,
                        delay: inherit.delay,
                        duration: inherit.duration,
                        ease: inherit.ease,
                        index: i
                    };
                    inherit = null;
                    ++lock.count;
                    d3.timer(function(elapsed) {
                        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
                        timer.t = delay + time;
                        if (delay <= elapsed) return start(elapsed - delay);
                        timer.c = start;
                        function start(elapsed) {
                            if (lock.active > id) return stop();
                            var active = lock[lock.active];
                            if (active) {
                                --lock.count;
                                delete lock[lock.active];
                                active.event && active.event.interrupt.call(node, node.__data__, active.index);
                            }
                            lock.active = id;
                            transition.event && transition.event.start.call(node, node.__data__, i);
                            transition.tween.forEach(function(key, value) {
                                if (value = value.call(node, node.__data__, i)) {
                                    tweened.push(value);
                                }
                            });
                            ease = transition.ease;
                            duration = transition.duration;
                            d3.timer(function() {
                                timer.c = tick(elapsed || 1) ? d3_true : tick;
                                return 1;
                            }, 0, time);
                        }
                        function tick(elapsed) {
                            if (lock.active !== id) return 1;
                            var t = elapsed / duration, e = ease(t), n = tweened.length;
                            while (n > 0) {
                                tweened[--n].call(node, e);
                            }
                            if (t >= 1) {
                                transition.event && transition.event.end.call(node, node.__data__, i);
                                return stop();
                            }
                        }
                        function stop() {
                            if (--lock.count) delete lock[id]; else delete node[ns];
                            return 1;
                        }
                    }, 0, time);
                }
            }
            d3.svg.axis = function() {
                var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
                function axis(g) {
                    g.each(function() {
                        var g = d3.select(this);
                        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
                        d3.transition(path));
                        tickEnter.append("line");
                        tickEnter.append("text");
                        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                        if (orient === "bottom" || orient === "top") {
                            tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                            text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                            pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                        } else {
                            tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                            text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                            pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                        }
                        lineEnter.attr(y2, sign * innerTickSize);
                        textEnter.attr(y1, sign * tickSpacing);
                        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                        if (scale1.rangeBand) {
                            var x = scale1, dx = x.rangeBand() / 2;
                            scale0 = scale1 = function(d) {
                                return x(d) + dx;
                            };
                        } else if (scale0.rangeBand) {
                            scale0 = scale1;
                        } else {
                            tickExit.call(tickTransform, scale1, scale0);
                        }
                        tickEnter.call(tickTransform, scale0, scale1);
                        tickUpdate.call(tickTransform, scale1, scale1);
                    });
                }
                axis.scale = function(x) {
                    if (!arguments.length) return scale;
                    scale = x;
                    return axis;
                };
                axis.orient = function(x) {
                    if (!arguments.length) return orient;
                    orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
                    return axis;
                };
                axis.ticks = function() {
                    if (!arguments.length) return tickArguments_;
                    tickArguments_ = arguments;
                    return axis;
                };
                axis.tickValues = function(x) {
                    if (!arguments.length) return tickValues;
                    tickValues = x;
                    return axis;
                };
                axis.tickFormat = function(x) {
                    if (!arguments.length) return tickFormat_;
                    tickFormat_ = x;
                    return axis;
                };
                axis.tickSize = function(x) {
                    var n = arguments.length;
                    if (!n) return innerTickSize;
                    innerTickSize = +x;
                    outerTickSize = +arguments[n - 1];
                    return axis;
                };
                axis.innerTickSize = function(x) {
                    if (!arguments.length) return innerTickSize;
                    innerTickSize = +x;
                    return axis;
                };
                axis.outerTickSize = function(x) {
                    if (!arguments.length) return outerTickSize;
                    outerTickSize = +x;
                    return axis;
                };
                axis.tickPadding = function(x) {
                    if (!arguments.length) return tickPadding;
                    tickPadding = +x;
                    return axis;
                };
                axis.tickSubdivide = function() {
                    return arguments.length && axis;
                };
                return axis;
            };
            var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
                top: 1,
                right: 1,
                bottom: 1,
                left: 1
            };
            function d3_svg_axisX(selection, x0, x1) {
                selection.attr("transform", function(d) {
                    var v0 = x0(d);
                    return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
                });
            }
            function d3_svg_axisY(selection, y0, y1) {
                selection.attr("transform", function(d) {
                    var v0 = y0(d);
                    return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
                });
            }
            d3.svg.brush = function() {
                var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
                function brush(g) {
                    g.each(function() {
                        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                        var background = g.selectAll(".background").data([ 0 ]);
                        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                        var resize = g.selectAll(".resize").data(resizes, d3_identity);
                        resize.exit().remove();
                        resize.enter().append("g").attr("class", function(d) {
                            return "resize " + d;
                        }).style("cursor", function(d) {
                            return d3_svg_brushCursor[d];
                        }).append("rect").attr("x", function(d) {
                            return /[ew]$/.test(d) ? -3 : null;
                        }).attr("y", function(d) {
                            return /^[ns]/.test(d) ? -3 : null;
                        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                        resize.style("display", brush.empty() ? "none" : null);
                        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                        if (x) {
                            range = d3_scaleRange(x);
                            backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                            redrawX(gUpdate);
                        }
                        if (y) {
                            range = d3_scaleRange(y);
                            backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                            redrawY(gUpdate);
                        }
                        redraw(gUpdate);
                    });
                }
                brush.event = function(g) {
                    g.each(function() {
                        var event_ = event.of(this, arguments), extent1 = {
                            x: xExtent,
                            y: yExtent,
                            i: xExtentDomain,
                            j: yExtentDomain
                        }, extent0 = this.__chart__ || extent1;
                        this.__chart__ = extent1;
                        if (d3_transitionInheritId) {
                            d3.select(this).transition().each("start.brush", function() {
                                xExtentDomain = extent0.i;
                                yExtentDomain = extent0.j;
                                xExtent = extent0.x;
                                yExtent = extent0.y;
                                event_({
                                    type: "brushstart"
                                });
                            }).tween("brush:brush", function() {
                                var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                                xExtentDomain = yExtentDomain = null;
                                return function(t) {
                                    xExtent = extent1.x = xi(t);
                                    yExtent = extent1.y = yi(t);
                                    event_({
                                        type: "brush",
                                        mode: "resize"
                                    });
                                };
                            }).each("end.brush", function() {
                                xExtentDomain = extent1.i;
                                yExtentDomain = extent1.j;
                                event_({
                                    type: "brush",
                                    mode: "resize"
                                });
                                event_({
                                    type: "brushend"
                                });
                            });
                        } else {
                            event_({
                                type: "brushstart"
                            });
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                            event_({
                                type: "brushend"
                            });
                        }
                    });
                };
                function redraw(g) {
                    g.selectAll(".resize").attr("transform", function(d) {
                        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
                    });
                }
                function redrawX(g) {
                    g.select(".extent").attr("x", xExtent[0]);
                    g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
                }
                function redrawY(g) {
                    g.select(".extent").attr("y", yExtent[0]);
                    g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
                }
                function brushstart() {
                    var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
                    var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
                    if (d3.event.changedTouches) {
                        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
                    } else {
                        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
                    }
                    g.interrupt().selectAll("*").interrupt();
                    if (dragging) {
                        origin[0] = xExtent[0] - origin[0];
                        origin[1] = yExtent[0] - origin[1];
                    } else if (resizing) {
                        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
                        origin[0] = xExtent[ex];
                        origin[1] = yExtent[ey];
                    } else if (d3.event.altKey) center = origin.slice();
                    g.style("pointer-events", "none").selectAll(".resize").style("display", null);
                    d3.select("body").style("cursor", eventTarget.style("cursor"));
                    event_({
                        type: "brushstart"
                    });
                    brushmove();
                    function keydown() {
                        if (d3.event.keyCode == 32) {
                            if (!dragging) {
                                center = null;
                                origin[0] -= xExtent[1];
                                origin[1] -= yExtent[1];
                                dragging = 2;
                            }
                            d3_eventPreventDefault();
                        }
                    }
                    function keyup() {
                        if (d3.event.keyCode == 32 && dragging == 2) {
                            origin[0] += xExtent[1];
                            origin[1] += yExtent[1];
                            dragging = 0;
                            d3_eventPreventDefault();
                        }
                    }
                    function brushmove() {
                        var point = d3.mouse(target), moved = false;
                        if (offset) {
                            point[0] += offset[0];
                            point[1] += offset[1];
                        }
                        if (!dragging) {
                            if (d3.event.altKey) {
                                if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
                                origin[0] = xExtent[+(point[0] < center[0])];
                                origin[1] = yExtent[+(point[1] < center[1])];
                            } else center = null;
                        }
                        if (resizingX && move1(point, x, 0)) {
                            redrawX(g);
                            moved = true;
                        }
                        if (resizingY && move1(point, y, 1)) {
                            redrawY(g);
                            moved = true;
                        }
                        if (moved) {
                            redraw(g);
                            event_({
                                type: "brush",
                                mode: dragging ? "move" : "resize"
                            });
                        }
                    }
                    function move1(point, scale, i) {
                        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                        if (dragging) {
                            r0 -= position;
                            r1 -= size + position;
                        }
                        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                        if (dragging) {
                            max = (min += position) + size;
                        } else {
                            if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                            if (position < min) {
                                max = min;
                                min = position;
                            } else {
                                max = position;
                            }
                        }
                        if (extent[0] != min || extent[1] != max) {
                            if (i) yExtentDomain = null; else xExtentDomain = null;
                            extent[0] = min;
                            extent[1] = max;
                            return true;
                        }
                    }
                    function brushend() {
                        brushmove();
                        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                        d3.select("body").style("cursor", null);
                        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                        dragRestore();
                        event_({
                            type: "brushend"
                        });
                    }
                }
                brush.x = function(z) {
                    if (!arguments.length) return x;
                    x = z;
                    resizes = d3_svg_brushResizes[!x << 1 | !y];
                    return brush;
                };
                brush.y = function(z) {
                    if (!arguments.length) return y;
                    y = z;
                    resizes = d3_svg_brushResizes[!x << 1 | !y];
                    return brush;
                };
                brush.clamp = function(z) {
                    if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
                    if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
                    return brush;
                };
                brush.extent = function(z) {
                    var x0, x1, y0, y1, t;
                    if (!arguments.length) {
                        if (x) {
                            if (xExtentDomain) {
                                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                            } else {
                                x0 = xExtent[0], x1 = xExtent[1];
                                if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                            }
                        }
                        if (y) {
                            if (yExtentDomain) {
                                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                            } else {
                                y0 = yExtent[0], y1 = yExtent[1];
                                if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                            }
                        }
                        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
                    }
                    if (x) {
                        x0 = z[0], x1 = z[1];
                        if (y) x0 = x0[0], x1 = x1[0];
                        xExtentDomain = [ x0, x1 ];
                        if (x.invert) x0 = x(x0), x1 = x(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
                    }
                    if (y) {
                        y0 = z[0], y1 = z[1];
                        if (x) y0 = y0[1], y1 = y1[1];
                        yExtentDomain = [ y0, y1 ];
                        if (y.invert) y0 = y(y0), y1 = y(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
                    }
                    return brush;
                };
                brush.clear = function() {
                    if (!brush.empty()) {
                        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
                        xExtentDomain = yExtentDomain = null;
                    }
                    return brush;
                };
                brush.empty = function() {
                    return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
                };
                return d3.rebind(brush, event, "on");
            };
            var d3_svg_brushCursor = {
                n: "ns-resize",
                e: "ew-resize",
                s: "ns-resize",
                w: "ew-resize",
                nw: "nwse-resize",
                ne: "nesw-resize",
                se: "nwse-resize",
                sw: "nesw-resize"
            };
            var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
            var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
            var d3_time_formatUtc = d3_time_format.utc;
            var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
            d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
            function d3_time_formatIsoNative(date) {
                return date.toISOString();
            }
            d3_time_formatIsoNative.parse = function(string) {
                var date = new Date(string);
                return isNaN(date) ? null : date;
            };
            d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
            d3_time.second = d3_time_interval(function(date) {
                return new d3_date(Math.floor(date / 1e3) * 1e3);
            }, function(date, offset) {
                date.setTime(date.getTime() + Math.floor(offset) * 1e3);
            }, function(date) {
                return date.getSeconds();
            });
            d3_time.seconds = d3_time.second.range;
            d3_time.seconds.utc = d3_time.second.utc.range;
            d3_time.minute = d3_time_interval(function(date) {
                return new d3_date(Math.floor(date / 6e4) * 6e4);
            }, function(date, offset) {
                date.setTime(date.getTime() + Math.floor(offset) * 6e4);
            }, function(date) {
                return date.getMinutes();
            });
            d3_time.minutes = d3_time.minute.range;
            d3_time.minutes.utc = d3_time.minute.utc.range;
            d3_time.hour = d3_time_interval(function(date) {
                var timezone = date.getTimezoneOffset() / 60;
                return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
            }, function(date, offset) {
                date.setTime(date.getTime() + Math.floor(offset) * 36e5);
            }, function(date) {
                return date.getHours();
            });
            d3_time.hours = d3_time.hour.range;
            d3_time.hours.utc = d3_time.hour.utc.range;
            d3_time.month = d3_time_interval(function(date) {
                date = d3_time.day(date);
                date.setDate(1);
                return date;
            }, function(date, offset) {
                date.setMonth(date.getMonth() + offset);
            }, function(date) {
                return date.getMonth();
            });
            d3_time.months = d3_time.month.range;
            d3_time.months.utc = d3_time.month.utc.range;
            function d3_time_scale(linear, methods, format) {
                function scale(x) {
                    return linear(x);
                }
                scale.invert = function(x) {
                    return d3_time_scaleDate(linear.invert(x));
                };
                scale.domain = function(x) {
                    if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
                    linear.domain(x);
                    return scale;
                };
                function tickMethod(extent, count) {
                    var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
                    return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                        return d / 31536e6;
                    }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
                }
                scale.nice = function(interval, skip) {
                    var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
                    if (method) interval = method[0], skip = method[1];
                    function skipped(date) {
                        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
                    }
                    return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                        floor: function(date) {
                            while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                            return date;
                        },
                        ceil: function(date) {
                            while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                            return date;
                        }
                    } : interval));
                };
                scale.ticks = function(interval, skip) {
                    var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
                        range: interval
                    }, skip ];
                    if (method) interval = method[0], skip = method[1];
                    return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
                };
                scale.tickFormat = function() {
                    return format;
                };
                scale.copy = function() {
                    return d3_time_scale(linear.copy(), methods, format);
                };
                return d3_scale_linearRebind(scale, linear);
            }
            function d3_time_scaleDate(t) {
                return new Date(t);
            }
            var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
            var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
            var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
                return d.getMilliseconds();
            } ], [ ":%S", function(d) {
                return d.getSeconds();
            } ], [ "%I:%M", function(d) {
                return d.getMinutes();
            } ], [ "%I %p", function(d) {
                return d.getHours();
            } ], [ "%a %d", function(d) {
                return d.getDay() && d.getDate() != 1;
            } ], [ "%b %d", function(d) {
                return d.getDate() != 1;
            } ], [ "%B", function(d) {
                return d.getMonth();
            } ], [ "%Y", d3_true ] ]);
            var d3_time_scaleMilliseconds = {
                range: function(start, stop, step) {
                    return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
                },
                floor: d3_identity,
                ceil: d3_identity
            };
            d3_time_scaleLocalMethods.year = d3_time.year;
            d3_time.scale = function() {
                return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
            };
            var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
                return [ m[0].utc, m[1] ];
            });
            var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
                return d.getUTCMilliseconds();
            } ], [ ":%S", function(d) {
                return d.getUTCSeconds();
            } ], [ "%I:%M", function(d) {
                return d.getUTCMinutes();
            } ], [ "%I %p", function(d) {
                return d.getUTCHours();
            } ], [ "%a %d", function(d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            } ], [ "%b %d", function(d) {
                return d.getUTCDate() != 1;
            } ], [ "%B", function(d) {
                return d.getUTCMonth();
            } ], [ "%Y", d3_true ] ]);
            d3_time_scaleUtcMethods.year = d3_time.year.utc;
            d3_time.scale.utc = function() {
                return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
            };
            d3.text = d3_xhrType(function(request) {
                return request.responseText;
            });
            d3.json = function(url, callback) {
                return d3_xhr(url, "application/json", d3_json, callback);
            };
            function d3_json(request) {
                return JSON.parse(request.responseText);
            }
            d3.html = function(url, callback) {
                return d3_xhr(url, "text/html", d3_html, callback);
            };
            function d3_html(request) {
                var range = d3_document.createRange();
                range.selectNode(d3_document.body);
                return range.createContextualFragment(request.responseText);
            }
            d3.xml = d3_xhrType(function(request) {
                return request.responseXML;
            });
            if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
            this.d3 = d3;
        }();
    }, {} ],
    2: [ function(require, module, exports) {
        (function(global, factory) {
            if (typeof module === "object" && typeof module.exports === "object") {
                module.exports = global.document ? factory(global, true) : function(w) {
                    if (!w.document) {
                        throw new Error("jQuery requires a window with a document");
                    }
                    return factory(w);
                };
            } else {
                factory(global);
            }
        })(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
            var arr = [];
            var slice = arr.slice;
            var concat = arr.concat;
            var push = arr.push;
            var indexOf = arr.indexOf;
            var class2type = {};
            var toString = class2type.toString;
            var hasOwn = class2type.hasOwnProperty;
            var support = {};
            var document = window.document, version = "2.1.4", jQuery = function(selector, context) {
                return new jQuery.fn.init(selector, context);
            }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
                return letter.toUpperCase();
            };
            jQuery.fn = jQuery.prototype = {
                jquery: version,
                constructor: jQuery,
                selector: "",
                length: 0,
                toArray: function() {
                    return slice.call(this);
                },
                get: function(num) {
                    return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
                },
                pushStack: function(elems) {
                    var ret = jQuery.merge(this.constructor(), elems);
                    ret.prevObject = this;
                    ret.context = this.context;
                    return ret;
                },
                each: function(callback, args) {
                    return jQuery.each(this, callback, args);
                },
                map: function(callback) {
                    return this.pushStack(jQuery.map(this, function(elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },
                slice: function() {
                    return this.pushStack(slice.apply(this, arguments));
                },
                first: function() {
                    return this.eq(0);
                },
                last: function() {
                    return this.eq(-1);
                },
                eq: function(i) {
                    var len = this.length, j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
                },
                end: function() {
                    return this.prevObject || this.constructor(null);
                },
                push: push,
                sort: arr.sort,
                splice: arr.splice
            };
            jQuery.extend = jQuery.fn.extend = function() {
                var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
                if (typeof target === "boolean") {
                    deep = target;
                    target = arguments[i] || {};
                    i++;
                }
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }
                if (i === length) {
                    target = this;
                    i--;
                }
                for (;i < length; i++) {
                    if ((options = arguments[i]) != null) {
                        for (name in options) {
                            src = target[name];
                            copy = options[name];
                            if (target === copy) {
                                continue;
                            }
                            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];
                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }
                                target[name] = jQuery.extend(deep, clone, copy);
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }
                return target;
            };
            jQuery.extend({
                expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
                isReady: true,
                error: function(msg) {
                    throw new Error(msg);
                },
                noop: function() {},
                isFunction: function(obj) {
                    return jQuery.type(obj) === "function";
                },
                isArray: Array.isArray,
                isWindow: function(obj) {
                    return obj != null && obj === obj.window;
                },
                isNumeric: function(obj) {
                    return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
                },
                isPlainObject: function(obj) {
                    if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                        return false;
                    }
                    if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                    return true;
                },
                isEmptyObject: function(obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    }
                    return true;
                },
                type: function(obj) {
                    if (obj == null) {
                        return obj + "";
                    }
                    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
                },
                globalEval: function(code) {
                    var script, indirect = eval;
                    code = jQuery.trim(code);
                    if (code) {
                        if (code.indexOf("use strict") === 1) {
                            script = document.createElement("script");
                            script.text = code;
                            document.head.appendChild(script).parentNode.removeChild(script);
                        } else {
                            indirect(code);
                        }
                    }
                },
                camelCase: function(string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                },
                nodeName: function(elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },
                each: function(obj, callback, args) {
                    var value, i = 0, length = obj.length, isArray = isArraylike(obj);
                    if (args) {
                        if (isArray) {
                            for (;i < length; i++) {
                                value = callback.apply(obj[i], args);
                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.apply(obj[i], args);
                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    } else {
                        if (isArray) {
                            for (;i < length; i++) {
                                value = callback.call(obj[i], i, obj[i]);
                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.call(obj[i], i, obj[i]);
                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    }
                    return obj;
                },
                trim: function(text) {
                    return text == null ? "" : (text + "").replace(rtrim, "");
                },
                makeArray: function(arr, results) {
                    var ret = results || [];
                    if (arr != null) {
                        if (isArraylike(Object(arr))) {
                            jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                        } else {
                            push.call(ret, arr);
                        }
                    }
                    return ret;
                },
                inArray: function(elem, arr, i) {
                    return arr == null ? -1 : indexOf.call(arr, elem, i);
                },
                merge: function(first, second) {
                    var len = +second.length, j = 0, i = first.length;
                    for (;j < len; j++) {
                        first[i++] = second[j];
                    }
                    first.length = i;
                    return first;
                },
                grep: function(elems, callback, invert) {
                    var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
                    for (;i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }
                    return matches;
                },
                map: function(elems, callback, arg) {
                    var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
                    if (isArray) {
                        for (;i < length; i++) {
                            value = callback(elems[i], i, arg);
                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);
                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }
                    return concat.apply([], ret);
                },
                guid: 1,
                proxy: function(fn, context) {
                    var tmp, args, proxy;
                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }
                    args = slice.call(arguments, 2);
                    proxy = function() {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                    return proxy;
                },
                now: Date.now,
                support: support
            });
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });
            function isArraylike(obj) {
                var length = "length" in obj && obj.length, type = jQuery.type(obj);
                if (type === "function" || jQuery.isWindow(obj)) {
                    return false;
                }
                if (obj.nodeType === 1 && length) {
                    return true;
                }
                return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
            }
            var Sizzle = function(window) {
                var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
                    var i = 0, len = list.length;
                    for (;i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                    ID: new RegExp("^#(" + characterEncoding + ")"),
                    CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                    TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + booleans + ")$", "i"),
                    needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 65536;
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
                }, unloadHandler = function() {
                    setDocument();
                };
                try {
                    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                    arr[preferredDoc.childNodes.length].nodeType;
                } catch (e) {
                    push = {
                        apply: arr.length ? function(target, els) {
                            push_native.apply(target, slice.call(els));
                        } : function(target, els) {
                            var j = target.length, i = 0;
                            while (target[j++] = els[i++]) {}
                            target.length = j - 1;
                        }
                    };
                }
                function Sizzle(selector, context, results, seed) {
                    var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;
                    results = results || [];
                    nodeType = context.nodeType;
                    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                        return results;
                    }
                    if (!seed && documentIsHTML) {
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                            if (m = match[1]) {
                                if (nodeType === 9) {
                                    elem = context.getElementById(m);
                                    if (elem && elem.parentNode) {
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                }
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;
                            } else if ((m = match[3]) && support.getElementsByClassName) {
                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }
                        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            nid = old = expando;
                            newContext = context;
                            newSelector = nodeType !== 1 && selector;
                            if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                                groups = tokenize(selector);
                                if (old = context.getAttribute("id")) {
                                    nid = old.replace(rescape, "\\$&");
                                } else {
                                    context.setAttribute("id", nid);
                                }
                                nid = "[id='" + nid + "'] ";
                                i = groups.length;
                                while (i--) {
                                    groups[i] = nid + toSelector(groups[i]);
                                }
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                newSelector = groups.join(",");
                            }
                            if (newSelector) {
                                try {
                                    push.apply(results, newContext.querySelectorAll(newSelector));
                                    return results;
                                } catch (qsaError) {} finally {
                                    if (!old) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }
                    return select(selector.replace(rtrim, "$1"), context, results, seed);
                }
                function createCache() {
                    var keys = [];
                    function cache(key, value) {
                        if (keys.push(key + " ") > Expr.cacheLength) {
                            delete cache[keys.shift()];
                        }
                        return cache[key + " "] = value;
                    }
                    return cache;
                }
                function markFunction(fn) {
                    fn[expando] = true;
                    return fn;
                }
                function assert(fn) {
                    var div = document.createElement("div");
                    try {
                        return !!fn(div);
                    } catch (e) {
                        return false;
                    } finally {
                        if (div.parentNode) {
                            div.parentNode.removeChild(div);
                        }
                        div = null;
                    }
                }
                function addHandle(attrs, handler) {
                    var arr = attrs.split("|"), i = attrs.length;
                    while (i--) {
                        Expr.attrHandle[arr[i]] = handler;
                    }
                }
                function siblingCheck(a, b) {
                    var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                    if (diff) {
                        return diff;
                    }
                    if (cur) {
                        while (cur = cur.nextSibling) {
                            if (cur === b) {
                                return -1;
                            }
                        }
                    }
                    return a ? 1 : -1;
                }
                function createInputPseudo(type) {
                    return function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === type;
                    };
                }
                function createButtonPseudo(type) {
                    return function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === "input" || name === "button") && elem.type === type;
                    };
                }
                function createPositionalPseudo(fn) {
                    return markFunction(function(argument) {
                        argument = +argument;
                        return markFunction(function(seed, matches) {
                            var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                            while (i--) {
                                if (seed[j = matchIndexes[i]]) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }
                function testContext(context) {
                    return context && typeof context.getElementsByTagName !== "undefined" && context;
                }
                support = Sizzle.support = {};
                isXML = Sizzle.isXML = function(elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? documentElement.nodeName !== "HTML" : false;
                };
                setDocument = Sizzle.setDocument = function(node) {
                    var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
                    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                        return document;
                    }
                    document = doc;
                    docElem = doc.documentElement;
                    parent = doc.defaultView;
                    if (parent && parent !== parent.top) {
                        if (parent.addEventListener) {
                            parent.addEventListener("unload", unloadHandler, false);
                        } else if (parent.attachEvent) {
                            parent.attachEvent("onunload", unloadHandler);
                        }
                    }
                    documentIsHTML = !isXML(doc);
                    support.attributes = assert(function(div) {
                        div.className = "i";
                        return !div.getAttribute("className");
                    });
                    support.getElementsByTagName = assert(function(div) {
                        div.appendChild(doc.createComment(""));
                        return !div.getElementsByTagName("*").length;
                    });
                    support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
                    support.getById = assert(function(div) {
                        docElem.appendChild(div).id = expando;
                        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                    });
                    if (support.getById) {
                        Expr.find["ID"] = function(id, context) {
                            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                var m = context.getElementById(id);
                                return m && m.parentNode ? [ m ] : [];
                            }
                        };
                        Expr.filter["ID"] = function(id) {
                            var attrId = id.replace(runescape, funescape);
                            return function(elem) {
                                return elem.getAttribute("id") === attrId;
                            };
                        };
                    } else {
                        delete Expr.find["ID"];
                        Expr.filter["ID"] = function(id) {
                            var attrId = id.replace(runescape, funescape);
                            return function(elem) {
                                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                return node && node.value === attrId;
                            };
                        };
                    }
                    Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } : function(tag, context) {
                        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                        if (tag === "*") {
                            while (elem = results[i++]) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }
                            return tmp;
                        }
                        return results;
                    };
                    Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                        if (documentIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };
                    rbuggyMatches = [];
                    rbuggyQSA = [];
                    if (support.qsa = rnative.test(doc.querySelectorAll)) {
                        assert(function(div) {
                            docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
                            if (div.querySelectorAll("[msallowcapture^='']").length) {
                                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                            }
                            if (!div.querySelectorAll("[selected]").length) {
                                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                            }
                            if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                                rbuggyQSA.push("~=");
                            }
                            if (!div.querySelectorAll(":checked").length) {
                                rbuggyQSA.push(":checked");
                            }
                            if (!div.querySelectorAll("a#" + expando + "+*").length) {
                                rbuggyQSA.push(".#.+[+~]");
                            }
                        });
                        assert(function(div) {
                            var input = doc.createElement("input");
                            input.setAttribute("type", "hidden");
                            div.appendChild(input).setAttribute("name", "D");
                            if (div.querySelectorAll("[name=d]").length) {
                                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                            }
                            if (!div.querySelectorAll(":enabled").length) {
                                rbuggyQSA.push(":enabled", ":disabled");
                            }
                            div.querySelectorAll("*,:x");
                            rbuggyQSA.push(",.*:");
                        });
                    }
                    if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                        assert(function(div) {
                            support.disconnectedMatch = matches.call(div, "div");
                            matches.call(div, "[s!='']:x");
                            rbuggyMatches.push("!=", pseudos);
                        });
                    }
                    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
                    hasCompare = rnative.test(docElem.compareDocumentPosition);
                    contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                    } : function(a, b) {
                        if (b) {
                            while (b = b.parentNode) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    sortOrder = hasCompare ? function(a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }
                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }
                            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                        }
                        return compare & 4 ? -1 : 1;
                    } : function(a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                        if (!aup || !bup) {
                            return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }
                        cur = a;
                        while (cur = cur.parentNode) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while (cur = cur.parentNode) {
                            bp.unshift(cur);
                        }
                        while (ap[i] === bp[i]) {
                            i++;
                        }
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                    };
                    return doc;
                };
                Sizzle.matches = function(expr, elements) {
                    return Sizzle(expr, null, null, elements);
                };
                Sizzle.matchesSelector = function(elem, expr) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    expr = expr.replace(rattributeQuotes, "='$1']");
                    if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                        try {
                            var ret = matches.call(elem, expr);
                            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                                return ret;
                            }
                        } catch (e) {}
                    }
                    return Sizzle(expr, document, null, [ elem ]).length > 0;
                };
                Sizzle.contains = function(context, elem) {
                    if ((context.ownerDocument || context) !== document) {
                        setDocument(context);
                    }
                    return contains(context, elem);
                };
                Sizzle.attr = function(elem, name) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                };
                Sizzle.error = function(msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg);
                };
                Sizzle.uniqueSort = function(results) {
                    var elem, duplicates = [], j = 0, i = 0;
                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice(0);
                    results.sort(sortOrder);
                    if (hasDuplicate) {
                        while (elem = results[i++]) {
                            if (elem === results[i]) {
                                j = duplicates.push(i);
                            }
                        }
                        while (j--) {
                            results.splice(duplicates[j], 1);
                        }
                    }
                    sortInput = null;
                    return results;
                };
                getText = Sizzle.getText = function(elem) {
                    var node, ret = "", i = 0, nodeType = elem.nodeType;
                    if (!nodeType) {
                        while (node = elem[i++]) {
                            ret += getText(node);
                        }
                    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                        if (typeof elem.textContent === "string") {
                            return elem.textContent;
                        } else {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                ret += getText(elem);
                            }
                        }
                    } else if (nodeType === 3 || nodeType === 4) {
                        return elem.nodeValue;
                    }
                    return ret;
                };
                Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: true
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: true
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(match) {
                            match[1] = match[1].replace(runescape, funescape);
                            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                            if (match[2] === "~=") {
                                match[3] = " " + match[3] + " ";
                            }
                            return match.slice(0, 4);
                        },
                        CHILD: function(match) {
                            match[1] = match[1].toLowerCase();
                            if (match[1].slice(0, 3) === "nth") {
                                if (!match[3]) {
                                    Sizzle.error(match[0]);
                                }
                                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                match[5] = +(match[7] + match[8] || match[3] === "odd");
                            } else if (match[3]) {
                                Sizzle.error(match[0]);
                            }
                            return match;
                        },
                        PSEUDO: function(match) {
                            var excess, unquoted = !match[6] && match[2];
                            if (matchExpr["CHILD"].test(match[0])) {
                                return null;
                            }
                            if (match[3]) {
                                match[2] = match[4] || match[5] || "";
                            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                                match[0] = match[0].slice(0, excess);
                                match[2] = unquoted.slice(0, excess);
                            }
                            return match.slice(0, 3);
                        }
                    },
                    filter: {
                        TAG: function(nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return nodeNameSelector === "*" ? function() {
                                return true;
                            } : function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                        },
                        CLASS: function(className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                            });
                        },
                        ATTR: function(name, operator, check) {
                            return function(elem) {
                                var result = Sizzle.attr(elem, name);
                                if (result == null) {
                                    return operator === "!=";
                                }
                                if (!operator) {
                                    return true;
                                }
                                result += "";
                                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                            };
                        },
                        CHILD: function(type, what, argument, first, last) {
                            var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                            return first === 1 && last === 0 ? function(elem) {
                                return !!elem.parentNode;
                            } : function(elem, context, xml) {
                                var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                                if (parent) {
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while (node = node[dir]) {
                                                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                    return false;
                                                }
                                            }
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }
                                    start = [ forward ? parent.firstChild : parent.lastChild ];
                                    if (forward && useCache) {
                                        outerCache = parent[expando] || (parent[expando] = {});
                                        cache = outerCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];
                                        while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                outerCache[type] = [ dirruns, nodeIndex, diff ];
                                                break;
                                            }
                                        }
                                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                        diff = cache[1];
                                    } else {
                                        while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                if (useCache) {
                                                    (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                                }
                                                if (node === elem) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    diff -= last;
                                    return diff === first || diff % first === 0 && diff / first >= 0;
                                }
                            };
                        },
                        PSEUDO: function(pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            if (fn[expando]) {
                                return fn(argument);
                            }
                            if (fn.length > 1) {
                                args = [ pseudo, pseudo, "", argument ];
                                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                    var idx, matched = fn(seed, argument), i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) : function(elem) {
                                    return fn(elem, 0, args);
                                };
                            }
                            return fn;
                        }
                    },
                    pseudos: {
                        not: markFunction(function(selector) {
                            var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                                var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                                while (i--) {
                                    if (elem = unmatched[i]) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) : function(elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                input[0] = null;
                                return !results.pop();
                            };
                        }),
                        has: markFunction(function(selector) {
                            return function(elem) {
                                return Sizzle(selector, elem).length > 0;
                            };
                        }),
                        contains: markFunction(function(text) {
                            text = text.replace(runescape, funescape);
                            return function(elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                            };
                        }),
                        lang: markFunction(function(lang) {
                            if (!ridentifier.test(lang || "")) {
                                Sizzle.error("unsupported lang: " + lang);
                            }
                            lang = lang.replace(runescape, funescape).toLowerCase();
                            return function(elem) {
                                var elemLang;
                                do {
                                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                    }
                                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                return false;
                            };
                        }),
                        target: function(elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id;
                        },
                        root: function(elem) {
                            return elem === docElem;
                        },
                        focus: function(elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },
                        enabled: function(elem) {
                            return elem.disabled === false;
                        },
                        disabled: function(elem) {
                            return elem.disabled === true;
                        },
                        checked: function(elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                        },
                        selected: function(elem) {
                            if (elem.parentNode) {
                                elem.parentNode.selectedIndex;
                            }
                            return elem.selected === true;
                        },
                        empty: function(elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                if (elem.nodeType < 6) {
                                    return false;
                                }
                            }
                            return true;
                        },
                        parent: function(elem) {
                            return !Expr.pseudos["empty"](elem);
                        },
                        header: function(elem) {
                            return rheader.test(elem.nodeName);
                        },
                        input: function(elem) {
                            return rinputs.test(elem.nodeName);
                        },
                        button: function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === "button" || name === "button";
                        },
                        text: function(elem) {
                            var attr;
                            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                        },
                        first: createPositionalPseudo(function() {
                            return [ 0 ];
                        }),
                        last: createPositionalPseudo(function(matchIndexes, length) {
                            return [ length - 1 ];
                        }),
                        eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                            return [ argument < 0 ? argument + length : argument ];
                        }),
                        even: createPositionalPseudo(function(matchIndexes, length) {
                            var i = 0;
                            for (;i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        odd: createPositionalPseudo(function(matchIndexes, length) {
                            var i = 1;
                            for (;i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (;--i >= 0; ) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (;++i < length; ) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        })
                    }
                };
                Expr.pseudos["nth"] = Expr.pseudos["eq"];
                for (i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true
                }) {
                    Expr.pseudos[i] = createInputPseudo(i);
                }
                for (i in {
                    submit: true,
                    reset: true
                }) {
                    Expr.pseudos[i] = createButtonPseudo(i);
                }
                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();
                tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                    if (cached) {
                        return parseOnly ? 0 : cached.slice(0);
                    }
                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;
                    while (soFar) {
                        if (!matched || (match = rcomma.exec(soFar))) {
                            if (match) {
                                soFar = soFar.slice(match[0].length) || soFar;
                            }
                            groups.push(tokens = []);
                        }
                        matched = false;
                        if (match = rcombinators.exec(soFar)) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: match[0].replace(rtrim, " ")
                            });
                            soFar = soFar.slice(matched.length);
                        }
                        for (type in Expr.filter) {
                            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice(matched.length);
                            }
                        }
                        if (!matched) {
                            break;
                        }
                    }
                    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
                };
                function toSelector(tokens) {
                    var i = 0, len = tokens.length, selector = "";
                    for (;i < len; i++) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }
                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
                    return combinator.first ? function(elem, context, xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                    } : function(elem, context, xml) {
                        var oldCache, outerCache, newCache = [ dirruns, doneName ];
                        if (xml) {
                            while (elem = elem[dir]) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while (elem = elem[dir]) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});
                                    if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                        return newCache[2] = oldCache[2];
                                    } else {
                                        outerCache[dir] = newCache;
                                        if (newCache[2] = matcher(elem, context, xml)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                function elementMatcher(matchers) {
                    return matchers.length > 1 ? function(elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } : matchers[0];
                }
                function multipleContexts(selector, contexts, results) {
                    var i = 0, len = contexts.length;
                    for (;i < len; i++) {
                        Sizzle(selector, contexts[i], results);
                    }
                    return results;
                }
                function condense(unmatched, map, filter, context, xml) {
                    var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                    for (;i < len; i++) {
                        if (elem = unmatched[i]) {
                            if (!filter || filter(elem, context, xml)) {
                                newUnmatched.push(elem);
                                if (mapped) {
                                    map.push(i);
                                }
                            }
                        }
                    }
                    return newUnmatched;
                }
                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    if (postFilter && !postFilter[expando]) {
                        postFilter = setMatcher(postFilter);
                    }
                    if (postFinder && !postFinder[expando]) {
                        postFinder = setMatcher(postFinder, postSelector);
                    }
                    return markFunction(function(seed, results, context, xml) {
                        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher) {
                            matcher(matcherIn, matcherOut, context, xml);
                        }
                        if (postFilter) {
                            temp = condense(matcherOut, postMap);
                            postFilter(temp, [], context, xml);
                            i = temp.length;
                            while (i--) {
                                if (elem = temp[i]) {
                                    matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                }
                            }
                        }
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    temp = [];
                                    i = matcherOut.length;
                                    while (i--) {
                                        if (elem = matcherOut[i]) {
                                            temp.push(matcherIn[i] = elem);
                                        }
                                    }
                                    postFinder(null, matcherOut = [], temp, xml);
                                }
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }
                        } else {
                            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                            if (postFinder) {
                                postFinder(null, results, matcherOut, xml);
                            } else {
                                push.apply(results, matcherOut);
                            }
                        }
                    });
                }
                function matcherFromTokens(tokens) {
                    var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                        return elem === checkContext;
                    }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    } ];
                    for (;i < len; i++) {
                        if (matcher = Expr.relative[tokens[i].type]) {
                            matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                        } else {
                            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                            if (matcher[expando]) {
                                j = ++i;
                                for (;j < len; j++) {
                                    if (Expr.relative[tokens[j].type]) {
                                        break;
                                    }
                                }
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                    value: tokens[i - 2].type === " " ? "*" : ""
                                })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                            }
                            matchers.push(matcher);
                        }
                    }
                    return elementMatcher(matchers);
                }
                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                        var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                        if (outermost) {
                            outermostContext = context !== document && context;
                        }
                        for (;i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                while (matcher = elementMatchers[j++]) {
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }
                            if (bySet) {
                                if (elem = !matcher && elem) {
                                    matchedCount--;
                                }
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while (matcher = setMatchers[j++]) {
                                matcher(unmatched, setMatched, context, xml);
                            }
                            if (seed) {
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }
                                setMatched = condense(setMatched);
                            }
                            push.apply(results, setMatched);
                            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }
                        return unmatched;
                    };
                    return bySet ? markFunction(superMatcher) : superMatcher;
                }
                compile = Sizzle.compile = function(selector, match) {
                    var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                    if (!cached) {
                        if (!match) {
                            match = tokenize(selector);
                        }
                        i = match.length;
                        while (i--) {
                            cached = matcherFromTokens(match[i]);
                            if (cached[expando]) {
                                setMatchers.push(cached);
                            } else {
                                elementMatchers.push(cached);
                            }
                        }
                        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                        cached.selector = selector;
                    }
                    return cached;
                };
                select = Sizzle.select = function(selector, context, results, seed) {
                    var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                    results = results || [];
                    if (match.length === 1) {
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results;
                            } else if (compiled) {
                                context = context.parentNode;
                            }
                            selector = selector.slice(tokens.shift().value.length);
                        }
                        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
                            if (Expr.relative[type = token.type]) {
                                break;
                            }
                            if (find = Expr.find[type]) {
                                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
                    return results;
                };
                support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
                support.detectDuplicates = !!hasDuplicate;
                setDocument();
                support.sortDetached = assert(function(div1) {
                    return div1.compareDocumentPosition(document.createElement("div")) & 1;
                });
                if (!assert(function(div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#";
                })) {
                    addHandle("type|href|height|width", function(elem, name, isXML) {
                        if (!isXML) {
                            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                        }
                    });
                }
                if (!support.attributes || !assert(function(div) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute("value", "");
                    return div.firstChild.getAttribute("value") === "";
                })) {
                    addHandle("value", function(elem, name, isXML) {
                        if (!isXML && elem.nodeName.toLowerCase() === "input") {
                            return elem.defaultValue;
                        }
                    });
                }
                if (!assert(function(div) {
                    return div.getAttribute("disabled") == null;
                })) {
                    addHandle(booleans, function(elem, name, isXML) {
                        var val;
                        if (!isXML) {
                            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                        }
                    });
                }
                return Sizzle;
            }(window);
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;
            var rneedsContext = jQuery.expr.match.needsContext;
            var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
            var risSimple = /^.[^:#\[\.,]*$/;
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function(elem, i) {
                        return !!qualifier.call(elem, i, elem) !== not;
                    });
                }
                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function(elem) {
                        return elem === qualifier !== not;
                    });
                }
                if (typeof qualifier === "string") {
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }
                    qualifier = jQuery.filter(qualifier, elements);
                }
                return jQuery.grep(elements, function(elem) {
                    return indexOf.call(qualifier, elem) >= 0 !== not;
                });
            }
            jQuery.filter = function(expr, elems, not) {
                var elem = elems[0];
                if (not) {
                    expr = ":not(" + expr + ")";
                }
                return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                    return elem.nodeType === 1;
                }));
            };
            jQuery.fn.extend({
                find: function(selector) {
                    var i, len = this.length, ret = [], self = this;
                    if (typeof selector !== "string") {
                        return this.pushStack(jQuery(selector).filter(function() {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }
                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }
                    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function(selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function(selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function(selector) {
                    return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
                }
            });
            var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
                var match, elem;
                if (!selector) {
                    return this;
                }
                if (typeof selector === "string") {
                    if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                        match = [ null, selector, null ];
                    } else {
                        match = rquickExpr.exec(selector);
                    }
                    if (match && (match[1] || !context)) {
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    if (jQuery.isFunction(this[match])) {
                                        this[match](context[match]);
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            elem = document.getElementById(match[2]);
                            if (elem && elem.parentNode) {
                                this.length = 1;
                                this[0] = elem;
                            }
                            this.context = document;
                            this.selector = selector;
                            return this;
                        }
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);
                    } else {
                        return this.constructor(context).find(selector);
                    }
                } else if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                } else if (jQuery.isFunction(selector)) {
                    return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
                }
                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }
                return jQuery.makeArray(selector, this);
            };
            init.prototype = jQuery.fn;
            rootjQuery = jQuery(document);
            var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
            jQuery.extend({
                dir: function(elem, dir, until) {
                    var matched = [], truncate = until !== undefined;
                    while ((elem = elem[dir]) && elem.nodeType !== 9) {
                        if (elem.nodeType === 1) {
                            if (truncate && jQuery(elem).is(until)) {
                                break;
                            }
                            matched.push(elem);
                        }
                    }
                    return matched;
                },
                sibling: function(n, elem) {
                    var matched = [];
                    for (;n; n = n.nextSibling) {
                        if (n.nodeType === 1 && n !== elem) {
                            matched.push(n);
                        }
                    }
                    return matched;
                }
            });
            jQuery.fn.extend({
                has: function(target) {
                    var targets = jQuery(target, this), l = targets.length;
                    return this.filter(function() {
                        var i = 0;
                        for (;i < l; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },
                closest: function(selectors, context) {
                    var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
                    for (;i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                            if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                                matched.push(cur);
                                break;
                            }
                        }
                    }
                    return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                },
                index: function(elem) {
                    if (!elem) {
                        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                    }
                    if (typeof elem === "string") {
                        return indexOf.call(jQuery(elem), this[0]);
                    }
                    return indexOf.call(this, elem.jquery ? elem[0] : elem);
                },
                add: function(selector, context) {
                    return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
                },
                addBack: function(selector) {
                    return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
                }
            });
            function sibling(cur, dir) {
                while ((cur = cur[dir]) && cur.nodeType !== 1) {}
                return cur;
            }
            jQuery.each({
                parent: function(elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function(elem) {
                    return jQuery.dir(elem, "parentNode");
                },
                parentsUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "parentNode", until);
                },
                next: function(elem) {
                    return sibling(elem, "nextSibling");
                },
                prev: function(elem) {
                    return sibling(elem, "previousSibling");
                },
                nextAll: function(elem) {
                    return jQuery.dir(elem, "nextSibling");
                },
                prevAll: function(elem) {
                    return jQuery.dir(elem, "previousSibling");
                },
                nextUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "nextSibling", until);
                },
                prevUntil: function(elem, i, until) {
                    return jQuery.dir(elem, "previousSibling", until);
                },
                siblings: function(elem) {
                    return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
                },
                children: function(elem) {
                    return jQuery.sibling(elem.firstChild);
                },
                contents: function(elem) {
                    return elem.contentDocument || jQuery.merge([], elem.childNodes);
                }
            }, function(name, fn) {
                jQuery.fn[name] = function(until, selector) {
                    var matched = jQuery.map(this, fn, until);
                    if (name.slice(-5) !== "Until") {
                        selector = until;
                    }
                    if (selector && typeof selector === "string") {
                        matched = jQuery.filter(selector, matched);
                    }
                    if (this.length > 1) {
                        if (!guaranteedUnique[name]) {
                            jQuery.unique(matched);
                        }
                        if (rparentsprev.test(name)) {
                            matched.reverse();
                        }
                    }
                    return this.pushStack(matched);
                };
            });
            var rnotwhite = /\S+/g;
            var optionsCache = {};
            function createOptions(options) {
                var object = optionsCache[options] = {};
                jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
                    object[flag] = true;
                });
                return object;
            }
            jQuery.Callbacks = function(options) {
                options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
                var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
                    memory = options.memory && data;
                    fired = true;
                    firingIndex = firingStart || 0;
                    firingStart = 0;
                    firingLength = list.length;
                    firing = true;
                    for (;list && firingIndex < firingLength; firingIndex++) {
                        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                            memory = false;
                            break;
                        }
                    }
                    firing = false;
                    if (list) {
                        if (stack) {
                            if (stack.length) {
                                fire(stack.shift());
                            }
                        } else if (memory) {
                            list = [];
                        } else {
                            self.disable();
                        }
                    }
                }, self = {
                    add: function() {
                        if (list) {
                            var start = list.length;
                            (function add(args) {
                                jQuery.each(args, function(_, arg) {
                                    var type = jQuery.type(arg);
                                    if (type === "function") {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && type !== "string") {
                                        add(arg);
                                    }
                                });
                            })(arguments);
                            if (firing) {
                                firingLength = list.length;
                            } else if (memory) {
                                firingStart = start;
                                fire(memory);
                            }
                        }
                        return this;
                    },
                    remove: function() {
                        if (list) {
                            jQuery.each(arguments, function(_, arg) {
                                var index;
                                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                    list.splice(index, 1);
                                    if (firing) {
                                        if (index <= firingLength) {
                                            firingLength--;
                                        }
                                        if (index <= firingIndex) {
                                            firingIndex--;
                                        }
                                    }
                                }
                            });
                        }
                        return this;
                    },
                    has: function(fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                    },
                    empty: function() {
                        list = [];
                        firingLength = 0;
                        return this;
                    },
                    disable: function() {
                        list = stack = memory = undefined;
                        return this;
                    },
                    disabled: function() {
                        return !list;
                    },
                    lock: function() {
                        stack = undefined;
                        if (!memory) {
                            self.disable();
                        }
                        return this;
                    },
                    locked: function() {
                        return !stack;
                    },
                    fireWith: function(context, args) {
                        if (list && (!fired || stack)) {
                            args = args || [];
                            args = [ context, args.slice ? args.slice() : args ];
                            if (firing) {
                                stack.push(args);
                            } else {
                                fire(args);
                            }
                        }
                        return this;
                    },
                    fire: function() {
                        self.fireWith(this, arguments);
                        return this;
                    },
                    fired: function() {
                        return !!fired;
                    }
                };
                return self;
            };
            jQuery.extend({
                Deferred: function(func) {
                    var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                        state: function() {
                            return state;
                        },
                        always: function() {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        then: function() {
                            var fns = arguments;
                            return jQuery.Deferred(function(newDefer) {
                                jQuery.each(tuples, function(i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    deferred[tuple[1]](function() {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                        } else {
                                            newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        promise: function(obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    }, deferred = {};
                    promise.pipe = promise.then;
                    jQuery.each(tuples, function(i, tuple) {
                        var list = tuple[2], stateString = tuple[3];
                        promise[tuple[1]] = list.add;
                        if (stateString) {
                            list.add(function() {
                                state = stateString;
                            }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                        }
                        deferred[tuple[0]] = function() {
                            deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                            return this;
                        };
                        deferred[tuple[0] + "With"] = list.fireWith;
                    });
                    promise.promise(deferred);
                    if (func) {
                        func.call(deferred, deferred);
                    }
                    return deferred;
                },
                when: function(subordinate) {
                    var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                        return function(value) {
                            contexts[i] = this;
                            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                            if (values === progressValues) {
                                deferred.notifyWith(contexts, values);
                            } else if (!--remaining) {
                                deferred.resolveWith(contexts, values);
                            }
                        };
                    }, progressValues, progressContexts, resolveContexts;
                    if (length > 1) {
                        progressValues = new Array(length);
                        progressContexts = new Array(length);
                        resolveContexts = new Array(length);
                        for (;i < length; i++) {
                            if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                            } else {
                                --remaining;
                            }
                        }
                    }
                    if (!remaining) {
                        deferred.resolveWith(resolveContexts, resolveValues);
                    }
                    return deferred.promise();
                }
            });
            var readyList;
            jQuery.fn.ready = function(fn) {
                jQuery.ready.promise().done(fn);
                return this;
            };
            jQuery.extend({
                isReady: false,
                readyWait: 1,
                holdReady: function(hold) {
                    if (hold) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready(true);
                    }
                },
                ready: function(wait) {
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }
                    jQuery.isReady = true;
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }
                    readyList.resolveWith(document, [ jQuery ]);
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                        jQuery(document).off("ready");
                    }
                }
            });
            function completed() {
                document.removeEventListener("DOMContentLoaded", completed, false);
                window.removeEventListener("load", completed, false);
                jQuery.ready();
            }
            jQuery.ready.promise = function(obj) {
                if (!readyList) {
                    readyList = jQuery.Deferred();
                    if (document.readyState === "complete") {
                        setTimeout(jQuery.ready);
                    } else {
                        document.addEventListener("DOMContentLoaded", completed, false);
                        window.addEventListener("load", completed, false);
                    }
                }
                return readyList.promise(obj);
            };
            jQuery.ready.promise();
            var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0, len = elems.length, bulk = key == null;
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }
                } else if (value !== undefined) {
                    chainable = true;
                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }
                    if (bulk) {
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;
                        } else {
                            bulk = fn;
                            fn = function(elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }
                    if (fn) {
                        for (;i < len; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }
                return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
            };
            jQuery.acceptData = function(owner) {
                return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
            };
            function Data() {
                Object.defineProperty(this.cache = {}, 0, {
                    get: function() {
                        return {};
                    }
                });
                this.expando = jQuery.expando + Data.uid++;
            }
            Data.uid = 1;
            Data.accepts = jQuery.acceptData;
            Data.prototype = {
                key: function(owner) {
                    if (!Data.accepts(owner)) {
                        return 0;
                    }
                    var descriptor = {}, unlock = owner[this.expando];
                    if (!unlock) {
                        unlock = Data.uid++;
                        try {
                            descriptor[this.expando] = {
                                value: unlock
                            };
                            Object.defineProperties(owner, descriptor);
                        } catch (e) {
                            descriptor[this.expando] = unlock;
                            jQuery.extend(owner, descriptor);
                        }
                    }
                    if (!this.cache[unlock]) {
                        this.cache[unlock] = {};
                    }
                    return unlock;
                },
                set: function(owner, data, value) {
                    var prop, unlock = this.key(owner), cache = this.cache[unlock];
                    if (typeof data === "string") {
                        cache[data] = value;
                    } else {
                        if (jQuery.isEmptyObject(cache)) {
                            jQuery.extend(this.cache[unlock], data);
                        } else {
                            for (prop in data) {
                                cache[prop] = data[prop];
                            }
                        }
                    }
                    return cache;
                },
                get: function(owner, key) {
                    var cache = this.cache[this.key(owner)];
                    return key === undefined ? cache : cache[key];
                },
                access: function(owner, key, value) {
                    var stored;
                    if (key === undefined || key && typeof key === "string" && value === undefined) {
                        stored = this.get(owner, key);
                        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
                    }
                    this.set(owner, key, value);
                    return value !== undefined ? value : key;
                },
                remove: function(owner, key) {
                    var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
                    if (key === undefined) {
                        this.cache[unlock] = {};
                    } else {
                        if (jQuery.isArray(key)) {
                            name = key.concat(key.map(jQuery.camelCase));
                        } else {
                            camel = jQuery.camelCase(key);
                            if (key in cache) {
                                name = [ key, camel ];
                            } else {
                                name = camel;
                                name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                            }
                        }
                        i = name.length;
                        while (i--) {
                            delete cache[name[i]];
                        }
                    }
                },
                hasData: function(owner) {
                    return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
                },
                discard: function(owner) {
                    if (owner[this.expando]) {
                        delete this.cache[owner[this.expando]];
                    }
                }
            };
            var data_priv = new Data();
            var data_user = new Data();
            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
            function dataAttr(elem, key, data) {
                var name;
                if (data === undefined && elem.nodeType === 1) {
                    name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                    data = elem.getAttribute(name);
                    if (typeof data === "string") {
                        try {
                            data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                        } catch (e) {}
                        data_user.set(elem, key, data);
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }
            jQuery.extend({
                hasData: function(elem) {
                    return data_user.hasData(elem) || data_priv.hasData(elem);
                },
                data: function(elem, name, data) {
                    return data_user.access(elem, name, data);
                },
                removeData: function(elem, name) {
                    data_user.remove(elem, name);
                },
                _data: function(elem, name, data) {
                    return data_priv.access(elem, name, data);
                },
                _removeData: function(elem, name) {
                    data_priv.remove(elem, name);
                }
            });
            jQuery.fn.extend({
                data: function(key, value) {
                    var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                    if (key === undefined) {
                        if (this.length) {
                            data = data_user.get(elem);
                            if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                                i = attrs.length;
                                while (i--) {
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = jQuery.camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                }
                                data_priv.set(elem, "hasDataAttrs", true);
                            }
                        }
                        return data;
                    }
                    if (typeof key === "object") {
                        return this.each(function() {
                            data_user.set(this, key);
                        });
                    }
                    return access(this, function(value) {
                        var data, camelKey = jQuery.camelCase(key);
                        if (elem && value === undefined) {
                            data = data_user.get(elem, key);
                            if (data !== undefined) {
                                return data;
                            }
                            data = data_user.get(elem, camelKey);
                            if (data !== undefined) {
                                return data;
                            }
                            data = dataAttr(elem, camelKey, undefined);
                            if (data !== undefined) {
                                return data;
                            }
                            return;
                        }
                        this.each(function() {
                            var data = data_user.get(this, camelKey);
                            data_user.set(this, camelKey, value);
                            if (key.indexOf("-") !== -1 && data !== undefined) {
                                data_user.set(this, key, value);
                            }
                        });
                    }, null, value, arguments.length > 1, null, true);
                },
                removeData: function(key) {
                    return this.each(function() {
                        data_user.remove(this, key);
                    });
                }
            });
            jQuery.extend({
                queue: function(elem, type, data) {
                    var queue;
                    if (elem) {
                        type = (type || "fx") + "queue";
                        queue = data_priv.get(elem, type);
                        if (data) {
                            if (!queue || jQuery.isArray(data)) {
                                queue = data_priv.access(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },
                dequeue: function(elem, type) {
                    type = type || "fx";
                    var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                        jQuery.dequeue(elem, type);
                    };
                    if (fn === "inprogress") {
                        fn = queue.shift();
                        startLength--;
                    }
                    if (fn) {
                        if (type === "fx") {
                            queue.unshift("inprogress");
                        }
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }
                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },
                _queueHooks: function(elem, type) {
                    var key = type + "queueHooks";
                    return data_priv.get(elem, key) || data_priv.access(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            data_priv.remove(elem, [ type + "queue", key ]);
                        })
                    });
                }
            });
            jQuery.fn.extend({
                queue: function(type, data) {
                    var setter = 2;
                    if (typeof type !== "string") {
                        data = type;
                        type = "fx";
                        setter--;
                    }
                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }
                    return data === undefined ? this : this.each(function() {
                        var queue = jQuery.queue(this, type, data);
                        jQuery._queueHooks(this, type);
                        if (type === "fx" && queue[0] !== "inprogress") {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                dequeue: function(type) {
                    return this.each(function() {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function(type) {
                    return this.queue(type || "fx", []);
                },
                promise: function(type, obj) {
                    var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                        if (!--count) {
                            defer.resolveWith(elements, [ elements ]);
                        }
                    };
                    if (typeof type !== "string") {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";
                    while (i--) {
                        tmp = data_priv.get(elements[i], type + "queueHooks");
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
            var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
            var isHidden = function(elem, el) {
                elem = el || elem;
                return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
            };
            var rcheckableType = /^(?:checkbox|radio)$/i;
            (function() {
                var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
                input.setAttribute("type", "radio");
                input.setAttribute("checked", "checked");
                input.setAttribute("name", "t");
                div.appendChild(input);
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            })();
            var strundefined = typeof undefined;
            support.focusinBubbles = "onfocusin" in window;
            var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
            function returnTrue() {
                return true;
            }
            function returnFalse() {
                return false;
            }
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) {}
            }
            jQuery.event = {
                global: {},
                add: function(elem, types, handler, data, selector) {
                    var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                    if (!elemData) {
                        return;
                    }
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function(e) {
                            return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                        };
                    }
                    types = (types || "").match(rnotwhite) || [ "" ];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();
                        if (!type) {
                            continue;
                        }
                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        special = jQuery.event.special[type] || {};
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join(".")
                        }, handleObjIn);
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;
                            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle, false);
                                }
                            }
                        }
                        if (special.add) {
                            special.add.call(elem, handleObj);
                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }
                        jQuery.event.global[type] = true;
                    }
                },
                remove: function(elem, types, handler, selector, mappedTypes) {
                    var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }
                    types = (types || "").match(rnotwhite) || [ "" ];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }
                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];
                            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                                handlers.splice(j, 1);
                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }
                        if (origCount && !handlers.length) {
                            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                jQuery.removeEvent(elem, type, elemData.handle);
                            }
                            delete events[type];
                        }
                    }
                    if (jQuery.isEmptyObject(events)) {
                        delete elemData.handle;
                        data_priv.remove(elem, "events");
                    }
                },
                trigger: function(event, data, elem, onlyHandlers) {
                    var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                    cur = tmp = elem = elem || document;
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }
                    if (type.indexOf(".") >= 0) {
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;
                    event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }
                    data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (;cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                        event.type = i > 1 ? bubbleType : special.bindType || type;
                        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                        if (handle) {
                            handle.apply(cur, data);
                        }
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && jQuery.acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;
                    if (!onlyHandlers && !event.isDefaultPrevented()) {
                        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                                tmp = elem[ontype];
                                if (tmp) {
                                    elem[ontype] = null;
                                }
                                jQuery.event.triggered = type;
                                elem[type]();
                                jQuery.event.triggered = undefined;
                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }
                    return event.result;
                },
                dispatch: function(event) {
                    event = jQuery.event.fix(event);
                    var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                    args[0] = event;
                    event.delegateTarget = this;
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;
                        j = 0;
                        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                            if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                                event.handleObj = handleObj;
                                event.data = handleObj.data;
                                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }
                    return event.result;
                },
                handlers: function(event, handlers) {
                    var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                    if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                        for (;cur !== this; cur = cur.parentNode || this) {
                            if (cur.disabled !== true || event.type !== "click") {
                                matches = [];
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];
                                    sel = handleObj.selector + " ";
                                    if (matches[sel] === undefined) {
                                        matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                                    }
                                    if (matches[sel]) {
                                        matches.push(handleObj);
                                    }
                                }
                                if (matches.length) {
                                    handlerQueue.push({
                                        elem: cur,
                                        handlers: matches
                                    });
                                }
                            }
                        }
                    }
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({
                            elem: this,
                            handlers: handlers.slice(delegateCount)
                        });
                    }
                    return handlerQueue;
                },
                props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                fixHooks: {},
                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function(event, original) {
                        if (event.which == null) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }
                        return event;
                    }
                },
                mouseHooks: {
                    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function(event, original) {
                        var eventDoc, doc, body, button = original.button;
                        if (event.pageX == null && original.clientX != null) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;
                            event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                            event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                        }
                        if (!event.which && button !== undefined) {
                            event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                        }
                        return event;
                    }
                },
                fix: function(event) {
                    if (event[jQuery.expando]) {
                        return event;
                    }
                    var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
                    if (!fixHook) {
                        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                    }
                    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                    event = new jQuery.Event(originalEvent);
                    i = copy.length;
                    while (i--) {
                        prop = copy[i];
                        event[prop] = originalEvent[prop];
                    }
                    if (!event.target) {
                        event.target = document;
                    }
                    if (event.target.nodeType === 3) {
                        event.target = event.target.parentNode;
                    }
                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                },
                special: {
                    load: {
                        noBubble: true
                    },
                    focus: {
                        trigger: function() {
                            if (this !== safeActiveElement() && this.focus) {
                                this.focus();
                                return false;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        trigger: function() {
                            if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                this.click();
                                return false;
                            }
                        },
                        _default: function(event) {
                            return jQuery.nodeName(event.target, "a");
                        }
                    },
                    beforeunload: {
                        postDispatch: function(event) {
                            if (event.result !== undefined && event.originalEvent) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },
                simulate: function(type, elem, event, bubble) {
                    var e = jQuery.extend(new jQuery.Event(), event, {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    });
                    if (bubble) {
                        jQuery.event.trigger(e, null, elem);
                    } else {
                        jQuery.event.dispatch.call(elem, e);
                    }
                    if (e.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                }
            };
            jQuery.removeEvent = function(elem, type, handle) {
                if (elem.removeEventListener) {
                    elem.removeEventListener(type, handle, false);
                }
            };
            jQuery.Event = function(src, props) {
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;
                    this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
                } else {
                    this.type = src;
                }
                if (props) {
                    jQuery.extend(this, props);
                }
                this.timeStamp = src && src.timeStamp || jQuery.now();
                this[jQuery.expando] = true;
            };
            jQuery.Event.prototype = {
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = returnTrue;
                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = returnTrue;
                    if (e && e.stopPropagation) {
                        e.stopPropagation();
                    }
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = returnTrue;
                    if (e && e.stopImmediatePropagation) {
                        e.stopImmediatePropagation();
                    }
                    this.stopPropagation();
                }
            };
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,
                    handle: function(event) {
                        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                        if (!related || related !== target && !jQuery.contains(target, related)) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });
            if (!support.focusinBubbles) {
                jQuery.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function(orig, fix) {
                    var handler = function(event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };
                    jQuery.event.special[fix] = {
                        setup: function() {
                            var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            data_priv.access(doc, fix, (attaches || 0) + 1);
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                data_priv.remove(doc, fix);
                            } else {
                                data_priv.access(doc, fix, attaches);
                            }
                        }
                    };
                });
            }
            jQuery.fn.extend({
                on: function(types, selector, data, fn, one) {
                    var origFn, type;
                    if (typeof types === "object") {
                        if (typeof selector !== "string") {
                            data = data || selector;
                            selector = undefined;
                        }
                        for (type in types) {
                            this.on(type, selector, data, types[type], one);
                        }
                        return this;
                    }
                    if (data == null && fn == null) {
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === "string") {
                            fn = data;
                            data = undefined;
                        } else {
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    } else if (!fn) {
                        return this;
                    }
                    if (one === 1) {
                        origFn = fn;
                        fn = function(event) {
                            jQuery().off(event);
                            return origFn.apply(this, arguments);
                        };
                        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                    }
                    return this.each(function() {
                        jQuery.event.add(this, types, fn, data, selector);
                    });
                },
                one: function(types, selector, data, fn) {
                    return this.on(types, selector, data, fn, 1);
                },
                off: function(types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                        return this;
                    }
                    if (typeof types === "object") {
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === "function") {
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function() {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                },
                trigger: function(type, data) {
                    return this.each(function() {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function(type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });
            var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                thead: [ 1, "<table>", "</table>" ],
                col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                _default: [ 0, "", "" ]
            };
            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;
            function manipulationTarget(elem, content) {
                return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
            }
            function disableScript(elem) {
                elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                return elem;
            }
            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);
                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }
                return elem;
            }
            function setGlobalEval(elems, refElements) {
                var i = 0, l = elems.length;
                for (;i < l; i++) {
                    data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
                }
            }
            function cloneCopyEvent(src, dest) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
                if (dest.nodeType !== 1) {
                    return;
                }
                if (data_priv.hasData(src)) {
                    pdataOld = data_priv.access(src);
                    pdataCur = data_priv.set(dest, pdataOld);
                    events = pdataOld.events;
                    if (events) {
                        delete pdataCur.handle;
                        pdataCur.events = {};
                        for (type in events) {
                            for (i = 0, l = events[type].length; i < l; i++) {
                                jQuery.event.add(dest, type, events[type][i]);
                            }
                        }
                    }
                }
                if (data_user.hasData(src)) {
                    udataOld = data_user.access(src);
                    udataCur = jQuery.extend({}, udataOld);
                    data_user.set(dest, udataCur);
                }
            }
            function getAll(context, tag) {
                var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
                return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
            }
            function fixInput(src, dest) {
                var nodeName = dest.nodeName.toLowerCase();
                if (nodeName === "input" && rcheckableType.test(src.type)) {
                    dest.checked = src.checked;
                } else if (nodeName === "input" || nodeName === "textarea") {
                    dest.defaultValue = src.defaultValue;
                }
            }
            jQuery.extend({
                clone: function(elem, dataAndEvents, deepDataAndEvents) {
                    var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
                    if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                        destElements = getAll(clone);
                        srcElements = getAll(elem);
                        for (i = 0, l = srcElements.length; i < l; i++) {
                            fixInput(srcElements[i], destElements[i]);
                        }
                    }
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);
                            for (i = 0, l = srcElements.length; i < l; i++) {
                                cloneCopyEvent(srcElements[i], destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }
                    destElements = getAll(clone, "script");
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                    }
                    return clone;
                },
                buildFragment: function(elems, context, scripts, selection) {
                    var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
                    for (;i < l; i++) {
                        elem = elems[i];
                        if (elem || elem === 0) {
                            if (jQuery.type(elem) === "object") {
                                jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                            } else if (!rhtml.test(elem)) {
                                nodes.push(context.createTextNode(elem));
                            } else {
                                tmp = tmp || fragment.appendChild(context.createElement("div"));
                                tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;
                                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                                j = wrap[0];
                                while (j--) {
                                    tmp = tmp.lastChild;
                                }
                                jQuery.merge(nodes, tmp.childNodes);
                                tmp = fragment.firstChild;
                                tmp.textContent = "";
                            }
                        }
                    }
                    fragment.textContent = "";
                    i = 0;
                    while (elem = nodes[i++]) {
                        if (selection && jQuery.inArray(elem, selection) !== -1) {
                            continue;
                        }
                        contains = jQuery.contains(elem.ownerDocument, elem);
                        tmp = getAll(fragment.appendChild(elem), "script");
                        if (contains) {
                            setGlobalEval(tmp);
                        }
                        if (scripts) {
                            j = 0;
                            while (elem = tmp[j++]) {
                                if (rscriptType.test(elem.type || "")) {
                                    scripts.push(elem);
                                }
                            }
                        }
                    }
                    return fragment;
                },
                cleanData: function(elems) {
                    var data, elem, type, key, special = jQuery.event.special, i = 0;
                    for (;(elem = elems[i]) !== undefined; i++) {
                        if (jQuery.acceptData(elem)) {
                            key = elem[data_priv.expando];
                            if (key && (data = data_priv.cache[key])) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }
                                if (data_priv.cache[key]) {
                                    delete data_priv.cache[key];
                                }
                            }
                        }
                        delete data_user.cache[elem[data_user.expando]];
                    }
                }
            });
            jQuery.fn.extend({
                text: function(value) {
                    return access(this, function(value) {
                        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                this.textContent = value;
                            }
                        });
                    }, null, value, arguments.length);
                },
                append: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },
                prepend: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },
                before: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },
                after: function() {
                    return this.domManip(arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },
                remove: function(selector, keepData) {
                    var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
                    for (;(elem = elems[i]) != null; i++) {
                        if (!keepData && elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem));
                        }
                        if (elem.parentNode) {
                            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                setGlobalEval(getAll(elem, "script"));
                            }
                            elem.parentNode.removeChild(elem);
                        }
                    }
                    return this;
                },
                empty: function() {
                    var elem, i = 0;
                    for (;(elem = this[i]) != null; i++) {
                        if (elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem, false));
                            elem.textContent = "";
                        }
                    }
                    return this;
                },
                clone: function(dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                    return this.map(function() {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },
                html: function(value) {
                    return access(this, function(value) {
                        var elem = this[0] || {}, i = 0, l = this.length;
                        if (value === undefined && elem.nodeType === 1) {
                            return elem.innerHTML;
                        }
                        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                            value = value.replace(rxhtmlTag, "<$1></$2>");
                            try {
                                for (;i < l; i++) {
                                    elem = this[i] || {};
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }
                                elem = 0;
                            } catch (e) {}
                        }
                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },
                replaceWith: function() {
                    var arg = arguments[0];
                    this.domManip(arguments, function(elem) {
                        arg = this.parentNode;
                        jQuery.cleanData(getAll(this));
                        if (arg) {
                            arg.replaceChild(elem, this);
                        }
                    });
                    return arg && (arg.length || arg.nodeType) ? this : this.remove();
                },
                detach: function(selector) {
                    return this.remove(selector, true);
                },
                domManip: function(args, callback) {
                    args = concat.apply([], args);
                    var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
                    if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                        return this.each(function(index) {
                            var self = set.eq(index);
                            if (isFunction) {
                                args[0] = value.call(this, index, self.html());
                            }
                            self.domManip(args, callback);
                        });
                    }
                    if (l) {
                        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                        first = fragment.firstChild;
                        if (fragment.childNodes.length === 1) {
                            fragment = first;
                        }
                        if (first) {
                            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                            hasScripts = scripts.length;
                            for (;i < l; i++) {
                                node = fragment;
                                if (i !== iNoClone) {
                                    node = jQuery.clone(node, true, true);
                                    if (hasScripts) {
                                        jQuery.merge(scripts, getAll(node, "script"));
                                    }
                                }
                                callback.call(this[i], node, i);
                            }
                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;
                                jQuery.map(scripts, restoreScript);
                                for (i = 0; i < hasScripts; i++) {
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                        if (node.src) {
                                            if (jQuery._evalUrl) {
                                                jQuery._evalUrl(node.src);
                                            }
                                        } else {
                                            jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return this;
                }
            });
            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(name, original) {
                jQuery.fn[name] = function(selector) {
                    var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
                    for (;i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);
                        push.apply(ret, elems.get());
                    }
                    return this.pushStack(ret);
                };
            });
            var iframe, elemdisplay = {};
            function actualDisplay(name, doc) {
                var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
                elem.detach();
                return display;
            }
            function defaultDisplay(nodeName) {
                var doc = document, display = elemdisplay[nodeName];
                if (!display) {
                    display = actualDisplay(nodeName, doc);
                    if (display === "none" || !display) {
                        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                        doc = iframe[0].contentDocument;
                        doc.write();
                        doc.close();
                        display = actualDisplay(nodeName, doc);
                        iframe.detach();
                    }
                    elemdisplay[nodeName] = display;
                }
                return display;
            }
            var rmargin = /^margin/;
            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
            var getStyles = function(elem) {
                if (elem.ownerDocument.defaultView.opener) {
                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
                }
                return window.getComputedStyle(elem, null);
            };
            function curCSS(elem, name, computed) {
                var width, minWidth, maxWidth, ret, style = elem.style;
                computed = computed || getStyles(elem);
                if (computed) {
                    ret = computed.getPropertyValue(name) || computed[name];
                }
                if (computed) {
                    if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                        ret = jQuery.style(elem, name);
                    }
                    if (rnumnonpx.test(ret) && rmargin.test(name)) {
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }
                return ret !== undefined ? ret + "" : ret;
            }
            function addGetHookIf(conditionFn, hookFn) {
                return {
                    get: function() {
                        if (conditionFn()) {
                            delete this.get;
                            return;
                        }
                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }
            (function() {
                var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
                if (!div.style) {
                    return;
                }
                div.style.backgroundClip = "content-box";
                div.cloneNode(true).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";
                container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
                container.appendChild(div);
                function computePixelPositionAndBoxSizingReliable() {
                    div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
                    div.innerHTML = "";
                    docElem.appendChild(container);
                    var divStyle = window.getComputedStyle(div, null);
                    pixelPositionVal = divStyle.top !== "1%";
                    boxSizingReliableVal = divStyle.width === "4px";
                    docElem.removeChild(container);
                }
                if (window.getComputedStyle) {
                    jQuery.extend(support, {
                        pixelPosition: function() {
                            computePixelPositionAndBoxSizingReliable();
                            return pixelPositionVal;
                        },
                        boxSizingReliable: function() {
                            if (boxSizingReliableVal == null) {
                                computePixelPositionAndBoxSizingReliable();
                            }
                            return boxSizingReliableVal;
                        },
                        reliableMarginRight: function() {
                            var ret, marginDiv = div.appendChild(document.createElement("div"));
                            marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                            marginDiv.style.marginRight = marginDiv.style.width = "0";
                            div.style.width = "1px";
                            docElem.appendChild(container);
                            ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                            docElem.removeChild(container);
                            div.removeChild(marginDiv);
                            return ret;
                        }
                    });
                }
            })();
            jQuery.swap = function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            };
            var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }, cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
            function vendorPropName(style, name) {
                if (name in style) {
                    return name;
                }
                var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in style) {
                        return name;
                    }
                }
                return origName;
            }
            function setPositiveNumber(elem, value, subtract) {
                var matches = rnumsplit.exec(value);
                return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
            }
            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
                for (;i < 4; i += 2) {
                    if (extra === "margin") {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }
                    if (isBorderBox) {
                        if (extra === "content") {
                            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        }
                        if (extra !== "margin") {
                            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    } else {
                        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        if (extra !== "padding") {
                            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                }
                return val;
            }
            function getWidthOrHeight(elem, name, extra) {
                var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
                if (val <= 0 || val == null) {
                    val = curCSS(elem, name, styles);
                    if (val < 0 || val == null) {
                        val = elem.style[name];
                    }
                    if (rnumnonpx.test(val)) {
                        return val;
                    }
                    valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
                    val = parseFloat(val) || 0;
                }
                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
            }
            function showHide(elements, show) {
                var display, elem, hidden, values = [], index = 0, length = elements.length;
                for (;index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    values[index] = data_priv.get(elem, "olddisplay");
                    display = elem.style.display;
                    if (show) {
                        if (!values[index] && display === "none") {
                            elem.style.display = "";
                        }
                        if (elem.style.display === "" && isHidden(elem)) {
                            values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    } else {
                        hidden = isHidden(elem);
                        if (display !== "none" || !hidden) {
                            data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                        }
                    }
                }
                for (index = 0; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    if (!show || elem.style.display === "none" || elem.style.display === "") {
                        elem.style.display = show ? values[index] || "" : "none";
                    }
                }
                return elements;
            }
            jQuery.extend({
                cssHooks: {
                    opacity: {
                        get: function(elem, computed) {
                            if (computed) {
                                var ret = curCSS(elem, "opacity");
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },
                cssNumber: {
                    columnCount: true,
                    fillOpacity: true,
                    flexGrow: true,
                    flexShrink: true,
                    fontWeight: true,
                    lineHeight: true,
                    opacity: true,
                    order: true,
                    orphans: true,
                    widows: true,
                    zIndex: true,
                    zoom: true
                },
                cssProps: {
                    "float": "cssFloat"
                },
                style: function(elem, name, value, extra) {
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }
                    var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                    if (value !== undefined) {
                        type = typeof value;
                        if (type === "string" && (ret = rrelNum.exec(value))) {
                            value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                            type = "number";
                        }
                        if (value == null || value !== value) {
                            return;
                        }
                        if (type === "number" && !jQuery.cssNumber[origName]) {
                            value += "px";
                        }
                        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                            style[name] = "inherit";
                        }
                        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                            style[name] = value;
                        }
                    } else {
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                            return ret;
                        }
                        return style[name];
                    }
                },
                css: function(elem, name, extra, styles) {
                    var val, num, hooks, origName = jQuery.camelCase(name);
                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                    if (hooks && "get" in hooks) {
                        val = hooks.get(elem, true, extra);
                    }
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }
                    if (val === "normal" && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }
                    if (extra === "" || extra) {
                        num = parseFloat(val);
                        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                    }
                    return val;
                }
            });
            jQuery.each([ "height", "width" ], function(i, name) {
                jQuery.cssHooks[name] = {
                    get: function(elem, computed, extra) {
                        if (computed) {
                            return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                                return getWidthOrHeight(elem, name, extra);
                            }) : getWidthOrHeight(elem, name, extra);
                        }
                    },
                    set: function(elem, value, extra) {
                        var styles = extra && getStyles(elem);
                        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
                    }
                };
            });
            jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
                if (computed) {
                    return jQuery.swap(elem, {
                        display: "inline-block"
                    }, curCSS, [ elem, "marginRight" ]);
                }
            });
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function(value) {
                        var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                        for (;i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                        }
                        return expanded;
                    }
                };
                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });
            jQuery.fn.extend({
                css: function(name, value) {
                    return access(this, function(elem, name, value) {
                        var styles, len, map = {}, i = 0;
                        if (jQuery.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;
                            for (;i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }
                            return map;
                        }
                        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                },
                show: function() {
                    return showHide(this, true);
                },
                hide: function() {
                    return showHide(this);
                },
                toggle: function(state) {
                    if (typeof state === "boolean") {
                        return state ? this.show() : this.hide();
                    }
                    return this.each(function() {
                        if (isHidden(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });
            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;
            Tween.prototype = {
                constructor: Tween,
                init: function(elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || "swing";
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
                },
                cur: function() {
                    var hooks = Tween.propHooks[this.prop];
                    return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
                },
                run: function(percent) {
                    var eased, hooks = Tween.propHooks[this.prop];
                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = (this.end - this.start) * eased + this.start;
                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }
                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };
            Tween.prototype.init.prototype = Tween.prototype;
            Tween.propHooks = {
                _default: {
                    get: function(tween) {
                        var result;
                        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                            return tween.elem[tween.prop];
                        }
                        result = jQuery.css(tween.elem, tween.prop, "");
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function(tween) {
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function(tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };
            jQuery.easing = {
                linear: function(p) {
                    return p;
                },
                swing: function(p) {
                    return .5 - Math.cos(p * Math.PI) / 2;
                }
            };
            jQuery.fx = Tween.prototype.init;
            jQuery.fx.step = {};
            var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
                "*": [ function(prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || ".5";
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                } ]
            };
            function createFxNow() {
                setTimeout(function() {
                    fxNow = undefined;
                });
                return fxNow = jQuery.now();
            }
            function genFx(type, includeWidth) {
                var which, i = 0, attrs = {
                    height: type
                };
                includeWidth = includeWidth ? 1 : 0;
                for (;i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs["margin" + which] = attrs["padding" + which] = type;
                }
                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }
                return attrs;
            }
            function createTween(value, prop, animation) {
                var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
                for (;index < length; index++) {
                    if (tween = collection[index].call(animation, prop, value)) {
                        return tween;
                    }
                }
            }
            function defaultPrefilter(elem, props, opts) {
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, "fx");
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;
                    anim.always(function() {
                        anim.always(function() {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, "fx").length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }
                if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
                    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
                    display = jQuery.css(elem, "display");
                    checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
                    if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                        style.display = "inline-block";
                    }
                }
                if (opts.overflow) {
                    style.overflow = "hidden";
                    anim.always(function() {
                        style.overflow = opts.overflow[0];
                        style.overflowX = opts.overflow[1];
                        style.overflowY = opts.overflow[2];
                    });
                }
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.exec(value)) {
                        delete props[prop];
                        toggle = toggle || value === "toggle";
                        if (value === (hidden ? "hide" : "show")) {
                            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                    } else {
                        display = undefined;
                    }
                }
                if (!jQuery.isEmptyObject(orig)) {
                    if (dataShow) {
                        if ("hidden" in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = data_priv.access(elem, "fxshow", {});
                    }
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        jQuery(elem).show();
                    } else {
                        anim.done(function() {
                            jQuery(elem).hide();
                        });
                    }
                    anim.done(function() {
                        var prop;
                        data_priv.remove(elem, "fxshow");
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                    for (prop in orig) {
                        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                        if (!(prop in dataShow)) {
                            dataShow[prop] = tween.start;
                            if (hidden) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }
                } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
                    style.display = display;
                }
            }
            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (jQuery.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }
                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }
                    hooks = jQuery.cssHooks[name];
                    if (hooks && "expand" in hooks) {
                        value = hooks.expand(value);
                        delete props[name];
                        for (index in value) {
                            if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }
            function Animation(elem, properties, options) {
                var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
                    delete tick.elem;
                }), tick = function() {
                    if (stopped) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                    for (;index < length; index++) {
                        animation.tweens[index].run(percent);
                    }
                    deferred.notifyWith(elem, [ animation, percent, remaining ]);
                    if (percent < 1 && length) {
                        return remaining;
                    } else {
                        deferred.resolveWith(elem, [ animation ]);
                        return false;
                    }
                }, animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(true, {
                        specialEasing: {}
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function(prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        animation.tweens.push(tween);
                        return tween;
                    },
                    stop: function(gotoEnd) {
                        var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) {
                            return this;
                        }
                        stopped = true;
                        for (;index < length; index++) {
                            animation.tweens[index].run(1);
                        }
                        if (gotoEnd) {
                            deferred.resolveWith(elem, [ animation, gotoEnd ]);
                        } else {
                            deferred.rejectWith(elem, [ animation, gotoEnd ]);
                        }
                        return this;
                    }
                }), props = animation.props;
                propFilter(props, animation.opts.specialEasing);
                for (;index < length; index++) {
                    result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        return result;
                    }
                }
                jQuery.map(props, createTween, animation);
                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }
                jQuery.fx.timer(jQuery.extend(tick, {
                    elem: elem,
                    anim: animation,
                    queue: animation.opts.queue
                }));
                return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
            }
            jQuery.Animation = jQuery.extend(Animation, {
                tweener: function(props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = [ "*" ];
                    } else {
                        props = props.split(" ");
                    }
                    var prop, index = 0, length = props.length;
                    for (;index < length; index++) {
                        prop = props[index];
                        tweeners[prop] = tweeners[prop] || [];
                        tweeners[prop].unshift(callback);
                    }
                },
                prefilter: function(callback, prepend) {
                    if (prepend) {
                        animationPrefilters.unshift(callback);
                    } else {
                        animationPrefilters.push(callback);
                    }
                }
            });
            jQuery.speed = function(speed, easing, fn) {
                var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = "fx";
                }
                opt.old = opt.complete;
                opt.complete = function() {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }
                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };
                return opt;
            };
            jQuery.fn.extend({
                fadeTo: function(speed, to, easing, callback) {
                    return this.filter(isHidden).css("opacity", 0).show().end().animate({
                        opacity: to
                    }, speed, easing, callback);
                },
                animate: function(prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        if (empty || data_priv.get(this, "finish")) {
                            anim.stop(true);
                        }
                    };
                    doAnimation.finish = doAnimation;
                    return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
                },
                stop: function(type, clearQueue, gotoEnd) {
                    var stopQueue = function(hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };
                    if (typeof type !== "string") {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || "fx", []);
                    }
                    return this.each(function() {
                        var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }
                        for (index = timers.length; index--; ) {
                            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function(type) {
                    if (type !== false) {
                        type = type || "fx";
                    }
                    return this.each(function() {
                        var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                        data.finish = true;
                        jQuery.queue(this, type, []);
                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }
                        for (index = timers.length; index--; ) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }
                        delete data.finish;
                    });
                }
            });
            jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function(speed, easing, callback) {
                    return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
                };
            });
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(name, props) {
                jQuery.fn[name] = function(speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });
            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer, i = 0, timers = jQuery.timers;
                fxNow = jQuery.now();
                for (;i < timers.length; i++) {
                    timer = timers[i];
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }
                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };
            jQuery.fx.timer = function(timer) {
                jQuery.timers.push(timer);
                if (timer()) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };
            jQuery.fx.interval = 13;
            jQuery.fx.start = function() {
                if (!timerId) {
                    timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                }
            };
            jQuery.fx.stop = function() {
                clearInterval(timerId);
                timerId = null;
            };
            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            };
            jQuery.fn.delay = function(time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || "fx";
                return this.queue(type, function(next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function() {
                        clearTimeout(timeout);
                    };
                });
            };
            (function() {
                var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
                input.type = "checkbox";
                support.checkOn = input.value !== "";
                support.optSelected = opt.selected;
                select.disabled = true;
                support.optDisabled = !opt.disabled;
                input = document.createElement("input");
                input.value = "t";
                input.type = "radio";
                support.radioValue = input.value === "t";
            })();
            var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
            jQuery.fn.extend({
                attr: function(name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },
                removeAttr: function(name) {
                    return this.each(function() {
                        jQuery.removeAttr(this, name);
                    });
                }
            });
            jQuery.extend({
                attr: function(elem, name, value) {
                    var hooks, ret, nType = elem.nodeType;
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }
                    if (typeof elem.getAttribute === strundefined) {
                        return jQuery.prop(elem, name, value);
                    }
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                    }
                    if (value !== undefined) {
                        if (value === null) {
                            jQuery.removeAttr(elem, name);
                        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        } else {
                            elem.setAttribute(name, value + "");
                            return value;
                        }
                    } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    } else {
                        ret = jQuery.find.attr(elem, name);
                        return ret == null ? undefined : ret;
                    }
                },
                removeAttr: function(elem, value) {
                    var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
                    if (attrNames && elem.nodeType === 1) {
                        while (name = attrNames[i++]) {
                            propName = jQuery.propFix[name] || name;
                            if (jQuery.expr.match.bool.test(name)) {
                                elem[propName] = false;
                            }
                            elem.removeAttribute(name);
                        }
                    }
                },
                attrHooks: {
                    type: {
                        set: function(elem, value) {
                            if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                                var val = elem.value;
                                elem.setAttribute("type", value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                }
            });
            boolHook = {
                set: function(elem, value, name) {
                    if (value === false) {
                        jQuery.removeAttr(elem, name);
                    } else {
                        elem.setAttribute(name, name);
                    }
                    return name;
                }
            };
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;
                attrHandle[name] = function(elem, name, isXML) {
                    var ret, handle;
                    if (!isXML) {
                        handle = attrHandle[name];
                        attrHandle[name] = ret;
                        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                        attrHandle[name] = handle;
                    }
                    return ret;
                };
            });
            var rfocusable = /^(?:input|select|textarea|button)$/i;
            jQuery.fn.extend({
                prop: function(name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },
                removeProp: function(name) {
                    return this.each(function() {
                        delete this[jQuery.propFix[name] || name];
                    });
                }
            });
            jQuery.extend({
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                },
                prop: function(elem, name, value) {
                    var ret, hooks, notxml, nType = elem.nodeType;
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }
                    notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
                    if (notxml) {
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }
                    if (value !== undefined) {
                        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
                    } else {
                        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
                    }
                },
                propHooks: {
                    tabIndex: {
                        get: function(elem) {
                            return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                        }
                    }
                }
            });
            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function(elem) {
                        var parent = elem.parentNode;
                        if (parent && parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                        return null;
                    }
                };
            }
            jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
                jQuery.propFix[this.toLowerCase()] = this;
            });
            var rclass = /[\t\r\n\f]/g;
            jQuery.fn.extend({
                addClass: function(value) {
                    var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).addClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = (value || "").match(rnotwhite) || [];
                        for (;i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                            if (cur) {
                                j = 0;
                                while (clazz = classes[j++]) {
                                    if (cur.indexOf(" " + clazz + " ") < 0) {
                                        cur += clazz + " ";
                                    }
                                }
                                finalValue = jQuery.trim(cur);
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }
                    return this;
                },
                removeClass: function(value) {
                    var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).removeClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = (value || "").match(rnotwhite) || [];
                        for (;i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                            if (cur) {
                                j = 0;
                                while (clazz = classes[j++]) {
                                    while (cur.indexOf(" " + clazz + " ") >= 0) {
                                        cur = cur.replace(" " + clazz + " ", " ");
                                    }
                                }
                                finalValue = value ? jQuery.trim(cur) : "";
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }
                    return this;
                },
                toggleClass: function(value, stateVal) {
                    var type = typeof value;
                    if (typeof stateVal === "boolean" && type === "string") {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }
                    if (jQuery.isFunction(value)) {
                        return this.each(function(i) {
                            jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                        });
                    }
                    return this.each(function() {
                        if (type === "string") {
                            var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                            while (className = classNames[i++]) {
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }
                        } else if (type === strundefined || type === "boolean") {
                            if (this.className) {
                                data_priv.set(this, "__className__", this.className);
                            }
                            this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                        }
                    });
                },
                hasClass: function(selector) {
                    var className = " " + selector + " ", i = 0, l = this.length;
                    for (;i < l; i++) {
                        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                            return true;
                        }
                    }
                    return false;
                }
            });
            var rreturn = /\r/g;
            jQuery.fn.extend({
                val: function(value) {
                    var hooks, ret, isFunction, elem = this[0];
                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                                return ret;
                            }
                            ret = elem.value;
                            return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                        }
                        return;
                    }
                    isFunction = jQuery.isFunction(value);
                    return this.each(function(i) {
                        var val;
                        if (this.nodeType !== 1) {
                            return;
                        }
                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }
                        if (val == null) {
                            val = "";
                        } else if (typeof val === "number") {
                            val += "";
                        } else if (jQuery.isArray(val)) {
                            val = jQuery.map(val, function(value) {
                                return value == null ? "" : value + "";
                            });
                        }
                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                            this.value = val;
                        }
                    });
                }
            });
            jQuery.extend({
                valHooks: {
                    option: {
                        get: function(elem) {
                            var val = jQuery.find.attr(elem, "value");
                            return val != null ? val : jQuery.trim(jQuery.text(elem));
                        }
                    },
                    select: {
                        get: function(elem) {
                            var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                            for (;i < max; i++) {
                                option = options[i];
                                if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                                    value = jQuery(option).val();
                                    if (one) {
                                        return value;
                                    }
                                    values.push(value);
                                }
                            }
                            return values;
                        },
                        set: function(elem, value) {
                            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                            while (i--) {
                                option = options[i];
                                if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                                    optionSet = true;
                                }
                            }
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }
                            return values;
                        }
                    }
                }
            });
            jQuery.each([ "radio", "checkbox" ], function() {
                jQuery.valHooks[this] = {
                    set: function(elem, value) {
                        if (jQuery.isArray(value)) {
                            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function(elem) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });
            jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
                jQuery.fn[name] = function(data, fn) {
                    return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
                };
            });
            jQuery.fn.extend({
                hover: function(fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                },
                bind: function(types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function(types, fn) {
                    return this.off(types, null, fn);
                },
                delegate: function(selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function(selector, types, fn) {
                    return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
                }
            });
            var nonce = jQuery.now();
            var rquery = /\?/;
            jQuery.parseJSON = function(data) {
                return JSON.parse(data + "");
            };
            jQuery.parseXML = function(data) {
                var xml, tmp;
                if (!data || typeof data !== "string") {
                    return null;
                }
                try {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            };
            var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
            function addToPrefiltersOrTransports(structure) {
                return function(dataTypeExpression, func) {
                    if (typeof dataTypeExpression !== "string") {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }
                    var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                    if (jQuery.isFunction(func)) {
                        while (dataType = dataTypes[i++]) {
                            if (dataType[0] === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
                var inspected = {}, seekingTransport = structure === transports;
                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !(selected = dataTypeOrTransport);
                        }
                    });
                    return selected;
                }
                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
            }
            function ajaxExtend(target, src) {
                var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
                for (key in src) {
                    if (src[key] !== undefined) {
                        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }
                return target;
            }
            function ajaxHandleResponses(s, jqXHR, responses) {
                var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
                while (dataTypes[0] === "*") {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }
                    finalDataType = finalDataType || firstDataType;
                }
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }
                current = dataTypes.shift();
                while (current) {
                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }
                    prev = current;
                    current = dataTypes.shift();
                    if (current) {
                        if (current === "*") {
                            current = prev;
                        } else if (prev !== "*" && prev !== current) {
                            conv = converters[prev + " " + current] || converters["* " + current];
                            if (!conv) {
                                for (conv2 in converters) {
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {
                                        conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                        if (conv) {
                                            if (conv === true) {
                                                conv = converters[conv2];
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            if (conv !== true) {
                                if (conv && s["throws"]) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                return {
                    state: "success",
                    data: response
                };
            }
            jQuery.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: ajaxLocation,
                    type: "GET",
                    isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /xml/,
                        html: /html/,
                        json: /json/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": true,
                        "text json": jQuery.parseJSON,
                        "text xml": jQuery.parseXML
                    },
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },
                ajaxSetup: function(target, settings) {
                    return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
                },
                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),
                ajax: function(url, options) {
                    if (typeof url === "object") {
                        options = url;
                        url = undefined;
                    }
                    options = options || {};
                    var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                        readyState: 0,
                        getResponseHeader: function(key) {
                            var match;
                            if (state === 2) {
                                if (!responseHeaders) {
                                    responseHeaders = {};
                                    while (match = rheaders.exec(responseHeadersString)) {
                                        responseHeaders[match[1].toLowerCase()] = match[2];
                                    }
                                }
                                match = responseHeaders[key.toLowerCase()];
                            }
                            return match == null ? null : match;
                        },
                        getAllResponseHeaders: function() {
                            return state === 2 ? responseHeadersString : null;
                        },
                        setRequestHeader: function(name, value) {
                            var lname = name.toLowerCase();
                            if (!state) {
                                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                requestHeaders[name] = value;
                            }
                            return this;
                        },
                        overrideMimeType: function(type) {
                            if (!state) {
                                s.mimeType = type;
                            }
                            return this;
                        },
                        statusCode: function(map) {
                            var code;
                            if (map) {
                                if (state < 2) {
                                    for (code in map) {
                                        statusCode[code] = [ statusCode[code], map[code] ];
                                    }
                                } else {
                                    jqXHR.always(map[jqXHR.status]);
                                }
                            }
                            return this;
                        },
                        abort: function(statusText) {
                            var finalText = statusText || strAbort;
                            if (transport) {
                                transport.abort(finalText);
                            }
                            done(0, finalText);
                            return this;
                        }
                    };
                    deferred.promise(jqXHR).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;
                    s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
                    s.type = options.method || options.type || s.method || s.type;
                    s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
                    if (s.crossDomain == null) {
                        parts = rurl.exec(s.url.toLowerCase());
                        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
                    }
                    if (s.data && s.processData && typeof s.data !== "string") {
                        s.data = jQuery.param(s.data, s.traditional);
                    }
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                    if (state === 2) {
                        return jqXHR;
                    }
                    fireGlobals = jQuery.event && s.global;
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger("ajaxStart");
                    }
                    s.type = s.type.toUpperCase();
                    s.hasContent = !rnoContent.test(s.type);
                    cacheURL = s.url;
                    if (!s.hasContent) {
                        if (s.data) {
                            cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                            delete s.data;
                        }
                        if (s.cache === false) {
                            s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                        }
                    }
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                        }
                    }
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader("Content-Type", s.contentType);
                    }
                    jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }
                    if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                        return jqXHR.abort();
                    }
                    strAbort = "abort";
                    for (i in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) {
                        jqXHR[i](s[i]);
                    }
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                    if (!transport) {
                        done(-1, "No Transport");
                    } else {
                        jqXHR.readyState = 1;
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                        }
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = setTimeout(function() {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                        }
                        try {
                            state = 1;
                            transport.send(requestHeaders, done);
                        } catch (e) {
                            if (state < 2) {
                                done(-1, e);
                            } else {
                                throw e;
                            }
                        }
                    }
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                        if (state === 2) {
                            return;
                        }
                        state = 2;
                        if (timeoutTimer) {
                            clearTimeout(timeoutTimer);
                        }
                        transport = undefined;
                        responseHeadersString = headers || "";
                        jqXHR.readyState = status > 0 ? 4 : 0;
                        isSuccess = status >= 200 && status < 300 || status === 304;
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }
                        response = ajaxConvert(s, response, jqXHR, isSuccess);
                        if (isSuccess) {
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }
                            if (status === 204 || s.type === "HEAD") {
                                statusText = "nocontent";
                            } else if (status === 304) {
                                statusText = "notmodified";
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {
                            error = statusText;
                            if (status || !statusText) {
                                statusText = "error";
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }
                        jqXHR.status = status;
                        jqXHR.statusText = (nativeStatusText || statusText) + "";
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                        } else {
                            deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                        }
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;
                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                        }
                        completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                            if (!--jQuery.active) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }
                    return jqXHR;
                },
                getJSON: function(url, data, callback) {
                    return jQuery.get(url, data, callback, "json");
                },
                getScript: function(url, callback) {
                    return jQuery.get(url, undefined, callback, "script");
                }
            });
            jQuery.each([ "get", "post" ], function(i, method) {
                jQuery[method] = function(url, data, callback, type) {
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }
                    return jQuery.ajax({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    });
                };
            });
            jQuery._evalUrl = function(url) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    async: false,
                    global: false,
                    "throws": true
                });
            };
            jQuery.fn.extend({
                wrapAll: function(html) {
                    var wrap;
                    if (jQuery.isFunction(html)) {
                        return this.each(function(i) {
                            jQuery(this).wrapAll(html.call(this, i));
                        });
                    }
                    if (this[0]) {
                        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }
                        wrap.map(function() {
                            var elem = this;
                            while (elem.firstElementChild) {
                                elem = elem.firstElementChild;
                            }
                            return elem;
                        }).append(this);
                    }
                    return this;
                },
                wrapInner: function(html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function(i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }
                    return this.each(function() {
                        var self = jQuery(this), contents = self.contents();
                        if (contents.length) {
                            contents.wrapAll(html);
                        } else {
                            self.append(html);
                        }
                    });
                },
                wrap: function(html) {
                    var isFunction = jQuery.isFunction(html);
                    return this.each(function(i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },
                unwrap: function() {
                    return this.parent().each(function() {
                        if (!jQuery.nodeName(this, "body")) {
                            jQuery(this).replaceWith(this.childNodes);
                        }
                    }).end();
                }
            });
            jQuery.expr.filters.hidden = function(elem) {
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
            };
            jQuery.expr.filters.visible = function(elem) {
                return !jQuery.expr.filters.hidden(elem);
            };
            var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
            function buildParams(prefix, obj, traditional, add) {
                var name;
                if (jQuery.isArray(obj)) {
                    jQuery.each(obj, function(i, v) {
                        if (traditional || rbracket.test(prefix)) {
                            add(prefix, v);
                        } else {
                            buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                        }
                    });
                } else if (!traditional && jQuery.type(obj) === "object") {
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }
                } else {
                    add(prefix, obj);
                }
            }
            jQuery.param = function(a, traditional) {
                var prefix, s = [], add = function(key, value) {
                    value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };
                if (traditional === undefined) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }
                if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                    jQuery.each(a, function() {
                        add(this.name, this.value);
                    });
                } else {
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }
                return s.join("&").replace(r20, "+");
            };
            jQuery.fn.extend({
                serialize: function() {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function() {
                    return this.map(function() {
                        var elements = jQuery.prop(this, "elements");
                        return elements ? jQuery.makeArray(elements) : this;
                    }).filter(function() {
                        var type = this.type;
                        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                    }).map(function(i, elem) {
                        var val = jQuery(this).val();
                        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            };
                        }) : {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        };
                    }).get();
                }
            });
            jQuery.ajaxSettings.xhr = function() {
                try {
                    return new XMLHttpRequest();
                } catch (e) {}
            };
            var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
                0: 200,
                1223: 204
            }, xhrSupported = jQuery.ajaxSettings.xhr();
            if (window.attachEvent) {
                window.attachEvent("onunload", function() {
                    for (var key in xhrCallbacks) {
                        xhrCallbacks[key]();
                    }
                });
            }
            support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
            support.ajax = xhrSupported = !!xhrSupported;
            jQuery.ajaxTransport(function(options) {
                var callback;
                if (support.cors || xhrSupported && !options.crossDomain) {
                    return {
                        send: function(headers, complete) {
                            var i, xhr = options.xhr(), id = ++xhrId;
                            xhr.open(options.type, options.url, options.async, options.username, options.password);
                            if (options.xhrFields) {
                                for (i in options.xhrFields) {
                                    xhr[i] = options.xhrFields[i];
                                }
                            }
                            if (options.mimeType && xhr.overrideMimeType) {
                                xhr.overrideMimeType(options.mimeType);
                            }
                            if (!options.crossDomain && !headers["X-Requested-With"]) {
                                headers["X-Requested-With"] = "XMLHttpRequest";
                            }
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                            callback = function(type) {
                                return function() {
                                    if (callback) {
                                        delete xhrCallbacks[id];
                                        callback = xhr.onload = xhr.onerror = null;
                                        if (type === "abort") {
                                            xhr.abort();
                                        } else if (type === "error") {
                                            complete(xhr.status, xhr.statusText);
                                        } else {
                                            complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                                text: xhr.responseText
                                            } : undefined, xhr.getAllResponseHeaders());
                                        }
                                    }
                                };
                            };
                            xhr.onload = callback();
                            xhr.onerror = callback("error");
                            callback = xhrCallbacks[id] = callback("abort");
                            try {
                                xhr.send(options.hasContent && options.data || null);
                            } catch (e) {
                                if (callback) {
                                    throw e;
                                }
                            }
                        },
                        abort: function() {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /(?:java|ecma)script/
                },
                converters: {
                    "text script": function(text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });
            jQuery.ajaxPrefilter("script", function(s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = "GET";
                }
            });
            jQuery.ajaxTransport("script", function(s) {
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function(_, complete) {
                            script = jQuery("<script>").prop({
                                async: true,
                                charset: s.scriptCharset,
                                src: s.url
                            }).on("load error", callback = function(evt) {
                                script.remove();
                                callback = null;
                                if (evt) {
                                    complete(evt.type === "error" ? 404 : 200, evt.type);
                                }
                            });
                            document.head.appendChild(script[0]);
                        },
                        abort: function() {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });
            var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                    this[callback] = true;
                    return callback;
                }
            });
            jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
                var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
                if (jsonProp || s.dataTypes[0] === "jsonp") {
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                    }
                    s.converters["script json"] = function() {
                        if (!responseContainer) {
                            jQuery.error(callbackName + " was not called");
                        }
                        return responseContainer[0];
                    };
                    s.dataTypes[0] = "json";
                    overwritten = window[callbackName];
                    window[callbackName] = function() {
                        responseContainer = arguments;
                    };
                    jqXHR.always(function() {
                        window[callbackName] = overwritten;
                        if (s[callbackName]) {
                            s.jsonpCallback = originalSettings.jsonpCallback;
                            oldCallbacks.push(callbackName);
                        }
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }
                        responseContainer = overwritten = undefined;
                    });
                    return "script";
                }
            });
            jQuery.parseHTML = function(data, context, keepScripts) {
                if (!data || typeof data !== "string") {
                    return null;
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;
                var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
                if (parsed) {
                    return [ context.createElement(parsed[1]) ];
                }
                parsed = jQuery.buildFragment([ data ], context, scripts);
                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }
                return jQuery.merge([], parsed.childNodes);
            };
            var _load = jQuery.fn.load;
            jQuery.fn.load = function(url, params, callback) {
                if (typeof url !== "string" && _load) {
                    return _load.apply(this, arguments);
                }
                var selector, type, response, self = this, off = url.indexOf(" ");
                if (off >= 0) {
                    selector = jQuery.trim(url.slice(off));
                    url = url.slice(0, off);
                }
                if (jQuery.isFunction(params)) {
                    callback = params;
                    params = undefined;
                } else if (params && typeof params === "object") {
                    type = "POST";
                }
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,
                        type: type,
                        dataType: "html",
                        data: params
                    }).done(function(responseText) {
                        response = arguments;
                        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                    }).complete(callback && function(jqXHR, status) {
                        self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
                    });
                }
                return this;
            };
            jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
                jQuery.fn[type] = function(fn) {
                    return this.on(type, fn);
                };
            });
            jQuery.expr.filters.animated = function(elem) {
                return jQuery.grep(jQuery.timers, function(fn) {
                    return elem === fn.elem;
                }).length;
            };
            var docElem = window.document.documentElement;
            function getWindow(elem) {
                return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
            }
            jQuery.offset = {
                setOffset: function(elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
                    if (position === "static") {
                        elem.style.position = "relative";
                    }
                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, "top");
                    curCSSLeft = jQuery.css(elem, "left");
                    calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;
                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }
                    if (jQuery.isFunction(options)) {
                        options = options.call(elem, i, curOffset);
                    }
                    if (options.top != null) {
                        props.top = options.top - curOffset.top + curTop;
                    }
                    if (options.left != null) {
                        props.left = options.left - curOffset.left + curLeft;
                    }
                    if ("using" in options) {
                        options.using.call(elem, props);
                    } else {
                        curElem.css(props);
                    }
                }
            };
            jQuery.fn.extend({
                offset: function(options) {
                    if (arguments.length) {
                        return options === undefined ? this : this.each(function(i) {
                            jQuery.offset.setOffset(this, options, i);
                        });
                    }
                    var docElem, win, elem = this[0], box = {
                        top: 0,
                        left: 0
                    }, doc = elem && elem.ownerDocument;
                    if (!doc) {
                        return;
                    }
                    docElem = doc.documentElement;
                    if (!jQuery.contains(docElem, elem)) {
                        return box;
                    }
                    if (typeof elem.getBoundingClientRect !== strundefined) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow(doc);
                    return {
                        top: box.top + win.pageYOffset - docElem.clientTop,
                        left: box.left + win.pageXOffset - docElem.clientLeft
                    };
                },
                position: function() {
                    if (!this[0]) {
                        return;
                    }
                    var offsetParent, offset, elem = this[0], parentOffset = {
                        top: 0,
                        left: 0
                    };
                    if (jQuery.css(elem, "position") === "fixed") {
                        offset = elem.getBoundingClientRect();
                    } else {
                        offsetParent = this.offsetParent();
                        offset = this.offset();
                        if (!jQuery.nodeName(offsetParent[0], "html")) {
                            parentOffset = offsetParent.offset();
                        }
                        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
                    }
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                    };
                },
                offsetParent: function() {
                    return this.map(function() {
                        var offsetParent = this.offsetParent || docElem;
                        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                            offsetParent = offsetParent.offsetParent;
                        }
                        return offsetParent || docElem;
                    });
                }
            });
            jQuery.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(method, prop) {
                var top = "pageYOffset" === prop;
                jQuery.fn[method] = function(val) {
                    return access(this, function(elem, method, val) {
                        var win = getWindow(elem);
                        if (val === undefined) {
                            return win ? win[prop] : elem[method];
                        }
                        if (win) {
                            win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length, null);
                };
            });
            jQuery.each([ "top", "left" ], function(i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                    if (computed) {
                        computed = curCSS(elem, prop);
                        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
                    }
                });
            });
            jQuery.each({
                Height: "height",
                Width: "width"
            }, function(name, type) {
                jQuery.each({
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name
                }, function(defaultExtra, funcName) {
                    jQuery.fn[funcName] = function(margin, value) {
                        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                        return access(this, function(elem, type, value) {
                            var doc;
                            if (jQuery.isWindow(elem)) {
                                return elem.document.documentElement["client" + name];
                            }
                            if (elem.nodeType === 9) {
                                doc = elem.documentElement;
                                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                            }
                            return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                        }, type, chainable ? margin : undefined, chainable, null);
                    };
                });
            });
            jQuery.fn.size = function() {
                return this.length;
            };
            jQuery.fn.andSelf = jQuery.fn.addBack;
            if (typeof define === "function" && define.amd) {
                define("jquery", [], function() {
                    return jQuery;
                });
            }
            var _jQuery = window.jQuery, _$ = window.$;
            jQuery.noConflict = function(deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }
                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }
                return jQuery;
            };
            if (typeof noGlobal === strundefined) {
                window.jQuery = window.$ = jQuery;
            }
            return jQuery;
        });
    }, {} ],
    3: [ function(require, module, exports) {
        var d3 = require("d3");
        var $ = require("jquery");
        var Graph = function() {
            function Graph(graph) {
                var _this = this;
                this.graph = graph;
                var w = $(window);
                var scrollbar = this.getScrollbarWidth();
                this.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;
                var width = w.width() - scrollbar;
                var height = w.height() - scrollbar;
                width *= this.devicePixelRatio;
                height *= this.devicePixelRatio;
                this.min = Math.min(width, height);
                this.max = Math.max(width, height);
                this.game = new Phaser.Game(width, width, Phaser.AUTO, $("body")[0], {
                    preload: this.preload.bind(this),
                    create: this.create.bind(this),
                    update: this.update.bind(this),
                    render: this.render.bind(this)
                }, false, false);
                this.game.forceSingleUpdate = true;
                this.nodes = {};
                this.graph.nodes.forEach(function(node) {
                    node.connections = [];
                    _this.nodes[node.id] = node;
                });
                this.graph.edges.forEach(function(edge) {
                    edge.sourceNode = _this.nodes[edge.source];
                    edge.targetNode = _this.nodes[edge.target];
                    edge.sourceNode.connections.push({
                        target: edge.targetNode,
                        distance: edge.value
                    });
                    edge.targetNode.connections.push({
                        target: edge.sourceNode,
                        distance: edge.value
                    });
                });
                this.d3 = {
                    force: d3.layout.force(),
                    nodes: [],
                    links: [],
                    size: 1500
                };
                this.graph.nodes.forEach(function(node) {
                    node.node = {};
                    _this.d3.nodes.push(node.node);
                });
                this.graph.edges.forEach(function(edge) {
                    _this.d3.links.push({
                        source: edge.sourceNode.node,
                        target: edge.targetNode.node
                    });
                });
                this.colors = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
                this.bmps = {};
                this.groupColors = {};
                this.groups = {};
                this.stroke = 1;
                this.keywordThreshold = 2;
            }
            Graph.prototype.preload = function() {};
            Graph.prototype.create = function() {
                var _this = this;
                this.game.time.advancedTiming = true;
                this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                this.game.stage.backgroundColor = "#FFFFFF";
                this.scale = Math.min(this.game.world.width, this.game.world.height) / 100;
                this.radius = .2;
                this.radius *= this.scale * this.devicePixelRatio;
                this.diameter = this.radius * 2;
                this.d3.force.nodes(this.d3.nodes).links(this.d3.links).size([ this.d3.size, this.d3.size ]).linkStrength(.1).linkDistance(50).charge(-40);
                this.colors.forEach(function(color) {
                    var bmp = _this.game.add.bitmapData(_this.diameter, _this.diameter);
                    bmp.ctx.fillStyle = color;
                    bmp.ctx.beginPath();
                    bmp.ctx.arc(_this.radius, _this.radius, _this.radius - _this.stroke, 0, Math.PI * 2);
                    bmp.ctx.closePath();
                    bmp.ctx.fill();
                    bmp.ctx.lineWidth = _this.stroke;
                    bmp.ctx.strokeStyle = "#7e7e7e";
                    bmp.ctx.stroke();
                    _this.bmps[color] = bmp;
                });
                this.graphics = this.game.add.graphics(0, 0);
                this.graph.nodes.forEach(function(node) {
                    var transversed = {};
                    var color = _this.groupColors[node.group];
                    if (!color) {
                        color = _this.colors[Math.floor(Math.random() * _this.colors.length)];
                        _this.groupColors[node.group] = color;
                        node.color = color;
                    }
                    node.sprite = _this.game.add.sprite(_this.getNodeX(node.node), _this.getNodeY(node.node), _this.bmps[color]);
                    node.sprite.anchor.setTo(.5);
                    if (node.connections.length == 0) {
                        node.sprite.kill();
                    }
                    var group = _this.groups[node.group];
                    if (!group) {
                        group = {
                            group: node.group,
                            nodes: [],
                            keywords: {},
                            color: node.color
                        };
                        _this.groups[group.group] = group;
                    }
                    group.nodes.push(node);
                });
                var textKeywords = [];
                for (var i in this.groups) {
                    var group = this.groups[i];
                    group.nodes.forEach(function(node) {
                        node.keywords.forEach(function(word) {
                            var keyword = group.keywords[word];
                            if (!keyword) {
                                keyword = {
                                    color: group.color,
                                    keyword: word,
                                    nodes: []
                                };
                                group.keywords[keyword.keyword] = keyword;
                            }
                            keyword.nodes.push(node);
                        });
                    });
                    for (var j in group.keywords) {
                        var keyword = group.keywords[j];
                        if (keyword.nodes.length < this.keywordThreshold) {
                            continue;
                        }
                        textKeywords.push(keyword);
                    }
                }
                textKeywords.sort(function(a, b) {
                    return a.nodes.length - b.nodes.length;
                });
                textKeywords.forEach(function(keyword) {
                    var center = _this.calculateCenter(keyword.nodes);
                    keyword.text = _this.game.add.text(center.x, center.y, keyword.keyword, {
                        font: (keyword.nodes.length * 1 + 20) * _this.devicePixelRatio + "px Calibri",
                        fill: keyword.color,
                        align: "center"
                    });
                    keyword.text.fontWeight = "lighter";
                    keyword.text.stroke = "#545454";
                    keyword.text.strokeThickness = 2;
                    keyword.text.anchor.setTo(Math.random(), Math.random());
                });
            };
            Graph.prototype.getScrollbarWidth = function() {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar";
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                outer.style.overflow = "scroll";
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            };
            Graph.prototype.calculateCenter = function(nodes) {
                var x = 0;
                var y = 0;
                nodes.forEach(function(node) {
                    x += node.sprite.x;
                    y += node.sprite.y;
                });
                x /= nodes.length;
                y /= nodes.length;
                return new Phaser.Point(x, y);
            };
            Graph.prototype.transverse = function(node, transversed) {
                var _this = this;
                if (transversed[node.id]) {
                    return node.color;
                } else {
                    if (node.color) {
                        return node.color;
                    }
                    transversed[node.id] = node;
                    node.connections.forEach(function(connection) {
                        var color = _this.transverse(connection.target, transversed);
                        if (color) {
                            return color;
                        }
                    });
                    return null;
                }
            };
            Graph.prototype.getNodeX = function(node) {
                return (node.x - this.d3.size / 2) / this.d3.size * this.max + this.game.width / 2;
            };
            Graph.prototype.getNodeY = function(node) {
                return (node.y - this.d3.size / 2) / this.d3.size * this.max + this.game.height / 2;
            };
            Graph.prototype.update = function() {
                var _this = this;
                this.d3.force.start();
                this.d3.force.tick();
                this.d3.force.stop();
                this.graph.nodes.forEach(function(node) {
                    node.sprite.x = _this.getNodeX(node.node);
                    node.sprite.y = _this.getNodeY(node.node);
                });
                this.graphics.clear();
                this.graph.edges.forEach(function(edge) {
                    _this.graphics.lineStyle(1, 0, .2);
                    var source = edge.sourceNode.sprite;
                    var target = edge.targetNode.sprite;
                    _this.graphics.moveTo(source.x, source.y);
                    _this.graphics.lineTo(target.x, target.y);
                });
                for (var i in this.groups) {
                    var group = this.groups[i];
                    for (var j in group.keywords) {
                        var keyword = group.keywords[j];
                        if (keyword.text) {
                            var center = this.calculateCenter(keyword.nodes);
                            keyword.text.x = center.x;
                            keyword.text.y = center.y;
                        }
                    }
                }
            };
            Graph.prototype.render = function() {};
            return Graph;
        }();
        module.exports = Graph;
    }, {
        d3: 1,
        jquery: 2
    } ],
    4: [ function(require, module, exports) {
        var $ = require("jquery");
        var Graph = require("./graph");
        var Util = require("./util");
        $(document).ready(function() {
            var date = Util.formatDate(new Date());
            document.title += " " + date;
            $.getJSON("/api/topics/filter?day=" + date, function(data, textStatus, jqXHR) {
                var graph = window["graph"] = new Graph(data[0].graph);
            });
        });
    }, {
        "./graph": 3,
        "./util": 5,
        jquery: 2
    } ],
    5: [ function(require, module, exports) {
        var Util = function() {
            function Util() {}
            Util.repeatString = function(s, times) {
                var out = "";
                for (var i = 0; i < times; i++) {
                    out += s;
                }
                return out;
            };
            Util.padNumber = function(num, pad) {
                var s = num.toString();
                return Util.repeatString("0", pad - s.length) + s;
            };
            Util.formatDate = function(date) {
                return date.getFullYear() + "-" + Util.padNumber(date.getMonth() + 1, 2) + "-" + Util.padNumber(date.getDate(), 2);
            };
            return Util;
        }();
        module.exports = Util;
    }, {} ]
}, {}, [ 4 ]);